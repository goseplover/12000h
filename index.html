<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<title>ËßÇÈ∏üÊ®°ÊãüÂô® - ‰∏Ä‰∏á‰∏§ÂçÉÈ∏ª‰ΩøÁî®AIÂà∂‰Ωú</title>
<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    user-select: none;
  }
  
  body {
    background-color: #000;
    overflow: hidden;
    font-family: 'SimSun', sans-serif;
    color: #333;
  }
  
  #gameContainer {
    position: relative;
    width: 100vw;
    height: 100vh;
    overflow: hidden;
  }
  
  #gameCanvas {
    display: block;
    background: linear-gradient(to bottom, #87CEEB 0%, #E0F7FF 100%);
    cursor: crosshair;
    width: 100%;
    height: 100%;
    object-fit: contain;
  }
  
  #poopCanvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 5;
  }
  
  #viewfinder {
    position: absolute;
    border: 2px dashed rgba(255, 255, 255, 0.8);
    background-color: rgba(255, 255, 255, 0.1);
    pointer-events: none;
    display: none;
    z-index: 100;
  }
  
  #photoPreview {
    position: absolute;
    top: 10px;
    left: 10px;
    width: 120px;
    height: 80px;
    border: 2px solid white;
    border-radius: 5px;
    background-color: rgba(0, 0, 0, 0.3);
    overflow: hidden;
    z-index: 60;
    cursor: pointer;
  }
  
  #photoPreview img {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }
  
  #photoPreview .noPhoto {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100%;
    color: white;
    font-size: 12px;
    text-align: center;
  }
  
  #birdingToggleContainer {
    position: absolute;
    top: 10px;
    right: 10px;
    z-index: 70;
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 5px;
  }
  
  #birdingModeToggle {
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    border: 2px solid #90EE90;
    border-radius: 20px;
    padding: 8px 16px;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.3s;
    min-width: 120px;
    text-align: center;
  }
  
  #birdingModeToggle:hover {
    background-color: rgba(144, 238, 144, 0.3);
  }
  
  #birdingModeToggle.active {
    background-color: rgba(144, 238, 144, 0.5);
    border-color: #FFFFFF;
  }
  
  #birdingStatusIndicator {
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 4px 10px;
    border-radius: 10px;
    font-size: 12px;
    border: 1px solid #90EE90;
    text-align: center;
    min-width: 120px;
  }
  
  #birdingRecordIcon {
    background: rgba(0, 0, 0, 0.8);
    border: 2px solid #FFD700;
    border-radius: 8px;
    width: 120px;
    height: 20px;
    cursor: pointer;
    transition: all 0.3s;
    position: relative;
    overflow: hidden;
    margin-top: 5px;
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
    font-size: 10px;
    color: #FFD700;
    font-weight: bold;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
  }
  
  #birdingRecordIcon:hover {
    background: rgba(255, 215, 0, 0.15);
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(255, 215, 0, 0.2);
  }
  
  #birdingRecordIcon:active {
    transform: translateY(0);
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
  }
  
  #birdingRecordIcon::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 3px;
    background: linear-gradient(90deg, #FFD700, #FFA500);
  }
  
  #birdingRecordIcon .iconNumber {
    font-size: 11px;
    font-weight: bold;
    color: #FFD700;
    margin-right: 4px;
  }
  
  #birdingRecordIcon .iconTime {
    font-size: 9px;
    color: #87CEEB;
    margin-right: 4px;
  }
  
  #birdingRecordIcon .iconBirdCount {
    font-size: 9px;
    color: #90EE90;
  }
  
  #birdingRecordNav {
    position: fixed;
    top: 50%;
    left: 0;
    right: 0;
    display: flex;
    justify-content: space-between;
    padding: 0 20px;
    z-index: 410;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.3s;
  }
  
  #birdingRecordNav.show {
    opacity: 1;
  }
  
  .birdingRecordNavButton {
    pointer-events: auto;
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    border: 2px solid #FFD700;
    border-radius: 50%;
    width: 50px;
    height: 50px;
    font-size: 24px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s;
  }
  
  .birdingRecordNavButton:hover {
    background-color: rgba(255, 215, 0, 0.3);
    transform: scale(1.1);
  }
  
  .birdingRecordNavButton:disabled {
    opacity: 0.3;
    cursor: not-allowed;
  }
  
  .birdingRecordNavButton:disabled:hover {
    background-color: rgba(0, 0, 0, 0.7);
    transform: none;
  }
  
  #birdingRecordCounter {
    position: fixed;
    bottom: 20px;
    left: 0;
    right: 0;
    text-align: center;
    color: white;
    font-size: 16px;
    z-index: 410;
    background-color: rgba(0, 0, 0, 0.5);
    padding: 10px;
    border-radius: 10px;
    margin: 0 auto;
    width: fit-content;
    opacity: 0;
    transition: opacity 0.3s;
  }
  
  #birdingRecordCounter.show {
    opacity: 1;
  }
  
  .swipe-hint {
    position: fixed;
    bottom: 80px;
    left: 0;
    right: 0;
    text-align: center;
    color: #FFD700;
    font-size: 14px;
    z-index: 410;
    opacity: 0.7;
    animation: pulse 2s infinite;
  }
  
  #textStats {
    position: absolute;
    top: 95px;
    left: 10px;
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 6px 12px;
    border-radius: 6px;
    z-index: 50;
    font-size: 12px;
    max-width: 90%;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  
  #textStats span {
    margin: 0 8px;
    color: #FFD700;
    font-weight: bold;
  }
  
  #albumModal {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.85);
    z-index: 200;
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }
  
  #albumTitle {
    color: white;
    margin-bottom: 10px;
    font-size: 24px;
  }
  
  #albumPromotion {
    color: #FFD700;
    margin-bottom: 20px;
    font-size: 16px;
    text-align: center;
  }
  
  #albumPhotos {
    display: flex;
    flex-wrap: wrap;
    justify-content: flex-start;
    align-content: flex-start;
    max-width: 90%;
    max-height: 70%;
    overflow-x: auto;
    overflow-y: auto;
    padding: 20px;
    width: 100%;
  }
  
  .albumPhoto {
    width: 160px;
    height: 140px;
    margin: 10px;
    border: 2px solid white;
    border-radius: 5px;
    overflow: hidden;
    position: relative;
    display: flex;
    flex-direction: column;
    flex-shrink: 0;
  }
  
  .albumPhoto img {
    width: 100%;
    height: 100px;
    object-fit: cover;
  }
  
  .photoInfo {
    background: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 5px;
    font-size: 12px;
    text-align: center;
    flex-grow: 1;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  
  #albumStats {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    max-width: 90%;
    max-height: 20%;
    overflow-y: auto;
    padding: 10px;
    margin-top: 10px;
  }
  
  .albumStatItem {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 4px 8px;
    margin: 2px;
    border-radius: 4px;
    background-color: rgba(255, 255, 255, 0.1);
    color: white;
    font-size: 12px;
    min-width: 120px;
  }
  
  #closeAlbum {
    position: absolute;
    top: 20px;
    right: 20px;
    background-color: rgba(255, 255, 255, 0.2);
    color: white;
    border: none;
    border-radius: 50%;
    width: 40px;
    height: 40px;
    font-size: 20px;
    cursor: pointer;
  }
  
  #gameTitle {
    position: absolute;
    top: 100px;
    left: 0;
    width: 100%;
    text-align: center;
    color: white;
    font-size: 24px;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
    z-index: 10;
    display: none;
  }
  
  #creator {
    position: absolute;
    top: 5px;
    left: 0;
    width: 100%;
    text-align: center;
    color: white;
    font-size: 16px;
    text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.7);
    z-index: 10;
  }
  
  #specialAlert {
    position: absolute;
    top: 140px;
    left: 0;
    width: 100%;
    text-align: center;
    color: #FFD700;
    font-size: 20px;
    font-weight: bold;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
    z-index: 10;
    opacity: 0;
    transition: opacity 0.5s;
  }
  
  #captureAlert {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: #FFD700;
    text-align: center;
    font-size: 18px;
    font-weight: bold;
    z-index: 150;
    opacity: 0;
    transition: opacity 0.3s;
    pointer-events: none;
    text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.9);
    background-color: transparent;
    padding: 0;
  }
  
  #gameNote {
    position: absolute;
    bottom: 5px;
    left: 0;
    width: 100%;
    text-align: center;
    color: white;
    font-size: 12px;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
    z-index: 10;
    opacity: 0.7;
    padding: 0 10px;
  }
  
  #modeToggleContainer {
    position: absolute;
    bottom: 10px;
    right: 10px;
    display: flex;
    gap: 10px;
    z-index: 70;
  }
  
  .modeToggleButton {
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    border: 2px solid #FFD700;
    border-radius: 20px;
    padding: 8px 16px;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.3s;
  }
  
  .modeToggleButton:hover {
    background-color: rgba(255, 215, 0, 0.3);
  }
  
  .modeToggleButton.active {
    background-color: rgba(255, 215, 0, 0.5);
    border-color: #FFFFFF;
  }
  
  #timeIndicator {
    position: absolute;
    top: 30px;
    left: 50%;
    transform: translateX(-50%);
    color: white;
    font-size: 14px;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
    z-index: 10;
    opacity: 0.8;
  }
  
  #nightObjectAlert {
    position: absolute;
    top: 180px;
    left: 0;
    width: 100%;
    text-align: center;
    color: #87CEEB;
    font-size: 18px;
    font-weight: bold;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
    z-index: 10;
    opacity: 0;
    transition: opacity 0.5s;
  }
  
  .meteor-trail {
    position: absolute;
    background: linear-gradient(to right, rgba(255,255,255,0) 0%, rgba(255,255,255,0.8) 50%, rgba(255,255,255,0) 100%);
    border-radius: 2px;
    z-index: 2;
    pointer-events: none;
  }
  
  .comet-trail {
    position: absolute;
    background: radial-gradient(circle, rgba(173,216,230,0.8) 0%, rgba(173,216,230,0) 70%);
    border-radius: 50%;
    z-index: 2;
    pointer-events: none;
  }
  
  .ufo-beam {
    position: absolute;
    background: linear-gradient(to bottom, rgba(144,238,144,0.7) 0%, rgba(144,238,144,0) 100%);
    border-radius: 50%;
    z-index: 2;
    pointer-events: none;
  }
  
  #allBirdsAlert {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: rgba(0, 0, 0, 0.9);
    color: #FFD700;
    padding: 30px 40px;
    border-radius: 15px;
    border: 3px solid #FFD700;
    font-size: 24px;
    font-weight: bold;
    text-align: center;
    z-index: 300;
    max-width: 80%;
    box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
    animation: pulse 2s infinite;
  }
  
  @keyframes pulse {
    0% {
      transform: translate(-50%, -50%) scale(1);
    }
    50% {
      transform: translate(-50%, -50%) scale(1.05);
    }
    100% {
      transform: translate(-50%, -50%) scale(1);
    }
  }
  
  #lensToggleContainer {
    position: absolute;
    bottom: 10px;
    left: 10px;
    display: flex;
    gap: 10px;
    z-index: 70;
    background-color: rgba(0, 0, 0, 0.7);
    padding: 8px;
    border-radius: 20px;
    border: 2px solid #FFD700;
  }
  
  .lensToggleButton {
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    border: 1px solid #FFD700;
    border-radius: 15px;
    padding: 6px 12px;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.3s;
  }
  
  .lensToggleButton:hover {
    background-color: rgba(255, 215, 0, 0.3);
  }
  
  .lensToggleButton.active {
    background-color: rgba(255, 215, 0, 0.5);
    border-color: #FFFFFF;
  }
  
  #lensIndicator {
    position: absolute;
    bottom: 60px;
    left: 20px;
    color: white;
    font-size: 14px;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
    z-index: 10;
    opacity: 0.8;
    background-color: rgba(0, 0, 0, 0.5);
    padding: 4px 8px;
    border-radius: 10px;
  }
  
  #goldenFilter {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(255, 215, 0, 0);
    pointer-events: none;
    z-index: 5;
    transition: background-color 1s ease;
  }
  
  .birdingRecordIcon {
    background: rgba(0, 0, 0, 0.8);
    border: 2px solid #FFD700;
    border-radius: 10px;
    width: 60px;
    height: 60px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.3s;
    position: relative;
    overflow: hidden;
  }
  
  .birdingRecordIcon:hover {
    background: rgba(255, 215, 0, 0.2);
    transform: scale(1.05);
    box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
  }
  
  .birdingRecordIcon::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 5px;
    background: linear-gradient(90deg, #FFD700, #FFA500);
  }
  
  .birdingRecordIcon .iconNumber {
    font-size: 18px;
    font-weight: bold;
    color: #FFD700;
    margin-bottom: 2px;
  }
  
  .birdingRecordIcon .iconTime {
    font-size: 11px;
    color: #87CEEB;
  }
  
  .birdingRecordIcon .iconBirdCount {
    font-size: 10px;
    color: #90EE90;
    margin-top: 2px;
  }
  
  .birdRecordText {
    background: rgba(0, 0, 0, 0.7);
    border-radius: 8px;
    padding: 15px;
    margin-bottom: 10px;
    border-left: 4px solid #87CEEB;
  }
  
  .birdRecordText.highlight {
    border-left-color: #FFD700;
    background: rgba(255, 215, 0, 0.1);
  }
  
  .birdRecordText .birdName {
    color: white;
    font-size: 16px;
    font-weight: bold;
    margin-bottom: 5px;
  }
  
  .birdRecordText .birdStats {
    font-size: 14px;
    color: #87CEEB;
  }
  
  .birdRecordText .birdStats span {
    margin-right: 15px;
  }
  
  .birdRecordText.highlight .birdName {
    color: #FFD700;
  }
  
  .recordSummaryText {
    background: rgba(0, 0, 0, 0.5);
    border-radius: 8px;
    padding: 12px;
    margin-bottom: 15px;
    border-top: 2px solid #90EE90;
  }
  
  .recordSummaryText .summaryItem {
    display: inline-block;
    margin-right: 20px;
    font-size: 14px;
  }
  
  .recordSummaryText .summaryLabel {
    color: #87CEEB;
  }
  
  .recordSummaryText .summaryValue {
    color: white;
    font-weight: bold;
  }
  
  .rareBirdText {
    background: rgba(255, 215, 0, 0.15);
    border: 1px solid #FFD700;
    border-radius: 6px;
    padding: 8px 12px;
    margin: 5px 0;
    color: #FFD700;
    font-size: 14px;
  }
  
  .rareBirdText::before {
    content: '‚òÖ ';
  }
  
  #gyroToggleContainer {
    position: absolute;
    left: 10px;
    top: 50%;
    transform: translateY(-50%);
    z-index: 70;
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 5px;
  }
  
  #gyroSensitivityContainer {
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 3px 8px;
    border-radius: 8px;
    border: 1px solid #FFA500;
    z-index: 70;
    width: 80px;
    margin-bottom: 5px;
    height: 35px;
    display: none;
  }
  
  #gyroSensitivityContainer.active {
    display: block;
  }
  
  #gyroSensitivityLabel {
    font-size: 10px;
    margin-bottom: 2px;
    text-align: center;
  }
  
  #gyroSensitivitySlider {
    width: 100%;
    height: 4px;
    -webkit-appearance: none;
    appearance: none;
    background: #555;
    border-radius: 2px;
    outline: none;
  }
  
  #gyroSensitivitySlider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 12px;
    height: 12px;
    background: #FFA500;
    border-radius: 50%;
    cursor: pointer;
  }
  
  #gyroSensitivityValue {
    font-size: 10px;
    margin-top: 1px;
    text-align: center;
  }
  
  #gyroModeToggle {
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    border: 2px solid #FFA500;
    border-radius: 20px;
    padding: 6px 12px;
    font-size: 12px;
    cursor: pointer;
    transition: all 0.3s;
    min-width: 60px;
    max-width: 80px;
    text-align: center;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  
  #gyroModeToggle:hover {
    background-color: rgba(255, 165, 0, 0.3);
  }
  
  #gyroModeToggle.active {
    background-color: rgba(255, 165, 0, 0.5);
    border-color: #FFFFFF;
  }
  
  #gyroStatusIndicator {
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 4px 8px;
    border-radius: 10px;
    font-size: 10px;
    border: 1px solid #FFA500;
    text-align: center;
    min-width: 60px;
    max-width: 80px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    margin-bottom: 5px;
  }
  
  #gyroCalibrateButton {
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    border: 2px solid #4CAF50;
    border-radius: 20px;
    padding: 4px 8px;
    font-size: 10px;
    cursor: pointer;
    transition: all 0.3s;
    min-width: 60px;
    max-width: 80px;
    text-align: center;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  
  #gyroCalibrateButton:hover {
    background-color: rgba(76, 175, 80, 0.3);
  }
  
  #cameraButton {
    position: absolute;
    right: 15px;
    top: 50%;
    transform: translateY(-50%);
    width: 70px;
    height: 70px;
    background-color: rgba(255, 255, 255, 0.9);
    border-radius: 50%;
    border: 4px solid #FFD700;
    cursor: pointer;
    z-index: 80;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  }
  
  #cameraButton:hover {
    background-color: rgba(255, 255, 255, 1);
    transform: translateY(-50%) scale(1.05);
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
  }
  
  #cameraButton:active {
    background-color: rgba(230, 230, 230, 1);
    transform: translateY(-50%) scale(0.95);
  }
  
  #cameraButton::after {
    content: '';
    width: 40px;
    height: 40px;
    background-color: #FFD700;
    border-radius: 50%;
    border: 3px solid #333;
  }
  
  #screenshotCanvas {
    position: fixed;
    top: -10000px;
    left: -10000px;
    width: 300px;
    height: 450px;
    z-index: 1000;
  }
  
  #screenshotButton {
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    border: 2px solid #87CEEB;
    border-radius: 20px;
    padding: 8px 16px;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.3s;
    position: absolute;
    top: 20px;
    right: 70px;
    z-index: 401;
    display: none;
  }
  
  #screenshotButton:hover {
    background-color: rgba(135, 206, 235, 0.3);
  }
  
  #screenshotButton:active {
    background-color: rgba(135, 206, 235, 0.5);
  }
  
  #screenshotPreviewModal {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.9);
    z-index: 500;
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    padding-top: 20px;
    overflow-y: auto;
  }
  
  #screenshotPreviewImage {
    max-height: 90vh;
    max-width: 90%;
    object-fit: contain;
    border: 3px solid #FFD700;
    border-radius: 10px;
    box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
    margin-bottom: 20px;
  }
  
  #screenshotPreviewControls {
    margin-top: 20px;
    display: flex;
    gap: 15px;
    margin-bottom: 20px;
  }
  
  .screenshotPreviewButton {
    background-color: rgba(255, 215, 0, 0.8);
    color: black;
    border: none;
    border-radius: 25px;
    padding: 10px 25px;
    font-size: 16px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s;
    min-width: 120px;
  }
  
  .screenshotPreviewButton:hover {
    background-color: rgba(255, 215, 0, 1);
    transform: scale(1.05);
  }
  
  .screenshotPreviewButton:active {
    transform: scale(0.95);
  }
  
  #screenshotPreviewClose {
    position: absolute;
    top: 20px;
    right: 20px;
    background-color: rgba(255, 255, 255, 0.2);
    color: white;
    border: none;
    border-radius: 50%;
    width: 40px;
    height: 40px;
    font-size: 20px;
    cursor: pointer;
  }
  
/* ÈôÄËû∫‰ª™Ê®°Âºè‰∏ãÁöÑÈöêËóèÂå∫ÂüüÊ†∑Âºè */
#lensToggleContainer.hidden-by-gyro,
#modeToggleContainer.hidden-by-gyro {
  opacity: 0.3;
  background-color: rgba(0, 0, 0, 0.3);
  border-color: rgba(255, 215, 0, 0.3);
  cursor: pointer;
  transition: opacity 0.3s, background-color 0.3s;
}

#lensToggleContainer.hidden-by-gyro:hover,
#modeToggleContainer.hidden-by-gyro:hover {
  opacity: 0.7;
  background-color: rgba(0, 0, 0, 0.5);
}

#lensToggleContainer.hidden-by-gyro::after,
#modeToggleContainer.hidden-by-gyro::after {
  content: 'ÁÇπÂáªÊòæÁ§∫';
  position: absolute;
  font-size: 10px;
  color: #FFD700;
  background: rgba(0, 0, 0, 0.7);
  padding: 2px 5px;
  border-radius: 3px;
  white-space: nowrap;
  z-index: 71;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.3s;
}

#lensToggleContainer.hidden-by-gyro:hover::after,
#modeToggleContainer.hidden-by-gyro:hover::after {
  opacity: 1;
}

#lensToggleContainer.hidden-by-gyro::after {
  bottom: -20px;
  left: 50%;
  transform: translateX(-50%);
}

#modeToggleContainer.hidden-by-gyro::after {
  bottom: -20px;
  right: 10px;
}

/* ‰∏¥Êó∂ÊòæÁ§∫Áä∂ÊÄÅ */
#lensToggleContainer.temporarily-show,
#modeToggleContainer.temporarily-show {
  opacity: 1 !important;
  background-color: rgba(0, 0, 0, 0.7) !important;
  border-color: #FFD700 !important;
  display: flex !important;
}

/* Ê®™Â±èÊ®°Âºè‰∏ãÈôÄËû∫‰ª™ÂºÄÂêØÊó∂ÁöÑÁâπÊÆäÊ†∑Âºè */
@media (orientation: landscape) {
  /* ÈôÄËû∫‰ª™ÂºÄÂêØÊó∂ÈöêËóèÊéßÂà∂Âå∫Âüü */
  .gyro-active #lensToggleContainer,
  .gyro-active #modeToggleContainer {
    display: none;
  }
  
  /* ÂΩìÊéßÂà∂Âå∫ÂüüË¢´ÈöêËóèÊó∂ÔºåÊòæÁ§∫ÁÇπÂáªÊèêÁ§∫ */
  .gyro-active #lensToggleContainer.hidden-by-gyro,
  .gyro-active #modeToggleContainer.hidden-by-gyro {
    display: flex;
  }
  
  /* Á°Æ‰øùÈöêËóèÁä∂ÊÄÅ‰∏ãÁöÑÊåâÈíÆ‰πüÊúâÊ≠£Á°ÆÁöÑÊÇ¨ÂÅúÊïàÊûú */
  .gyro-active #lensToggleContainer.hidden-by-gyro .lensToggleButton,
  .gyro-active #modeToggleContainer.hidden-by-gyro .modeToggleButton {
    pointer-events: none;
    opacity: 0.5;
  }
}

@media (orientation: portrait) { 
    #photoPreview {
      top: 10px;
      left: 10px;
      width: 90px;
      height: 70px;
    }
    
    #photoPreview .noPhoto {
      font-size: 10px;
      padding: 3px;
    }
    
    #birdingToggleContainer {
      top: 10px;
      right: 10px;
    }
    
    #birdingModeToggle {
      padding: 5px 10px;
      font-size: 12px;
      min-width: 100px;
    }
    
    #birdingStatusIndicator {
      font-size: 10px;
      padding: 3px 8px;
      min-width: 100px;
    }
    
    #birdingRecordIcon {
      width: 100px;
      height: 18px;
      font-size: 9px;
      border-width: 1px;
      border-radius: 6px;
      margin-top: 3px;
    }
    
    #birdingRecordIcon::before {
      height: 2px;
    }
    
    #birdingRecordIcon .iconNumber {
      font-size: 10px;
      margin-right: 3px;
    }
    
    #birdingRecordIcon .iconTime, #birdingRecordIcon .iconBirdCount {
      font-size: 8px;
      margin-right: 3px;
    }
    
    #textStats {
      top: 85px;
      left: 10px;
      padding: 5px 10px;
      font-size: 11px;
      max-width: 60%;
      white-space: normal;
      max-height: 70px;
      overflow-y: auto;
    }
    
    #textStats span {
      margin: 0 5px;
    }
    
    #lensToggleContainer {
      bottom: 170px;
      left: 10px;
      padding: 3px;
      gap: 3px;
      border-radius: 15px;
      border-width: 1px;
      min-width: auto;
      max-width: 120px; /* ÂáèÂ∞èÊúÄÂ§ßÂÆΩÂ∫¶Ôºå‰ªé160pxÊîπ‰∏∫120px */
    }
    
    .lensToggleButton {
      padding: 2px 6px;
      font-size: 9px;
      border-radius: 8px;
      border-width: 0.5px;
      min-height: 24px;
      min-width: 40px; /* Ê∑ªÂä†ÊúÄÂ∞èÂÆΩÂ∫¶ÔºåÂáèÂ∞èÊåâÈíÆÂÆΩÂ∫¶ */
    }
    
    #lensIndicator {
      bottom: 105px;
      left: 15px;
      font-size: 9px;
      padding: 2px 4px;
    }
    
    #modeToggleContainer {
      bottom: 170px;
      right: 10px;
      flex-wrap: wrap;
      justify-content: flex-end;
      gap: 3px;
      max-width: 45%;
    }
    
    .modeToggleButton {
      padding: 2px 6px;
      font-size: 9px;
      border-radius: 8px;
      border-width: 1px;
      min-height: 24px;
      flex-shrink: 1;
      min-width: 50px;
      text-align: center;
      line-height: 1.2;
    }
    
    #birdingModeToggle {
      padding: 2px 6px;
      font-size: 9px;
      min-width: 50px;
      border-width: 1px;
      border-radius: 8px;
    }
    
    #birdingStatusIndicator {
      font-size: 8px;
      padding: 1px 4px;
      min-width: 50px;
      border-radius: 5px;
      border-width: 0.5px;
    }
    
    #birdingRecordIconsContainer {
      top: 85px;
      left: 10px;
      max-height: 150px;
    }
    
    .birdingRecordIcon {
      width: 50px;
      height: 50px;
    }
    
    .birdingRecordIcon .iconNumber {
      font-size: 16px;
    }
    
    .birdingRecordIcon .iconTime {
      font-size: 10px;
    }
    
    .birdingRecordIcon .iconBirdCount {
      font-size: 9px;
    }
    
    #timeIndicator {
      top: 30px;
      font-size: 12px;
    }
    
    #creator {
      top: 5px;
      font-size: 14px;
    }
    
    #gameTitle {
      top: 90px;
      font-size: 20px;
    }
    
    #specialAlert {
      top: 130px;
      font-size: 16px;
    }
    
    #gameNote {
      bottom: 20px;
      font-size: 10px;
      padding: 0 5px;
    }
    
    #albumModal {
      padding: 10px;
    }
    
    #albumTitle {
      font-size: 20px;
      margin-bottom: 5px;
    }
    
    #albumPromotion {
      font-size: 14px;
      margin-bottom: 10px;
    }
    
    .albumPhoto {
      width: 120px;
      height: 105px;
      margin: 5px;
    }
    
    .albumPhoto img {
      height: 75px;
    }
    
    .photoInfo {
      font-size: 10px;
      padding: 3px;
    }
    
    .albumStatItem {
      font-size: 10px;
      min-width: 100px;
      padding: 3px 6px;
    }
    
    #birdingRecordModal {
      padding: 10px;
    }
    
    #birdingRecordModal > div {
      width: 95%;
      padding: 15px;
      margin-top: 20px;
    }
    
    #birdingRecordTitle {
      font-size: 22px;
      margin-bottom: 15px;
    }
    
    .birdRecordText {
      padding: 10px;
      margin-bottom: 8px;
    }
    
    .birdRecordText .birdName {
      font-size: 14px;
    }
    
    .birdRecordText .birdStats {
      font-size: 12px;
    }
    
    .recordSummaryText {
      padding: 8px;
      margin-bottom: 10px;
    }
    
    .recordSummaryText .summaryItem {
      margin-right: 10px;
      font-size: 12px;
    }
    
    .rareBirdText {
      padding: 6px 10px;
      font-size: 12px;
    }
    
    #allBirdsAlert {
      padding: 20px 25px;
      font-size: 18px;
      max-width: 90%;
    }
    
    #allBirdsAlert button {
      padding: 8px 20px;
      font-size: 14px;
    }
    
    #gyroToggleContainer {
      left: auto !important;
      right: 10px !important;
      top: 100px !important;
      transform: none !important;
      flex-direction: column !important;
      align-items: flex-end !important;
      z-index: 71 !important;
    }
    
    #gyroSensitivityContainer {
      width: 100px !important;
      height: 35px !important;
      margin-bottom: 5px !important;
    }
    
    #gyroSensitivityLabel {
      font-size: 8px;
      margin-bottom: 1px;
    }
    
    #gyroSensitivitySlider {
      height: 3px;
    }
    
    #gyroSensitivitySlider::-webkit-slider-thumb {
      width: 8px;
      height: 8px;
    }
    
    #gyroSensitivityValue {
      font-size: 8px;
      margin-top: 0;
    }
    
    #gyroModeToggle {
      padding: 2px 4px;
      font-size: 9px;
      min-width: 100px !important;
      max-width: 100px !important;
      border-width: 1px;
      border-radius: 10px;
    }
    
    #gyroStatusIndicator {
      font-size: 8px;
      padding: 1px 3px;
      min-width: 100px !important;
      max-width: 100px !important;
      border-width: 0.5px;
      border-radius: 5px;
    }
    
    #gyroCalibrateButton {
      padding: 1px 3px;
      font-size: 8px;
      min-width: 100px !important;
      max-width: 100px !important;
      border-width: 1px;
      border-radius: 10px;
    }
    
    #cameraButton {
      right: auto;
      top: auto;
      bottom: 70px;
      left: 50%;
      transform: translateX(-50%);
      width: 80px;
      height: 80px;
      background-color: rgba(255, 255, 255, 0.9);
      border-radius: 50%;
      border: 4px solid #FFD700;
      cursor: pointer;
      z-index: 80;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }
    
    #cameraButton:hover {
      background-color: rgba(255, 255, 255, 1);
      transform: translateX(-50%) scale(1.05);
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
    }
    
    #cameraButton:active {
      background-color: rgba(230, 230, 230, 1);
      transform: translateX(-50%) scale(0.95);
    }
    
    #cameraButton::after {
      content: '';
      width: 45px;
      height: 45px;
      background-color: #FFD700;
      border-radius: 50%;
      border: 3px solid #333;
    }
    
    #screenshotButton {
      top: 10px;
      right: 70px;
      padding: 5px 10px;
      font-size: 12px;
      border-width: 1px;
      border-radius: 15px;
    }
    
    .screenshotPreviewButton {
      padding: 8px 20px;
      font-size: 14px;
      min-width: 100px;
    }
    
    /* ËßÇÈ∏üËÆ∞ÂΩïÊ®°ÊÄÅÊ°ÜÂú®Â∞èÂ±èÂπï‰∏äÁöÑË∞ÉÊï¥ */
    #birdingRecordModal > div[style*="position: fixed; top: 0"] {
      padding: 8px 15px !important;
    }
    
    #birdingRecordModal > div[style*="position: fixed; top: 0"] div:first-child {
      font-size: 16px !important;
    }
    
    #birdingRecordModal > div[style*="position: fixed; top: 0"] #birdingRecordCounter {
      font-size: 12px !important;
      padding: 3px 8px !important;
    }
    
    #birdingRecordModal > div[style*="position: fixed; top: 0"] #screenshotButton {
      padding: 6px 12px !important;
      font-size: 12px !important;
    }
    
    #birdingRecordModal > div[style*="position: fixed; top: 0"] #closeBirdingRecord {
      width: 30px !important;
      height: 30px !important;
      font-size: 16px !important;
    }
    
    #birdingRecordContent {
      margin-top: 65px !important;
      padding: 0 15px 20px 15px !important;
      font-size: 15px !important;
    }
    
    #birdingRecordNav {
      padding: 0 10px !important;
    }
    
    .birdingRecordNavButton {
      width: 40px !important;
      height: 40px !important;
      font-size: 20px !important;
    }
  }
  
  @media (orientation: portrait) and (max-width: 400px) {
    #photoPreview {
      width: 70px;
      height: 50px;
    }
    
    #textStats {
      font-size: 10px;
      padding: 4px 8px;
      top: 65px;
    }
    
    #birdingModeToggle, .lensToggleButton, .modeToggleButton {
      padding: 4px 8px;
      font-size: 11px;
      min-width: 80px;
    }
    
    #birdingStatusIndicator {
      font-size: 9px;
      padding: 2px 6px;
      min-width: 80px;
    }
    
    #birdingRecordIcon {
      width: 80px;
      height: 16px;
      font-size: 8px;
      border-radius: 4px;
      margin-top: 2px;
    }
    
    #birdingRecordIcon .iconNumber {
      font-size: 9px;
      margin-right: 2px;
    }
    
    #birdingRecordIcon .iconTime, #birdingRecordIcon .iconBirdCount {
      font-size: 7px;
      margin-right: 2px;
    }
    
    #lensToggleContainer {
      bottom: 60px;
      gap: 2px;
      padding: 2px;
      border-radius: 12px;
      max-width: 90px; /* Ëøõ‰∏ÄÊ≠•ÂáèÂ∞èÊúÄÂ§ßÂÆΩÂ∫¶ */
    }
    
    .lensToggleButton {
      padding: 1px 4px;
      font-size: 8px;
      border-radius: 6px;
      min-height: 20px;
      min-width: 30px; /* Ëøõ‰∏ÄÊ≠•ÂáèÂ∞èÊúÄÂ∞èÂÆΩÂ∫¶ */
    }
    
    #lensIndicator {
      bottom: 95px;
      font-size: 8px;
      padding: 1px 3px;
    }
    
    #modeToggleContainer {
      bottom: 60px;
      gap: 2px;
    }
    
    .modeToggleButton {
      padding: 1px 4px;
      font-size: 8px;
      border-radius: 6px;
      min-width: 40px;
      min-height: 20px;
    }
    
    #birdingModeToggle {
      padding: 1px 4px;
      font-size: 8px;
      min-width: 40px;
      border-radius: 6px;
    }
    
    #birdingStatusIndicator {
      font-size: 7px;
      padding: 1px 2px;
      min-width: 40px;
      border-radius: 4px;
    }
    
    .birdingRecordIcon {
      width: 40px;
      height: 40px;
    }
    
    .birdingRecordIcon .iconNumber {
      font-size: 14px;
    }
    
    .birdingRecordIcon .iconTime, .birdingRecordIcon .iconBirdCount {
      font-size: 9px;
    }
    
    #gyroToggleContainer {
      top: 70px !important;
      right: 5px !important;
    }
    
    #gyroSensitivityContainer {
      width: 80px !important;
      height: 30px !important;
    }
    
    #gyroModeToggle, #gyroCalibrateButton {
      min-width: 80px !important;
      max-width: 80px !important;
      font-size: 10px !important;
      padding: 3px 6px !important;
    }
    
    #gyroStatusIndicator {
      min-width: 80px !important;
      max-width: 80px !important;
      font-size: 10px !important;
      padding: 2px 4px !important;
    }
    
    #cameraButton {
      right: auto;
      top: auto;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      width: 70px;
      height: 70px;
    }
    
    #cameraButton::after {
      width: 40px;
      height: 40px;
    }
    
    #screenshotButton {
      right: 70px;
      padding: 4px 8px;
      font-size: 10px;
    }
    
    /* ËßÇÈ∏üËÆ∞ÂΩïÊ®°ÊÄÅÊ°ÜÂú®Êõ¥Â∞èÂ±èÂπï‰∏äÁöÑËøõ‰∏ÄÊ≠•Ë∞ÉÊï¥ */
    #birdingRecordModal > div[style*="position: fixed; top: 0"] {
      padding: 6px 10px !important;
    }
    
    #birdingRecordModal > div[style*="position: fixed; top: 0"] div:first-child {
      font-size: 14px !important;
    }
    
    #birdingRecordModal > div[style*="position: fixed; top: 0"] #birdingRecordCounter {
      font-size: 11px !important;
      padding: 2px 6px !important;
    }
    
    #birdingRecordModal > div[style*="position: fixed; top: 0"] #screenshotButton {
      padding: 4px 8px !important;
      font-size: 11px !important;
    }
    
    #birdingRecordModal > div[style*="position: fixed; top: 0"] #closeBirdingRecord {
      width: 28px !important;
      height: 28px !important;
      font-size: 14px !important;
    }
    
    #birdingRecordContent {
      margin-top: 55px !important;
      padding: 0 10px 15px 10px !important;
      font-size: 14px !important;
      line-height: 1.5 !important;
    }
    
    .birdingRecordNavButton {
      width: 35px !important;
      height: 35px !important;
      font-size: 18px !important;
    }
    
    #swipeHint {
      font-size: 12px !important;
      bottom: 10px !important;
    }
  }
  
  @media (orientation: landscape) and (max-height: 500px) {
    #photoPreview {
      top: 5px;
      left: 5px;
      width: 80px;
      height: 60px;
    }
    
    #birdingToggleContainer {
      top: 5px;
      right: 5px;
    }
    
    #birdingModeToggle {
      padding: 4px 8px;
      font-size: 12px;
      min-width: 100px;
    }
    
    #birdingStatusIndicator {
      font-size: 10px;
      padding: 2px 6px;
      min-width: 100px;
    }
    
    #birdingRecordIcon {
      width: 100px;
      height: 18px;
      font-size: 9px;
      border-width: 1px;
      border-radius: 6px;
      margin-top: 3px;
    }
    
    #birdingRecordIcon::before {
      height: 2px;
    }
    
    #textStats {
      top: 70px;
      left: 5px;
      font-size: 10px;
      padding: 4px 8px;
    }
    
    #lensToggleContainer {
      bottom: 40px;
      left: 5px;
    }
    
    #modeToggleContainer {
      bottom: 40px;
      right: 5px;
    }
    
    #lensIndicator {
      bottom: 65px;
    }
    
    #birdingRecordIconsContainer {
      top: 50px;
      max-height: 150px;
    }
    
    .birdingRecordIcon {
      width: 40px;
      height: 40px;
    }
    
    .birdingRecordIcon .iconNumber {
      font-size: 14px;
    }
    
    .birdingRecordIcon .iconTime {
      font-size: 9px;
    }
    
    .birdingRecordIcon .iconBirdCount {
      font-size: 8px;
    }
    
    #gyroToggleContainer {
      left: 5px;
      top: 50%;
    }
    
    #gyroSensitivityContainer {
      width: 70px;
      padding: 3px 6px;
      height: 32px;
    }
    
    #gyroModeToggle {
      padding: 4px 8px;
      font-size: 11px;
      min-width: 55px;
      max-width: 70px;
    }
    
    #gyroStatusIndicator {
      font-size: 9px;
      padding: 2px 6px;
      min-width: 55px;
      max-width: 70px;
    }
    
    #gyroCalibrateButton {
      padding: 3px 6px;
      font-size: 9px;
      min-width: 55px;
      max-width: 70px;
    }
    
    #cameraButton {
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
      width: 60px;
      height: 60px;
    }
    
    #cameraButton::after {
      width: 35px;
      height: 35px;
    }
  }
</style>
</head>
<body>
<div id="gameContainer">
  <canvas id="gameCanvas"></canvas>
  <canvas id="poopCanvas"></canvas>
  <div id="goldenFilter"></div>
  <div id="viewfinder"></div>
  <div id="photoPreview" onclick="openAlbum()">
    <div class="noPhoto">ÁÇπÂáªÊü•ÁúãÁõ∏ÂÜå<br>ÊöÇÊó†ÁÖßÁâá</div>
  </div>
  
  <!-- Êà™ÂõæÁõ∏ÂÖ≥ÂÖÉÁ¥† -->
  <canvas id="screenshotCanvas"></canvas>
  <div id="screenshotPreviewModal">
    <button id="screenshotPreviewClose" onclick="closeScreenshotPreview()">√ó</button>
    <img id="screenshotPreviewImage" src="" alt="Êà™ÂõæÈ¢ÑËßà">
    <div id="screenshotPreviewControls">
      <button class="screenshotPreviewButton" onclick="saveScreenshot()">üíæ ‰øùÂ≠òÂõæÁâá</button>
      <button class="screenshotPreviewButton" onclick="closeScreenshotPreview()">‚úï ÂÖ≥Èó≠</button>
    </div>
  </div>
  
  <div id="gyroToggleContainer">
    <div id="gyroSensitivityContainer">
      <div id="gyroSensitivityLabel">ÁÅµÊïèÂ∫¶</div>
      <input type="range" id="gyroSensitivitySlider" min="5" max="20" value="10">
      <div id="gyroSensitivityValue">10</div>
    </div>
    <div id="gyroStatusIndicator">ÂÖ≥Èó≠</div>
    <button id="gyroModeToggle">ÈôÄËû∫‰ª™</button>
    <button id="gyroCalibrateButton">Ê†°ÂáÜ</button>
  </div>
  
  <div id="cameraButton" onclick="handleCameraButtonClick()"></div>
  
  <div id="birdingToggleContainer">
    <button id="birdingModeToggle">ËßÇÈ∏üÊ®°Âºè</button>
    <div id="birdingStatusIndicator">Êú™ÂºÄÂßã</div>
    <!-- Ê∑ªÂä†ËßÇÈ∏üËÆ∞ÂΩïÂõæÊ†áÊåâÈíÆ -->
    <div id="birdingRecordIcon" style="display: none;"></div>
  </div>
  <div id="birdingRecordIconsContainer" style="position: absolute; top: 100px; right: 10px; display: flex; flex-direction: column; gap: 5px; z-index: 70; max-height: 200px; overflow-y: auto; display: none;"></div>
  <div id="textStats">
    Â∑≤Âá∫Áé∞È∏üÁ±ª: <span id="appearedCount">0</span> | Â∑≤ÊãçÊëÑÈ∏üÁ±ª: <span id="capturedCount">0</span>
  </div>
  
  <div id="modeToggleContainer">
    <button id="dayModeToggle" class="modeToggleButton">Ê∞∏‰πÖÊó•Èó¥</button>
    <button id="normalModeToggle" class="modeToggleButton active">ÊôÆÈÄöÊ®°Âºè</button>
    <button id="nightModeToggle" class="modeToggleButton">Ê∞∏‰πÖÂ§úÈó¥</button>
  </div>
  
  <div id="timeIndicator">ÁôΩÂ§© 30:00 / 30:00 | 00:00</div>
  
  <div id="lensToggleContainer">
    <button id="lens600Toggle" class="lensToggleButton active">600ÈïúÂ§¥</button>
    <button id="lens800Toggle" class="lensToggleButton">800ÈïúÂ§¥</button>
    <button id="lens1200Toggle" class="lensToggleButton">1200ÈïúÂ§¥</button>
  </div>
  
  <div id="lensIndicator">ÂΩìÂâçÈïúÂ§¥: 600mm</div>
  <div id="gameTitle">ËßÇÈ∏üÊ®°ÊãüÂô®-‰∏Ä‰∏á‰∏§ÂçÉÈ∏ªAIÂà∂‰Ωú</div>
  <div id="specialAlert"></div>
  <div id="nightObjectAlert"></div>
  <div id="captureAlert"></div>
<div id="creator">Ê≠£Âú®Âä†ËΩΩÂàõ‰ΩúËÄÖ‰ø°ÊÅØ...</div>
  
  <div id="albumModal">
    <h2 id="albumTitle">ÊàëÁöÑÁõ∏ÂÜå - ‰∏Ä‰∏á‰∏§ÂçÉÈ∏ª</h2>
    <div id="albumPhotos"></div>
    <div id="albumStats"></div>
    <button id="closeAlbum" onclick="closeAlbum()">√ó</button>
  </div>
  
<div id="birdingRecordModal" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.95); z-index: 400; display: none; color: white; font-family: 'SimSun', monospace; overflow-y: auto; white-space: pre-wrap;">
  <!-- È°∂ÈÉ®Âõ∫ÂÆöÊ†è -->
  <div style="position: fixed; top: 0; left: 0; right: 0; background: rgba(0, 0, 0, 0.9); border-bottom: 2px solid #FFD700; padding: 12px 20px; z-index: 10; display: flex; justify-content: space-between; align-items: center; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);">
    <div style="font-size: 20px; font-weight: bold; color: #FFD700;">üìñ ËßÇÈ∏üËÆ∞ÂΩï</div>
    <div id="birdingRecordCounter" style="color: white; font-size: 14px; background: rgba(255, 215, 0, 0.2); padding: 4px 12px; border-radius: 12px; border: 1px solid #FFD700;">ËÆ∞ÂΩï 1 / 1</div>
    <div style="display: flex; gap: 10px;">
      <button id="screenshotButton" onclick="captureBirdingRecord()" style="background: rgba(255, 215, 0, 0.8); color: black; border: none; border-radius: 15px; padding: 8px 15px; font-size: 14px; font-weight: bold; cursor: pointer; transition: all 0.3s;">üì∏ Êà™Âõæ</button>
      <button id="closeBirdingRecord" onclick="closeBirdingRecord()" style="background: rgba(255, 255, 255, 0.2); color: white; border: none; border-radius: 50%; width: 36px; height: 36px; font-size: 18px; cursor: pointer; transition: all 0.3s;">√ó</button>
    </div>
  </div>
  
  <!-- ÂØºËà™ÊåâÈíÆ -->
  <div id="birdingRecordNav" style="position: fixed; top: 50%; left: 0; right: 0; display: flex; justify-content: space-between; padding: 0 15px; z-index: 5; pointer-events: none; opacity: 0; transition: opacity 0.3s;">
    <button id="prevRecordButton" class="birdingRecordNavButton" onclick="switchBirdingRecord(-1)" style="pointer-events: auto; background-color: rgba(0, 0, 0, 0.7); color: white; border: 2px solid #FFD700; border-radius: 50%; width: 45px; height: 45px; font-size: 22px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.3s;">‚Üê</button>
    <button id="nextRecordButton" class="birdingRecordNavButton" onclick="switchBirdingRecord(1)" style="pointer-events: auto; background-color: rgba(0, 0, 0, 0.7); color: white; border: 2px solid #FFD700; border-radius: 50%; width: 45px; height: 45px; font-size: 22px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.3s;">‚Üí</button>
  </div>
  
  <!-- ÂÜÖÂÆπÂå∫ÂüüÔºå‰ªéÈ°∂ÈÉ®Âõ∫ÂÆöÊ†è‰∏ãÊñπÂºÄÂßã -->
  <div id="birdingRecordContent" style="margin-top: 80px; font-size: 16px; line-height: 1.6; padding: 0 20px 30px 20px;"></div>
  
  <!-- ÊªëÂä®ÊèêÁ§∫ -->
  <div id="swipeHint" class="swipe-hint" style="display: none; position: fixed; bottom: 15px; left: 0; right: 0; text-align: center; color: #FFD700; font-size: 14px; z-index: 410; opacity: 0.7; animation: pulse 2s infinite;">‰ΩøÁî®ÊªöËΩÆÊàñÊªëÂä®ÂàáÊç¢ËÆ∞ÂΩï</div>
</div>
  
  <div id="birdingRecordContent" style="margin-top: 10px; font-size: 16px; line-height: 1.6;"></div>
</div>
</div>

<script>
const GAME_WIDTH = 1600;
const GAME_HEIGHT = 900;
const ASPECT_RATIO = 16/9;

let gyroModeActive = false;
let isGyroCalibrated = false;
let lastGyroUpdate = 0;
let gyroSensitivity = 10;
let gyroX = GAME_WIDTH / 2;
let gyroY = GAME_HEIGHT / 2;
let gyroAlpha = 0;
let gyroBeta = 0;
let gyroGamma = 0;
let gyroCenterBeta = 0;
let gyroCenterGamma = 0;
let requestCalibration = true;
let currentRecordIndex = 0;
let isNavigatingRecords = false;
let touchStartY = 0;
let touchStartX = 0;
let lastWheelTime = 0;
const WHEEL_COOLDOWN = 500; // ÊªöËΩÆÂÜ∑Âç¥Êó∂Èó¥ÔºàÊØ´ÁßíÔºâ

window.addEventListener('orientationchange', () => {
  requestCalibration = true;
});

let gamePaused = false;
let pausedTimeState = {
  gameTime: 0,
  dayNightTimer: 0,
  moonPhaseTimer: 0,
  dayModeTimeState: 0,
  nightModeTimeState: 0,
  nightModeMoonPhaseTimer: 0,
  lastFrameTime: 0,
  lastBirdTime: 0,
  lastRareBirdTime: 0,
  lastLittleOwlTime: 0,
  lastOwlSpawnTime: 0,
  lastDoveSummonCheck: 0,
  pauseStartTime: 0,
  pauseDeltaOffset: 0
};

const LENS_SETTINGS = {
  '600': { name: '600mm', multiplier: 2.0, viewfinderScale: 1.0 },
  '800': { name: '800mm', multiplier: 1.42, viewfinderScale: 1.0 },
  '1200': { name: '1200mm', multiplier: 1.0, viewfinderScale: 1.0 }
};

let currentLens = '600';
let viewfinderBaseWidth = 180;
let viewfinderBaseHeight = 120;

const BIRD_COMMON_PROPS = {
  base: {
    color: "#000000",
    eyeColor: "#000000",
    whiteEyeRing: false,
    groupSize: 1,
    probability: 0.05,
    size: 1.0,
    behavior: "flyThrough",
    stayTime: 10
  },
  props: {
    BLACKBIRD_POOP: {
      poopInterval: 3000,
      poopProbability: 0.33,
      poopColor: "#FFFFFF"
    },
    EAT_FRUITS: {
      eatFruits: true,
      eatProbability: 0.1,
      eatDuration: 2000
    },
    EYE_RING: {
      white: { whiteEyeRing: true },
      yellow: { yellowEyeRing: true },
      brown: { brownEyeRing: true }
    },
    BEAK: {
      onePointFive: { beakOnePointFive: true },
      onePointThree: { beakOnePointThree: true },
      half: { halfBeak: true },
      quarter: { quarterBeak: true },
      fifth: { fifthBeak: true },
      double: { doubleBeak: true },
      long: { longBeak: true },
      reducedQuarter: { beakReducedQuarter: true }
    },
    TAIL: {
      longBlack: { longBlackTail: true },
      longBrown: { longBrownTail: true },
      longWhite: { longWhiteTail: true }
    },
    NOCTURNAL: {
      canAppearAtNight: true,
      nightProbability: 0.01
    }
  }
};

const NIGHT_OBJECTS = {
  METEOR: {
    name: "ÊµÅÊòü",
    type: "meteor",
    probability: 0.02,
    duration: 2000,
    size: 0.1,
    speed: 5.0,
    color: "#FFFFFF",
    trailLength: 100,
    trailColor: "rgba(255, 255, 200, 0.7)",
    summonProbability: 0.67
  },
  COMET: {
    name: "ÂΩóÊòü",
    type: "comet",
    probability: 0.001,
    duration: 1800000,
    size: 0.5,
    speed: 0.01,
    color: "#4682B4",
    tailLength: 50,
    tailColor: "rgba(135, 206, 235, 0.4)",
    angle: 2 * Math.PI / 3
  },
  UFO: {
    name: "UFO",
    type: "ufo",
    probability: 0.001,
    duration: 8000,
    size: 1.0,
    speed: GAME_WIDTH / 8,
    color: "#00FF00",
    beamLength: 100,
    beamColor: "rgba(144, 238, 144, 0.3)"
  }
};

const BIRD_TYPES = {
  MAGPIE: {
    name: "ÂñúÈπä",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#FFFFFF",
    headColor: "#000000",
    wingColor: "#000000",
    tailColor: "#3399ff",
    groupSize: [2, 5],
    probability: 0.067,
    size: 1.8,
    behavior: "landOnTree",
    stayTime: 100,
    whiteEyeRing: true,
    longBlackTail: true,
    eatFruits: true,
    eatProbability: 0.1,
    eatDuration: 2000,
    originalSize: 1.8
  },
  CROW: {
    name: "‰πåÈ∏¶",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#000000",
    headColor: "#000000",
    wingColor: "#000000",
    tailColor: "#000000",
    groupSize: [1, 3],
    probability: 0.051,
    size: 1.8,
    behavior: "landOnTree",
    stayTime: 50,
    whiteEyeRing: true,
    speedMultiplier: 1.5
  },
  BULBUL: {
    name: "ÁôΩÂ§¥Èπé",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#90EE90",
    headColor: "#FFFFFF",
    wingColor: "#000000",
    tailColor: "#000000",
    groupSize: [5, 10],
    probability: 0.06,
    size: 1.2,
    behavior: "flyThrough",
    whiteEyeRing: true,
    eatFruits: true,
    eatProbability: 0.15,
    eatDuration: 1500,
    originalSize: 1.2,
    speedMultiplier: 1.5
  },
  HOOPOE: {
    name: "Êà¥ËÉú",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#D2B48C",
    headColor: "#D2B48C",
    wingColor: "#000000",
    tailColor: "#000000",
    groupSize: 1,
    probability: 0.035,
    size: 1.3,
    behavior: "waveFlight",
    hasCrest: true,
    crestColor: "#D2B48C",
    whiteEyeRing: true,
    beakOnePointFive: true,
    speedMultiplier: 2.0
  },
  DOVE: {
    name: "ÊñëÈ∏†",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#808080",
    headColor: "#808080",
    wingColor: "#A0522D",
    tailColor: "#A0522D",
    groupSize: [1, 3],
    probability: 0.065,
    size: 1.5,
    behavior: "flyThrough",
    whiteEyeRing: false,
    brownEyeRing: true,
    eatFruits: true,
    eatProbability: 0.08,
    eatDuration: 1800,
    originalSize: 1.5
  },
  BLACKBIRD: {
    name: "‰πåÈ∏´",
    color: "#FFFF00",
    eyeColor: "#000000",
    bodyColor: "#000000",
    headColor: "#000000",
    wingColor: "#000000",
    tailColor: "#000000",
    groupSize: 1,
    probability: 0.064,
    size: 1.3,
    behavior: "flyThrough",
    whiteEyeRing: false,
    yellowEyeRing: true,
    eatFruits: true,
    eatProbability: 0.12,
    eatDuration: 1600,
    originalSize: 1.3,
    poopInterval: 3000,
    poopProbability: 0.33,
    poopColor: "#FFFFFF",
    speedMultiplier: 1.5
  },
  DUCK: {
    name: "ÁªøÂ§¥È∏≠",
    color: "#FFFF00",
    eyeColor: "#000000",
    bodyColor: "#FFFFFF",
    headColor: "#00AA00",
    wingColor: "#FF0000",
    tailColor: "#8B4513",
    groupSize: [5, 7],
    probability: 0.032,
    size: 2.0,
    behavior: "flyThrough",
    variant: true,
    whiteEyeRing: true,
    doubleBeak: true,
    beakOnePointFive: true
  },
  WAGTAIL: {
    name: "ÁôΩÈπ°È∏∞",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#FFFFFF",
    headColor: "#FFFFFF",
    wingColor: "#000000",
    tailColor: "#000000",
    groupSize: 2,
    probability: 0.029,
    size: 1.2,
    behavior: "waveFlight",
    whiteEyeRing: true,
    longBlackTail: true,
    hasHeart: true
  },
  WOODPECKER: {
    name: "ÂïÑÊú®È∏ü",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#8B4513",
    headColor: "#FF0000",
    wingColor: "#000000",
    tailColor: "#000000",
    groupSize: 1,
    probability: 0.056,
    size: 1.7,
    behavior: "landOnTree",
    stayTime: 10,
    whiteEyeRing: true,
    doubleBeak: true,
    peckingAction: true,
    speedMultiplier: 1.5
  },
  HERON: {
    name: "Â§úÈπ≠",
    color: "#000000",
    eyeColor: "#FF0000",
    bodyColor: "#FFFFFF",
    headColor: "#FFFFFF",
    wingColor: "#1E90FF",
    tailColor: "#FFFFFF",
    groupSize: [1, 3],
    probability: 0.04,
    size: 3.0,
    behavior: "landOnTree",
    stayTime: 20,
    whiteEyeRing: false,
    longBeak: true,
    beakReducedQuarter: true,
    canAppearAtNight: true,
    nightBodyColor: "#808080",
    nightWingColor: "#4682B4",
    nightProbability: 0.01
  },
  TIT: {
    name: "Â±±ÈõÄ",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#EEEEE0",
    headColor: "#000000",
    wingColor: "#000000",
    tailColor: "#000000",
    groupSize: [2, 5],
    probability: 0.05,
    size: 0.8,
    behavior: "landOnTreeThenMove",
    whiteEyeRing: true,
    halfBeak: true,
    stayTimePerTree: 2000,
    speedMultiplier: 1.5
  },
  PARROTBILL: {
    name: "Ê£ïÂ§¥È∏¶ÈõÄ",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#8B4513",
    headColor: "#8B4513",
    wingColor: "#8B4513",
    tailColor: "#8B4513",
    groupSize: [5, 10],
    probability: 0.033,
    size: 0.5,
    behavior: "flyInReedsAndStay",
    whiteEyeRing: true,
    quarterBeak: true,
    longBrownTail: true,
    stayTimeInReeds: 10000,
    speedMultiplier: 1.5
  },
  WARBLER: {
    name: "ÊüêÁßçÊü≥Ëé∫",
    color: "#FFFF00",
    eyeColor: "#000000",
    bodyColor: "#EEEEE0",
    headColor: "#90EE90",
    wingColor: "#339966",
    tailColor: "#339966",
    groupSize: 1,
    probability: 0.023,
    size: 0.5,
    behavior: "appearOnTree",
    stayTime: 2,
    whiteEyeRing: true,
    halfBeak: true,
    speedMultiplier: 2.0
  },
  SPARROW: {
    name: "È∫ªÈõÄ",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#D2B48C",
    headColor: "#8B4513",
    wingColor: "#808080",
    tailColor: "#8B4513",
    groupSize: [5, 10],
    probability: 0,
    size: 1.0,
    behavior: "flyThrough",
    whiteEyeRing: true,
    halfBeak: true,
    speedMultiplier: 2.0
  },
  GOLDFINCH: {
    name: "ÈáëÁøÖÈõÄ",
    color: "#000000",
    eyeColor: "#8B4513",
    bodyColor: "#D2B48C",
    headColor: "#808080",
    wingColor: "#FFD700",
    tailColor: "#FFD700",
    groupSize: [2, 9],
    probability: 0.055,
    size: 1.0,
    behavior: "flyThrough",
    whiteEyeRing: true,
    halfBeak: true,
    eatFruits: true,
    eatProbability: 0.2,
    eatDuration: 1200,
    originalSize: 1.0,
    speedMultiplier: 2.0
  },
  KENTISH_PLOVER: {
    name: "ÈáëÁú∂È∏ª",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#FFFFFF",
    headColor: "#D2B48C",
    wingColor: "#D2B48C",
    tailColor: "#D2B48C",
    groupSize: [2, 3],
    probability: 0.015,
    size: 1.3,
    behavior: "flyThrough",
    whiteEyeRing: false,
    yellowEyeRing: true,
    beakOnePointFive: true,
    landOnReedsChance: 0.8,
    landOnReedsTime: 10,
    groundPecking: true,
    groundMoveSpeed: 0.3
  },
  PEREGRINE: {
    name: "Ê∏∏Èöº",
    color: "#FFFF00",
    eyeColor: "#000000",
    bodyColor: "#FFFFFF",
    headColor: "#000000",
    wingColor: "#808080",
    tailColor: "#808080",
    groupSize: 1,
    probability: 0.009,
    size: 2.0,
    behavior: "circleThenHuntBird",
    iconColor: "#FFFFFF",
    whiteEyeRing: true,
    yellowEyeRing: true
  },
  KESTREL: {
    name: "Á∫¢Èöº",
    color: "#FFFF00",
    eyeColor: "#000000",
    bodyColor: "#D2B48C",
    headColor: "#606060",
    wingColor: "#8B0000",
    tailColor: "#707070",
    groupSize: 1,
    probability: 0.027,
    size: 2.0,
    behavior: "circleThenHunt",
    iconColor: "#8B0000",
    whiteEyeRing: false,
    yellowEyeRing: true,
    isPredator: true,
    diveSpeedMultiplier: 2.0,
    catchDoveChance: 0.3,
    catchMouseChance: 0.5,
    leaveChance: 0.2,
    scareOtherBirds: true
  },
  RUDDYSHELDUCK: {
    name: "Ëµ§È∫ªÈ∏≠",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#FF8C00",
    headColor: "#FFFFFF",
    wingColor: "#FF8C00",
    tailColor: "#FF8C00",
    groupSize: 2,
    probability: 0.025,
    size: 3.0,
    behavior: "flyThrough",
    iconColor: "#FF8C00",
    whiteEyeRing: true,
    beakOnePointThree: true,
    speedMultiplier: 2.0
  },
  MINIVET: {
    name: "Â±±Ê§íÈ∏ü",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#FF0000",
    headColor: "#000000",
    wingColor: "#000000",
    tailColor: "#000000",
    groupSize: [8, 10],
    probability: 0.008,
    size: 1.2,
    behavior: "flyThrough",
    variant: true,
    iconColor: "#FF0000",
    whiteEyeRing: true
  },
  KINGFISHER: {
    name: "Áø†È∏ü",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#FF9933", // Ë∫´‰ΩìÊ©ôËâ≤
    headColor: "#33CCCC", // Â§¥ÈÉ®ÈùíËâ≤
    wingColor: "#3399FF", // ÁøÖËÜÄËìùËâ≤
    tailColor: "#33CCCC", // Â∞æÈÉ®ÈùíËâ≤
    beakColor: "#000000", // Âò¥ÈªëËâ≤
    eyeRingColor: "#FFA500", // ÁúºÂúàÊ©ôËâ≤
    groupSize: 1,
    probability: 0.023,
    size: 1.2, // 1.2ÂÄçÈ∫ªÈõÄÂ§ßÂ∞è
    behavior: "flyToReedAndPerch",
    stayTime: [45000, 60000], // ÂÅúÁïô45-60Áßí
    headAngle: Math.PI/4, // Â§¥ÊñúÂêë‰∏ã45Â∫¶
    turnInterval: [15000, 25000], // ÊØè15-25ÁßíÊç¢Âêë
    diveSpeed: 3.0,
    beakLengthMultiplier: 3, // Âò¥Èïø‰∏∫3ÂÄç
    isVulnerableToRaptors: true,
    canAppearAtNight: false, // Âè™Âú®ÁôΩÂ§©Âá∫Áé∞
    isKingfisher: true, // ÁâπÊÆäÊ†áËÆ∞
    fishSize: 15, // È±ºÁöÑÂ§ßÂ∞è
    fishColor: "#3399FF", // È±ºÁöÑÈ¢úËâ≤
    originalSize: 1.2
  },
  GOLDCREST: {
    name: "Êà¥Ëèä",
    color: "#000000",
    eyeColor: "#FFFFFF",
    bodyColor: "#90EE90",
    headColor: "#FFFF00",
    wingColor: "#00FF00",
    tailColor: "#00FF00",
    groupSize: 1,
    probability: 0.01,
    size: 0.5,
    behavior: "appearOnTree",
    stayTime: 5,
    iconColor: "#FFFF00",
    whiteEyeRing: false,
    riceBallAppearance: true,
    halfBeakFlying: true,
    halfBeak: true
  },
  OWL: {
    name: "ÈïøËÄ≥È∏Æ",
    color: "#000000",
    bodyColor: "#8B4513",
    groupSize: 1,
    probability: 0.011,
    size: 2.5,
    behavior: "appearOnTree",
    stayTime: 15,
    faceScreen: true,
    iconColor: "#8B4513",
    eyeColor: "#FFA500",
    whiteEyeRing: true
  },
  LITTLEGREBE: {
    name: "Â∞èÂåó",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#FFFFFF",
    headColor: "#FFFFFF",
    wingColor: "#000000",
    tailColor: "#000000",
    groupSize: [2, 5],
    probability: 0.013,
    size: 0.5,
    behavior: "flyToReedsAndStay",
    stayTime: 30,
    iconColor: "#FFFFFF",
    whiteEyeRing: false,
    longBlackTail: true,
    fifthBeak: true,
    reedStayTime: 20000,
    reedMoveSpeed: 0.6
  },
  BLACKWINGEDKITE: {
    name: "ÈªëÁøÖÈ∏¢",
    color: "#000000",
    eyeColor: "#FF0000",
    bodyColor: "#FFFFFF",
    headColor: "#FFFFFF",
    wingColor: "#808080",
    tailColor: "#FFFFFF",
    groupSize: 1,
    probability: 0.02,
    size: 2.0,
    behavior: "circleThenHoverThenHuntMouse",
    iconColor: "#000000",
    whiteEyeRing: true
  },
  TWELVE_THOUSAND_PLOVER: {
    name: "12000È∏ª",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#FFFFFF",
    headColor: "#D2B48C",
    wingColor: "#D2B48C",
    tailColor: "#D2B48C",
    groupSize: [10, 20],
    probability: 0.00008333,
    size: 1.3,
    behavior: "flyThrough",
    whiteEyeRing: false,
    yellowEyeRing: true,
    beakOnePointFive: true,
    landOnReedsChance: 0.8,
    landOnReedsTime: 10,
    groundPecking: true,
    groundMoveSpeed: 0.3,
    isSpecial: true
  },
  LITTLE_OWL: {
    name: "Â∞èÈ∏Æ",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#D2B48C",
    headColor: "#D2B48C",
    wingColor: "#D2B48C",
    tailColor: "#D2B48C",
    groupSize: 1,
    probability: 0.014,
    size: 1.28,
    behavior: "appearInWallHole",
    stayTime: 15,
    iconColor: "#D2B48C",
    whiteEyeRing: true,
    isNocturnal: true,
    nightEyeColor: "#FFFF99",
    nightEyeRingColor: "#FFFF99"
  },
  EAGLE_OWL: {
    name: "ÈõïÈ∏Æ",
    color: "#6B4F37",
    eyeColor: "#FFFF99",
    bodyColor: "#666666",
    headColor: "#6B4F37",
    wingColor: "#5A422E",
    tailColor: "#5A422E",
    groupSize: 1,
    probability: 0.05,
    size: 3.2,
    behavior: "circleThenGlideToGround",
    iconColor: "#6B4F37",
    whiteEyeRing: false,
    isNocturnal: true,
    isOwl: true,
    speedMultiplier: 0.6,
    circleTime: 30000,
    catchPreyChance: 0.3,
    catchPreyType: "hedgehog",
    scareOtherOwls: true,
    wingOffset: -0.33
  },
  SHORT_EARED_OWL: {
    name: "Áü≠ËÄ≥È∏Æ",
    color: "#8B7D6B",
    eyeColor: "#FFFF99",
    bodyColor: "#8B7D6B",
    headColor: "#8B7D6B",
    wingColor: "#7A6D5C",
    tailColor: "#7A6D5C",
    groupSize: 1,
    probability: 0.15,
    size: 1.8,
    behavior: "circleThenGlideToGround",
    iconColor: "#8B7D6B",
    whiteEyeRing: false,
    blackEyeRing: true,
    isNocturnal: true,
    isOwl: true,
    speedMultiplier: 0.5,
    circleTime: 50000,
    catchPreyChance: 0.5,
    catchPreyType: "mouse",
    scaredByEagleOwl: true,
    wingOffset: -0.33,
    flyInLowerHalf: true
  },
  LONGTAILED_FINCH: {
    name: "ÈïøÂ∞æÈõÄ",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#FF3366",
    headColor: "#EED2EE",
    wingColor: "#A0522D",
    tailColor: "#000000",
    groupSize: [1, 2],
    probability: 0.012,
    size: 1.0,
    behavior: "landOnTreeTop",
    stayTime: 10,
    whiteEyeRing: false,
    halfBeak: true,
    isVulnerableToRaptors: true
  },
  ROBIN: {
    name: "ÁΩóÂÆæ",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#F4F4F4",
    headColor: "#FF6600",
    wingColor: "#A0522D",
    tailColor: "#000000",
    groupSize: [1, 2],
    probability: 0.005,
    size: 1.0,
    behavior: "landOnTreeBottom",
    stayTime: 5,
    whiteEyeRing: false,
    beakLengthMultiplier: 0.8,
    isVulnerableToRaptors: true
  },
  HAWFINCH: {
    name: "Ëú°Âò¥ÈõÄ",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#D9D9D9",
    headColor: "#000000",
    wingColor: "#000000",
    tailColor: "#000000",
    beakColor: "#FF8C00",
    groupSize: [2, 6],
    probability: 0.031,
    size: 1.2,
    behavior: "landOnTreeTop",
    stayTime: 15,
    whiteEyeRing: false,
    quarterBeak: true,
    beakLengthMultiplier: 0.25,
    isVulnerableToRaptors: true,
    eatFruits: true,
    eatProbability: 0.15,
    eatDuration: 2000,
    originalSize: 1.2,
    iconColor: "#8B4513"
  },
  BRAMBLING: {
    name: "ÁáïÈõÄ",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#FCFCFC",
    headColor: "#D9D9D9",
    wingColor: "#FFA500",
    tailColor: "#000000",
    beakColor: "#FF4500",
    groupSize: [2, 8],
    probability: 0.045,
    size: 1.0,
    behavior: "flyThrough",
    stayTime: 10,
    whiteEyeRing: false,
    halfBeak: true,
    isVulnerableToRaptors: true,
    eatFruits: true,
    eatProbability: 0.1,
    eatDuration: 1800,
    originalSize: 1.0,
    iconColor: "#FFA500"
  },
  BAT: {
    name: "ËùôËù†",
    color: "#333333",
    eyeColor: "#000000",
    bodyColor: "#333333",
    headColor: "#333333",
    wingColor: "#666666",
    tailColor: "#333333",
    groupSize: [1, 2],
    probability: 0.10,
    size: 1.0,
    behavior: "circleThenLeave",
    iconColor: "#333333",
    whiteEyeRing: false,
    isNocturnal: true,
    isBat: true,
    speedMultiplier: 0.7,
    circleTime: 15000,
    maxConcurrent: 3,
    flyInUpperHalf: true
  }
};

let raptorsPresent = [];
let chasingMagpiesCrows = [];

let totalProbability = 0;
Object.values(BIRD_TYPES).forEach(bird => {
  if (bird.name !== "È∫ªÈõÄ" && !bird.isSpecial && !bird.isOwl && !bird.isBat) {
    totalProbability += bird.probability;
  }
});
BIRD_TYPES.SPARROW.probability = Math.max(0, 1 - totalProbability);

let canvas, ctx, poopCanvas, poopCtx;
let trees = [];
let birds = [];
let nightObjects = [];
let photos = [];
let capturedBirds = {};
let appearedBirds = {};
let mouseX = GAME_WIDTH / 2, mouseY = GAME_HEIGHT / 2;
let viewfinderVisible = false;
let viewfinderWidth = 90, viewfinderHeight = 60;
let lastBirdTime = 0;
let birdInterval = 10000;
let birdIntervalVariation = 500;
let gameTime = 0;
let treePositions = [];
let reedZone = null;
let isHunting = false;
let birdSpeedMultiplier = 1;
let specialBirdAlertTimeout = null;
let nightObjectAlertTimeout = null;
let captureAlertTimeout = null;
let isTakingPhoto = false;
let lastFrameTime = 0;
let fixedLeaves = [];
let scareMode = false;
let scareModeEndTime = 0;
let chasingBirds = [];
let reedBends = [];
let birdGroupInfo = {};
let nextGroupId = 1;
let poops = [];
let groundObjects = [];
let fruits = [];
let lastDoveSummonCheck = 0;
const DOVE_SUMMON_INTERVAL = 5000;
let stars = [];
const STARS_COUNT = 50;
let hasShownAllBirdsAlert = false;
const ALL_BIRDS = Object.values(BIRD_TYPES).filter(bird => !bird.isSpecial && !bird.isBat).map(bird => bird.name);

let isDaytime = true;
let dayNightTimer = 0;
const DAY_NIGHT_CYCLE_DURATION = 15 * 60 * 1000;
const RARE_BIRDS = ['KENTISH_PLOVER', 'MINIVET', 'GOLDCREST', 'OWL', 'LITTLEGREBE', 'LONGTAILED_FINCH', 'ROBIN'];
let lastRareBirdTime = 0;
const RARE_BIRD_INTERVAL = 60 * 60 * 1000;
let sunMoonPosition = 0;
let sunMoonX = 0;
let sunMoonY = 0;
let moonPhase = 0;
const MOON_PHASE_CYCLE = 354 * 60 * 1000;
let moonPhaseTimer = 0;
let wall = null;
let hole = null;
let littleOwl = null;
let lastLittleOwlTime = 0;
const LITTLE_OWL_DAY_COOLDOWN = 300000;
const LITTLE_OWL_NIGHT_COOLDOWN = 180000;
const NIGHT_OWL_SPAWN_INTERVAL = 30000;
let lastOwlSpawnTime = 0;
const MAX_SHORT_EARED_OWL_COUNT = 3;
const MAX_BAT_COUNT = 3;

let gameMode = 'normal';
let normalModeTimeState = { isDaytime: true, dayNightTimer: 0, moonPhaseTimer: 0 };
let dayModeTimeState = 0;
let nightModeTimeState = 0;
let nightModeMoonPhaseTimer = 0;

let isGoldenFilterActive = false;

let birdingRecords = [];
let lastBirdingRecordTime = 0;
let currentBirdingRecord = null;
let birdingModeActive = false;
let birdingModeStartTime = 0;
let birdingModeDuration = 0;
let birdingModeEndTime = 0;
let isDaytimeAtStart = true;
let birdingModeStartSnapshot = {};
let birdingModeBirdTracker = {};
let birdingObservedSpecies = new Set();
let birdingModeRecordedBirds = new Set();
let birdingModeUpdateInterval = null;
let birdingModeCapturedSpecies = null; // Áî®‰∫éËÆ∞ÂΩïÊú¨Ê¨°ËßÇÈ∏üÊúüÈó¥ÊãçÊëÑÁöÑÈ∏üÁßç

// Êà™ÂõæÁõ∏ÂÖ≥ÂèòÈáè
let screenshotCanvas, screenshotCtx;
let currentScreenshotDataURL = null;

function initGyro() {
    const gyroModeButton = document.getElementById('gyroModeToggle');
    const gyroStatusIndicator = document.getElementById('gyroStatusIndicator');
    const sensitivitySlider = document.getElementById('gyroSensitivitySlider');
    const sensitivityValue = document.getElementById('gyroSensitivityValue');
    const sensitivityContainer = document.getElementById('gyroSensitivityContainer');
    const calibrateButton = document.getElementById('gyroCalibrateButton');
    const cameraButton = document.getElementById('cameraButton'); // Ëé∑ÂèñÂø´Èó®ÊåâÈíÆ
    
    // ËÆæÁΩÆÈªòËÆ§Áä∂ÊÄÅÔºöÂè™ÊòæÁ§∫ÈôÄËû∫‰ª™ÊåâÈíÆÔºåÂÖ∂‰ªñÂÖÉÁ¥†ÈöêËóè
    gyroStatusIndicator.style.display = 'none';
    sensitivityContainer.style.display = 'none';
    calibrateButton.style.display = 'none';
    cameraButton.style.display = 'none'; // ÈöêËóèÂø´Èó®ÊåâÈíÆ
    
    // ËÆæÁΩÆÈôÄËû∫‰ª™ÊåâÈíÆ‰∏∫ÂçäÈÄèÊòé
    gyroModeButton.style.opacity = '0.5';
    
    gyroModeButton.addEventListener('click', toggleGyroMode);
    calibrateButton.addEventListener('click', handleGyroCalibrate);
    sensitivitySlider.addEventListener('input', function() {
        gyroSensitivity = parseInt(this.value);
        sensitivityValue.textContent = gyroSensitivity;
    });
    
    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
        // iOSËÆæÂ§áÈúÄË¶ÅÊùÉÈôê
    } else if ('ondeviceorientation' in window) {
        // ËÆæÂ§áÊîØÊåÅÈôÄËû∫‰ª™
    } else {
        // ËÆæÂ§á‰∏çÊîØÊåÅÈôÄËû∫‰ª™
        gyroModeButton.disabled = true;
        gyroModeButton.style.opacity = '0.3';
        gyroModeButton.title = "ËÆæÂ§á‰∏çÊîØÊåÅÈôÄËû∫‰ª™";
    }
}

function handleGyroCalibrate() {
  if (!gyroModeActive) {
    showSpecialAlert("ËØ∑ÂÖàÂºÄÂêØÈôÄËû∫‰ª™Ê®°Âºè");
    return;
  }
  calibrateGyro();
}

function toggleGyroMode() {
  if (gamePaused) return;
  
  if (!gyroModeActive) {
    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
      DeviceOrientationEvent.requestPermission()
        .then(permissionState => {
          if (permissionState === 'granted') {
            startGyroMode();
          } else {
            showSpecialAlert("ÈôÄËû∫‰ª™ÊùÉÈôêË¢´ÊãíÁªù");
          }
        })
        .catch(console.error);
    } else {
      startGyroMode();
    }
  } else {
    stopGyroMode();
  }
}

function startGyroMode() {
  gyroModeActive = true;
  isGyroCalibrated = false;
  const gyroModeButton = document.getElementById('gyroModeToggle');
  const gyroStatusIndicator = document.getElementById('gyroStatusIndicator');
  const sensitivityContainer = document.getElementById('gyroSensitivityContainer');
  const calibrateButton = document.getElementById('gyroCalibrateButton');
  const cameraButton = document.getElementById('cameraButton');
  const goldenFilter = document.getElementById('goldenFilter');
  const lensToggleContainer = document.getElementById('lensToggleContainer');
  const modeToggleContainer = document.getElementById('modeToggleContainer');
  
  goldenFilter.style.backgroundColor = 'rgba(255, 215, 0, 0)';
  
  gyroModeButton.classList.add('active');
  gyroModeButton.textContent = "ÂÖ≥Èó≠ÈôÄËû∫‰ª™";
  gyroModeButton.style.opacity = '1';
  gyroStatusIndicator.style.display = 'block';
  sensitivityContainer.style.display = 'block';
  calibrateButton.style.display = 'block';
  cameraButton.style.display = 'flex';
  gyroStatusIndicator.textContent = "Ê†°ÂáÜ‰∏≠...";
  
  // Ê®™Â±èÊó∂ÈöêËóèÈïúÂ§¥ÂàáÊç¢Âå∫ÂíåÊ®°ÂºèÂàáÊç¢Âå∫
  if (window.matchMedia("(orientation: landscape)").matches) {
    if (lensToggleContainer) {
      lensToggleContainer.style.display = 'none';
      lensToggleContainer.classList.add('hidden-by-gyro');
    }
    if (modeToggleContainer) {
      modeToggleContainer.style.display = 'none';
      modeToggleContainer.classList.add('hidden-by-gyro');
    }
  }
  
  gyroX = GAME_WIDTH / 2;
  gyroY = GAME_HEIGHT / 2;
  mouseX = gyroX;
  mouseY = gyroY;
  
  showSpecialAlert("ÈôÄËû∫‰ª™Ê®°ÂºèÂ∑≤ÂêØÂä®ÔºÅËØ∑‰øùÊåÅËÆæÂ§áÊ∞¥Âπ≥‰ª•ËøõË°åÊ†°ÂáÜ„ÄÇ");
  
  setTimeout(() => {
    if (gyroModeActive && !isGyroCalibrated) {
      calibrateGyro();
    }
  }, 2000);
  
  window.addEventListener('deviceorientation', handleDeviceOrientation);
}

function stopGyroMode() {
  gyroModeActive = false;
  const gyroModeButton = document.getElementById('gyroModeToggle');
  const gyroStatusIndicator = document.getElementById('gyroStatusIndicator');
  const sensitivityContainer = document.getElementById('gyroSensitivityContainer');
  const calibrateButton = document.getElementById('gyroCalibrateButton');
  const cameraButton = document.getElementById('cameraButton');
  const lensToggleContainer = document.getElementById('lensToggleContainer');
  const modeToggleContainer = document.getElementById('modeToggleContainer');
  
  gyroModeButton.classList.remove('active');
  gyroModeButton.textContent = "ÈôÄËû∫‰ª™";
  gyroModeButton.style.opacity = '0.5';
  gyroStatusIndicator.style.display = 'none';
  sensitivityContainer.style.display = 'none';
  calibrateButton.style.display = 'none';
  cameraButton.style.display = 'none';
  gyroStatusIndicator.textContent = "ÂÖ≥Èó≠";
  
  // ÊÅ¢Â§çÊòæÁ§∫ÈïúÂ§¥ÂàáÊç¢Âå∫ÂíåÊ®°ÂºèÂàáÊç¢Âå∫
  if (lensToggleContainer) {
    lensToggleContainer.style.display = 'flex';
    lensToggleContainer.classList.remove('hidden-by-gyro');
  }
  if (modeToggleContainer) {
    modeToggleContainer.style.display = 'flex';
    modeToggleContainer.classList.remove('hidden-by-gyro');
  }
  
  window.removeEventListener('deviceorientation', handleDeviceOrientation);
  showSpecialAlert("ÈôÄËû∫‰ª™Ê®°ÂºèÂ∑≤ÂÖ≥Èó≠");
}

// Ê∑ªÂä†ÁÇπÂáª‰∫ã‰ª∂ÁõëÂê¨Âô®ÔºåÂÖÅËÆ∏ÁÇπÂáªË¢´ÈöêËóèÁöÑÂå∫ÂüüÊù•ÊòæÁ§∫ÂÆÉ‰ª¨
function addToggleAreaClickListeners() {
  const lensToggleContainer = document.getElementById('lensToggleContainer');
  const modeToggleContainer = document.getElementById('modeToggleContainer');
  
  if (lensToggleContainer) {
    lensToggleContainer.addEventListener('click', function(e) {
      // Â¶ÇÊûúËøô‰∏™Âå∫ÂüüË¢´ÈôÄËû∫‰ª™ÈöêËóè‰∫ÜÔºåÁÇπÂáªÊó∂ÊòæÁ§∫ÂÆÉ
      if (this.classList.contains('hidden-by-gyro') && gyroModeActive) {
        this.style.display = 'flex';
        this.classList.remove('hidden-by-gyro');
        e.stopPropagation();
        
        // 5ÁßíÂêéËá™Âä®ÈöêËóè
        setTimeout(() => {
          if (gyroModeActive && window.matchMedia("(orientation: landscape)").matches) {
            this.style.display = 'none';
            this.classList.add('hidden-by-gyro');
          }
        }, 5000);
      }
    });
  }
  
  if (modeToggleContainer) {
    modeToggleContainer.addEventListener('click', function(e) {
      // Â¶ÇÊûúËøô‰∏™Âå∫ÂüüË¢´ÈôÄËû∫‰ª™ÈöêËóè‰∫ÜÔºåÁÇπÂáªÊó∂ÊòæÁ§∫ÂÆÉ
      if (this.classList.contains('hidden-by-gyro') && gyroModeActive) {
        this.style.display = 'flex';
        this.classList.remove('hidden-by-gyro');
        e.stopPropagation();
        
        // 5ÁßíÂêéËá™Âä®ÈöêËóè
        setTimeout(() => {
          if (gyroModeActive && window.matchMedia("(orientation: landscape)").matches) {
            this.style.display = 'none';
            this.classList.add('hidden-by-gyro');
          }
        }, 5000);
      }
    });
  }
}

function calibrateGyro() {
    if (!gyroModeActive) return;
    requestCalibration = true;
    isGyroCalibrated = true;
    const gyroStatusIndicator = document.getElementById('gyroStatusIndicator');
    gyroStatusIndicator.textContent = "Â∑≤Ê†°ÂáÜ";
    showSpecialAlert("ÈôÄËû∫‰ª™Ê†°ÂáÜÂÆåÊàêÔºÅ");
}

function handleDeviceOrientation(event) {
  if (!gyroModeActive || gamePaused) return;
  
  const now = Date.now();
  if (now - lastGyroUpdate < 16) return;
  lastGyroUpdate = now;
  
  const beta = event.beta;
  const gamma = event.gamma;
  
  if (beta === null || gamma === null) return;
  
  if (!isGyroCalibrated) {
    calibrateGyro();
    return;
  }
  
  if (requestCalibration) {
    gyroCenterBeta = beta;
    gyroCenterGamma = gamma;
    requestCalibration = false;
    return;
  }
  
  const sensitivityFactor = gyroSensitivity / 10;
  
  let orientation = window.orientation || 0;
  if (screen.orientation && screen.orientation.angle) {
    orientation = screen.orientation.angle;
  }
  
  let xAngle = 0;
  let yAngle = 0;
  
  if (orientation === 90) {
    xAngle = beta - gyroCenterBeta;
    yAngle = -(gamma - gyroCenterGamma);
  } else if (orientation === -90 || orientation === 270) {
    xAngle = -(beta - gyroCenterBeta);
    yAngle = gamma - gyroCenterGamma;
  } else if (orientation === 180) {
    xAngle = -(gamma - gyroCenterGamma);
    yAngle = -(beta - gyroCenterBeta);
  } else {
    xAngle = gamma - gyroCenterGamma;
    yAngle = beta - gyroCenterBeta;
  }
  
  const maxTiltAngle = 30;
  const xMultiplier = (GAME_WIDTH / 2) / maxTiltAngle;
  const yMultiplier = (GAME_HEIGHT / 2) / maxTiltAngle;
  
  const limitedXAngle = Math.max(-60, Math.min(60, xAngle));
  const limitedYAngle = Math.max(-60, Math.min(60, yAngle));
  
  const targetX = GAME_WIDTH / 2 + (limitedXAngle * xMultiplier * sensitivityFactor);
  const targetY = GAME_HEIGHT / 2 + (limitedYAngle * yMultiplier * sensitivityFactor);
  
  gyroX = gyroX + (targetX - gyroX) * 0.2;
  gyroY = gyroY + (targetY - gyroY) * 0.2;
  
  mouseX = Math.max(0, Math.min(GAME_WIDTH, gyroX));
  mouseY = Math.max(0, Math.min(GAME_HEIGHT, gyroY));
  
  updateViewfinderFromGyro();
}

function updateViewfinderFromGyro() {
  if (!gyroModeActive || gamePaused) return;
  
  const viewfinder = document.getElementById('viewfinder');
  const viewfinderSize = getViewfinderSize();
  const actualViewfinderWidth = viewfinderSize.width;
  const actualViewfinderHeight = viewfinderSize.height;
  
  const rect = canvas.getBoundingClientRect();
  const container = document.getElementById('gameContainer');
  const containerRect = container.getBoundingClientRect();
  
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  
  const screenX = mouseX / scaleX;
  const screenY = mouseY / scaleY;
  
  const canvasLeft = rect.left - containerRect.left;
  const canvasTop = rect.top - containerRect.top;
  
  viewfinder.style.display = 'block';
  viewfinder.style.width = (actualViewfinderWidth * rect.width / canvas.width) + 'px';
  viewfinder.style.height = (actualViewfinderHeight * rect.height / canvas.height) + 'px';
  viewfinder.style.left = (canvasLeft + screenX - actualViewfinderWidth * rect.width / canvas.width / 2) + 'px';
  viewfinder.style.top = (canvasTop + screenY - actualViewfinderHeight * rect.height / canvas.height / 2) + 'px';
}

function handleCameraButtonClick() {
  handleMouseClick();
  
  const cameraButton = document.getElementById('cameraButton');
  cameraButton.style.backgroundColor = 'rgba(200, 200, 200, 0.9)';
  setTimeout(() => {
    cameraButton.style.backgroundColor = 'rgba(255, 255, 255, 0.9)';
  }, 100);
}

function handleMouseMove(e) {
  if (gyroModeActive) return;
  
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  
  mouseX = (e.clientX - rect.left) * scaleX;
  mouseY = (e.clientY - rect.top) * scaleY;
  
  if (!gyroModeActive) {
    const viewfinder = document.getElementById('viewfinder');
    const viewfinderSize = getViewfinderSize();
    const actualViewfinderWidth = viewfinderSize.width;
    const actualViewfinderHeight = viewfinderSize.height;
    
    viewfinder.style.display = 'block';
    viewfinder.style.width = (actualViewfinderWidth * rect.width / canvas.width) + 'px';
    viewfinder.style.height = (actualViewfinderHeight * rect.height / canvas.height) + 'px';
    viewfinder.style.left = (e.clientX - actualViewfinderWidth * rect.width / canvas.width / 2) + 'px';
    viewfinder.style.top = (e.clientY - actualViewfinderHeight * rect.height / canvas.height / 2) + 'px';
  }
}

// Âú®JavaScript‰∏≠Ê∑ªÂä†Ëøô‰∏™ÂáΩÊï∞
function loadCreatorInfo() {
    fetch('creator.txt')
        .then(response => {
            if (!response.ok) {
                throw new Error('Êó†Ê≥ïÂä†ËΩΩÂàõ‰ΩúËÄÖ‰ø°ÊÅØ');
            }
            return response.text();
        })
        .then(text => {
            const creatorDiv = document.getElementById('creator');
            if (creatorDiv && text.trim()) {
                creatorDiv.textContent = text.trim();
            } else {
                creatorDiv.textContent = "È∏ü‰∫∫È∏üËØ≠";
            }
        })
        .catch(error => {
            console.error('Âä†ËΩΩÂàõ‰ΩúËÄÖ‰ø°ÊÅØÂ§±Ë¥•:', error);
            const creatorDiv = document.getElementById('creator');
            if (creatorDiv) {
                creatorDiv.textContent = "È∏ü‰∫∫È∏üËØ≠";
            }
        });
}


function init() {
    canvas = document.getElementById('gameCanvas');
    ctx = canvas.getContext('2d');
    poopCanvas = document.getElementById('poopCanvas');
    poopCtx = poopCanvas.getContext('2d');
    
    loadCreatorInfo();
    
    // Á°Æ‰øùÊà™ÂõæÁîªÂ∏ÉÊ≠£Á°ÆÂàùÂßãÂåñ
    screenshotCanvas = document.getElementById('screenshotCanvas');
    screenshotCtx = screenshotCanvas.getContext('2d');
    
    // ËÆæÁΩÆÊà™ÂõæÁîªÂ∏É‰∏∫ÈöêËóè‰ΩÜÂèØÁî®Áä∂ÊÄÅ
    screenshotCanvas.style.position = 'absolute';
    screenshotCanvas.style.left = '-9999px';
    screenshotCanvas.style.top = '-9999px';
    screenshotCanvas.style.width = '300px';
    screenshotCanvas.style.height = '450px';
        
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    initStars();
    initTrees();
    initReeds();
    initFixedLeaves();
    initTextStats();
    initFruits();
    initWallAndHole();
    initModeToggleButtons();
    initLensToggleButtons();
    initGyro();
    
    const birdingModeButton = document.getElementById('birdingModeToggle');
    birdingModeButton.addEventListener('click', toggleBirdingMode);
    
    lastRareBirdTime = gameTime;
    canvas.addEventListener('mousemove', handleMouseMove);
    canvas.addEventListener('mousedown', handleMouseClick);
    document.addEventListener('keydown', handleKeyDown);
    lastFrameTime = performance.now();
    
    const goldenFilter = document.getElementById('goldenFilter');
    if (!gyroModeActive) {
        goldenFilter.style.backgroundColor = 'rgba(255, 215, 0, 0.1)';
    }
    addToggleAreaClickListeners();
    updateTimeIndicator();
    updateLensIndicator();
    initBirdingRecords();
    updateBirdingModeButton();
// ÂàùÂßãÂåñËßÇÈ∏üËÆ∞ÂΩïÂõæÊ†áÊòæÁ§∫
    updateBirdingRecordIcons();

    requestAnimationFrame(gameLoop);

// Á°Æ‰øùÊà™ÂõæÊåâÈíÆÂú®È°µÈù¢Âä†ËΩΩÊó∂Â∞±ÁªëÂÆö‰∫ã‰ª∂
    const screenshotButton = document.getElementById('screenshotButton');
    if (screenshotButton) {
        // ÁßªÈô§ÂèØËÉΩÂ≠òÂú®ÁöÑÊóßÁõëÂê¨Âô®ÔºåÈáçÊñ∞ÁªëÂÆö
        const newScreenshotButton = screenshotButton.cloneNode(true);
        screenshotButton.parentNode.replaceChild(newScreenshotButton, screenshotButton);
        
        // ÈáçÊñ∞Ëé∑ÂèñÊåâÈíÆÂºïÁî®
        const updatedScreenshotButton = document.getElementById('screenshotButton');
        updatedScreenshotButton.onclick = function(e) {
            e.stopPropagation();
            captureBirdingRecord();
        };
    }
}

function handleVisibilityChange() {
    if (document.hidden) {
        // È°µÈù¢‰∏çÂèØËßÅÊó∂ÔºåÂèØ‰ª•ÈÄÇÂΩìÈôç‰ΩéÊ∏∏ÊàèÂæ™ÁéØÈ¢ëÁéáÊàñÊöÇÂÅúÈùûÂøÖË¶ÅÊõ¥Êñ∞
        console.log('È°µÈù¢Â§±ÂéªÁÑ¶ÁÇπ');
    } else {
        // È°µÈù¢ÈáçÊñ∞ÂèØËßÅÊó∂ÔºåÈáçÁΩÆ lastFrameTime ÈÅøÂÖçÊó∂Èó¥Ë∑≥Ë∑É
        lastFrameTime = performance.now();
        console.log('È°µÈù¢ÈáçÊñ∞Ëé∑ÂæóÁÑ¶ÁÇπ');
    }
}

function gameLoop(timestamp) {
    if (gamePaused) {
        requestAnimationFrame(gameLoop);
        return;
    }
    
    // ÈôêÂà∂ÊúÄÂ§ß deltaTimeÔºåÈÅøÂÖçÂ§±ÂéªÁÑ¶ÁÇπÂêéÊó∂Èó¥Â∑ÆËøáÂ§ß
    let deltaTime = timestamp - lastFrameTime;
    lastFrameTime = timestamp;
    
    // ÈôêÂà∂ÊúÄÂ§ß deltaTime ‰∏∫ 30ms
    if (deltaTime > 30) {
        deltaTime = 30;
    }
    
    updateDayNight(deltaTime);
    updateBirds(deltaTime);
    updateNightObjects(deltaTime);
    generateBird();
    
    if (gyroModeActive) {
        updateViewfinderFromGyro();
    }
    
    requestAnimationFrame(gameLoop);
}

function initBirdingRecords() {
  lastBirdingRecordTime = gameTime;
  birdingModeBirdTracker = {};
  birdingObservedSpecies = new Set();
  birdingModeRecordedBirds = new Set();
}

function getBirdsInView() {
  const viewBounds = {
    left: 0,
    right: GAME_WIDTH,
    top: 0,
    bottom: GAME_HEIGHT
  };
  
  const birdsInView = [];
  const countedGroups = new Set();
  
  birds.forEach(bird => {
    if (!bird.name || bird.isBat || bird.type?.isSpecial) return;
    
    const baseSize = 20;
    const birdSize = baseSize * bird.size;
    const birdRadius = birdSize / 2;
    
    const isInView = bird.x + birdRadius >= viewBounds.left &&
                    bird.x - birdRadius <= viewBounds.right &&
                    bird.y + birdRadius >= viewBounds.top &&
                    bird.y - birdRadius <= viewBounds.bottom;
    
    if (isInView) {
      birdsInView.push(bird);
      
      if (bird.groupId && birdGroupInfo[bird.groupId]) {
        if (!countedGroups.has(bird.groupId)) {
          countedGroups.add(bird.groupId);
        }
      }
    }
  });
  
  return birdsInView;
}

function countBirdsInView() {
  const birdsInView = getBirdsInView();
  const birdCounts = {};
  const countedGroups = new Set();
  
  birdsInView.forEach(bird => {
    const birdName = bird.name;
    if (!birdCounts[birdName]) {
      birdCounts[birdName] = 0;
    }
    
    if (bird.groupId && birdGroupInfo[bird.groupId]) {
      if (!countedGroups.has(bird.groupId)) {
        const group = birdGroupInfo[bird.groupId];
        if (group && group.birds) {
          let groupCount = 0;
          group.birds.forEach(groupBird => {
            if (groupBird && birds.includes(groupBird)) {
              const baseSize = 20;
              const groupBirdRadius = baseSize * groupBird.size / 2;
              const isGroupBirdInView = groupBird.x + groupBirdRadius >= 0 &&
                                        groupBird.x - groupBirdRadius <= GAME_WIDTH &&
                                        groupBird.y + groupBirdRadius >= 0 &&
                                        groupBird.y - groupBirdRadius <= GAME_HEIGHT;
              if (isGroupBirdInView) {
                groupCount++;
              }
            }
          });
          birdCounts[birdName] += groupCount;
          countedGroups.add(bird.groupId);
        }
      }
    } else {
      birdCounts[birdName]++;
    }
  });
  
  return birdCounts;
}

// Êõ¥Êñ∞ËßÇÈ∏üËÆ∞ÂΩïÂõæÊ†áÊòæÁ§∫
function updateBirdingRecordIcons() {
    const iconElement = document.getElementById('birdingRecordIcon');
    if (!iconElement) return;
    
    // Â¶ÇÊûúÊúâËßÇÈ∏üËÆ∞ÂΩïÔºåÊòæÁ§∫ÂõæÊ†á
    if (birdingRecords.length > 0) {
        const latestRecord = birdingRecords[birdingRecords.length - 1];
        
        const totalSeconds = Math.floor(latestRecord.birdingModeDuration / 1000);
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        
        // ËÆæÁΩÆÂõæÊ†áÂÜÖÂÆπ
        iconElement.innerHTML = `
            <span class="iconNumber">#${latestRecord.id}</span>
            <span class="iconTime">${minutes}:${seconds.toString().padStart(2, '0')}</span>
            <span class="iconBirdCount">${latestRecord.totalObservedSpecies}Áßç</span>
        `;
        
        // Ê∑ªÂä†ÁÇπÂáª‰∫ã‰ª∂
        iconElement.onclick = function() {
            openBirdingRecord(birdingRecords.length - 1);
        };
        
        // ÊòæÁ§∫ÂõæÊ†á
        iconElement.style.display = 'flex';
    } else {
        // Ê≤°ÊúâËÆ∞ÂΩïÊó∂ÈöêËóèÂõæÊ†á
        iconElement.style.display = 'none';
    }
}

function createBirdingRecord() {
  if (!birdingModeActive && birdingObservedSpecies.size === 0) {
    return null;
  }
  
  // ËÆ°ÁÆóÊú¨Ê¨°ËßÇÈ∏üÊúüÈó¥ÊãçÊëÑÁöÑÈ∏üÁßçÊï∞
  const capturedInSession = birdingModeCapturedSpecies ? birdingModeCapturedSpecies.size : 0;
   
  // Êü•ÊâæÊúÄÁ®ÄÊúâÈ∏üÁßç
  let rarestBird = null;
  let minProbability = Infinity;
  for (const birdName of birdingObservedSpecies) {
    const birdKey = Object.keys(BIRD_TYPES).find(key => BIRD_TYPES[key].name === birdName);
    if (birdKey && BIRD_TYPES[birdKey].probability > 0 && BIRD_TYPES[birdKey].probability < minProbability) {
      minProbability = BIRD_TYPES[birdKey].probability;
      rarestBird = birdName;
    }
  }
  
  // ÂàõÂª∫ËßÇÈ∏üËÆ∞ÂΩï
  const record = {
    id: birdingRecords.length + 1,
    time: gameTime,
    observedSpecies: Array.from(birdingObservedSpecies),
    totalObservedSpecies: birdingObservedSpecies.size,
    capturedInSession: capturedInSession, // Êú¨Ê¨°ËßÇÈ∏üÊúüÈó¥ÊãçÊëÑÁöÑÈ∏üÁßçÊï∞
    rarestBird: rarestBird,
    birdingModeDuration: birdingModeActive ? (gameTime - birdingModeStartTime) : 
                         (birdingModeEndTime ? (birdingModeEndTime - birdingModeStartTime) : 0),
    startedAtDaytime: isDaytimeAtStart,
    endedAtDaytime: isDaytime
  };
  
  // ‰øùÂ≠òËÆ∞ÂΩïÔºàÊúÄÂ§ö20Êù°Ôºâ
  birdingRecords.push(record);
  if (birdingRecords.length > 20) {
    birdingRecords.shift();
  }
  
  // Êõ¥Êñ∞ÂõæÊ†á
  updateBirdingRecordIcons();
  
  return record;
}

function openBirdingRecord(recordIndex) {
  if (recordIndex < 0 || recordIndex >= birdingRecords.length) return;
  
  pauseGame();
  
  const modal = document.getElementById('birdingRecordModal');
  const content = document.getElementById('birdingRecordContent');
  const screenshotButton = document.getElementById('screenshotButton');
  const nav = document.getElementById('birdingRecordNav');
  const counter = document.getElementById('birdingRecordCounter');
  const swipeHint = document.getElementById('swipeHint');
  
  // ËÆæÁΩÆÂΩìÂâçËÆ∞ÂΩïÁ¥¢Âºï
  currentRecordIndex = recordIndex;
  
  modal.style.display = 'block';
  modal.style.zIndex = '400';
  
  // ÊòæÁ§∫ÂØºËà™ÊåâÈíÆÂíåËÆ°Êï∞Âô®
  nav.classList.add('show');
  counter.classList.add('show');
  swipeHint.style.display = 'block';
  
  screenshotButton.style.display = 'block';
  screenshotButton.style.pointerEvents = 'auto';
  screenshotButton.style.opacity = '1';
  screenshotButton.style.zIndex = '401';
  screenshotButton.parentNode.appendChild(screenshotButton);
  
  // Êõ¥Êñ∞ÂØºËà™ÊåâÈíÆÁä∂ÊÄÅ
  updateRecordNavButtons();
  
  // Êõ¥Êñ∞ËÆ∞ÂΩïÂÜÖÂÆπ
  updateRecordContent(recordIndex);
  
  // Ê∑ªÂä†‰∫ã‰ª∂ÁõëÂê¨Âô®
  modal.addEventListener('wheel', handleRecordWheel, { passive: false });
  modal.addEventListener('touchstart', handleRecordTouchStart, { passive: true });
  modal.addEventListener('touchmove', handleRecordTouchMove, { passive: false });
  modal.addEventListener('touchend', handleRecordTouchEnd, { passive: true });
  
  screenshotButton.onclick = function(e) {
    e.stopPropagation();
    captureBirdingRecord();
  };
  
  // 3ÁßíÂêéÈöêËóèÊªëÂä®ÊèêÁ§∫
  setTimeout(() => {
    swipeHint.style.display = 'none';
  }, 3000);
}
  
  function updateRecordContent(recordIndex) {
  const record = birdingRecords[recordIndex];
  const content = document.getElementById('birdingRecordContent');
  const counter = document.getElementById('birdingRecordCounter');
  
  currentBirdingRecord = record;
  currentRecordIndex = recordIndex;
  
  const totalSeconds = Math.floor(record.birdingModeDuration / 1000);
  const minutes = Math.floor(totalSeconds / 60);
  const seconds = totalSeconds % 60;
  
  let recordText = `Á¨¨ ${record.id} Ê¨°ËßÇÈ∏üËÆ∞ÂΩï\n`;
  recordText += "=".repeat(50) + "\n\n";
  recordText += `ËßÇÈ∏üÊó∂Èïø: ${minutes}ÂàÜ${seconds}Áßí\n`;
  recordText += `Êó∂Èó¥Ë∑®Â∫¶: ${record.startedAtDaytime ? "ÁôΩÂ§©" : "ÈªëÂ§ú"} ‚Üí ${record.endedAtDaytime ? "ÁôΩÂ§©" : "ÈªëÂ§ú"}\n`;
  recordText += `ËßÇÂØüÈ∏üÁßç: ${record.totalObservedSpecies} Áßç\n`;
  recordText += `ÊãçÊëÑÈ∏üÁßç: ${record.capturedInSession} Áßç\n`;
  
  if (record.rarestBird) {
    recordText += `ÊúÄÁ®ÄÊúâÈ∏üÁßç: ${record.rarestBird}\n`;
  }
  
  recordText += "=".repeat(50) + "\n\n";
  recordText += "ËßÇÂØüÂà∞ÁöÑÈ∏üÁßç:\n";
  recordText += "-".repeat(50) + "\n\n";
  
  record.observedSpecies.sort().forEach((birdName, index) => {
    const birdKey = Object.keys(BIRD_TYPES).find(key => BIRD_TYPES[key].name === birdName);
    const isRare = birdKey && BIRD_TYPES[birdKey].probability < 0.02;
    
    if (birdName === record.rarestBird) {
      recordText += `${index + 1}. ${birdName} ‚òÖ\n`;
    } else if (isRare) {
      recordText += `${index + 1}. ${birdName} (Á®ÄÊúâ)\n`;
    } else {
      recordText += `${index + 1}. ${birdName}\n`;
    }
  });
  
  content.textContent = recordText;
  
  // Êõ¥Êñ∞ËÆ°Êï∞Âô®
  counter.textContent = `ËÆ∞ÂΩï ${recordIndex + 1} / ${birdingRecords.length}`;
  
  // Êõ¥Êñ∞ÂØºËà™ÊåâÈíÆÁä∂ÊÄÅ
  updateRecordNavButtons();
}

function updateRecordNavButtons() {
  const prevButton = document.getElementById('prevRecordButton');
  const nextButton = document.getElementById('nextRecordButton');
  
  prevButton.disabled = currentRecordIndex <= 0;
  nextButton.disabled = currentRecordIndex >= birdingRecords.length - 1;
}

// ÂàáÊç¢ËÆ∞ÂΩï
function switchBirdingRecord(direction) {
  if (isNavigatingRecords) return;
  
  const newIndex = currentRecordIndex + direction;
  
  if (newIndex >= 0 && newIndex < birdingRecords.length) {
    isNavigatingRecords = true;
    
    // Ê∑ªÂä†ÂàáÊç¢Âä®ÁîªÊïàÊûú
    const content = document.getElementById('birdingRecordContent');
    content.style.opacity = '0.5';
    content.style.transition = 'opacity 0.2s';
    
    setTimeout(() => {
      updateRecordContent(newIndex);
      content.style.opacity = '1';
      
      setTimeout(() => {
        isNavigatingRecords = false;
      }, 100);
    }, 100);
  }
}

// Â§ÑÁêÜÊªöËΩÆ‰∫ã‰ª∂
function handleRecordWheel(event) {
  if (isNavigatingRecords) return;
  
  const now = Date.now();
  if (now - lastWheelTime < WHEEL_COOLDOWN) return;
  
  event.preventDefault();
  
  // Âà§Êñ≠ÊªöËΩÆÊñπÂêë
  if (event.deltaY > 0) {
    // Âêë‰∏ãÊªöÂä®ÔºåÂàáÊç¢Âà∞‰∏ã‰∏ÄÊù°ËÆ∞ÂΩï
    switchBirdingRecord(1);
  } else if (event.deltaY < 0) {
    // Âêë‰∏äÊªöÂä®ÔºåÂàáÊç¢Âà∞‰∏ä‰∏ÄÊù°ËÆ∞ÂΩï
    switchBirdingRecord(-1);
  }
  
  lastWheelTime = now;
}

// Â§ÑÁêÜËß¶Êë∏ÂºÄÂßã‰∫ã‰ª∂
function handleRecordTouchStart(event) {
  if (event.touches.length === 1) {
    touchStartY = event.touches[0].clientY;
    touchStartX = event.touches[0].clientX;
  }
}

// Â§ÑÁêÜËß¶Êë∏ÁßªÂä®‰∫ã‰ª∂
function handleRecordTouchMove(event) {
  if (isNavigatingRecords || event.touches.length !== 1) return;
  
  event.preventDefault();
  
  const touchY = event.touches[0].clientY;
  const touchX = event.touches[0].clientX;
  
  // ËÆ°ÁÆóÂûÇÁõ¥ÊªëÂä®Ë∑ùÁ¶ª
  const deltaY = touchY - touchStartY;
  const deltaX = touchX - touchStartX;
  
  // Â¶ÇÊûúÊòØÂûÇÁõ¥ÊªëÂä®‰∏îË∑ùÁ¶ªË∂≥Â§üÂ§ßÔºåÂàôÂàáÊç¢ËÆ∞ÂΩï
  if (Math.abs(deltaY) > 50 && Math.abs(deltaY) > Math.abs(deltaX)) {
    if (deltaY > 0) {
      // Âêë‰∏ãÊªëÂä®ÔºåÂàáÊç¢Âà∞‰∏ä‰∏ÄÊù°ËÆ∞ÂΩï
      switchBirdingRecord(-1);
    } else {
      // Âêë‰∏äÊªëÂä®ÔºåÂàáÊç¢Âà∞‰∏ã‰∏ÄÊù°ËÆ∞ÂΩï
      switchBirdingRecord(1);
    }
    
    // ÈáçÁΩÆËß¶Êë∏Ëµ∑ÁÇπ
    touchStartY = touchY;
    touchStartX = touchX;
  }
}

// Â§ÑÁêÜËß¶Êë∏ÁªìÊùü‰∫ã‰ª∂
function handleRecordTouchEnd() {
  touchStartY = 0;
  touchStartX = 0;
}

// ‰øÆÊîπ closeBirdingRecord ÂáΩÊï∞
function closeBirdingRecord() {
  const modal = document.getElementById('birdingRecordModal');
  const screenshotButton = document.getElementById('screenshotButton');
  const nav = document.getElementById('birdingRecordNav');
  const counter = document.getElementById('birdingRecordCounter');
  
  // ÁßªÈô§‰∫ã‰ª∂ÁõëÂê¨Âô®
  modal.removeEventListener('wheel', handleRecordWheel);
  modal.removeEventListener('touchstart', handleRecordTouchStart);
  modal.removeEventListener('touchmove', handleRecordTouchMove);
  modal.removeEventListener('touchend', handleRecordTouchEnd);
  
  modal.style.display = 'none';
  nav.classList.remove('show');
  counter.classList.remove('show');
  
  screenshotButton.style.display = 'none';
  currentBirdingRecord = null;
  
  resumeGame();
}

function toggleBirdingMode() {
  if (gamePaused) return;
  
  if (!birdingModeActive) {
    // ÂºÄÂßãËßÇÈ∏üÊ®°Âºè
    birdingModeActive = true;
    birdingModeStartTime = gameTime;
    isDaytimeAtStart = isDaytime;
    
    // Á¶ÅÁî®ÂÖ∂‰ªñÊ®°ÂºèÊåâÈíÆ
    const dayModeButton = document.getElementById('dayModeToggle');
    const normalModeButton = document.getElementById('normalModeToggle');
    const nightModeButton = document.getElementById('nightModeToggle');
    dayModeButton.disabled = true;
    normalModeButton.disabled = true;
    nightModeButton.disabled = true;
    dayModeButton.style.opacity = '0.5';
    normalModeButton.style.opacity = '0.5';
    nightModeButton.style.opacity = '0.5';
    
    // ÂàùÂßãÂåñÊú¨Ê¨°ËßÇÈ∏üÁöÑÁªüËÆ°
    birdingObservedSpecies = new Set();
    birdingModeRecordedBirds = new Set();
    birdingModeCapturedSpecies = new Set(); // ÂàùÂßãÂåñÊú¨Ê¨°ËßÇÈ∏üÊãçÊëÑÈ∏üÁßçÈõÜÂêà
    
    // ËÆ∞ÂΩïÂàùÂßãÁä∂ÊÄÅ
    const initialBirds = getBirdsInView();
    initialBirds.forEach(bird => {
      if (bird.noStats) return;
      const birdId = `${bird.name}_${bird.x}_${bird.y}_${bird.groupId || 'single'}`;
      if (!birdingModeRecordedBirds.has(birdId)) {
        birdingModeRecordedBirds.add(birdId);
        birdingObservedSpecies.add(bird.name);
      }
    });
    
    // ËÆ∞ÂΩïËßÇÈ∏üÊ®°ÂºèÂºÄÂßãÊó∂ÁöÑÂø´ÁÖß
    birdingModeStartSnapshot = {
      startTime: gameTime,
      startedAtDaytime: isDaytime,
      birdCounts: countBirdsInView(),
      captured: {...capturedBirds}, // Â§çÂà∂ÂΩìÂâçÁöÑÊãçÊëÑÁä∂ÊÄÅ
      birds: birds.map(bird => ({ 
        name: bird.name, 
        type: bird.type, 
        x: bird.x, 
        y: bird.y, 
        groupId: bird.groupId 
      }))
    };
    
    birdingModeBirdTracker = {};
    lastBirdingRecordTime = gameTime;
    
    showSpecialAlert("ËßÇÈ∏üÊ®°ÂºèÂ∑≤ÂêØÂä®ÔºÅËÆ∞ÂΩïÂ∑≤ÂºÄÂßã„ÄÇ");
    updateBirdingModeButton();
  } else {
    // ÁªìÊùüËßÇÈ∏üÊ®°Âºè
    birdingModeActive = false;
    birdingModeEndTime = gameTime;
    
    // ÈáçÊñ∞ÂêØÁî®ÂÖ∂‰ªñÊ®°ÂºèÊåâÈíÆ
    const dayModeButton = document.getElementById('dayModeToggle');
    const normalModeButton = document.getElementById('normalModeToggle');
    const nightModeButton = document.getElementById('nightModeToggle');
    dayModeButton.disabled = false;
    normalModeButton.disabled = false;
    nightModeButton.disabled = false;
    dayModeButton.style.opacity = '1';
    normalModeButton.style.opacity = '1';
    nightModeButton.style.opacity = '1';
    
    // ÂàõÂª∫ËßÇÈ∏üËÆ∞ÂΩï
    const record = createBirdingRecord();
    updateBirdingModeButton();
    
    if (record) {
      const elapsedMinutes = Math.floor(record.birdingModeDuration / 60000);
      const elapsedSeconds = Math.floor((record.birdingModeDuration % 60000) / 1000);
      showSpecialAlert(`ËßÇÈ∏üÊ®°ÂºèÁªìÊùüÔºÅÊåÅÁª≠${elapsedMinutes}ÂàÜ${elapsedSeconds}ÁßíÔºåËßÇÂØü${record.totalObservedSpecies}ÁßçÔºåÊãçÊëÑ${record.capturedInSession}Áßç`);
      
      if (record.totalObservedSpecies > 0) {
        pauseGame();
        openBirdingRecord(record.id - 1);
      }
    } else {
      showSpecialAlert("ËßÇÈ∏üÊ®°ÂºèÁªìÊùüÔºåÊú™ÁîüÊàêËÆ∞ÂΩïÊï∞ÊçÆ„ÄÇ");
    }
    
    // Ê∏ÖÁ©∫ËßÇÈ∏üÊ®°ÂºèÁõ∏ÂÖ≥Êï∞ÊçÆ
    birdingModeStartSnapshot = {};
    birdingObservedSpecies = new Set();
    birdingModeRecordedBirds = new Set();
    birdingModeCapturedSpecies = null; // Ê∏ÖÁ©∫Êú¨Ê¨°ËßÇÈ∏üÊãçÊëÑËÆ∞ÂΩï
  }
}

function updateBirdingModeButton() {
  const birdingModeButton = document.getElementById('birdingModeToggle');
  const birdingStatusIndicator = document.getElementById('birdingStatusIndicator');
  
  if (birdingModeActive) {
    birdingModeButton.classList.add('active');
    birdingModeButton.style.borderColor = '#90EE90';
    birdingModeButton.textContent = "ÁªìÊùüËßÇÈ∏üÊ®°Âºè";
    
    const birdingDuration = gameTime - birdingModeStartTime;
    const birdingMinutes = Math.floor(birdingDuration / 60000);
    const birdingSeconds = Math.floor((birdingDuration % 60000) / 1000);
    
    birdingStatusIndicator.textContent = `ËøõË°å‰∏≠ ${birdingMinutes}:${birdingSeconds.toString().padStart(2, '0')}`;
    birdingStatusIndicator.style.color = '#90EE90';
    
    if (birdingModeUpdateInterval) {
      clearInterval(birdingModeUpdateInterval);
      birdingModeUpdateInterval = null;
    }
    
    birdingModeUpdateInterval = setInterval(() => {
      if (birdingModeActive) {
        const currentBirds = getBirdsInView();
        currentBirds.forEach(bird => {
          if (bird.noStats) return;
          const birdId = `${bird.name}_${bird.x}_${bird.y}_${bird.groupId || 'single'}`;
          if (!birdingModeRecordedBirds.has(birdId)) {
            birdingModeRecordedBirds.add(birdId);
            birdingObservedSpecies.add(bird.name);
          }
        });
      }
    }, 1000);
  } else {
    birdingModeButton.classList.remove('active');
    birdingModeButton.style.borderColor = '#90EE90';
    birdingModeButton.textContent = "ËßÇÈ∏üÊ®°Âºè";
    birdingStatusIndicator.textContent = "Êú™ÂºÄÂßã";
    birdingStatusIndicator.style.color = "white";
    
    if (birdingModeUpdateInterval) {
      clearInterval(birdingModeUpdateInterval);
      birdingModeUpdateInterval = null;
    }
  }
}

function initLensToggleButtons() {
  const lens600Button = document.getElementById('lens600Toggle');
  const lens800Button = document.getElementById('lens800Toggle');
  const lens1200Button = document.getElementById('lens1200Toggle');
  
  lens600Button.addEventListener('click', () => setLens('600'));
  lens800Button.addEventListener('click', () => setLens('800'));
  lens1200Button.addEventListener('click', () => setLens('1200'));
  
  updateLensToggleButtons();
}

function setLens(lens) {
  if (currentLens === lens) return;
  
  currentLens = lens;
  showSpecialAlert(`ÂàáÊç¢Âà∞${LENS_SETTINGS[lens].name}ÈïúÂ§¥`);
  
  updateLensToggleButtons();
  updateLensIndicator();
}

function updateLensToggleButtons() {
  const lens600Button = document.getElementById('lens600Toggle');
  const lens800Button = document.getElementById('lens800Toggle');
  const lens1200Button = document.getElementById('lens1200Toggle');
  
  lens600Button.classList.toggle('active', currentLens === '600');
  lens800Button.classList.toggle('active', currentLens === '800');
  lens1200Button.classList.toggle('active', currentLens === '1200');
}

function updateLensIndicator() {
  const lensIndicator = document.getElementById('lensIndicator');
  lensIndicator.textContent = `ÂΩìÂâçÈïúÂ§¥: ${LENS_SETTINGS[currentLens].name}`;
}

function getViewfinderSize() {
  const lensMultiplier = LENS_SETTINGS[currentLens].multiplier;
  return {
    width: viewfinderBaseWidth * lensMultiplier,
    height: viewfinderBaseHeight * lensMultiplier
  };
}

function initFixedLeaves() {
  fixedLeaves = [];
  
  treePositions.forEach(tree => {
    for (let i = 0; i < 30; i++) {
      const leafX = tree.x + Math.random() * tree.width;
      const leafY = tree.y + Math.random() * tree.height * 0.8;
      const leafSize = 3 + Math.random() * 5;
      const leafType = Math.floor(Math.random() * 3);
      const leafColor = leafType === 0 ? '#228B22' : leafType === 1 ? '#2E8B57' : '#32CD32';
      
      fixedLeaves.push({
        treeIndex: treePositions.indexOf(tree),
        x: leafX,
        y: leafY,
        size: leafSize,
        color: leafColor,
        type: leafType,
        rotation: Math.random() * Math.PI * 2,
        offsetX: (Math.random() - 0.5) * 2,
        offsetY: (Math.random() - 0.5) * 2
      });
    }
  });
}

function initWallAndHole() {
  const wallWidth = 80;
  const wallHeight = 200;
  const wallX = GAME_WIDTH - wallWidth - 10;
  const wallY = GAME_HEIGHT - wallHeight;
  
  wall = {
    x: wallX,
    y: wallY,
    width: wallWidth,
    height: wallHeight,
    color: '#505050'
  };
  
  const sparrowSize = 20 * BIRD_TYPES.SPARROW.size;
  const holeDiameter = sparrowSize * 2;
  const holeX = wallX + wallWidth / 2;
  const holeY = wallY + wallHeight * 0.3;
  
  hole = {
    x: holeX,
    y: holeY,
    diameter: holeDiameter
  };
}

function initModeToggleButtons() {
  const dayModeButton = document.getElementById('dayModeToggle');
  const normalModeButton = document.getElementById('normalModeToggle');
  const nightModeButton = document.getElementById('nightModeToggle');
  
  dayModeButton.addEventListener('click', () => setGameMode('day'));
  normalModeButton.addEventListener('click', () => setGameMode('normal'));
  nightModeButton.addEventListener('click', () => setGameMode('night'));
  
  updateModeToggleButtons();
}

function easeInOutQuad(t) {
  return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
}

function setGameMode(mode) {
  if (gameMode === mode) return;
  
  const oldMode = gameMode;
  gameMode = mode;
  
  if (mode === 'day') {
    if (oldMode === 'normal') {
      normalModeTimeState = {
        isDaytime: isDaytime,
        dayNightTimer: dayNightTimer,
        moonPhaseTimer: moonPhaseTimer
      };
    }
    
    isDaytime = true;
    dayNightTimer = dayModeTimeState;
    
    showSpecialAlert("ÂàáÊç¢Âà∞Ê∞∏‰πÖÊó•Èó¥Ê®°Âºè");
    
    for (let i = birds.length - 1; i >= 0; i--) {
      if (birds[i].isOwl || birds[i].isBat) {
        birds.splice(i, 1);
      }
    }
    
    if (littleOwl) {
      birds.splice(birds.indexOf(littleOwl), 1);
      littleOwl = null;
    }
    
    nightObjects = [];
  } else if (mode === 'night') {
    if (oldMode === 'normal') {
      normalModeTimeState = {
        isDaytime: isDaytime,
        dayNightTimer: dayNightTimer,
        moonPhaseTimer: moonPhaseTimer
      };
    }
    
    isDaytime = false;
    dayNightTimer = nightModeTimeState;
    moonPhaseTimer = nightModeMoonPhaseTimer || Math.random() * MOON_PHASE_CYCLE;
    
    showSpecialAlert("ÂàáÊç¢Âà∞Ê∞∏‰πÖÂ§úÈó¥Ê®°Âºè");
    
    for (let i = birds.length - 1; i >= 0; i--) {
      if (!birds[i].isOwl && !birds[i].isBat && birds[i].name !== "Â∞èÈ∏Æ" && birds[i].name !== "Â§úÈπ≠") {
        birds.splice(i, 1);
      }
    }
    
    nightObjects = [];
  } else if (mode === 'normal') {
    if (oldMode === 'day') {
      dayModeTimeState = dayNightTimer;
      isDaytime = normalModeTimeState.isDaytime;
      dayNightTimer = normalModeTimeState.dayNightTimer;
      moonPhaseTimer = normalModeTimeState.moonPhaseTimer;
    } else if (oldMode === 'night') {
      nightModeTimeState = dayNightTimer;
      nightModeMoonPhaseTimer = moonPhaseTimer;
      isDaytime = normalModeTimeState.isDaytime;
      dayNightTimer = normalModeTimeState.dayNightTimer;
      moonPhaseTimer = normalModeTimeState.moonPhaseTimer;
    } else {
      if (normalModeTimeState) {
        isDaytime = normalModeTimeState.isDaytime;
        dayNightTimer = normalModeTimeState.dayNightTimer;
        moonPhaseTimer = normalModeTimeState.moonPhaseTimer;
      } else {
        isDaytime = true;
        dayNightTimer = 0;
        moonPhaseTimer = 0;
      }
    }
    
    showSpecialAlert("ÂàáÊç¢Âà∞ÊôÆÈÄöÊ®°Âºè");
    
    if (oldMode === 'night') {
      for (let i = birds.length - 1; i >= 0; i--) {
        if (birds[i].isOwl || birds[i].isBat) {
          birds.splice(i, 1);
        }
      }
      nightObjects = [];
    }
  }
  
  updateModeToggleButtons();
  updateTimeIndicator();
}

function updateModeToggleButtons() {
  const dayModeButton = document.getElementById('dayModeToggle');
  const normalModeButton = document.getElementById('normalModeToggle');
  const nightModeButton = document.getElementById('nightModeToggle');
  
  dayModeButton.classList.toggle('active', gameMode === 'day');
  normalModeButton.classList.toggle('active', gameMode === 'normal');
  nightModeButton.classList.toggle('active', gameMode === 'night');
}

function updateTimeIndicator() {
  const timeIndicator = document.getElementById('timeIndicator');
  const totalSeconds = Math.floor(gameTime / 1000);
  const minutes = Math.floor(totalSeconds / 60);
  const seconds = totalSeconds % 60;
  
  if (gameMode === 'normal') {
    const remainingTime = DAY_NIGHT_CYCLE_DURATION - dayNightTimer;
    const remainingMinutes = Math.floor(remainingTime / 60000);
    const remainingSeconds = Math.floor((remainingTime % 60000) / 1000);
    
    const timeText = `${isDaytime ? "ÁôΩÂ§©" : "ÈªëÂ§ú"} ${remainingMinutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')} / 15:00 | ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    timeIndicator.textContent = timeText;
  } else if (gameMode === 'day') {
    const timeText = `Ê∞∏‰πÖÊó•Èó¥ | ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    timeIndicator.textContent = timeText;
  } else if (gameMode === 'night') {
    const timeText = `Ê∞∏‰πÖÂ§úÈó¥ | ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    timeIndicator.textContent = timeText;
  }
}

// ËßÇÈ∏üËÆ∞ÂΩïÊà™ÂõæÂáΩÊï∞
function captureBirdingRecord() {
    console.log("ÂºÄÂßãÊà™ÂõæËÆ∞ÂΩï...");
    
    if (!currentBirdingRecord) {
        console.warn("Ê≤°ÊúâÂΩìÂâçËßÇÈ∏üËÆ∞ÂΩï");
        showSpecialAlert("ËØ∑ÂÖàÊâìÂºÄËßÇÈ∏üËÆ∞ÂΩïÔºÅ");
        return;
    }
    
    const screenshotButton = document.getElementById('screenshotButton');
    screenshotButton.disabled = true;
    screenshotButton.style.opacity = '0.5';
    screenshotButton.textContent = "ÁîüÊàê‰∏≠...";
    
// ‰∏¥Êó∂Á¶ÅÁî®ÊªëÂä®ÂäüËÉΩ
  const originalNavigating = isNavigatingRecords;
  isNavigatingRecords = true;
  
  try {
    if (!gamePaused) {
      pauseGame();
    }
        
        const SCREENSHOT_WIDTH = 300;
        const lineHeight = 22;
        const record = currentBirdingRecord;
        const speciesCount = record.observedSpecies.length;
        
        // Á≤æÁ°ÆËÆ°ÁÆóÊâÄÈúÄÈ´òÂ∫¶
        const titleHeight = 50;
        const recordInfoHeight = 5 * lineHeight;
        const headerMargin = 35;
        const footerHeight = 30;
        const speciesListHeight = speciesCount * lineHeight;
        
        // Âä®ÊÄÅËÆ°ÁÆóÊÄªÈ´òÂ∫¶ÔºàÊîØÊåÅÂ§öÂàóÂ∏ÉÂ±ÄÔºâ
        const baseHeight = titleHeight + recordInfoHeight + headerMargin + footerHeight + 20;
        const dynamicHeight = baseHeight + Math.min(speciesListHeight, 800); // ÈôêÂà∂ÂàóË°®ÈÉ®ÂàÜÈ´òÂ∫¶
        
        // ËÆæÁΩÆÂêàÁêÜÁöÑÊúÄÂ§ßÊúÄÂ∞èÈ´òÂ∫¶
        const MAX_SCREENSHOT_HEIGHT = 2000;
        const MIN_SCREENSHOT_HEIGHT = 650;
        
        const SCREENSHOT_HEIGHT = Math.max(MIN_SCREENSHOT_HEIGHT, 
                                          Math.min(MAX_SCREENSHOT_HEIGHT, dynamicHeight));
        
        screenshotCanvas.width = SCREENSHOT_WIDTH;
        screenshotCanvas.height = SCREENSHOT_HEIGHT;
        
        screenshotCtx.clearRect(0, 0, SCREENSHOT_WIDTH, SCREENSHOT_HEIGHT);
        
        // ÁªòÂà∂ËÉåÊôØ
        const gradient = screenshotCtx.createLinearGradient(0, 0, 0, SCREENSHOT_HEIGHT);
        gradient.addColorStop(0, '#16213e');
        gradient.addColorStop(1, '#0f3460');
        screenshotCtx.fillStyle = gradient;
        screenshotCtx.fillRect(0, 0, SCREENSHOT_WIDTH, SCREENSHOT_HEIGHT);
        
        // ÁªòÂà∂Ê†áÈ¢ò
        screenshotCtx.fillStyle = '#FFD700';
        screenshotCtx.font = 'bold 24px "AlimamaShuHeiTi-Bold.ttf", Arial, sans-serif';
        screenshotCtx.textAlign = 'center';
        screenshotCtx.fillText('ËßÇÈ∏üËÆ∞ÂΩï', SCREENSHOT_WIDTH / 2, 40);
        
        screenshotCtx.strokeStyle = '#87CEEB';
        screenshotCtx.lineWidth = 2;
        screenshotCtx.beginPath();
        screenshotCtx.moveTo(50, 55);
        screenshotCtx.lineTo(SCREENSHOT_WIDTH - 50, 55);
        screenshotCtx.stroke();
        
        // ÁªòÂà∂ÂÜÖÂÆπ
        const startY = 85;
        const availableHeight = SCREENSHOT_HEIGHT - startY - footerHeight - 10;
        drawRecordInfoSingleColumn(record, startY, lineHeight, SCREENSHOT_WIDTH - 40, availableHeight);
        
        // ÁªòÂà∂È°µËÑö
        screenshotCtx.fillStyle = '#FFD700';
        screenshotCtx.font = 'bold 14px "AlimamaShuHeiTi-Bold.ttf", Arial, sans-serif';
        screenshotCtx.textAlign = 'center';
        const bottomText = 'https://goseplover.github.io/12000h';
        screenshotCtx.fillText(bottomText, SCREENSHOT_WIDTH / 2, SCREENSHOT_HEIGHT - 15);
        
        currentScreenshotDataURL = screenshotCanvas.toDataURL('image/png');
    console.log("Êà™ÂõæÁîüÊàêÂÆåÊàêÔºåÊï∞ÊçÆURLÈïøÂ∫¶:", currentScreenshotDataURL.length);
    
    setTimeout(() => {
      showScreenshotPreview();
      screenshotButton.disabled = false;
      screenshotButton.style.opacity = '1';
      screenshotButton.textContent = "üì∏ Êà™ÂõæËÆ∞ÂΩï";
      isNavigatingRecords = originalNavigating; // ÊÅ¢Â§çÊªëÂä®ÂäüËÉΩ
    }, 100);
    
  } catch (error) {
    console.error("Êà™ÂõæÁªòÂà∂ËøáÁ®ã‰∏≠Âá∫Èîô:", error);
    showSpecialAlert("Êà™ÂõæÁªòÂà∂Â§±Ë¥•");
    screenshotButton.disabled = false;
    screenshotButton.style.opacity = '1';
    screenshotButton.textContent = "üì∏ Êà™ÂõæËÆ∞ÂΩï";
    isNavigatingRecords = originalNavigating; // ÊÅ¢Â§çÊªëÂä®ÂäüËÉΩ
    resumeGame();
  }
}

function drawRecordInfoSingleColumn(record, startY, lineHeight, columnWidth, maxHeight) {
  let y = startY;
  const x = 20;
  const speciesListStartY = y;
  
  screenshotCtx.fillStyle = '#FFFFFF';
  screenshotCtx.font = '16px "AlimamaShuHeiTi-Bold.ttf", Arial, sans-serif';
  screenshotCtx.textAlign = 'left';
  
  screenshotCtx.fillText(`ËÆ∞ÂΩïÁºñÂè∑: #${record.id}`, x, y);
  y += lineHeight;
  
  const durationText = `ËßÇÈ∏üÊó∂Èïø: ${Math.floor(record.birdingModeDuration / 60000)}ÂàÜ${Math.floor((record.birdingModeDuration % 60000) / 1000)}Áßí`;
  screenshotCtx.fillText(durationText, x, y);
  y += lineHeight;
  
  screenshotCtx.fillText(`Êó∂Èó¥: ${record.startedAtDaytime ? "ÁôΩÂ§©" : "ÈªëÂ§ú"} ‚Üí ${record.endedAtDaytime ? "ÁôΩÂ§©" : "ÈªëÂ§ú"}`, x, y);
  y += lineHeight;
  
  screenshotCtx.fillText(`ËßÇÂØüÈ∏üÁßç: ${record.totalObservedSpecies} Áßç`, x, y);
  y += lineHeight;

  screenshotCtx.fillText(`ÊãçÊëÑÈ∏üÁßç: ${record.capturedInSession || 0} Áßç`, x, y);
  y += lineHeight;
  
  if (record.rarestBird) {
    screenshotCtx.fillStyle = '#FFD700';
    screenshotCtx.fillText(`ÊúÄÁ®ÄÊúâ: ${record.rarestBird}`, x, y);
    screenshotCtx.fillStyle = '#FFFFFF';
    y += lineHeight;
  }
  
  y += lineHeight;
  
  screenshotCtx.fillStyle = '#87CEEB';
  screenshotCtx.fillText('ËßÇÂØüÂà∞ÁöÑÈ∏üÁßç:', x, y);
  y += lineHeight;
  
  screenshotCtx.strokeStyle = '#87CEEB';
  screenshotCtx.lineWidth = 1;
  screenshotCtx.beginPath();
  screenshotCtx.moveTo(x, y - 5);
  screenshotCtx.lineTo(x + 120, y - 5);
  screenshotCtx.stroke();
  
  y += 5;
  
  const sortedSpecies = [...record.observedSpecies].sort();
  
  // ÊØèÂàóÊòæÁ§∫15‰∏™È∏üÁßç
  const itemsPerColumn = 15;
  const columnCount = Math.ceil(sortedSpecies.length / itemsPerColumn);
  
  // ËÆ°ÁÆóÂàóÂÆΩÔºàÂÅáËÆæÊúâ3ÂàóÁ©∫Èó¥ÔºåÂÆûÈôÖÊ†πÊçÆÂàóÊï∞Ë∞ÉÊï¥Ôºâ
  const maxColumns = 3; // ÊúÄÂ§ß3Âàó
  const actualColumnCount = Math.min(columnCount, maxColumns);
  const actualColumnWidth = (screenshotCanvas.width - 40) / actualColumnCount;
  
  // ÊåâÂàó‰ºòÂÖàÊéíÂàóÔºàÂÖàÁ´ñÊéíÔºåÂ°´Êª°‰∏ÄÂàóÂêéÂÜçÊç¢‰∏ã‰∏ÄÂàóÔºâ
  for (let col = 0; col < actualColumnCount; col++) {
    const columnX = x + col * actualColumnWidth;
    let columnY = y;
    
    for (let row = 0; row < itemsPerColumn; row++) {
      const index = col * itemsPerColumn + row; // Âàó‰ºòÂÖàÁ¥¢Âºï
      
      if (index >= sortedSpecies.length) {
        break;
      }
      
      const birdName = sortedSpecies[index];
      const birdKey = Object.keys(BIRD_TYPES).find(key => BIRD_TYPES[key].name === birdName);
      const isRare = birdKey && BIRD_TYPES[birdKey].probability < 0.02;
      const isRarest = birdName === record.rarestBird;
      
      if (isRarest) {
        screenshotCtx.fillStyle = '#FFD700';
        screenshotCtx.font = 'bold 14px "AlimamaShuHeiTi-Bold.ttf"';
        screenshotCtx.fillText(`${index + 1}. ${birdName} ‚òÖ`, columnX, columnY);
        screenshotCtx.font = '14px "AlimamaShuHeiTi-Bold.ttf"';
      } else if (isRare) {
        screenshotCtx.fillStyle = '#FFA500';
        screenshotCtx.fillText(`${index + 1}. ${birdName} (Á®ÄÊúâ)`, columnX, columnY);
      } else {
        screenshotCtx.fillStyle = '#FFFFFF';
        screenshotCtx.fillText(`${index + 1}. ${birdName}`, columnX, columnY);
      }
      
      columnY += lineHeight;
    }
  }
  
  // Â¶ÇÊûúÈ∏üÁßçÂ§™Â§öÔºåË∂ÖËøáÊòæÁ§∫Á©∫Èó¥ÔºåÊ∑ªÂä†ÊèêÁ§∫
  if (sortedSpecies.length > itemsPerColumn * actualColumnCount) {
    const remainingCount = sortedSpecies.length - (itemsPerColumn * actualColumnCount);
    screenshotCtx.fillStyle = '#FFA500';
    screenshotCtx.font = '12px "AlimamaShuHeiTi-Bold.ttf"';
    screenshotCtx.fillText(`... ËøòÊúâ ${remainingCount} ÁßçÊú™ÊòæÁ§∫`, x, y + itemsPerColumn * lineHeight + 10);
  }
  
  return y;
}

// ÊòæÁ§∫Êà™ÂõæÈ¢ÑËßà
function showScreenshotPreview() {
    console.log("ÊòæÁ§∫Êà™ÂõæÈ¢ÑËßà...");
    
    if (!currentScreenshotDataURL) {
        console.error("Ê≤°ÊúâÂèØÁî®ÁöÑÊà™ÂõæÊï∞ÊçÆ");
        showSpecialAlert("Ê≤°ÊúâÂèØÁî®ÁöÑÊà™ÂõæÊï∞ÊçÆ");
        return;
    }

    const previewModal = document.getElementById('screenshotPreviewModal');
    const previewImage = document.getElementById('screenshotPreviewImage');
    
    if (!previewModal || !previewImage) {
        console.error("È¢ÑËßàÂÖÉÁ¥†Êú™ÊâæÂà∞");
        showSpecialAlert("È¢ÑËßàÂÖÉÁ¥†Êú™ÊâæÂà∞");
        return;
    }

    // ËÆæÁΩÆÂõæÁâáÊ∫ê
    previewImage.src = currentScreenshotDataURL;
    
    // ÊòæÁ§∫Ê®°ÊÄÅÊ°Ü
    previewModal.style.display = 'flex';
    previewModal.style.zIndex = '500';
    
    console.log("È¢ÑËßàÊ®°ÊÄÅÊ°ÜÂ∑≤ÊòæÁ§∫");
    
    // Ê∑ªÂä†Âä†ËΩΩÂÆåÊàêÂíåÂä†ËΩΩÈîôËØØÁöÑÂ§ÑÁêÜ
    previewImage.onload = function() {
        console.log("È¢ÑËßàÂõæÁâáÂä†ËΩΩÊàêÂäü");
    };
    
    previewImage.onerror = function() {
        console.error("È¢ÑËßàÂõæÁâáÂä†ËΩΩÂ§±Ë¥•");
        showSpecialAlert("È¢ÑËßàÂõæÁâáÂä†ËΩΩÂ§±Ë¥•");
        previewModal.style.display = 'none';
    };
}

function closeScreenshotPreview() {
    const previewModal = document.getElementById('screenshotPreviewModal');
    previewModal.style.display = 'none';
    
    // ÊÅ¢Â§çÊ∏∏Êàè
    resumeGame();
}

function saveScreenshot() {
    console.log("Â∞ùËØï‰øùÂ≠òÊà™Âõæ...");
    
    if (!currentScreenshotDataURL) {
        console.error("Ê≤°ÊúâÂèØÁî®ÁöÑÊà™ÂõæÊï∞ÊçÆ");
        showSpecialAlert("Ê≤°ÊúâÂèØÁî®ÁöÑÊà™ÂõæÊï∞ÊçÆ");
        return;
    }
    
    try {
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const fileName = `ËßÇÈ∏üËÆ∞ÂΩï_${timestamp}.png`;
        
        const downloadLink = document.createElement('a');
        downloadLink.href = currentScreenshotDataURL;
        downloadLink.download = fileName;
        downloadLink.style.display = 'none';
        
        document.body.appendChild(downloadLink);
        downloadLink.click();
        
        setTimeout(() => {
            document.body.removeChild(downloadLink);
        }, 100);
        
        console.log("Êà™Âõæ‰øùÂ≠òÊàêÂäü");
        showSpecialAlert("Êà™ÂõæÂ∑≤‰øùÂ≠òÔºÅ");
        closeScreenshotPreview();
        
    } catch (error) {
        console.error("‰øùÂ≠òÊà™ÂõæÊó∂Âá∫Èîô:", error);
        showSpecialAlert("‰øùÂ≠òÂ§±Ë¥•: " + error.message);
    }
}

// ‰øÆÊîπ handleKeyDown ÂáΩÊï∞ÔºåÊ∑ªÂä†ÈîÆÁõòÂØºËà™ÊîØÊåÅ
function handleKeyDown(e) {
  if (e.key === 'Escape') {
    closeAlbum();
    closeBirdingRecord();
  } else if (e.key === 'y' || e.key === 'Y') {
    generatePeregrine(false);
  } else if (e.key === 'h' || e.key === 'H') {
    generateKestrel(false);
  } else if (e.key === 'c' || e.key === 'C') {
    generateBlackWingedKite(false);
  } else if (e.key === 'x' || e.key === 'X') {
    generateComet(false);
  } else if (e.key === 'd' || e.key === 'D') {
    generateGoldcrest(false);
  } else if (e.key === '1') {
    generateTwelveThousandPlover(false);
  } else if (e.key === 'w' || e.key === 'W') {
    generateBlackbird(false);
  } else if (e.key === 'b' || e.key === 'B') {
    generateLittleGrebe(false);
  } else if (e.key === 'l' || e.key === 'L') {
    generateMeteor(false);
  } else if (e.key === 'u' || e.key === 'U') {
    generateUFO(false);
  } else if (e.key === 'q' || e.key === 'Q') {
    generateMagpie(false);
  } else if (e.key === 'k' || e.key === 'K') {
    generateKingfisher(true);
  } else if (e.key === 'r' || e.key === 'R') {
    createBirdingRecord();
  } else if (e.key === 'v' || e.key === 'V') {
    if (birdingRecords.length > 0) {
      openBirdingRecord(birdingRecords.length - 1);
    }
  } else if (e.key === 'm' || e.key === 'M') {
    toggleBirdingMode();
  } else if (e.key === '0') {
    generateRareBird();
  } else if (e.key === '2') {
    generateBramblingManual(true);
  } else if (e.key === '3') {
    generateHawfinchManual(true);
  } else if (e.key === 'p' || e.key === 'P') {
    if (currentBirdingRecord) {
      captureBirdingRecord();
    }
  } else if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
    // Âú®ËßÇÈ∏üËÆ∞ÂΩïÁïåÈù¢Êó∂ÔºåÂ∑¶ÁÆ≠Â§¥Êàñ‰∏äÁÆ≠Â§¥ÂàáÊç¢Âà∞‰∏ä‰∏ÄÊù°ËÆ∞ÂΩï
    const modal = document.getElementById('birdingRecordModal');
    if (modal.style.display === 'block') {
      e.preventDefault();
      switchBirdingRecord(-1);
    }
  } else if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {
    // Âú®ËßÇÈ∏üËÆ∞ÂΩïÁïåÈù¢Êó∂ÔºåÂè≥ÁÆ≠Â§¥Êàñ‰∏ãÁÆ≠Â§¥ÂàáÊç¢Âà∞‰∏ã‰∏ÄÊù°ËÆ∞ÂΩï
    const modal = document.getElementById('birdingRecordModal');
    if (modal.style.display === 'block') {
      e.preventDefault();
      switchBirdingRecord(1);
    }
  }
}

function generateBlackbird(countStats = false) {
    const blackbirdType = BIRD_TYPES.BLACKBIRD;
    if (countStats) {
        appearedBirds[blackbirdType.name]++;
        updateTextStats();
    }
    
    const fromLeft = Math.random() > 0.5;
    const startX = fromLeft ? -50 : GAME_WIDTH + 50;
    const startY = Math.random() * (GAME_HEIGHT * 0.6) + GAME_HEIGHT * 0.2;
    
    const bird = {
        type: blackbirdType,
        name: blackbirdType.name,
        x: startX,
        y: startY,
        size: blackbirdType.size,
        speed: (1 + Math.random()) * 1.5,
        direction: fromLeft ? 1 : -1,
        state: 'flying',
        stateTime: 0,
        whiteEyeRing: false,
        yellowEyeRing: true,
        eatFruits: true,
        eatProbability: 0.12,
        eatDuration: 1600,
        originalSize: 1.3,
        poopInterval: 3000,
        poopProbability: 0.33,
        poopColor: "#FFFFFF",
        lastPoopTime: 0,
        noStats: !countStats,
        isNight: !isDaytime
    };
    
    birds.push(bird);
}

function generateTwelveThousandPlover(countStats = false) {
    const ploverType = BIRD_TYPES.TWELVE_THOUSAND_PLOVER;
    if (countStats) {
        // ‰∏çÁªüËÆ°
    }
    
    const fromLeft = Math.random() > 0.5;
    const birdCount = getRandomGroupSize(ploverType);
    const groupId = nextGroupId++;
    birdGroupInfo[groupId] = { direction: fromLeft ? 1 : -1, birds: [] };
    
    for (let i = 0; i < birdCount; i++) {
        let startX, startY;
        let behavior = ploverType.behavior;
        let stayTime = ploverType.stayTime || 10;
        
        if (Math.random() < ploverType.landOnReedsChance) {
            behavior = "landOnReeds";
            stayTime = ploverType.landOnReedsTime;
        }
        
        startX = fromLeft ? -50 : GAME_WIDTH + 50;
        startY = Math.random() * (GAME_HEIGHT * 0.6) + GAME_HEIGHT * 0.2;
        
        let baseSpeed = (1.6 + Math.random() * 0.8);
        const speedMultiplier = ploverType.speedMultiplier || 1;
        const finalSpeed = baseSpeed * speedMultiplier;
        
        const bird = createCommonBird(ploverType, startX, startY, fromLeft, behavior, stayTime, finalSpeed, groupId);
        bird.noStats = true;
        bird.yellowEyeRing = true;
        
        if (behavior === "landOnReeds" && reedZone) {
            bird.reedTargetX = reedZone.x + Math.random() * reedZone.width;
            bird.reedTargetY = reedZone.y + reedZone.height - 3;
            bird.state = 'landingOnReeds';
            bird.groundDirection = Math.random() > 0.5 ? 1 : -1;
            bird.isLandingOnReeds = true;
        }
        
        birds.push(bird);
        birdGroupInfo[groupId].birds.push(bird);
    }
}

function generateGoldcrest(countStats = true) {
    const goldcrestType = BIRD_TYPES.GOLDCREST;
    if (countStats) {
        appearedBirds[goldcrestType.name]++;
        updateTextStats();
    }
    
    const targetTree = treePositions[Math.floor(Math.random() * treePositions.length)];
    const x = targetTree.x + targetTree.width * 0.4 + Math.random() * targetTree.width * 0.2;
    const y = targetTree.y + targetTree.height * 0.2 + Math.random() * targetTree.height * 0.3;
    
    const bird = {
        type: goldcrestType,
        name: goldcrestType.name,
        x: x,
        y: y,
        size: goldcrestType.size,
        speed: 0,
        direction: targetTree.side === 'left' ? 1 : -1,
        state: 'perching',
        stateTime: 0,
        stayTime: 5,
        riceBallAppearance: true,
        halfBeakFlying: true,
        halfBeak: true,
        noStats: !countStats,
        isNight: !isDaytime
    };
    
    birds.push(bird);
}

function generateLittleGrebe(countStats = false) {
    const littleGrebeType = BIRD_TYPES.LITTLEGREBE;
    if (countStats) {
        appearedBirds[littleGrebeType.name]++;
        updateTextStats();
    }
    
    const fromLeft = Math.random() > 0.5;
    const birdCount = getRandomGroupSize(littleGrebeType);
    const groupId = nextGroupId++;
    birdGroupInfo[groupId] = { direction: fromLeft ? 1 : -1, birds: [] };
    
    for (let i = 0; i < birdCount; i++) {
        const startX = fromLeft ? -50 : GAME_WIDTH + 50;
        const startY = reedZone.y + reedZone.height * 0.5 + Math.random() * reedZone.height * 0.3;
        
        let baseSpeed = (1.6 + Math.random() * 0.8);
        
        const bird = {
            type: littleGrebeType,
            name: littleGrebeType.name,
            x: startX,
            y: startY,
            size: littleGrebeType.size,
            speed: baseSpeed,
            direction: fromLeft ? 1 : -1,
            state: 'flying',
            stateTime: 0,
            circlingTime: 0,
            hoveringTime: 0,
            circlingRadius: 100 + Math.random() * 50,
            circlingAngle: Math.random() * Math.PI * 2,
            circlingCenterX: 0,
            circlingCenterY: 0,
            actualBehavior: "flyToReedsAndStay",
            stayTime: littleGrebeType.stayTime,
            originalBehavior: littleGrebeType.behavior,
            groupId: groupId,
            targetX: fromLeft ? GAME_WIDTH + 100 : -100,
            reedStayTime: littleGrebeType.reedStayTime || 20000,
            reedMoveSpeed: littleGrebeType.reedMoveSpeed || 0.6,
            reedTargetX: 0,
            reedTargetY: 0,
            whiteEyeRing: false,
            longBlackTail: true,
            fifthBeak: true,
            noStats: !countStats,
            isNight: !isDaytime
        };
        
        birds.push(bird);
        birdGroupInfo[groupId].birds.push(bird);
    }
}

function generateMeteor(countStats = false, summoned = false, intersectionPoint = null) {
    const isNightMode = gameMode === 'night' || (gameMode === 'normal' && !isDaytime);
    if (!isNightMode) {
        return;
    }
    
    const meteorType = NIGHT_OBJECTS.METEOR;
    
    let startX, startY, angle;
    
    if (!summoned) {
        const intersectionX = GAME_WIDTH * 0.5 + (Math.random() - 0.5) * GAME_WIDTH * 0.5;
        const intersectionY = -500 - Math.random() * 500;
        
        startX = intersectionX;
        startY = intersectionY;
        
        const targetX = -100 + Math.random() * (GAME_WIDTH + 200);
        const targetY = -100 + Math.random() * (GAME_HEIGHT * 0.55 + 100);
        angle = Math.atan2(targetY - startY, targetX - startX);
        
        const meteor = {
            type: meteorType,
            name: meteorType.name,
            x: startX,
            y: startY,
            size: meteorType.size,
            speed: meteorType.speed,
            angle: angle,
            state: 'flying',
            createdAt: gameTime,
            duration: meteorType.duration,
            color: meteorType.color,
            trailLength: meteorType.trailLength,
            trailColor: meteorType.trailColor,
            summonProbability: meteorType.summonProbability,
            hasSummoned: false,
            summoned: summoned,
            isNightObject: true,
            intersectionPoint: { x: intersectionX, y: intersectionY },
            targetPoint: { x: targetX, y: targetY }
        };
        
        nightObjects.push(meteor);
        return meteor;
    } else {
        if (!intersectionPoint) {
            intersectionPoint = { x: -1800 + Math.random() * (GAME_WIDTH + 3600), y: -1800 + Math.random() * (GAME_HEIGHT * 0.55 + 1800) };
        }
        
        startX = intersectionPoint.x;
        startY = intersectionPoint.y;
        
        const targetX = -100 + Math.random() * (GAME_WIDTH + 200);
        const targetY = -100 + Math.random() * (GAME_HEIGHT * 0.55 + 100);
        angle = Math.atan2(targetY - startY, targetX - startX);
        
        const meteor = {
            type: meteorType,
            name: meteorType.name,
            x: startX,
            y: startY,
            size: meteorType.size,
            speed: meteorType.speed,
            angle: angle,
            state: 'flying',
            createdAt: gameTime,
            duration: meteorType.duration,
            color: meteorType.color,
            trailLength: meteorType.trailLength,
            trailColor: meteorType.trailColor,
            summonProbability: meteorType.summonProbability,
            hasSummoned: false,
            summoned: summoned,
            isNightObject: true,
            intersectionPoint: intersectionPoint,
            targetPoint: { x: targetX, y: targetY }
        };
        
        nightObjects.push(meteor);
        return meteor;
    }
}

function generateComet(countStats = false) {
    const isNightMode = gameMode === 'night' || (gameMode === 'normal' && !isDaytime);
    if (!isNightMode) {
        return;
    }
    
    const cometType = NIGHT_OBJECTS.COMET;
    const startX = GAME_WIDTH / 2;
    const startY = GAME_HEIGHT * 0.55 - 100;
    
    const comet = {
        type: cometType,
        name: cometType.name,
        x: startX,
        y: startY,
        size: cometType.size * (1/3),
        speed: cometType.speed,
        state: 'flying',
        createdAt: gameTime,
        duration: cometType.duration,
        color: cometType.color,
        tailLength: cometType.tailLength,
        tailColor: cometType.tailColor,
        angle: cometType.angle,
        isNightObject: true
    };
    
    nightObjects.push(comet);
}

function generateUFO(countStats = false) {
    const isNightMode = gameMode === 'night' || (gameMode === 'normal' && !isDaytime);
    if (!isNightMode) {
        return;
    }
    
    const ufoType = NIGHT_OBJECTS.UFO;
    const startX = GAME_WIDTH + 50;
    const startY = Math.random() * (GAME_HEIGHT * 0.5) + GAME_HEIGHT * 0.2;
    
    const ufo = {
        type: ufoType,
        name: ufoType.name,
        x: startX,
        y: startY,
        size: ufoType.size,
        speed: ufoType.speed,
        state: 'flying',
        direction: -1,
        createdAt: gameTime,
        duration: ufoType.duration,
        color: ufoType.color,
        beamLength: ufoType.beamLength,
        beamColor: ufoType.beamColor,
        beamActive: Math.random() > 0.5,
        beamPhase: Math.random() * Math.PI * 2,
        isNightObject: true
    };
    
    nightObjects.push(ufo);
}

function showNightObjectAlert(text) {
    // ÂÆûÁé∞Â§úÊãçÁâ©‰ΩìÊèêÁ§∫
}

function initTrees() {
    treePositions.push({
        x: 0,
        y: GAME_HEIGHT * 0.3,
        width: GAME_WIDTH * 0.25,
        height: GAME_HEIGHT * 0.7,
        side: 'left',
        fruits: []
    });
    
    const wallWidth = 80;
    const wallMargin = 10;
    const rightTreeWidth = GAME_WIDTH * 0.25;
    
    treePositions.push({
        x: GAME_WIDTH - wallWidth - wallMargin - rightTreeWidth - 20,
        y: GAME_HEIGHT * 0.3,
        width: rightTreeWidth,
        height: GAME_HEIGHT * 0.7,
        side: 'right',
        fruits: []
    });
}

function resizeCanvas() {
    const container = document.getElementById('gameContainer');
    const containerWidth = container.clientWidth;
    const containerHeight = container.clientHeight;
    
    let width = containerWidth;
    let height = containerWidth / ASPECT_RATIO;
    
    if (height > containerHeight) {
        height = containerHeight;
        width = containerHeight * ASPECT_RATIO;
    }
    
    canvas.width = GAME_WIDTH;
    canvas.height = GAME_HEIGHT;
    poopCanvas.width = GAME_WIDTH;
    poopCanvas.height = GAME_HEIGHT;
    
    canvas.style.width = width + 'px';
    canvas.style.height = height + 'px';
    canvas.style.position = 'absolute';
    canvas.style.left = '50%';
    canvas.style.top = '50%';
    canvas.style.transform = 'translate(-50%, -50%)';
    
    poopCanvas.style.width = width + 'px';
    poopCanvas.style.height = height + 'px';
    poopCanvas.style.position = 'absolute';
    poopCanvas.style.left = '50%';
    poopCanvas.style.top = '50%';
    poopCanvas.style.transform = 'translate(-50%, -50%)';
    
    viewfinderBaseWidth = GAME_WIDTH / 15;
    viewfinderBaseHeight = viewfinderBaseWidth * 2/3;
}

function initFruits() {
    fruits = [];
    
    treePositions.forEach((tree, treeIndex) => {
        tree.fruits = [];
        
        const redCount = Math.floor((15 + Math.floor(Math.random() * 10)) / 4);
        const yellowCount = Math.floor((10 + Math.floor(Math.random() * 8)) / 4);
        
        for (let i = 0; i < redCount; i++) {
            const fruit = createFruit(tree, treeIndex, "red");
            fruits.push(fruit);
            tree.fruits.push(fruit);
        }
        
        for (let i = 0; i < yellowCount; i++) {
            const fruit = createFruit(tree, treeIndex, "yellow");
            fruits.push(fruit);
            tree.fruits.push(fruit);
        }
    });
}

function createFruit(tree, treeIndex, color) {
    const treeCrownX = tree.x + tree.width * 0.2;
    const treeCrownY = tree.y + tree.height * 0.2;
    const treeCrownWidth = tree.width * 0.6;
    const treeCrownHeight = tree.height * 0.25;
    
    const fruit = {
        id: fruits.length,
        treeIndex: treeIndex,
        x: treeCrownX + Math.random() * treeCrownWidth,
        y: treeCrownY + Math.random() * treeCrownHeight,
        size: 4,
        color: color,
        originalColor: color,
        isEaten: false,
        eatenBy: null,
        eatStartTime: 0
    };
    
    return fruit;
}

function initReeds() {
    const trunkHeight = GAME_HEIGHT * 0.7 * 0.3;
    const reedHeight = trunkHeight * 2 * 0.8;
    
    const wallWidth = 80;
    const wallMargin = 10;
    const wallSpace = wallWidth + wallMargin;
    
    const leftIndent = 200;
    
    reedZone = {
        x: leftIndent,
        y: GAME_HEIGHT - reedHeight,
        width: GAME_WIDTH - leftIndent - wallSpace,
        height: reedHeight
    };
    
    reedBends = [];
    const reedCount = Math.floor(150 * (reedZone.width / (GAME_WIDTH - wallSpace)));
    
    for (let i = 0; i < reedCount; i++) {
        const reedType = Math.floor(Math.random() * 6);
        reedBends.push({
            bendAmount: (Math.random() - 0.5) * 35,
            bendPointRatio: 0.2 + Math.random() * 0.6,
            topBendAmount: (Math.random() - 0.5) * 40,
            reedType: reedType,
            reedColor: ['#8B4513', '#654321', '#A0522D'][Math.floor(Math.random() * 3)],
            topColor: ['#DAA520', '#B8860B', '#8B7355', '#A0522D'][Math.floor(Math.random() * 4)],
            reedWidth: 0.5 + Math.random() * 1.0
        });
    }
}

function initTextStats() {
    for (const birdName of ALL_BIRDS) {
        capturedBirds[birdName] = 0;
        appearedBirds[birdName] = 0;
    }
    updateTextStats();
}

function updateTextStats() {
    const appearedCount = Object.values(appearedBirds).filter(count => count > 0).length;
    const capturedCount = Object.values(capturedBirds).filter(count => count > 0).length;
    
    document.getElementById('appearedCount').textContent = appearedCount;
    document.getElementById('capturedCount').textContent = capturedCount;
}

function updateAlbumStats() {
    const albumStats = document.getElementById('albumStats');
    albumStats.innerHTML = '';
    
    const capturedBirdNames = Object.keys(capturedBirds).filter(name => capturedBirds[name] > 0);
    
    if (capturedBirdNames.length === 0) {
        albumStats.innerHTML = '<div style="color: white; font-size: 14px;">ÊöÇÊó†Â∑≤ÊãçÊëÑÈ∏üÁ±ª</div>';
        return;
    }
    
    const recordInfo = document.createElement('div');
    recordInfo.className = 'albumStatItem';
    recordInfo.innerHTML = `
        <span>üìù ËßÇÈ∏üËÆ∞ÂΩï</span>
        <span class="statCount">${birdingRecords.length}</span>
    `;
    albumStats.appendChild(recordInfo);
    
    if (birdingModeActive) {
        const birdingModeInfo = document.createElement('div');
        birdingModeInfo.className = 'albumStatItem';
        birdingModeInfo.innerHTML = `
            <span>üîç ËßÇÈ∏üÊ®°Âºè</span>
            <span class="statCount" style="color: #90EE90;">ËøõË°å‰∏≠</span>
        `;
        albumStats.appendChild(birdingModeInfo);
    }
    
    capturedBirdNames.forEach(birdName => {
        let birdType = null;
        for (const key in BIRD_TYPES) {
            if (BIRD_TYPES[key].name === birdName) {
                birdType = BIRD_TYPES[key];
                break;
            }
        }
        
        if (!birdType || birdType.isBat) return;
        
        const statItem = document.createElement('div');
        statItem.className = 'albumStatItem';
        statItem.innerHTML = `
            <span>
                <span class="birdIcon" style="background-color: ${birdType.iconColor || birdType.bodyColor || '#FFFFFF'}"></span>
                ${birdName}
            </span>
            <span class="statCount">${capturedBirds[birdName] || 0}</span>
        `;
        albumStats.appendChild(statItem);
    });
}

function handleMouseClick() {
    if (isTakingPhoto) return;
    
    isTakingPhoto = true;
    
    const viewfinderSize = getViewfinderSize();
    const actualViewfinderWidth = viewfinderSize.width;
    const actualViewfinderHeight = viewfinderSize.height;
    
    // Á°Æ‰øù mouseX Âíå mouseY ÊòØÂü∫‰∫éÊ∏∏ÊàèÈÄªËæëÂùêÊ†áÁöÑ
    // Âú®ÈôÄËû∫‰ª™Ê®°Âºè‰∏ãÔºåmouseX/Y Â∑≤ÁªèÂú® handleDeviceOrientation ‰∏≠Ë¢´ÈôêÂà∂Âú® 0-GAME_WIDTH ‰πãÈó¥
    // Âú®ÊôÆÈÄöÊ®°Âºè‰∏ãÔºåhandleMouseMove ‰πüÂ∑≤ÁªèÂÅö‰∫ÜÁº©ÊîæÊò†Â∞Ñ
    
    const viewfinderLeft = mouseX - actualViewfinderWidth / 2;
    const viewfinderTop = mouseY - actualViewfinderHeight / 2;
    const viewfinderRight = viewfinderLeft + actualViewfinderWidth;
    const viewfinderBottom = viewfinderTop + actualViewfinderHeight;
    
    // Á°Æ‰øùÊãçÁÖßÂå∫ÂüüÂú®ÁîªÂ∏ÉËåÉÂõ¥ÂÜÖÔºåÈÅøÂÖçÈªëËæπ
    // Ê≥®ÊÑèÔºöcreatePhoto ÂÜÖÈÉ®‰ºöÂ§ÑÁêÜËæπÁïåÂâ™Ë£ÅÔºå‰ΩÜÂ¶ÇÊûú‰º†ÂÖ•ÂùêÊ†áÂÆåÂÖ®Âú®ÁîªÂ∏ÉÂ§ñÔºåÂ∞±‰ºöÂÖ®Èªë
    // Êàë‰ª¨‰∏ªË¶Å‰øùËØÅ mouseX/Y ÊòØÊ≠£Á°ÆÁöÑÈÄªËæëÂùêÊ†áÂç≥ÂèØ
    
    const centerRegionWidth = actualViewfinderWidth * 0.7;
    const centerRegionHeight = actualViewfinderHeight * 0.7;
    const centerRegionLeft = mouseX - centerRegionWidth / 2;
    const centerRegionTop = mouseY - centerRegionHeight / 2;
    const centerRegionRight = centerRegionLeft + centerRegionWidth;
    const centerRegionBottom = centerRegionTop + centerRegionHeight;
    
    let capturedBird = null;
    let capturedNightObject = null;
    let maxSize = 0;
    
    for (const bird of birds) {
        const baseSize = 20;
        const birdSize = baseSize * bird.size;
        let birdDisplayX = bird.x;
        
        const isInCenterRegion = birdDisplayX >= centerRegionLeft && birdDisplayX <= centerRegionRight &&
                                  bird.y >= centerRegionTop && bird.y <= centerRegionBottom;
        
        if (isInCenterRegion) {
            if (birdSize > maxSize) {
                maxSize = birdSize;
                capturedBird = bird;
                capturedNightObject = null;
            }
        }
    }
    
    for (const obj of nightObjects) {
        const baseSize = 20;
        const objSize = baseSize * obj.size;
        
        const isInCenterRegion = obj.x >= centerRegionLeft && obj.x <= centerRegionRight &&
                                  obj.y >= centerRegionTop && obj.y <= centerRegionBottom;
        
        if (isInCenterRegion) {
            if (objSize > maxSize) {
                maxSize = objSize;
                capturedBird = null;
                capturedNightObject = obj;
            }
        }
    }
    
    if (!capturedBird && !capturedNightObject) {
        let fallbackCapturedBird = null;
        let fallbackCapturedNightObject = null;
        let fallbackMaxSize = 0;
        
        for (const bird of birds) {
            const baseSize = 20;
            const birdSize = baseSize * bird.size;
            const birdRadius = birdSize / 2;
            let birdDisplayX = bird.x;
            
            const birdLeft = birdDisplayX - birdRadius;
            const birdRight = birdDisplayX + birdRadius;
            const birdTop = bird.y - birdRadius;
            const birdBottom = bird.y + birdRadius;
            
            const overlapX = birdRight >= viewfinderLeft && birdLeft <= viewfinderRight;
            const overlapY = birdBottom >= viewfinderTop && birdTop <= viewfinderBottom;
            const isInViewfinder = overlapX && overlapY;
            
            if (isInViewfinder) {
                if (birdSize > fallbackMaxSize) {
                    fallbackMaxSize = birdSize;
                    fallbackCapturedBird = bird;
                    fallbackCapturedNightObject = null;
                }
            }
        }
        
        for (const obj of nightObjects) {
            const baseSize = 20;
            const objSize = baseSize * obj.size;
            const objRadius = objSize / 2;
            
            const objLeft = obj.x - objRadius;
            const objRight = obj.x + objRadius;
            const objTop = obj.y - objRadius;
            const objBottom = obj.y + objRadius;
            
            const overlapX = objRight >= viewfinderLeft && objLeft <= viewfinderRight;
            const overlapY = objBottom >= viewfinderTop && objTop <= viewfinderBottom;
            const isInViewfinder = overlapX && overlapY;
            
            if (isInViewfinder) {
                if (objSize > fallbackMaxSize) {
                    fallbackMaxSize = objSize;
                    fallbackCapturedBird = null;
                    fallbackCapturedNightObject = obj;
                }
            }
        }
        
        capturedBird = fallbackCapturedBird;
        capturedNightObject = fallbackCapturedNightObject;
    }
    
    createPhoto(viewfinderLeft, viewfinderTop, actualViewfinderWidth, actualViewfinderHeight, capturedBird, capturedNightObject);
    updateTextStats();
    playCameraSound();
    
    if (capturedBird) {
        showCaptureAlert(`ÊãçÊëÑÂà∞${capturedBird.name}ÔºÅ`);
    } else if (capturedNightObject) {
        showCaptureAlert(`ÊãçÊëÑÂà∞${capturedNightObject.name}ÔºÅ`);
    }
    
    setTimeout(() => {
        isTakingPhoto = false;
    }, 50);
}

function checkIfAllBirdsCollected() {
    for (const birdName of ALL_BIRDS) {
        if (!capturedBirds[birdName] || capturedBirds[birdName] === 0) {
            return false;
        }
    }
    return true;
}

function showAllBirdsAlert() {
    const allBirdsAlert = document.createElement('div');
    allBirdsAlert.id = 'allBirdsAlert';
    allBirdsAlert.innerHTML = `
        <div style="margin-bottom: 20px; font-size: 28px;">üéâ ÊÅ≠ÂñúÔºÅ üéâ</div>
        <div style="margin-bottom: 15px;">ÊÇ®Â∑≤ÈõÜÈΩêÊâÄÊúâÂ∞èÈ∏üÔºÅ</div>
        <div style="margin-bottom: 25px; font-size: 20px;">ÊÑüË∞¢ÊÇ®ÁöÑÊ∏∏Áé©ÔºÅ</div>
        <div style="font-size: 18px; color: #FF6347;">
            ËøôÊòØÁî±Â∞èÁ∫¢‰π¶Âè∑Ôºö<br>
            <span style="font-size: 22px; color: #FFD700; text-shadow: 0 0 10px rgba(255, 215, 0, 0.7);">S_Asuka_Langley</span>
            <div style="font-size: 18px; color: #FF6347;"> Âà∂‰ΩúÁöÑ<br></div>
        </div>
        <div style="margin-top: 25px; font-size: 16px; color: #87CEEB;">
            (ÊèêÁ§∫ÔºöÊÇ®‰ªçÁÑ∂ÂèØ‰ª•ÁªßÁª≠ÊãçÊëÑÈ∏üÁ±ªÂíåÂ§úÊãçÁâ©‰Ωì)
        </div>
        <button id="closeAllBirdsAlert" style="
            margin-top: 20px;
            background-color: #FFD700;
            color: #000;
            border: none;
            padding: 10px 25px;
            border-radius: 25px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        ">Á°ÆÂÆö</button>
    `;
    
    document.getElementById('gameContainer').appendChild(allBirdsAlert);
    
    document.getElementById('closeAllBirdsAlert').addEventListener('click', function() {
        document.getElementById('gameContainer').removeChild(allBirdsAlert);
    });
    
    setTimeout(() => {
        if (document.getElementById('allBirdsAlert')) {
            document.getElementById('gameContainer').removeChild(allBirdsAlert);
        }
    }, 5000);
}

function createPhoto(x, y, width, height, capturedBird, capturedNightObject) {
  const tempCanvas = document.createElement('canvas');
  tempCanvas.width = width;
  tempCanvas.height = height;
  const tempCtx = tempCanvas.getContext('2d');
    
    let sourceX = Math.max(0, Math.min(x, GAME_WIDTH));
    let sourceY = Math.max(0, Math.min(y, GAME_HEIGHT));
    let drawX = 0;
    let drawY = 0;
    let drawWidth = width;
    let drawHeight = height;
    
    if (x < 0) {
        drawX = -x;
        drawWidth = width + x;
    }
    if (y < 0) {
        drawY = -y;
        drawHeight = height + y;
    }
    if (x + width > GAME_WIDTH) {
        drawWidth = GAME_WIDTH - x;
    }
    if (y + height > GAME_HEIGHT) {
        drawHeight = GAME_HEIGHT - y;
    }
    
    sourceX = Math.max(0, sourceX);
    sourceY = Math.max(0, sourceY);
    drawWidth = Math.max(0, drawWidth);
    drawHeight = Math.max(0, drawHeight);
    
    if (drawWidth > 0 && drawHeight > 0) {
        tempCtx.drawImage(
            canvas,
            sourceX, sourceY, drawWidth, drawHeight,
            drawX, drawY, drawWidth, drawHeight
        );
    }
    
    const goldenFilter = document.getElementById('goldenFilter');
    const filterStyle = window.getComputedStyle(goldenFilter);
    const filterColor = filterStyle.backgroundColor;
    
    // Âè™Âú®ÈùûÈôÄËû∫‰ª™Ê®°Âºè‰∏ãÂ∫îÁî®Êª§ÈïúÔºàÈôÄËû∫‰ª™Ê®°Âºè‰∏ã‰øùÊåÅÂéüËâ≤Ôºâ
    if (!gyroModeActive && filterColor && filterColor !== 'rgba(0, 0, 0, 0)' && filterColor !== 'transparent') {
        tempCtx.fillStyle = filterColor;
        tempCtx.fillRect(0, 0, drawWidth, drawHeight);
    }
    
    const finalCanvas = document.createElement('canvas');
    finalCanvas.width = viewfinderBaseWidth;
    finalCanvas.height = viewfinderBaseHeight;
    const finalCtx = finalCanvas.getContext('2d');
    
    finalCtx.drawImage(tempCanvas, 0, 0, width, height, 0, 0, viewfinderBaseWidth, viewfinderBaseHeight);
    
    finalCtx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
    finalCtx.lineWidth = 2;
    finalCtx.strokeRect(0, 0, viewfinderBaseWidth, viewfinderBaseHeight);
    
    if (capturedBird) {
        if (!capturedBird.type.isSpecial && !capturedBird.isBat && capturedBirds[capturedBird.name] !== undefined && !capturedBird.noStats) {
            capturedBirds[capturedBird.name]++;
        }
        
        const highlightColor = 'rgba(255, 255, 255, 0.1)';
        finalCtx.fillStyle = highlightColor;
        finalCtx.fillRect(0, 0, viewfinderBaseWidth, viewfinderBaseHeight);
        
        finalCtx.fillStyle = '#FFFFFF';
        finalCtx.font = '12px Arial';
        finalCtx.textAlign = 'left';
        finalCtx.fillText(capturedBird.name, 5, viewfinderBaseHeight - 5);
    } else if (capturedNightObject) {
        const highlightColor = 'rgba(173, 216, 230, 0.1)';
        finalCtx.fillStyle = highlightColor;
        finalCtx.fillRect(0, 0, viewfinderBaseWidth, viewfinderBaseHeight);
        
        finalCtx.fillStyle = '#87CEEB';
        finalCtx.font = '12px Arial';
        finalCtx.textAlign = 'left';
        finalCtx.fillText(capturedNightObject.name, 5, viewfinderBaseHeight - 5);
    }
    
  const hasCollectedAllBirds = checkIfAllBirdsCollected();
  if (hasCollectedAllBirds && !hasShownAllBirdsAlert) {
    showAllBirdsAlert();
    hasShownAllBirdsAlert = true;
  }
  
  const photo = {
    id: photos.length,
    x: x,
    y: y,
    width: width,
    height: height,
    lens: currentLens,
    time: gameTime,
    bird: capturedBird ? capturedBird.name : null,
    birdType: capturedBird ? capturedBird.type : null,
    nightObject: capturedNightObject ? capturedNightObject.name : null,
    nightObjectType: capturedNightObject ? capturedNightObject.type : null,
    imageData: finalCanvas.toDataURL('image/png')
  };
  
  photos.push(photo);
  
  // Â¶ÇÊûúÊãçÊëÑÂà∞È∏üÔºåÂπ∂‰∏îÂ§Ñ‰∫éËßÇÈ∏üÊ®°ÂºèÔºåËÆ∞ÂΩïÂà∞Êú¨Ê¨°ËßÇÈ∏üÁöÑÊãçÊëÑÁªüËÆ°‰∏≠
  if (capturedBird && !capturedBird.type.isSpecial && !capturedBird.isBat && 
      capturedBirds[capturedBird.name] !== undefined && !capturedBird.noStats) {
    capturedBirds[capturedBird.name]++;
    
    // ËÆ∞ÂΩïÂà∞Êú¨Ê¨°ËßÇÈ∏üÁöÑÊãçÊëÑÁªüËÆ°
    if (birdingModeActive && birdingModeCapturedSpecies) {
      birdingModeCapturedSpecies.add(capturedBird.name);
    }
  }
  
  updatePhotoPreview();
}

function updatePhotoPreview() {
    const photoPreview = document.getElementById('photoPreview');
    if (photos.length > 0) {
        const latestPhoto = photos[photos.length - 1];
        photoPreview.innerHTML = `<img src="${latestPhoto.imageData}" alt="ÁÖßÁâá">`;
    } else {
        photoPreview.innerHTML = '<div class="noPhoto">ÁÇπÂáªÊü•ÁúãÁõ∏ÂÜå<br>ÊöÇÊó†ÁÖßÁâá</div>';
    }
}

function showSpecialAlert(text) {
    const alertElement = document.getElementById('specialAlert');
    alertElement.textContent = text;
    alertElement.style.opacity = 1;
    
    if (specialBirdAlertTimeout) {
        clearTimeout(specialBirdAlertTimeout);
    }
    specialBirdAlertTimeout = setTimeout(() => {
        alertElement.style.opacity = 0;
    }, 3000);
}

function showCaptureAlert(text) {
    const captureAlert = document.getElementById('captureAlert');
    captureAlert.textContent = text;
    captureAlert.style.opacity = 1;
    
    if (captureAlertTimeout) {
        clearTimeout(captureAlertTimeout);
    }
    captureAlertTimeout = setTimeout(() => {
        captureAlert.style.opacity = 0;
    }, 3000);
}

function playCameraSound() {
    try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator1 = audioContext.createOscillator();
        const oscillator2 = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator1.connect(gainNode);
        oscillator2.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator1.frequency.value = 800;
        oscillator1.type = 'sine';
        oscillator2.frequency.value = 1200;
        oscillator2.type = 'sine';
        
        const currentTime = audioContext.currentTime;
        gainNode.gain.setValueAtTime(0, currentTime);
        gainNode.gain.linearRampToValueAtTime(0.5, currentTime + 0.01);
        gainNode.gain.exponentialRampToValueAtTime(0.01, currentTime + 0.05);
        gainNode.gain.linearRampToValueAtTime(0, currentTime + 0.1);
        
        oscillator1.start(currentTime);
        oscillator2.start(currentTime);
        oscillator1.stop(currentTime + 0.1);
        oscillator2.stop(currentTime + 0.1);
    } catch (e) {
        console.log("Èü≥È¢ë‰∏ä‰∏ãÊñá‰∏çÊîØÊåÅÔºåË∑≥ËøáÈü≥Êïà");
    }
}

function openAlbum() {
    if (!hasShownAllBirdsAlert && checkIfAllBirdsCollected()) {
        showAllBirdsAlert();
        hasShownAllBirdsAlert = true;
    }
    
    pauseGame();
    
    const albumModal = document.getElementById('albumModal');
    const albumPhotos = document.getElementById('albumPhotos');
    albumPhotos.innerHTML = '';
    
    if (photos.length === 0) {
        albumPhotos.innerHTML = '<div style="color: white; font-size: 18px;">ÊöÇÊó†ÁÖßÁâáÔºåÂø´ÂéªÊãçÁÖßÂêßÔºÅ</div>';
    } else {
        const photosPerRow = Math.ceil(photos.length / 3);
        
        for (let row = 0; row < 3; row++) {
            const rowStart = row * photosPerRow;
            const rowEnd = Math.min((row + 1) * photosPerRow, photos.length);
            
            if (rowStart < photos.length) {
                for (let i = rowStart; i < rowEnd; i++) {
                    const photo = photos[i];
                    const photoDiv = document.createElement('div');
                    photoDiv.className = 'albumPhoto';
                    
                    const lensText = photo.lens ? ` (${LENS_SETTINGS[photo.lens].name})` : '';
                    
                    photoDiv.innerHTML = `
                        <img src="${photo.imageData}" alt="ÁÖßÁâá">
                        <div class="photoInfo">${i + 1}${photo.bird ? ` - ${photo.bird}${lensText}` : photo.nightObject ? ` - ${photo.nightObject}${lensText}` : lensText}</div>
                    `;
                    
                    albumPhotos.appendChild(photoDiv);
                }
            }
        }
    }
    
    updateAlbumStats();
    albumModal.style.display = 'flex';
}

function closeAlbum() {
    resumeGame();
    document.getElementById('albumModal').style.display = 'none';
}

function pauseGame() {
    gamePaused = true;
    pausedTimeState.gameTime = gameTime;
    pausedTimeState.dayNightTimer = dayNightTimer;
    pausedTimeState.moonPhaseTimer = moonPhaseTimer;
    pausedTimeState.dayModeTimeState = dayModeTimeState;
    pausedTimeState.nightModeTimeState = nightModeTimeState;
    pausedTimeState.nightModeMoonPhaseTimer = nightModeMoonPhaseTimer;
    pausedTimeState.lastFrameTime = lastFrameTime;
    pausedTimeState.lastBirdTime = lastBirdTime;
    pausedTimeState.lastRareBirdTime = lastRareBirdTime;
    pausedTimeState.lastLittleOwlTime = lastLittleOwlTime;
    pausedTimeState.lastOwlSpawnTime = lastOwlSpawnTime;
    pausedTimeState.lastDoveSummonCheck = lastDoveSummonCheck;
    pausedTimeState.pauseStartTime = performance.now();
    pausedTimeState.pauseDeltaOffset = 0;
}

function resumeGame() {
    if (!gamePaused) return;
    
    gamePaused = false;
    const pauseEndTime = performance.now();
    const pauseDuration = pauseEndTime - pausedTimeState.pauseStartTime;
    
    gameTime = pausedTimeState.gameTime;
    dayNightTimer = pausedTimeState.dayNightTimer;
    moonPhaseTimer = pausedTimeState.moonPhaseTimer;
    dayModeTimeState = pausedTimeState.dayModeTimeState;
    nightModeTimeState = pausedTimeState.nightModeTimeState;
    nightModeMoonPhaseTimer = pausedTimeState.nightModeMoonPhaseTimer;
    lastBirdTime = pausedTimeState.lastBirdTime;
    lastRareBirdTime = pausedTimeState.lastRareBirdTime;
    lastLittleOwlTime = pausedTimeState.lastLittleOwlTime;
    lastOwlSpawnTime = pausedTimeState.lastOwlSpawnTime;
    lastDoveSummonCheck = pausedTimeState.lastDoveSummonCheck;
    
    lastFrameTime = performance.now() - pauseDuration;
    
    updateTimeIndicator();
    requestAnimationFrame(gameLoop);
}

function getRandomGroupSize(birdType) {
    if (Array.isArray(birdType.groupSize)) {
        const [min, max] = birdType.groupSize;
        return min + Math.floor(Math.random() * (max - min + 1));
    } else {
        return birdType.groupSize || 1;
    }
}

function generateBird() {
    if (gamePaused) return;
    
    const now = Date.now();
    // Ê†πÊçÆËßÇÈ∏üÊ®°ÂºèË∞ÉÊï¥ÁîüÊàêÈó¥Èöî
    let currentInterval = birdInterval;
    let currentVariation = birdIntervalVariation;
    
    if (birdingModeActive) {
        // ËßÇÈ∏üÊ®°ÂºèÔºö15~25Áßí
        currentInterval = 20000;  // 20ÁßíÂü∫Á°Ä
        currentVariation = 5000;  // ¬±5ÁßíÂèòÂåñ
    }
    if (now - lastBirdTime < birdInterval + (Math.random() - 0.5) * birdIntervalVariation) {
        return;
    }
    lastBirdTime = now;
    
    const isNightMode = gameMode === 'night' || (gameMode === 'normal' && !isDaytime);
    
    if (isNightMode) {
        const rand = Math.random();
        if (rand < NIGHT_OBJECTS.METEOR.probability) {
            generateMeteor(true);
            return;
        }
        if (rand < NIGHT_OBJECTS.METEOR.probability + NIGHT_OBJECTS.COMET.probability) {
            generateComet(true);
            return;
        }
        if (rand < NIGHT_OBJECTS.METEOR.probability + NIGHT_OBJECTS.COMET.probability + NIGHT_OBJECTS.UFO.probability) {
            generateUFO(true);
            return;
        }
    }
    
    if (isNightMode) {
        let eagleOwlPresent = false;
        let eagleOwlCount = 0;
        for (const bird of birds) {
            if (bird.name === "ÈõïÈ∏Æ") {
                eagleOwlPresent = true;
                eagleOwlCount++;
                break;
            }
        }
        
        if (eagleOwlPresent) {
            for (const bird of birds) {
                if (bird.name === "Áü≠ËÄ≥È∏Æ" && !bird.isFleeing && bird.state !== 'fleeing') {
                    bird.state = 'fleeing';
                    bird.speed = bird.speed * 3;
                    bird.direction = bird.direction === 1 ? -1 : 1;
                    bird.fleeStartTime = gameTime;
                }
            }
        }
        
        let shortEaredOwlCount = 0;
        for (const bird of birds) {
            if (bird.name === "Áü≠ËÄ≥È∏Æ") {
                shortEaredOwlCount++;
            }
        }
        
        let batCount = 0;
        for (const bird of birds) {
            if (bird.isBat) {
                batCount++;
            }
        }
        
        if (batCount < MAX_BAT_COUNT) {
            const batProbability = (gameMode === 'normal' && !isDaytime) ? 0.10 : 0.20;
            if (Math.random() < batProbability) {
                const batType = BIRD_TYPES.BAT;
                const bat = createBat(batType);
                birds.push(bat);
                return;
            }
        }
        
        const rand = Math.random();
        let cumulativeProbability = 0;
        let selectedBirdType = null;
        
        const nocturnalBirds = {};
        for (const key in BIRD_TYPES) {
            if (BIRD_TYPES[key].isOwl || BIRD_TYPES[key].canAppearAtNight || BIRD_TYPES[key].name === "Â∞èÈ∏Æ") {
                nocturnalBirds[key] = BIRD_TYPES[key];
            }
        }
        
        const adjustedProbabilities = {};
        for (const key in nocturnalBirds) {
            let probability = nocturnalBirds[key].probability;
            
            if (gameMode === 'normal' && !isDaytime) {
                probability = probability * 0.5;
            }
            
            if (nocturnalBirds[key].name === "ÈõïÈ∏Æ" && eagleOwlCount > 0) {
                probability = 0;
            }
            
            if (nocturnalBirds[key].name === "Áü≠ËÄ≥È∏Æ" && shortEaredOwlCount >= MAX_SHORT_EARED_OWL_COUNT) {
                probability *= 0.1;
            }
            
            if (nocturnalBirds[key].name === "Â§úÈπ≠" && nocturnalBirds[key].nightProbability !== undefined) {
                probability = nocturnalBirds[key].nightProbability;
                if (gameMode === 'normal' && !isDaytime) {
                    probability = probability * 0.5;
                }
            }
            
            adjustedProbabilities[key] = probability;
        }
        
        let totalAdjustedProbability = 0;
        for (const key in adjustedProbabilities) {
            totalAdjustedProbability += adjustedProbabilities[key];
        }
        
        if (rand > totalAdjustedProbability) {
            return;
        }
        
        let normalizedCumulative = 0;
        for (const key in adjustedProbabilities) {
            const normalizedProbability = adjustedProbabilities[key] / totalAdjustedProbability;
            normalizedCumulative += normalizedProbability;
            if (rand <= normalizedCumulative) {
                selectedBirdType = nocturnalBirds[key];
                break;
            }
        }
        
        if (!selectedBirdType) {
            return;
        }
        
        const goldenFilter = document.getElementById('goldenFilter');
        const filterStyle = window.getComputedStyle(goldenFilter);
        const filterColor = filterStyle.backgroundColor;
        let filterAlpha = 0;
        
        if (filterColor && filterColor !== 'rgba(0, 0, 0, 0)' && filterColor !== 'transparent') {
            const rgbaMatch = filterColor.match(/rgba?\((\d+),\s*(\d+),\s*(\d+),\s*([\d.]+)\)/);
            if (rgbaMatch) {
                filterAlpha = parseFloat(rgbaMatch[4]);
            }
        }
        
        if (filterAlpha > 0.01) {
            const dawnDuskRand = Math.random();
            if (dawnDuskRand < 0.15) {
                const raptorChoice = Math.random();
                if (raptorChoice < 0.1) {
                    generatePeregrine();
                    return;
                } else if (raptorChoice < 0.7) {
                    generateKestrel();
                    return;
                } else {
                    generateBlackWingedKite();
                    return;
                }
            }
        }
        
        appearedBirds[selectedBirdType.name]++;
        updateTextStats();
        
        if (selectedBirdType.isOwl || selectedBirdType.name === "Â∞èÈ∏Æ") {
            const fromLeft = Math.random() > 0.5;
            const birdCount = getRandomGroupSize(selectedBirdType);
            const groupId = nextGroupId++;
            birdGroupInfo[groupId] = { direction: fromLeft ? 1 : -1, birds: [] };
            
            for (let i = 0; i < birdCount; i++) {
                let startX, startY;
                
                if (selectedBirdType.flyInLowerHalf) {
                    startX = GAME_WIDTH * 0.5 + (Math.random() - 0.5) * 200;
                    startY = GAME_HEIGHT * 0.7 + Math.random() * 100;
                } else {
                    startX = GAME_WIDTH * 0.5 + (Math.random() - 0.5) * 200;
                    startY = -50;
                }
                
                let baseSpeed = (1.6 + Math.random() * 0.8);
                const speedMultiplier = selectedBirdType.speedMultiplier || 1;
                const finalSpeed = baseSpeed * speedMultiplier;
                
                const bird = {
                    type: selectedBirdType,
                    name: selectedBirdType.name,
                    x: startX,
                    y: startY,
                    size: selectedBirdType.size,
                    speed: finalSpeed,
                    direction: Math.random() > 0.5 ? 1 : -1,
                    state: 'circling',
                    stateTime: 0,
                    circlingTime: 0,
                    circlingRadius: 150 + Math.random() * 50,
                    circlingAngle: Math.random() * Math.PI * 2,
                    circlingCenterX: selectedBirdType.flyInLowerHalf ? GAME_WIDTH * 0.5 : GAME_WIDTH * 0.5,
                    circlingCenterY: selectedBirdType.flyInLowerHalf ? GAME_HEIGHT * 0.7 : GAME_HEIGHT * 0.3,
                    isOwl: selectedBirdType.isOwl || false,
                    circleTime: selectedBirdType.circleTime || 30000,
                    catchPreyChance: selectedBirdType.catchPreyChance || 0,
                    catchPreyType: selectedBirdType.catchPreyType || null,
                    caughtPrey: null,
                    hasGlided: false,
                    glidingStartY: 0,
                    faceDirection: -1,
                    faceChangeTimer: 0,
                    faceChangeInterval: 10000 + Math.random() * 10000,
                    wingsOpen: true,
                    isFleeing: false,
                    fleeStartTime: 0,
                    isEagleOwl: selectedBirdType.name === "ÈõïÈ∏Æ",
                    wingOffset: selectedBirdType.wingOffset || 0,
                    isNight: true
                };
                
                birds.push(bird);
                birdGroupInfo[groupId].birds.push(bird);
            }
        } else {
            const fromLeft = Math.random() > 0.5;
            const birdCount = getRandomGroupSize(selectedBirdType);
            const groupId = nextGroupId++;
            birdGroupInfo[groupId] = { direction: fromLeft ? 1 : -1, birds: [] };
            
            for (let i = 0; i < birdCount; i++) {
                let startX, startY;
                let behavior = selectedBirdType.behavior;
                let stayTime = selectedBirdType.stayTime || 10;
                
                startX = fromLeft ? -50 : GAME_WIDTH + 50;
                startY = Math.random() * (GAME_HEIGHT * 0.6) + GAME_HEIGHT * 0.2;
                
                let baseSpeed = (1.6 + Math.random() * 0.8);
                const speedMultiplier = selectedBirdType.speedMultiplier || 1;
                const finalSpeed = baseSpeed * speedMultiplier;
                
                const bird = createCommonBird(selectedBirdType, startX, startY, fromLeft, behavior, stayTime, finalSpeed, groupId);
                bird.isNight = true;
                
                birds.push(bird);
                birdGroupInfo[groupId].birds.push(bird);
            }
        }
        
        return;
    }
    
    if (Math.random() < 0.01) {
        generatePeregrine();
        return;
    }
    
    if (Math.random() < 0.02) {
        generateBlackWingedKite();
        return;
    }
    
  // Áø†È∏üÊ£ÄÊü•ÔºàÊñ∞Â¢ûÔºâ
  // Âè™Âú®ÁôΩÂ§©Âá∫Áé∞ÔºåÊ¶ÇÁéá‰∏∫0.023
  if (gameMode !== 'night') {
    const kingfisherChance = Math.random();
    // ‰ΩøÁî®ÈÖçÁΩÆ‰∏≠ÁöÑÊ¶ÇÁéá
    const kingfisherProb = BIRD_TYPES.KINGFISHER.probability || 0.023;
    if (kingfisherChance < kingfisherProb) {
      generateKingfisher(true);
      return;
    }
  }

    const rand = Math.random();
    let cumulativeProbability = 0;
    let selectedBirdType = null;
    
    const availableBirds = {};
    for (const key in BIRD_TYPES) {
        if (key !== "PEREGRINE" && key !== "BLACKWINGEDKITE" && !BIRD_TYPES[key].isSpecial && !BIRD_TYPES[key].isOwl && !BIRD_TYPES[key].isBat) {
            availableBirds[key] = BIRD_TYPES[key];
        }
    }
    
    for (const key in availableBirds) {
        cumulativeProbability += availableBirds[key].probability;
        if (rand <= cumulativeProbability) {
            selectedBirdType = availableBirds[key];
            break;
        }
    }
    
    if (!selectedBirdType) {
        selectedBirdType = BIRD_TYPES.SPARROW;
    }
    
    appearedBirds[selectedBirdType.name]++;
    updateTextStats();
    
    const fromLeft = Math.random() > 0.5;
    const birdCount = getRandomGroupSize(selectedBirdType);
    const groupId = nextGroupId++;
    birdGroupInfo[groupId] = { direction: fromLeft ? 1 : -1, birds: [] };
    
    for (let i = 0; i < birdCount; i++) {
        let startX, startY;
        let behavior = selectedBirdType.behavior;
        let stayTime = selectedBirdType.stayTime || 10;
        
        // ‰øÆÊîπÔºöÁôΩÂ§¥ÈπéÊúâ30%Ê¶ÇÁéáÂÅúÁïôÂú®Ê†ë‰∏ä15Áßí
if (selectedBirdType.name === "ÁôΩÂ§¥Èπé") {
    if (Math.random() < 0.3) {
        behavior = "landOnTree";
        stayTime = 15;
    }
}

// ‰øÆÊîπÈ∫ªÈõÄË°å‰∏∫Ôºö30%Ê¶ÇÁéáÈ£ûÂêëËä¶ËãáÂå∫Âπ∂ÂÅúÁïôÔºå70%Ê¶ÇÁéá‰øùÊåÅÂéüÊúâË°å‰∏∫
if (selectedBirdType.name === "È∫ªÈõÄ") {
    if (Math.random() < 0.3) {
        behavior = "flyToReedsAndStay";
    } else {
        behavior = "flyThrough";
    }
}

    // Êñ∞È∏üÁ±ªÔºöÈïøÂ∞æÈõÄ„ÄÅËú°Âò¥ÈõÄ„ÄÅÁáïÈõÄ„ÄÅÁΩóÂÆæÁöÑÊ†ëÈ°∂ÈÉ®/Â∫ïÈÉ®ÂÅúÁïôË°å‰∏∫
    if (selectedBirdType.name === "ÈïøÂ∞æÈõÄ" || selectedBirdType.name === "Ëú°Âò¥ÈõÄ" || selectedBirdType.name === "ÁáïÈõÄ") {
      behavior = "landOnTreeTop";
      stayTime = 10;
    } else if (selectedBirdType.name === "ÁΩóÂÆæ") {
      behavior = "landOnTreeBottom";
      stayTime = 5;
    }
        
        if ((selectedBirdType.name === "ÈáëÁú∂È∏ª" || selectedBirdType.name === "12000È∏ª") && Math.random() < selectedBirdType.landOnReedsChance) {
                   }
        
        if (selectedBirdType.behavior === 'circleThenHuntBird' || selectedBirdType.behavior === 'circleThenHunt') {
            startX = GAME_WIDTH * 0.5 + (Math.random() - 0.5) * 200;
            startY = -50;
        } else if (selectedBirdType.behavior === 'hunt') {
            startX = fromLeft ? -100 : GAME_WIDTH + 100;
            startY = GAME_HEIGHT * 0.3 + Math.random() * (GAME_HEIGHT * 0.4);
        } else if (selectedBirdType.behavior === 'flyInReedsAndStay') {
            startX = fromLeft ? -50 : GAME_WIDTH + 50;
            startY = reedZone.y + Math.random() * reedZone.height;
        } else {
            startX = fromLeft ? -50 : GAME_WIDTH + 50;
            startY = Math.random() * (GAME_HEIGHT * 0.6) + GAME_HEIGHT * 0.2;
        }
        
        let baseSpeed = (1.6 + Math.random() * 0.8);
        if (selectedBirdType.name === "ÊñëÈ∏†") {
            baseSpeed *= 0.8;
        }
        
        const speedMultiplier = selectedBirdType.speedMultiplier || 1;
        const finalSpeed = baseSpeed * speedMultiplier;
        
        const bird = createCommonBird(selectedBirdType, startX, startY, fromLeft, behavior, stayTime, finalSpeed, groupId);

// ÈíàÂØπÊñ∞È∏üÁ±ªÁöÑÁâπÊÆäËÆæÁΩÆ
    if (selectedBirdType.name === "ÈïøÂ∞æÈõÄ" || selectedBirdType.name === "Ëú°Âò¥ÈõÄ" || selectedBirdType.name === "ÁáïÈõÄ" || selectedBirdType.name === "ÁΩóÂÆæ") {
      bird.isVulnerableToRaptors = true;
    }
        
// ËÆæÁΩÆÂêÉÊ∞¥ÊûúÁöÑÈ∏üÁ±ª
    if (selectedBirdType.name === "Ëú°Âò¥ÈõÄ" || selectedBirdType.name === "ÁáïÈõÄ") {
      bird.eatFruits = true;
      bird.eatProbability = 0.1;
      bird.eatDuration = 2000;
      bird.originalSize = selectedBirdType.size;
    }

        if (selectedBirdType.behavior === 'appearOnTree' && bird.targetTree) {
            if (bird.name === "Â∞èÂåó" || bird.name === "Êà¥Ëèä" || bird.name === "ÊüêÁßçÊü≥Ëé∫") {
                bird.x = bird.targetTree.x + bird.targetTree.width * 0.4 + Math.random() * bird.targetTree.width * 0.2;
                bird.y = bird.targetTree.y + bird.targetTree.height * 0.2 + Math.random() * bird.targetTree.height * 0.3;
            } else {
                bird.x = bird.targetTree.x + Math.random() * bird.targetTree.width;
                bird.y = bird.targetTree.y + Math.random() * (bird.targetTree.height * 0.7);
            }
            bird.state = 'perching';
            bird.stateTime = 0;
            bird.speed = 0;
            bird.direction = bird.targetTree.side === 'left' ? 1 : -1;
        }
        
        if (behavior === "landOnReeds" && reedZone) {
            bird.reedTargetX = reedZone.x + Math.random() * reedZone.width;
            bird.reedTargetY = reedZone.y + reedZone.height - 3;
            bird.state = 'landingOnReeds';
            bird.groundDirection = Math.random() > 0.5 ? 1 : -1;
            bird.isLandingOnReeds = true;
        }
        
        birds.push(bird);
        birdGroupInfo[groupId].birds.push(bird);
    }
}

function createCommonBird(birdType, startX, startY, fromLeft, behavior, stayTime, speed, groupId) {
    // ÂØπ‰∫éÈ∫ªÈõÄÁöÑÁâπÊÆäÂ§ÑÁêÜÔºöÂ¶ÇÊûúË°å‰∏∫ÊòØÈ£ûÂêëËä¶ËãáÂå∫ÔºåËÆæÁΩÆÂàùÂßãÁä∂ÊÄÅ‰∏∫È£ûÂêëËä¶ËãáÂå∫
    if (birdType.name === "È∫ªÈõÄ" && behavior === "flyToReedsAndStay") {
        behavior = "flyToReedsAndStay";
    }
    
    const bird = {
        type: birdType,
        name: birdType.name,
        x: startX,
        y: startY,
        size: birdType.size,
        speed: speed,
        direction: fromLeft ? 1 : -1,
        state: 'flying',
        stateTime: 0,
        circlingTime: 0,
        hoveringTime: 0,
        circlingRadius: 100 + Math.random() * 50,
        circlingAngle: Math.random() * Math.PI * 2,
        circlingCenterX: 0,
        circlingCenterY: 0,
        variant: birdType.variant ? Math.random() > 0.5 : false,
        whiteEyeRing: birdType.whiteEyeRing || false,
        brownEyeRing: birdType.brownEyeRing || false,
        yellowEyeRing: birdType.yellowEyeRing || false,
        longBlackTail: birdType.longBlackTail || false,
        longWhiteTail: birdType.longWhiteTail || false,
        longBrownTail: birdType.longBrownTail || false,
        targetTree: (behavior === 'landOnTree' || behavior === 'appearOnTree' || behavior === 'landOnTreeThenMove') ? treePositions[Math.floor(Math.random() * treePositions.length)] : null,
        originalBehavior: birdType.behavior,
        actualBehavior: (birdType.name === "ÂñúÈπä" || birdType.name === "‰πåÈ∏¶" || birdType.name === "ÁôΩÂ§¥Èπé") ? "landOnTree" : behavior,
        stayTime: stayTime,
        hasMovedToSecondTree: false,
        isScared: false,
        isChasing: false,
        originalX: undefined,
        spreadDirection: undefined,
        headOffsetX: 0,
        hasLanded: false,
        groundTime: 0,
        isLandingOnReeds: behavior === "landOnReeds",
        reedTargetX: 0,
        reedTargetY: 0,
        peckingState: 0,
        peckingTimer: 0,
        groundDirection: 0,
        chasingTarget: null,
        isBeingChased: false,
        escapeDirection: 0,
        escapeSpeed: 0,
        isEscaping: false,
        escapeStartTime: 0,
        originalState: '',
        originalSpeed: 0,
        groupId: groupId,
        targetX: fromLeft ? GAME_WIDTH + 100 : -100,
        isEating: false,
        eatingFruit: null,
        eatingTime: 0,
        eatAnimationOffset: 0,
        lastPoopTime: 0,
        isFleeingFromRaptor: false,
        isHidingFromRaptor: false,
        isChasingRaptor: false,
        chasingTarget: null,
        isFleeingFromChasers: false,
        originalState: '',
        originalSpeed: 0,
        fleeFromRaptorStartTime: 0,
        fleeFromChasersStartTime: 0,
        chaseStartTime: 0,
        originalY: 0,
        hasCrest: birdType.hasCrest || false,
        crestColor: birdType.crestColor || null,
        doubleBeak: birdType.doubleBeak || false,
        beakOnePointFive: birdType.beakOnePointFive || false,
        beakOnePointThree: birdType.beakOnePointThree || false,
    beakLengthMultiplier: birdType.beakLengthMultiplier || 1,
    isVulnerableToRaptors: birdType.isVulnerableToRaptors || false,
    hideFromRaptors: birdType.hideFromRaptors || false,
    specialSummon: birdType.specialSummon || null,
    summonInterval: birdType.summonInterval || 0,
    summonProbability: birdType.summonProbability || 0,
    headOffsetY: birdType.headOffsetY || 0,
        fifthBeak: birdType.fifthBeak || false,
        riceBallAppearance: birdType.riceBallAppearance || false,
        halfBeakFlying: birdType.halfBeakFlying || false,
        peckingAction: birdType.peckingAction || false,
        hasHeart: birdType.hasHeart || false,
        groundPecking: birdType.groundPecking || false,
        groundMoveSpeed: birdType.groundMoveSpeed || 0.3,
        landOnReedsChance: birdType.landOnReedsChance || 0,
        landOnReedsTime: birdType.landOnReedsTime || 10,
        stayTimePerTree: birdType.stayTimePerTree || 2000,
        eatFruits: birdType.eatFruits || false,
        eatProbability: birdType.eatProbability || 0,
        eatDuration: birdType.eatDuration || 0,
        originalSize: birdType.originalSize || birdType.size,
        poopInterval: birdType.poopInterval || 0,
        poopProbability: birdType.poopProbability || 0,
        poopColor: birdType.poopColor || null,
        isPredator: birdType.isPredator || false,
        diveSpeedMultiplier: birdType.diveSpeedMultiplier || 1,
        catchDoveChance: birdType.catchDoveChance || 0,
        catchMouseChance: birdType.catchMouseChance || 0,
        leaveChance: birdType.leaveChance || 0,
        scareOtherBirds: birdType.scareOtherBirds || false,
        longBeak: birdType.longBeak || false,
        beakReducedQuarter: birdType.beakReducedQuarter || false,
        halfBeak: birdType.halfBeak || false,
        quarterBeak: birdType.quarterBeak || false,
        huntingBird: birdType.behavior === 'circleThenHuntBird',
        huntingMouse: birdType.behavior === 'circleThenHoverThenHuntMouse',
        faceScreen: birdType.faceScreen || false,
        isNight: false
    };
    
    if (birdType.name === "Â§úÈπ≠") {
        bird.isNight = false;
    }
    
    if (birdType.behavior === 'circleThenHuntBird' || birdType.behavior === 'circleThenHunt' || birdType.behavior === 'circleThenHoverThenHuntMouse') {
        bird.circlingCenterX = GAME_WIDTH * 0.5;
        bird.circlingCenterY = GAME_HEIGHT * 0.3;
        bird.state = 'circling';
        bird.speed = 1.5;
    }
    
    if (birdType.isKingfisher) {
        bird.state = 'flyingToReed';
        bird.targetX = reedZone.x + Math.random() * reedZone.width;
        bird.targetY = reedZone.y + reedZone.height * 0.7;
        // ÈáçÊñ∞Ë∞ÉÊï¥ÂàùÂßãYÂùêÊ†áÔºåÈÅøÂÖçÁõ¥Êé•ÁîüÊàêÂú®ÁõÆÊ†á‰ΩçÁΩÆ
        bird.y = reedZone.y + reedZone.height * 0.5 + Math.random() * (GAME_HEIGHT * 0.1);
        bird.headAngle = 0;
        bird.turnInterval = birdType.turnInterval[0] + Math.random() * (birdType.turnInterval[1] - birdType.turnInterval[0]);
        bird.stayTime = birdType.stayTime[0] + Math.random() * (birdType.stayTime[1] - birdType.stayTime[0]);
        bird.nextTurnTime = gameTime + bird.turnInterval;
        bird.facingDirection = bird.direction;
    }
    
    return bird;
}

function generateMagpie(countStats = false) {
    const magpieType = BIRD_TYPES.MAGPIE;
    if (countStats) {
        appearedBirds[magpieType.name]++;
        updateTextStats();
    }
    
    const fromLeft = Math.random() > 0.5;
    const birdCount = getRandomGroupSize(magpieType);
    const groupId = nextGroupId++;
    birdGroupInfo[groupId] = { direction: fromLeft ? 1 : -1, birds: [] };
    
    for (let i = 0; i < birdCount; i++) {
        const startX = fromLeft ? -50 : GAME_WIDTH + 50;
        const startY = Math.random() * (GAME_HEIGHT * 0.6) + GAME_HEIGHT * 0.2;
        
        const bird = createCommonBird(
            magpieType, 
            startX, 
            startY, 
            fromLeft, 
            "landOnTree", 
            magpieType.stayTime, 
            (2 + Math.random()) * 2,
            groupId
        );
        
        bird.whiteEyeRing = true;
        bird.longBlackTail = true;
        bird.eatFruits = true;
        bird.eatProbability = 0.1;
        bird.eatDuration = 2000;
        bird.noStats = !countStats;
        bird.isNight = !isDaytime;
        
        birds.push(bird);
        birdGroupInfo[groupId].birds.push(bird);
    }
}

// Ê≠•È™§1Ôºö‰øÆÊîπÁø†È∏üÁîüÊàêÂáΩÊï∞ÔºåË∞ÉÊï¥ËßíÂ∫¶ÂíåÈÄªËæë
function generateKingfisher(countStats = false) {
  const kingfisherType = BIRD_TYPES.KINGFISHER;
  
  if (countStats) {
    appearedBirds[kingfisherType.name] = (appearedBirds[kingfisherType.name] || 0) + 1;
    updateTextStats();
  }
  
  // ‰ªéÁîªÈù¢Â§ñÈ£ûÂÖ•ÔºåÁõ¥Êé•È£ûÂêëËä¶Ëãá‰∏õ
  const fromLeft = Math.random() > 0.5;
  const startX = fromLeft ? -50 : GAME_WIDTH + 50;
  
  // È£ûÂêëËä¶Ëãá‰∏õÂå∫Âüü
  const targetReedX = reedZone.x + Math.random() * reedZone.width;
  const targetReedY = reedZone.y + reedZone.height * 0.7; // ÂÅúÂú®Ëä¶Ëãá‰∏ä
  
  // ËÆæÁΩÆËæÉ‰ΩéÁöÑÈ£ûË°åÈ´òÂ∫¶ - ‰ªéËä¶ËãáÂå∫Âüü‰∏äÊñπ‰∏ÄÁÇπÈ£ûÂÖ•
  const startY = reedZone.y + reedZone.height * 0.7 + Math.random() * (GAME_HEIGHT * 0.1);
  
  const bird = {
    type: kingfisherType,
    name: kingfisherType.name,
    x: startX,
    y: startY, // ËæÉ‰ΩéÁöÑÂàùÂßãÈ´òÂ∫¶
    size: kingfisherType.size,
    speed: 2.0,
    direction: fromLeft ? 1 : -1, // 1=ÂêëÂè≥Ôºå-1=ÂêëÂ∑¶
    state: 'flyingToReed',
    stateTime: 0,
    targetX: targetReedX,
    targetY: targetReedY,
    
    // È£ûÂÖ•Êó∂Ê∞¥Âπ≥ÔºåheadAngle = 0
    headAngle: 0, // Ê∞¥Âπ≥
    
    // ÂàùÂßãÊúùÂêëÔºàÁúãÂêëÁöÑÊñπÂêëÔºâ
    facingDirection: fromLeft ? 1 : -1, // 1=ÂêëÂè≥Ôºå-1=ÂêëÂ∑¶
    
    // Êç¢ÂêëÁõ∏ÂÖ≥
    nextTurnTime: 0,
    turnInterval: kingfisherType.turnInterval[0] + 
                  Math.random() * (kingfisherType.turnInterval[1] - kingfisherType.turnInterval[0]),
    
    stayTime: kingfisherType.stayTime[0] + 
              Math.random() * (kingfisherType.stayTime[1] - kingfisherType.stayTime[0]),
    
    diveTargetX: 0,
    diveTargetY: 0,
    hasDived: false,
    hasCaughtFish: false,
    caughtFish: null,
    fishOffsetX: 0,
    fishOffsetY: 0,
    fishAngle: 0,
    beakLengthMultiplier: kingfisherType.beakLengthMultiplier,
    isVulnerableToRaptors: true,
    noStats: !countStats,
    isKingfisher: true,
    
    // Ë∫´‰ΩìÊòØÂê¶ÁøªËΩ¨ÁöÑÊ†áÂøóÔºàÁî®‰∫éÁªòÂà∂Ôºâ
    bodyFlipped: false
  };
  
  // ËÆæÁΩÆËΩ¨ÂêëÊó∂Èó¥
  bird.nextTurnTime = gameTime + bird.turnInterval;
  
  birds.push(bird);
  
  if (countStats) {
    showSpecialAlert(`ÂèëÁé∞${kingfisherType.name}ÔºÅ`);
  }
}

function generateHawfinchManual(countStats = false) {
    const hawfinchType = BIRD_TYPES.HAWFINCH;
    
    if (countStats) {
        appearedBirds[hawfinchType.name] = (appearedBirds[hawfinchType.name] || 0) + 1;
        updateTextStats();
    }
    
    const fromLeft = Math.random() > 0.5;
    const birdCount = getRandomGroupSize(hawfinchType);
    const groupId = nextGroupId++;
    
    birdGroupInfo[groupId] = {
        direction: fromLeft ? 1 : -1,
        birds: []
    };
    
    for (let i = 0; i < birdCount; i++) {
        const startX = fromLeft ? -50 : GAME_WIDTH + 50;
        const startY = Math.random() * (GAME_HEIGHT * 0.6) + GAME_HEIGHT * 0.2;
        
        // Ëú°Âò¥ÈõÄÁöÑË°å‰∏∫ÈÄöÂ∏∏ÊòØÂÅúÂú®Ê†ë‰∏ä
        let behavior = "landOnTreeTop";
        let stayTime = 15;
        
        // Â∞èÊ¶ÇÁéáÈ£ûË°å
        if (Math.random() < 0.2) {
            behavior = "flyThrough";
        }
        
        let baseSpeed = 1.6 + Math.random() * 0.8;
        const speedMultiplier = hawfinchType.speedMultiplier || 1;
        const finalSpeed = baseSpeed * speedMultiplier;
        
        const bird = createCommonBird(
            hawfinchType,
            startX,
            startY,
            fromLeft,
            behavior,
            stayTime,
            finalSpeed,
            groupId
        );
        
        // ËÆæÁΩÆËú°Âò¥ÈõÄÁâπÊúâÂ±ûÊÄß
        bird.quarterBeak = true;
        bird.beakLengthMultiplier = 0.25;
        bird.isVulnerableToRaptors = true;
        bird.eatFruits = true;
        bird.eatProbability = 0.15;
        bird.eatDuration = 2000;
        bird.originalSize = hawfinchType.size;
        bird.noStats = !countStats;
        bird.isNight = !isDaytime;
        
        if (behavior === "landOnTreeTop") {
            bird.targetTree = treePositions[Math.floor(Math.random() * treePositions.length)];
            bird.x = bird.targetTree.x + Math.random() * bird.targetTree.width;
            bird.y = bird.targetTree.y + bird.targetTree.height * 0.2;
            bird.state = 'perching';
            bird.stateTime = 0;
            bird.speed = 0;
            bird.direction = bird.targetTree.side === 'left' ? 1 : -1;
        }
        
        birds.push(bird);
        birdGroupInfo[groupId].birds.push(bird);
    }
    
    // ÊòæÁ§∫ÊèêÁ§∫‰ø°ÊÅØ
    showSpecialAlert(`ÁîüÊàêËú°Âò¥ÈõÄ ${birdCount} Âè™`);
}

function generateBramblingManual(countStats = false) {
    const bramblingType = BIRD_TYPES.BRAMBLING;
    
    if (countStats) {
        appearedBirds[bramblingType.name] = (appearedBirds[bramblingType.name] || 0) + 1;
        updateTextStats();
    }
    
    const fromLeft = Math.random() > 0.5;
    const birdCount = getRandomGroupSize(bramblingType);
    const groupId = nextGroupId++;
    
    birdGroupInfo[groupId] = {
        direction: fromLeft ? 1 : -1,
        birds: []
    };
    
    for (let i = 0; i < birdCount; i++) {
        const startX = fromLeft ? -50 : GAME_WIDTH + 50;
        const startY = Math.random() * (GAME_HEIGHT * 0.6) + GAME_HEIGHT * 0.2;
        
        // ÁáïÈõÄÁöÑË°å‰∏∫ÂèØ‰ª•ÊòØÈ£ûË°åÊàñÂÅúÂú®Ê†ë‰∏ä
        let behavior = "flyThrough";
        let stayTime = 10;
        
        if (Math.random() < 0.3) {
            behavior = "landOnTreeTop";
            stayTime = 10;
        }
        
        let baseSpeed = 1.6 + Math.random() * 0.8;
        const speedMultiplier = bramblingType.speedMultiplier || 1;
        const finalSpeed = baseSpeed * speedMultiplier;
        
        const bird = createCommonBird(
            bramblingType,
            startX,
            startY,
            fromLeft,
            behavior,
            stayTime,
            finalSpeed,
            groupId
        );
        
        // ËÆæÁΩÆÁáïÈõÄÁâπÊúâÂ±ûÊÄß
        bird.halfBeak = true;
        bird.isVulnerableToRaptors = true;
        bird.eatFruits = true;
        bird.eatProbability = 0.1;
        bird.eatDuration = 1800;
        bird.originalSize = bramblingType.size;
        bird.noStats = !countStats;
        bird.isNight = !isDaytime;
        
        if (behavior === "landOnTreeTop") {
            bird.targetTree = treePositions[Math.floor(Math.random() * treePositions.length)];
            bird.x = bird.targetTree.x + Math.random() * bird.targetTree.width;
            bird.y = bird.targetTree.y + bird.targetTree.height * 0.2;
            bird.state = 'perching';
            bird.stateTime = 0;
            bird.speed = 0;
            bird.direction = bird.targetTree.side === 'left' ? 1 : -1;
        }
        
        birds.push(bird);
        birdGroupInfo[groupId].birds.push(bird);
    }
    
    // ÊòæÁ§∫ÊèêÁ§∫‰ø°ÊÅØ
    showSpecialAlert(`ÁîüÊàêÁáïÈõÄ ${birdCount} Âè™`);
}

function generateKestrel(countStats = false) {
    const kestrelType = BIRD_TYPES.KESTREL;
    if (countStats) {
        appearedBirds[kestrelType.name]++;
        updateTextStats();
    }
    
    generateGroundMouseForPredator("Á∫¢Èöº");
    scareMode = true;
    scareModeEndTime = gameTime + 3000;
    
    const startX = GAME_WIDTH * 0.5 + (Math.random() - 0.5) * 200;
    const startY = -50;
    
    const bird = {
        type: kestrelType,
        name: kestrelType.name,
        x: startX,
        y: startY,
        size: kestrelType.size,
        speed: 1.5,
        direction: Math.random() > 0.5 ? 1 : -1,
        state: 'circling',
        stateTime: 0,
        circlingTime: 0,
        hoveringTime: 0,
        circlingRadius: 100 + Math.random() * 50,
        circlingAngle: Math.random() * Math.PI * 2,
        circlingCenterX: GAME_WIDTH * 0.5,
        circlingCenterY: GAME_HEIGHT * 0.3,
        hasDecided: false,
        decision: null,
        caughtPrey: null,
        isPredator: true,
        diveSpeed: 3.0,
        noStats: !countStats,
        isFleeingFromChasers: false,
        originalState: '',
        originalSpeed: 1.2,
        fleeFromChasersStartTime: 0,
        chasedStartTime: 0,
        maxChasedTime: 15000,
        whiteEyeRing: kestrelType.whiteEyeRing || false,
        yellowEyeRing: kestrelType.yellowEyeRing || false,
        hasBeenNearCenter: false,
        centerArrivalTime: 0,
        requiredCirclingWhenChasedCount: 1 + Math.floor(Math.random() * 3),
        circlingWhenChasedCount: 0,
        circlingWhenChasedStartTime: 0,
        circlingWhenChasedCenterX: 0,
        circlingWhenChasedCenterY: 0,
        circlingWhenChasedAngle: 0,
        circlingWhenChasedRadius: 300,
        isCirclingWhenChased: false,
        forcedToLeave: false,
        fleeDirection: 0,
        fleeSpeed: 0,
        isNight: !isDaytime,
        caughtMouse: null,
        mouseTarget: null,
        hasGeneratedMouse: true,
        hasFoundMouse: false,
        catchMouseChance: kestrelType.catchMouseChance || 0.5,
        catchDoveChance: kestrelType.catchDoveChance || 0.3,
        leaveChance: kestrelType.leaveChance || 0.2
    };
    
    birds.push(bird);
}

function generatePeregrine(countStats = true) {
    const peregrineType = BIRD_TYPES.PEREGRINE;
    if (countStats) {
        appearedBirds[peregrineType.name]++;
        updateTextStats();
    }
    
    const startX = GAME_WIDTH * 0.5 + (Math.random() - 0.5) * 200;
    const startY = -50;
    
    const bird = {
        type: peregrineType,
        name: peregrineType.name,
        x: startX,
        y: startY,
        size: peregrineType.size,
        speed: 1.5,
        direction: Math.random() > 0.5 ? 1 : -1,
        state: 'circling',
        stateTime: 0,
        circlingTime: 0,
        circlingRadius: 100 + Math.random() * 50,
        circlingAngle: Math.random() * Math.PI * 2,
        circlingCenterX: GAME_WIDTH * 0.5,
        circlingCenterY: GAME_HEIGHT * 0.3,
        huntingBird: true,
        hasLanded: false,
        groundTime: 0,
        isBeingChased: false,
        escapeDirection: 0,
        escapeSpeed: 0,
        isEscaping: false,
        escapeStartTime: 0,
        originalState: '',
        originalSpeed: 1.5,
        noStats: !countStats,
        isFleeingFromChasers: false,
        fleeFromChasersStartTime: 0,
        chasedStartTime: 0,
        maxChasedTime: 10000,
        whiteEyeRing: peregrineType.whiteEyeRing || false,
        yellowEyeRing: peregrineType.yellowEyeRing || false,
        hasBeenNearCenter: false,
        centerArrivalTime: 0,
        requiredCirclingWhenChasedCount: 1 + Math.floor(Math.random() * 3),
        circlingWhenChasedCount: 0,
        circlingWhenChasedStartTime: 0,
        circlingWhenChasedCenterX: 0,
        circlingWhenChasedCenterY: 0,
        circlingWhenChasedAngle: 0,
        circlingWhenChasedRadius: 300,
        isCirclingWhenChased: false,
        forcedToLeave: false,
        fleeDirection: 0,
        fleeSpeed: 0,
        isNight: !isDaytime,
        originalState: 'circling',
        hasTriggeredRaptorLeave: false
    };
    
    birds.push(bird);
}

function generateBlackWingedKite(countStats = true) {
    const kiteType = BIRD_TYPES.BLACKWINGEDKITE;
    if (countStats) {
        appearedBirds[kiteType.name]++;
        updateTextStats();
    }
    
    generateGroundMouseForPredator("ÈªëÁøÖÈ∏¢");
    
    const startX = GAME_WIDTH * 0.5 + (Math.random() - 0.5) * 200;
    const startY = -50;
    
    const bird = {
        type: kiteType,
        name: kiteType.name,
        x: startX,
        y: startY,
        size: kiteType.size,
        speed: 1.5,
        direction: Math.random() > 0.5 ? 1 : -1,
        state: 'circling',
        stateTime: 0,
        circlingTime: 0,
        hoveringTime: 0,
        circlingRadius: 100 + Math.random() * 50,
        circlingAngle: Math.random() * Math.PI * 2,
        circlingCenterX: GAME_WIDTH * 0.5,
        circlingCenterY: GAME_HEIGHT * 0.3,
        huntingMouse: true,
        caughtMouse: null,
        mouseRelativeX: 15,
        mouseRelativeY: 10,
        mouseSwingAngle: 0,
        mouseSwingSpeed: 0.05 + Math.random() * 0.05,
        hasLanded: false,
        groundTime: 0,
        isBeingChased: false,
        escapeDirection: 0,
        escapeSpeed: 0,
        isEscaping: false,
        escapeStartTime: 0,
        originalState: '',
        originalSpeed: 1.2,
        mouseTarget: null,
        hasGeneratedMouse: false,
        noStats: !countStats,
        isFleeingFromChasers: false,
        fleeFromChasersStartTime: 0,
        chasedStartTime: 0,
        maxChasedTime: 20000,
        whiteEyeRing: kiteType.whiteEyeRing || false,
        hasBeenNearCenter: false,
        centerArrivalTime: 0,
        requiredCirclingWhenChasedCount: 1 + Math.floor(Math.random() * 3),
        circlingWhenChasedCount: 0,
        circlingWhenChasedStartTime: 0,
        circlingWhenChasedCenterX: 0,
        circlingWhenChasedCenterY: 0,
        circlingWhenChasedAngle: 0,
        circlingWhenChasedRadius: 300,
        isCirclingWhenChased: false,
        forcedToLeave: false,
        fleeDirection: 0,
        fleeSpeed: 0,
        isNight: !isDaytime,
        originalState: 'circling',
        hasTriggeredRaptorLeave: false,
        // ÈªëÁøÖÈ∏¢ÁâπÊúâÂ±ûÊÄß
        catchMouseChance: 0.5,
        leaveChance: 0.2
    };
    
    birds.push(bird);
}

function generateKentishPlover(countStats = false) {
    const kentishPloverType = BIRD_TYPES.KENTISH_PLOVER;
    
    if (countStats) {
        appearedBirds[kentishPloverType.name]++;
        updateTextStats();
    }
    
    const fromLeft = Math.random() > 0.5;
    const birdCount = getRandomGroupSize(kentishPloverType);
    const groupId = nextGroupId++;
    
    // ‚úÖ Êñ∞Â¢ûÔºöÂ∞èÁªÑÁªü‰∏ÄÂÜ≥ÂÆöË°å‰∏∫
    let groupBehavior = "flyThrough"; // ÈªòËÆ§È£ûËøá
    let groupStayTime = kentishPloverType.stayTime || 10;
    
    // Êï¥‰∏™Â∞èÁªÑÁªü‰∏ÄÂÜ≥ÂÆöÊòØÂê¶ÈôçËêΩÂú®Ëä¶Ëãá‰∏ä
    if (Math.random() < kentishPloverType.landOnReedsChance) {
        groupBehavior = "landOnReeds";
        groupStayTime = kentishPloverType.landOnReedsTime;
    }
    
    // ‚úÖ Êñ∞Â¢ûÔºö‰∏∫Êï¥‰∏™Â∞èÁªÑÈÄâÊã©‰∏Ä‰∏™Áªü‰∏ÄÁöÑËä¶ËãáÈôçËêΩÂå∫Âüü
    let groupReedTargetX = 0;
    let groupReedTargetY = 0;
    let groupGroundDirection = Math.random() > 0.5 ? 1 : -1;
    
    if (groupBehavior === "landOnReeds" && reedZone) {
        // Â∞èÁªÑÈôçËêΩÂú®Ëä¶ËãáÁöÑÂêå‰∏Ä‰∏™Âå∫ÂüüÈôÑËøë
        const baseX = reedZone.x + Math.random() * reedZone.width * 0.7;
        const baseY = reedZone.y + reedZone.height - 3;
        groupReedTargetX = baseX;
        groupReedTargetY = baseY;
    }
    
    birdGroupInfo[groupId] = {
        direction: fromLeft ? 1 : -1,
        birds: [],
        behavior: groupBehavior, // Â≠òÂÇ®Â∞èÁªÑË°å‰∏∫
        reedTargetX: groupReedTargetX,
        reedTargetY: groupReedTargetY,
        groundDirection: groupGroundDirection
    };
    
    for (let i = 0; i < birdCount; i++) {
        let startX, startY;
        
        // ‰ΩøÁî®Â∞èÁªÑÁªü‰∏ÄÁöÑË°å‰∏∫
        startX = fromLeft ? -50 : GAME_WIDTH + 50;
        startY = Math.random() * (GAME_HEIGHT * 0.6) + GAME_HEIGHT * 0.2;
        
        let baseSpeed = (2.6 + Math.random() * 0.8);
        const speedMultiplier = kentishPloverType.speedMultiplier || 1;
        const finalSpeed = baseSpeed * speedMultiplier;
        
        const bird = createCommonBird(
            kentishPloverType, 
            startX, 
            startY, 
            fromLeft, 
            groupBehavior, // ‰ΩøÁî®Â∞èÁªÑÁªü‰∏ÄË°å‰∏∫
            groupStayTime,  // ‰ΩøÁî®Â∞èÁªÑÁªü‰∏ÄÂÅúÁïôÊó∂Èó¥
            finalSpeed, 
            groupId
        );
        
        bird.noStats = true;
        bird.yellowEyeRing = true;
        bird.groundPecking = true;
        bird.groundMoveSpeed = 0.3;
        
        if (groupBehavior === "landOnReeds" && reedZone) {
            // ÊØèÂè™È∏üÂú®Â∞èÁªÑÁõÆÊ†á‰ΩçÁΩÆÈôÑËøëÂ∞èËåÉÂõ¥ÈöèÊú∫ÂàÜÂ∏É
            const spreadX = (Math.random() - 0.5) * 60; // ¬±30ÂÉèÁ¥†ËåÉÂõ¥ÂÜÖ
            const spreadY = (Math.random() - 0.5) * 20; // ¬±10ÂÉèÁ¥†ËåÉÂõ¥ÂÜÖ
            
            bird.reedTargetX = groupReedTargetX + spreadX;
            bird.reedTargetY = groupReedTargetY + spreadY;
            bird.state = 'landingOnReeds';
            bird.groundDirection = groupGroundDirection; // ‰ΩøÁî®Â∞èÁªÑÁªü‰∏ÄÊñπÂêë
            bird.isLandingOnReeds = true;
        }
        
        birds.push(bird);
        birdGroupInfo[groupId].birds.push(bird);
    }
}


function generateLittleOwl(countStats = true) {
    if (littleOwl) return;
    
    let cooldown;
    if (gameMode === 'day') {
        cooldown = LITTLE_OWL_DAY_COOLDOWN;
    } else if (gameMode === 'night') {
        cooldown = LITTLE_OWL_NIGHT_COOLDOWN;
    } else {
        cooldown = isDaytime ? LITTLE_OWL_DAY_COOLDOWN : LITTLE_OWL_NIGHT_COOLDOWN;
    }
    
    if (gameTime - lastLittleOwlTime < cooldown) {
        return;
    }
    
    const littleOwlType = BIRD_TYPES.LITTLE_OWL;
    if (countStats) {
        appearedBirds[littleOwlType.name]++;
        updateTextStats();
    }
    
    const baseSize = 20;
    const birdSize = baseSize * littleOwlType.size;
    const birdRadius = birdSize / 2;
    const holeBottomY = hole.y + hole.diameter / 2;
    const owlY = holeBottomY - birdRadius;
    
    const owl = {
        type: littleOwlType,
        name: littleOwlType.name,
        x: hole.x,
        y: owlY,
        size: littleOwlType.size,
        state: 'appearing',
        stateTime: 0,
        stayTime: littleOwlType.stayTime || 15,
        isBackground: littleOwlType.isBackground || false,
        whiteEyeRing: littleOwlType.whiteEyeRing || false,
        noStats: !countStats,
        isNight: !isDaytime
    };
    
    littleOwl = owl;
    birds.push(owl);
    lastLittleOwlTime = gameTime;
}

function generateGroundMouseForPredator(predatorName) {
    const mouse = {
        x: GAME_WIDTH * 0.3 + Math.random() * (GAME_WIDTH * 0.4),
        y: GAME_HEIGHT - 10,
        size: 8,
        color: "#D3D3D3",
        type: "mouse",
        createdAt: gameTime,
        lifetime: 10000,
        predatorTarget: predatorName
    };
    
    groundObjects.push(mouse);
    return mouse;
}

function generateHedgehog() {
    const hedgehog = {
        x: GAME_WIDTH * 0.3 + Math.random() * (GAME_WIDTH * 0.4),
        y: GAME_HEIGHT - 15,
        size: 12,
        color: "#A0522D",
        type: "hedgehog",
        createdAt: gameTime,
        lifetime: 15000,
        spikes: []
    };
    
    for (let i = 0; i < 24; i++) {
        const angle = (i / 24) * Math.PI * 2;
        const length = 3 + Math.random() * 1.5;
        hedgehog.spikes.push({ angle: angle, length: length });
    }
    
    groundObjects.push(hedgehog);
    return hedgehog;
}

function createBat(batType) {
    const startX = GAME_WIDTH * 0.5 + (Math.random() - 0.5) * 200;
    const startY = -50;
    
    const baseSpeed = (1.5 + Math.random());
    const speedMultiplier = batType.speedMultiplier || 1;
    const finalSpeed = baseSpeed * speedMultiplier;
    
    const circlingCenterY = GAME_HEIGHT * 0.25 + Math.random() * (GAME_HEIGHT * 0.25);
    
    const bat = {
        type: batType,
        name: batType.name,
        x: startX,
        y: startY,
        size: batType.size,
        speed: finalSpeed,
        direction: Math.random() > 0.5 ? 1 : -1,
        state: 'circling',
        stateTime: 0,
        circlingTime: 0,
        circlingRadius: 80 + Math.random() * 40,
        circlingAngle: Math.random() * Math.PI * 2,
        circlingCenterX: GAME_WIDTH * 0.5,
        circlingCenterY: circlingCenterY,
        isBat: true,
        circleTime: batType.circleTime || 15000,
        faceDirection: -1,
        faceChangeTimer: 0,
        faceChangeInterval: 10000 + Math.random() * 10000,
        wingsOpen: true,
        isNight: true,
        wingFlapTimer: 0,
        wingFlapSpeed: 0.1 + Math.random() * 0.05,
        maxConcurrent: batType.maxConcurrent || 3
    };
    
    return bat;
}

function spawnNightOwls() {
    let shortEaredOwlCount = 0;
    let eagleOwlCount = 0;
    
    for (const bird of birds) {
        if (bird.name === "Áü≠ËÄ≥È∏Æ") {
            shortEaredOwlCount++;
        } else if (bird.name === "ÈõïÈ∏Æ") {
            eagleOwlCount++;
        }
    }
    
    if (eagleOwlCount > 0) {
        if (shortEaredOwlCount >= MAX_SHORT_EARED_OWL_COUNT) {
            return;
        }
        const owlType = BIRD_TYPES.SHORT_EARED_OWL;
        createNightOwl(owlType);
        return;
    }
    
    const owlTypes = ['EAGLE_OWL', 'SHORT_EARED_OWL'];
    let selectedType = owlTypes[Math.floor(Math.random() * owlTypes.length)];
    
    if (selectedType === 'SHORT_EARED_OWL' && shortEaredOwlCount >= MAX_SHORT_EARED_OWL_COUNT) {
        selectedType = 'EAGLE_OWL';
    }
    
    const owlType = BIRD_TYPES[selectedType];
    
    appearedBirds[owlType.name]++;
    updateTextStats();
    
    createNightOwl(owlType);
}

function createNightOwl(owlType) {
    const bird = {
        type: owlType,
        name: owlType.name,
        x: GAME_WIDTH * 0.5 + (Math.random() - 0.5) * 200,
        y: owlType.flyInLowerHalf ? GAME_HEIGHT * 0.7 + Math.random() * 100 : -50,
        size: owlType.size,
        speed: 1.1 * (owlType.speedMultiplier || 1),
        direction: Math.random() > 0.5 ? 1 : -1,
        state: 'circling',
        stateTime: 0,
        circlingTime: 0,
        circlingRadius: 150 + Math.random() * 50,
        circlingAngle: Math.random() * Math.PI * 2,
        circlingCenterX: GAME_WIDTH * 0.5,
        circlingCenterY: owlType.flyInLowerHalf ? GAME_HEIGHT * 0.7 : GAME_HEIGHT * 0.3,
        isOwl: true,
        circleTime: owlType.circleTime || 30000,
        catchPreyChance: owlType.catchPreyChance || 0,
        catchPreyType: owlType.catchPreyType || null,
        caughtPrey: null,
        hasGlided: false,
        glidingStartY: 0,
        faceDirection: -1,
        faceChangeTimer: 0,
        faceChangeInterval: 10000 + Math.random() * 10000,
        wingsOpen: true,
        isFleeing: false,
        fleeStartTime: 0,
        isEagleOwl: owlType.name === "ÈõïÈ∏Æ",
        wingOffset: owlType.wingOffset || 0,
        isNight: true
    };
    
    if (owlType.name === "ÈõïÈ∏Æ") {
        for (const otherBird of birds) {
            if (otherBird.isOwl && otherBird.name === "Áü≠ËÄ≥È∏Æ") {
                otherBird.state = 'fleeing';
                otherBird.speed = otherBird.speed * 2;
                otherBird.direction = Math.random() > 0.5 ? 1 : -1;
                otherBird.fleeStartTime = gameTime;
            }
        }
    }
    
    birds.push(bird);
}

function startEatingFruit(bird) {
    let nearestFruit = null;
    let minDistance = Infinity;
    
    for (const fruit of fruits) {
        if (!fruit.isEaten && fruit.treeIndex === treePositions.indexOf(bird.targetTree)) {
            const dx = fruit.x - bird.x;
            const dy = fruit.y - bird.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < 50 && distance < minDistance) {
                minDistance = distance;
                nearestFruit = fruit;
            }
        }
    }
    
    if (nearestFruit) {
        bird.isEating = true;
        bird.eatingFruit = nearestFruit;
        bird.eatingTime = 0;
        bird.eatAnimationOffset = 0;
        
        nearestFruit.isEaten = true;
        nearestFruit.eatenBy = bird.name;
        nearestFruit.eatStartTime = gameTime;
        
        if (nearestFruit.color === "red") {
            nearestFruit.color = "#8B0000";
        } else if (nearestFruit.color === "yellow") {
            nearestFruit.color = "#DAA520";
        }
    }
}

function finishEatingFruit(bird) {
    bird.isEating = false;
    bird.eatingFruit = null;
    bird.eatingTime = 0;
    bird.eatAnimationOffset = 0;
    bird.size = bird.type.originalSize;
}

function drawNightObject(obj) {
    const baseSize = 20;
    const objSize = baseSize * obj.size;
    
    ctx.save();
    
    switch (obj.type.type) {
        case 'meteor':
            ctx.fillStyle = obj.color;
            ctx.beginPath();
            ctx.arc(obj.x, obj.y, objSize, 0, Math.PI * 2);
            ctx.fill();
            
            const trailLength = obj.trailLength;
            const trailX = obj.x - Math.cos(obj.angle) * trailLength;
            const trailY = obj.y - Math.sin(obj.angle) * trailLength;
            
            const gradient = ctx.createLinearGradient(trailX, trailY, obj.x, obj.y);
            gradient.addColorStop(0, 'rgba(255, 255, 200, 0)');
            gradient.addColorStop(0.5, obj.trailColor);
            gradient.addColorStop(1, 'rgba(255, 255, 200, 0)');
            
            ctx.strokeStyle = gradient;
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(trailX, trailY);
            ctx.lineTo(obj.x, obj.y);
            ctx.stroke();
            break;
            
        case 'comet':
            const coreRadius = objSize * (1/3);
            ctx.fillStyle = obj.color;
            ctx.beginPath();
            ctx.arc(obj.x, obj.y, coreRadius, 0, Math.PI * 2);
            ctx.fill();
            
            const tailLength = obj.tailLength * 8;
            const tailX = obj.x - Math.cos(obj.angle) * tailLength;
            const tailY = obj.y - Math.sin(obj.angle) * tailLength;
            const halfTailWidth = tailLength * Math.tan(5 * Math.PI / 180);
            const tailWidth = 2 * halfTailWidth;
            
            const tailGradient = ctx.createRadialGradient(
                obj.x, obj.y, 0,
                tailX, tailY, tailLength * 0.8
            );
            tailGradient.addColorStop(0, "rgba(173, 216, 230, 0.4)");
            tailGradient.addColorStop(0.3, obj.tailColor);
            tailGradient.addColorStop(0.7, "rgba(135, 206, 235, 0.2)");
            tailGradient.addColorStop(1, 'rgba(135, 206, 235, 0)');
            
            ctx.fillStyle = tailGradient;
            ctx.beginPath();
            ctx.moveTo(obj.x, obj.y);
            ctx.lineTo(tailX - halfTailWidth, tailY - tailLength * 0.05);
            ctx.lineTo(tailX + halfTailWidth, tailY + tailLength * 0.05);
            ctx.closePath();
            ctx.fill();
            break;
            
        case 'ufo':
            ctx.fillStyle = obj.color;
            ctx.beginPath();
            ctx.ellipse(obj.x, obj.y, objSize * 1.5, objSize * 0.8, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#32CD32';
            ctx.beginPath();
            ctx.ellipse(obj.x, obj.y - objSize * 0.5, objSize, objSize * 0.5, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#FFFF00';
            for (let i = 0; i < 5; i++) {
                const lightX = obj.x - objSize + i * (objSize / 2);
                ctx.beginPath();
                ctx.arc(lightX, obj.y + objSize * 0.3, 2, 0, Math.PI * 2);
                ctx.fill();
            }
            
            if (obj.beamActive) {
                const beamPulse = Math.sin(gameTime * 0.005 + obj.beamPhase) * 0.3 + 0.7;
                const beamGradient = ctx.createLinearGradient(
                    obj.x, obj.y + objSize,
                    obj.x, obj.y + obj.beamLength
                );
                beamGradient.addColorStop(0, `rgba(144, 238, 144, ${0.5 * beamPulse})`);
                beamGradient.addColorStop(1, 'rgba(144, 238, 144, 0)');
                
                ctx.fillStyle = beamGradient;
                ctx.beginPath();
                ctx.ellipse(obj.x, obj.y + obj.beamLength * 0.5, objSize * 0.8, obj.beamLength * 0.5, 0, 0, Math.PI * 2);
                ctx.fill();
            }
            break;
    }
    
    ctx.restore();
}

function updateNightObjects(deltaTime) {
    if (gamePaused) return;
    
    for (let i = nightObjects.length - 1; i >= 0; i--) {
        const obj = nightObjects[i];
        
        if (gameTime - obj.createdAt > obj.duration) {
            nightObjects.splice(i, 1);
            continue;
        }
        
        if (obj.type.type === 'meteor' && !obj.hasSummoned) {
            if (gameTime - obj.createdAt > 500) {
                if (Math.random() < obj.summonProbability) {
                    generateMeteor(false, true, obj.intersectionPoint);
                }
                obj.hasSummoned = true;
            }
        }
        
        switch (obj.type.type) {
            case 'meteor':
                obj.x += Math.cos(obj.angle) * obj.speed;
                obj.y += Math.sin(obj.angle) * obj.speed;
                
                const dx = obj.x - (obj.targetPoint?.x || 0);
                const dy = obj.y - (obj.targetPoint?.y || 0);
                const distanceToTarget = Math.sqrt(dx * dx + dy * dy);
                
                const isOutOfBounds = obj.x < -2000 || obj.x > GAME_WIDTH + 2000 || obj.y < -2000 || obj.y > GAME_HEIGHT + 2000;
                const isBelowMountain = obj.y >= GAME_HEIGHT * 0.55;
                const isNearTarget = distanceToTarget < 50;
                
                if (isOutOfBounds || isBelowMountain || isNearTarget) {
                    nightObjects.splice(i, 1);
                }
                break;
                
            case 'comet':
                obj.x += Math.cos(obj.angle) * obj.speed;
                obj.y += Math.sin(obj.angle) * obj.speed;
                
                if (obj.y > GAME_HEIGHT + 100) {
                    nightObjects.splice(i, 1);
                }
                break;
                
            case 'ufo':
                obj.x += obj.speed * obj.direction * (deltaTime / 1000);
                obj.y += Math.sin(gameTime * 0.001) * 0.5;
                
                if ((obj.direction === -1 && obj.x < -100) || (obj.direction === 1 && obj.x > GAME_WIDTH + 100)) {
                    nightObjects.splice(i, 1);
                }
                break;
        }
    }
}

function drawBackground() {
    const isNightMode = gameMode === 'night' || (gameMode === 'normal' && !isDaytime);
    
    if (!isNightMode) {
        const gradient = ctx.createLinearGradient(0, 0, 0, GAME_HEIGHT);
        gradient.addColorStop(0, '#87CEEB');
        gradient.addColorStop(1, '#E0F7FF');
        ctx.fillStyle = gradient;
    } else {
        const gradient = ctx.createLinearGradient(0, 0, 0, GAME_HEIGHT);
        gradient.addColorStop(0, '#191970');
        gradient.addColorStop(0.5, '#000033');
        gradient.addColorStop(1, '#000000');
        ctx.fillStyle = gradient;
    }
    
    ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
}

function drawSunMoon() {
    if (gameMode !== 'normal') {
        return;
    }
    
    const archHeight = 350;
    const t = sunMoonPosition;
    
    const archX = GAME_WIDTH * (1 - t);
    const verticalOffset = GAME_HEIGHT / 3;
    const archY = (GAME_HEIGHT - verticalOffset) - (Math.sin(t * Math.PI) * archHeight);
    
    const minY = 50;
    const finalY = Math.max(minY, archY);
    
    sunMoonX = archX;
    sunMoonY = finalY;
    
    const isNightMode = gameMode === 'normal' && !isDaytime;
    
    if (!isNightMode) {
        const sunGradient = ctx.createRadialGradient(
            archX, finalY, 0,
            archX, finalY, 40
        );
        sunGradient.addColorStop(0, '#FFFF00');
        sunGradient.addColorStop(0.7, '#FFD700');
        sunGradient.addColorStop(1, 'rgba(255, 215, 0, 0.3)');
        
        ctx.fillStyle = sunGradient;
        ctx.beginPath();
        ctx.arc(archX, finalY, 40, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = 'rgba(255, 255, 200, 0.2)';
        ctx.beginPath();
        ctx.arc(archX, finalY, 60, 0, Math.PI * 2);
        ctx.fill();
    } else {
        drawMoon(archX, finalY);
    }
}

function drawMoon(x, y) {
    const moonRadius = 30;
    
    ctx.save();
    
    const phase = (moonPhaseTimer / MOON_PHASE_CYCLE) % 1;
    
    let glowIntensity = 0.15;
    if (phase === 0.5) {
        glowIntensity = 0.25;
    } else if (phase < 0.25 || phase > 0.75) {
        glowIntensity = 0.05;
    }
    
    ctx.fillStyle = `rgba(240, 240, 255, ${glowIntensity})`;
    ctx.beginPath();
    ctx.arc(x, y, 50, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = '#F0F0F0';
    ctx.beginPath();
    ctx.arc(x, y, moonRadius, 0, Math.PI * 2);
    ctx.fill();
    
    if (phase > 0 && phase < 0.5) {
        const illumination = 0.5 - phase;
        const gradient = ctx.createRadialGradient(
            x + illumination * moonRadius * 2, y, 0,
            x, y, moonRadius
        );
        
        if (phase < 0.25) {
            gradient.addColorStop(0, 'rgba(0, 0, 51, 0.9)');
            gradient.addColorStop(0.3, 'rgba(0, 0, 51, 0.6)');
            gradient.addColorStop(0.6, 'rgba(0, 0, 51, 0.3)');
            gradient.addColorStop(1, 'rgba(0, 0, 51, 0)');
        } else {
            gradient.addColorStop(0, 'rgba(0, 0, 51, 0.7)');
            gradient.addColorStop(0.5, 'rgba(0, 0, 51, 0.4)');
            gradient.addColorStop(1, 'rgba(0, 0, 51, 0)');
        }
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(x, y, moonRadius, 0, Math.PI * 2);
        ctx.fill();
        
        const edgeGradient = ctx.createRadialGradient(
            x, y, moonRadius - 2,
            x, y, moonRadius + 5
        );
        edgeGradient.addColorStop(0, 'rgba(240, 240, 255, 0.3)');
        edgeGradient.addColorStop(1, 'rgba(240, 240, 255, 0)');
        
        ctx.fillStyle = edgeGradient;
        ctx.beginPath();
        ctx.arc(x, y, moonRadius + 5, 0, Math.PI * 2);
        ctx.fill();
    } else if (phase > 0.5 && phase < 1) {
        const illumination = phase - 0.5;
        const gradient = ctx.createRadialGradient(
            x - illumination * moonRadius * 2, y, 0,
            x, y, moonRadius
        );
        
        if (phase < 0.75) {
            gradient.addColorStop(0, 'rgba(0, 0, 51, 0.9)');
            gradient.addColorStop(0.3, 'rgba(0, 0, 51, 0.6)');
            gradient.addColorStop(0.6, 'rgba(0, 0, 51, 0.3)');
            gradient.addColorStop(1, 'rgba(0, 0, 51, 0)');
        } else {
            gradient.addColorStop(0, 'rgba(0, 0, 51, 0.7)');
            gradient.addColorStop(0.5, 'rgba(0, 0, 51, 0.4)');
            gradient.addColorStop(1, 'rgba(0, 0, 51, 0)');
        }
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(x, y, moonRadius, 0, Math.PI * 2);
        ctx.fill();
        
        const edgeGradient = ctx.createRadialGradient(
            x, y, moonRadius - 2,
            x, y, moonRadius + 5
        );
        edgeGradient.addColorStop(0, 'rgba(240, 240, 255, 0.3)');
        edgeGradient.addColorStop(1, 'rgba(240, 240, 255, 0)');
        
        ctx.fillStyle = edgeGradient;
        ctx.beginPath();
        ctx.arc(x, y, moonRadius + 5, 0, Math.PI * 2);
        ctx.fill();
    } else if (phase === 0 || phase === 1) {
        ctx.fillStyle = 'rgba(0, 0, 51, 0.95)';
        ctx.beginPath();
        ctx.arc(x, y, moonRadius, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = 'rgba(240, 240, 255, 0.05)';
        ctx.beginPath();
        ctx.arc(x, y, moonRadius + 3, 0, Math.PI * 2);
        ctx.fill();
    }
    
    if (phase !== 0 && phase !== 1) {
        let craterBrightness = 0.8;
        if (phase < 0.5) {
            craterBrightness = 0.7 + (phase * 0.6);
        } else {
            craterBrightness = 0.7 + ((1 - phase) * 0.6);
        }
        
        ctx.fillStyle = `rgba(208, 208, 208, ${craterBrightness})`;
        
        if (phase < 0.5) {
            ctx.beginPath();
            ctx.arc(x + 10, y - 5, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + 15, y + 10, 8, 0, Math.PI * 2);
            ctx.fill();
        } else if (phase > 0.5) {
            ctx.beginPath();
            ctx.arc(x - 10, y - 5, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x - 15, y + 10, 8, 0, Math.PI * 2);
            ctx.fill();
        }
        
        if (phase > 0.2 && phase < 0.8) {
            ctx.beginPath();
            ctx.arc(x - 20, y + 15, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + 5, y - 15, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + 8, y + 18, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x - 12, y - 10, 3, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    
    ctx.restore();
}

function drawWallAndHole() {
    if (!wall || !hole) return;
    
    ctx.fillStyle = wall.color;
    ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
    
    ctx.strokeStyle = '#A9A9A9';
    ctx.lineWidth = 2;
    
    for (let i = 0; i < 5; i++) {
        const x = wall.x + (i + 1) * wall.width / 6;
        ctx.beginPath();
        ctx.moveTo(x, wall.y);
        ctx.lineTo(x, wall.y + wall.height);
        ctx.stroke();
    }
    
    for (let i = 0; i < 3; i++) {
        const y = wall.y + (i + 1) * wall.height / 4;
        ctx.beginPath();
        ctx.moveTo(wall.x, y);
        ctx.lineTo(wall.x + wall.width, y);
        ctx.stroke();
    }
    
    ctx.save();
    ctx.beginPath();
    ctx.rect(wall.x, wall.y, wall.width, wall.height);
    ctx.arc(hole.x, hole.y, hole.diameter / 2, 0, Math.PI * 2);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
    
    ctx.strokeStyle = '#5D4037';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(hole.x, hole.y, hole.diameter / 2, 0, Math.PI * 2);
    ctx.stroke();
    
    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
    ctx.beginPath();
    ctx.arc(hole.x, hole.y, hole.diameter / 2 - 2, 0, Math.PI * 2);
    ctx.fill();
}

function drawTrees() {
    treePositions.forEach(tree => {
        ctx.fillStyle = '#2F4F4F';
        ctx.fillRect(tree.x + tree.width * 0.4, tree.y + tree.height * 0.7, tree.width * 0.2, tree.height * 0.3);
        
        ctx.fillStyle = '#2E8B57';
        ctx.beginPath();
        ctx.ellipse(tree.x + tree.width/2, tree.y + tree.height * 0.4, tree.width/2, tree.height * 0.5, 0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#228B22';
        
        fixedLeaves.forEach(leaf => {
            if (leaf.treeIndex === treePositions.indexOf(tree)) {
                ctx.save();
                ctx.translate(leaf.x + leaf.offsetX, leaf.y + leaf.offsetY);
                ctx.rotate(leaf.rotation);
                
                ctx.fillStyle = leaf.color;
                if (leaf.type === 0) {
                    ctx.beginPath();
                    ctx.arc(0, 0, leaf.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.strokeStyle = '#1A6B1A';
                    ctx.lineWidth = 0.5;
                    ctx.beginPath();
                    ctx.moveTo(0, -leaf.size/2);
                    ctx.lineTo(0, leaf.size/2);
                    ctx.stroke();
                } else if (leaf.type === 1) {
                    ctx.beginPath();
                    ctx.ellipse(0, 0, leaf.size, leaf.size/1.5, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.strokeStyle = '#1A6B1A';
                    ctx.lineWidth = 0.5;
                    ctx.beginPath();
                    ctx.moveTo(-leaf.size/2, 0);
                    ctx.lineTo(leaf.size/2, 0);
                    ctx.stroke();
                } else {
                    ctx.beginPath();
                    ctx.moveTo(0, -leaf.size);
                    ctx.lineTo(leaf.size/1.5, 0);
                    ctx.lineTo(0, leaf.size);
                    ctx.lineTo(-leaf.size/1.5, 0);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.strokeStyle = '#1A6B1A';
                    ctx.lineWidth = 0.5;
                    ctx.beginPath();
                    ctx.moveTo(0, -leaf.size);
                    ctx.lineTo(0, leaf.size);
                    ctx.stroke();
                }
                
                ctx.restore();
            }
        });
    });
    
    drawFruits();
}

function drawFruits() {
    fruits.forEach(fruit => {
        if (fruit.isEaten) {
            ctx.globalAlpha = 0.6;
        } else {
            ctx.globalAlpha = 1;
        }
        
        if (fruit.color === "red" || fruit.color === "#8B0000") {
            ctx.fillStyle = fruit.isEaten ? "#8B0000" : "#FF4500";
        } else {
            ctx.fillStyle = fruit.isEaten ? "#DAA520" : "#FFD700";
        }
        
        ctx.beginPath();
        ctx.arc(fruit.x, fruit.y, fruit.size, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.strokeStyle = '#8B4513';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(fruit.x, fruit.y - fruit.size);
        ctx.lineTo(fruit.x, fruit.y - fruit.size - 4);
        ctx.stroke();
        
        ctx.globalAlpha = 1;
        
        if (fruit.isEaten && fruit.eatenBy) {
            const timeSinceEaten = gameTime - fruit.eatStartTime;
            if (timeSinceEaten < 1000) {
                ctx.fillStyle = 'rgba(255, 255, 200, 0.3)';
                ctx.beginPath();
                ctx.arc(fruit.x, fruit.y, fruit.size * 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    });
}

function drawReeds() {
    if (!reedZone) return;
    
    const reedCount = reedBends.length;
    
    for (let i = 0; i < reedCount; i++) {
        const reedX = reedZone.x + (i / reedCount) * reedZone.width;
        
        // ‰ªéÂàùÂßãÂåñÂèÇÊï∞‰∏≠Ëé∑ÂèñËä¶ËãáÁ±ªÂûã
        const reedBend = reedBends[i] || { 
            bendAmount: 0, 
            bendPointRatio: 0.5, 
            topBendAmount: 0,
            reedType: 0,
            reedColor: '#8B4513',
            topColor: '#DAA520',
            reedWidth: 1.0
        };
        
        const reedType = reedBend.reedType;
        
        // ‰∏çÂêåÁ±ªÂûãÁöÑËä¶ËãáÊúâ‰∏çÂêåÁöÑÈ´òÂ∫¶ÂíåÂºØÊõ≤ÁâπÊÄß
        let reedHeight, reedY;
        
        // Ê†πÊçÆÁ±ªÂûãËÆæÁΩÆ‰∏çÂêåÁöÑÈ´òÂ∫¶
        switch(reedType) {
            case 0: // ÊôÆÈÄöÁªÜËä¶Ëãá
                reedHeight = reedZone.height * (0.5 + ((i % 10) / 25));
                reedY = reedZone.y + reedZone.height - reedHeight;
                break;
            case 1: // Á≤óËä¶Ëãá
                reedHeight = reedZone.height * (0.6 + ((i % 8) / 20));
                reedY = reedZone.y + reedZone.height - reedHeight;
                break;
            case 2: // ÁªÜÈïøËä¶Ëãá
                reedHeight = reedZone.height * (0.7 + ((i % 12) / 30));
                reedY = reedZone.y + reedZone.height - reedHeight;
                break;
            case 3: // ÂºØÊõ≤ÊòéÊòæÁöÑËä¶Ëãá
                reedHeight = reedZone.height * (0.4 + ((i % 15) / 35));
                reedY = reedZone.y + reedZone.height - reedHeight;
                break;
            case 4: // ÁüÆËä¶Ëãá
                reedHeight = reedZone.height * (0.3 + ((i % 6) / 15));
                reedY = reedZone.y + reedZone.height - reedHeight;
                break;
            case 5: // È°∂ÈÉ®ÊúâÂºØÊõ≤ÁöÑËä¶Ëãá
                reedHeight = reedZone.height * (0.5 + ((i % 10) / 22));
                reedY = reedZone.y + reedZone.height - reedHeight;
                break;
            default:
                reedHeight = reedZone.height * (0.5 + ((i % 10) / 20));
                reedY = reedZone.y + reedZone.height - reedHeight;
        }
        
        const bendAmount = reedBend.bendAmount;
        const bendPoint = reedHeight * reedBend.bendPointRatio;
        const topBendAmount = reedBend.topBendAmount;
        
        // ÁªòÂà∂Ëä¶ËãáËåé
        ctx.strokeStyle = reedBend.reedColor;
        ctx.lineWidth = reedBend.reedWidth;
        ctx.lineCap = 'round';
        
        ctx.beginPath();
        ctx.moveTo(reedX, reedY + reedHeight);
        ctx.bezierCurveTo(
            reedX + bendAmount * (reedType === 3 ? 1.5 : 1),
            reedY + reedHeight - bendPoint,
            reedX + topBendAmount * (reedType === 5 ? 1.8 : 1),
            reedY + reedHeight * 0.2,
            reedX, reedY
        );
        ctx.stroke();
        
        // ÁªòÂà∂Ëä¶ËãáÊ£íÔºàËä¶ËãáÈ°∂ÈÉ®Ôºâ
        let topSize;
        
        // ‰∏çÂêåÁ±ªÂûãËä¶ËãáÁöÑËä¶ËãáÊ£íÂ§ßÂ∞è
        switch(reedType) {
            case 1: // Á≤óËä¶ËãáÁöÑËä¶ËãáÊ£íËæÉÂ§ß
                topSize = 4 + ((i % 5) / 1.5);
                break;
            case 4: // ÁüÆËä¶ËãáÁöÑËä¶ËãáÊ£íËæÉÂ∞è
                topSize = 2 + ((i % 5) / 3);
                break;
            default: // ÂÖ∂‰ªñËä¶Ëãá
                topSize = 3 + ((i % 5) / 2);
        }
        
        // ÁªòÂà∂Ëä¶ËãáÊ£íÔºàÊ§≠ÂúÜÂΩ¢ÁöÑÁ©óÁä∂ÁªìÊûÑÔºâ
        ctx.fillStyle = reedBend.topColor;
        
        // Ê†πÊçÆËä¶ËãáÁ±ªÂûãÁªòÂà∂‰∏çÂêåÂΩ¢Áä∂ÁöÑËä¶ËãáÊ£í
        switch(reedType) {
            case 0: // ÊôÆÈÄöÁªÜËä¶Ëãá - ÁÆÄÂçïÁöÑÊ§≠ÂúÜ
                ctx.beginPath();
                ctx.ellipse(reedX, reedY, topSize/2, topSize, 0, 0, Math.PI * 2);
                ctx.fill();
                break;
            case 1: // Á≤óËä¶Ëãá - ËæÉÂ§ßÁöÑÊ§≠ÂúÜ
                ctx.beginPath();
                ctx.ellipse(reedX, reedY, topSize/1.5, topSize*1.2, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Ê∑ªÂä†‰∏Ä‰∫õÁ∫πÁêÜ
                ctx.fillStyle = '#B8860B';
                for (let j = 0; j < 3; j++) {
                    const angle = (j / 3) * Math.PI * 2;
                    const offsetX = Math.cos(angle) * (topSize/3);
                    const offsetY = Math.sin(angle) * (topSize/1.5);
                    ctx.beginPath();
                    ctx.arc(reedX + offsetX, reedY + offsetY, 1, 0, Math.PI * 2);
                    ctx.fill();
                }
                break;
            case 2: // ÁªÜÈïøËä¶Ëãá - ÁªÜÈïøÁöÑÊ§≠ÂúÜ
                ctx.beginPath();
                ctx.ellipse(reedX, reedY, topSize/3, topSize*1.3, 0, 0, Math.PI * 2);
                ctx.fill();
                break;
            case 3: // ÂºØÊõ≤ÊòéÊòæÁöÑËä¶Ëãá - Ê§≠ÂúÜÂΩ¢
                ctx.beginPath();
                ctx.ellipse(reedX, reedY, topSize/2, topSize*0.8, 0, 0, Math.PI * 2);
                ctx.fill();
                break;
            case 4: // ÁüÆËä¶Ëãá - Â∞èÂúÜÂΩ¢
                ctx.beginPath();
                ctx.arc(reedX, reedY, topSize, 0, Math.PI * 2);
                ctx.fill();
                break;
            case 5: // È°∂ÈÉ®ÊúâÂºØÊõ≤ÁöÑËä¶Ëãá - Ê§≠ÂúÜ
                ctx.beginPath();
                ctx.ellipse(reedX, reedY, topSize/2, topSize*0.9, topBendAmount * 0.1, 0, Math.PI * 2);
                ctx.fill();
                break;
            default:
                ctx.beginPath();
                ctx.arc(reedX, reedY, topSize, 0, Math.PI * 2);
                ctx.fill();
        }
        
        // Ê∑ªÂä†‰∏Ä‰∫õÁªÜËäÇÔºöËä¶ËãáËäÇ
        if (reedType !== 4) {
            const jointCount = 2 + (i % 3);
            
            for (let j = 1; j <= jointCount; j++) {
                const jointY = reedY + reedHeight * (j / (jointCount + 1));
                const jointSize = reedBend.reedWidth * 0.7;
                
                ctx.fillStyle = '#654321';
                ctx.beginPath();
                ctx.arc(reedX, jointY, jointSize, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    }
}

function drawMountains() {
    const isNightMode = gameMode === 'night' || (gameMode === 'normal' && !isDaytime);
    
    ctx.fillStyle = !isNightMode ? '#4682B4' : '#2F4F4F';
    ctx.strokeStyle = !isNightMode ? '#FFFFFF' : '#1E1E1E';
    ctx.lineWidth = 4;
    
    ctx.beginPath();
    ctx.moveTo(-50, GAME_HEIGHT * 0.7);
    ctx.lineTo(200, GAME_HEIGHT * 0.5);
    ctx.lineTo(450, GAME_HEIGHT * 0.7);
    ctx.lineTo(-50, GAME_HEIGHT * 0.7);
    ctx.fill();
    ctx.stroke();
    
    ctx.beginPath();
    ctx.moveTo(300, GAME_HEIGHT * 0.75);
    ctx.lineTo(600, GAME_HEIGHT * 0.55);
    ctx.lineTo(900, GAME_HEIGHT * 0.75);
    ctx.lineTo(300, GAME_HEIGHT * 0.75);
    ctx.fill();
    ctx.stroke();
    
    ctx.beginPath();
    ctx.moveTo(700, GAME_HEIGHT * 0.8);
    ctx.lineTo(1000, GAME_HEIGHT * 0.6);
    ctx.lineTo(1300, GAME_HEIGHT * 0.8);
    ctx.lineTo(700, GAME_HEIGHT * 0.8);
    ctx.fill();
    ctx.stroke();
    
    ctx.strokeStyle = !isNightMode ? '#2F4F4F' : '#1E1E1E';
    ctx.lineWidth = 1;
    
    for (let i = 0; i < 5; i++) {
        const x = 50 + i * 80;
        ctx.beginPath();
        ctx.moveTo(x, GAME_HEIGHT * 0.7);
        ctx.lineTo(200, GAME_HEIGHT * 0.5 + i * 10);
        ctx.stroke();
    }
    
    for (let i = 0; i < 5; i++) {
        const x = 400 + i * 80;
        ctx.beginPath();
        ctx.moveTo(x, GAME_HEIGHT * 0.75);
        ctx.lineTo(600, GAME_HEIGHT * 0.55 + i * 10);
        ctx.stroke();
    }
}

function drawClouds() {
    const isNightMode = gameMode === 'night' || (gameMode === 'normal' && !isDaytime);
    if (isNightMode) return;
    
    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
    ctx.beginPath();
    ctx.arc(200, 100, 30, 0, Math.PI * 2);
    ctx.arc(240, 90, 40, 0, Math.PI * 2);
    ctx.arc(280, 100, 30, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.beginPath();
    ctx.arc(600, 150, 25, 0, Math.PI * 2);
    ctx.arc(640, 140, 35, 0, Math.PI * 2);
    ctx.arc(680, 150, 25, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.beginPath();
    ctx.arc(1000, 80, 30, 0, Math.PI * 2);
    ctx.arc(1040, 70, 40, 0, Math.PI * 2);
    ctx.arc(1080, 80, 30, 0, Math.PI * 2);
    ctx.fill();
}

// ÂàùÂßãÂåñÂõ∫ÂÆöÊòüÊòü
function initStars() {
    stars = [];
    for (let i = 0; i < STARS_COUNT; i++) {
        stars.push({
            x: Math.random() * GAME_WIDTH,
            y: Math.random() * (GAME_HEIGHT * 0.5),
            size: Math.random() * 2 + 0.5,
            alpha: 0.5 + Math.random() * 0.3, // ÈöèÊú∫ÈÄèÊòéÂ∫¶
            twinkleSpeed: 0.5 + Math.random() * 1.5, // Èó™ÁÉÅÈÄüÂ∫¶
            twinkleOffset: Math.random() * Math.PI * 2 // Èó™ÁÉÅÂÅèÁßª
        });
    }
}

// ‰øÆÊîπÂêéÁöÑdrawStarsÂáΩÊï∞
function drawStars() {
    const isNightMode = gameMode === 'night' || (gameMode === 'normal' && !isDaytime);
    if (!isNightMode) return;
    
    stars.forEach(star => {
        // Âü∫‰∫éÊó∂Èó¥ÁöÑÈó™ÁÉÅÊïàÊûú
        const twinkle = 0.6 + 0.4 * Math.sin(gameTime * 0.002 * star.twinkleSpeed + star.twinkleOffset);
        
        // ÁªòÂà∂ÊòüÊòü‰∏ª‰Ωì
        ctx.fillStyle = `rgba(255, 255, 255, ${star.alpha * twinkle})`;
        ctx.beginPath();
        ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
        ctx.fill();
        
        // Ê∑ªÂä†ÂæÆÂ∞èÁöÑÂÖâÊôïÊïàÊûúÔºàÂèØÈÄâÔºâ
        if (twinkle > 0.8) {
            ctx.fillStyle = `rgba(255, 255, 255, ${0.2 * (twinkle - 0.8)})`;
            ctx.beginPath();
            ctx.arc(star.x, star.y, star.size * 1.5, 0, Math.PI * 2);
            ctx.fill();
        }
    });
}

function drawLittleOwl(bird) {
    const baseSize = 20;
    const birdSize = baseSize * bird.size;
    
    ctx.save();
    
    ctx.fillStyle = "#D2B48C";
    ctx.beginPath();
    ctx.arc(bird.x, bird.y, birdSize/2, 0, Math.PI * 2);
    ctx.fill();
    
    let eyeRingColor = "#FFFFFF";
    let eyeColor = "#000000";
    
    if (bird.isNight) {
        eyeRingColor = "#FFFF99";
        eyeColor = "#FFFF99";
    }
    
    ctx.fillStyle = eyeRingColor;
    ctx.beginPath();
    ctx.arc(bird.x - 8, bird.y - 5, 4.2, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(bird.x + 8, bird.y - 5, 4.2, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = eyeColor;
    ctx.beginPath();
    ctx.arc(bird.x - 8, bird.y - 5, 2.1, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(bird.x + 8, bird.y - 5, 2.1, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = "#8B4513";
    ctx.beginPath();
    ctx.moveTo(bird.x - 3, bird.y + 5);
    ctx.lineTo(bird.x + 3, bird.y + 5);
    ctx.lineTo(bird.x, bird.y + 10);
    ctx.closePath();
    ctx.fill();
    
    ctx.strokeStyle = "#8B4513";
    ctx.lineWidth = 1;
    for (let i = 0; i < 6; i++) {
        const angle = (i * Math.PI * 2) / 6;
        const startX = bird.x + Math.cos(angle) * (birdSize/2 - 5);
        const startY = bird.y + Math.sin(angle) * (birdSize/2 - 5);
        const endX = bird.x + Math.cos(angle) * (birdSize/2 - 2);
        const endY = bird.y + Math.sin(angle) * (birdSize/2 - 2);
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(endX, endY);
        ctx.stroke();
    }
    
    ctx.restore();
}

function drawBat(bird) {
    const baseSize = 20;
    const birdSize = baseSize * bird.size;
    
    ctx.save();
    
    bird.wingFlapTimer += bird.wingFlapSpeed;
    const wingFlapOffset = Math.sin(bird.wingFlapTimer) * 5;
    
    const x = bird.x;
    const y = bird.y;
    
    const bodyWidth = 10;
    const bodyHeight = 6;
    
    ctx.fillStyle = "#333333";
    ctx.beginPath();
    ctx.ellipse(x, y, bodyWidth/2, bodyHeight/2, 0, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = "#333333";
    const headSize = 4;
    ctx.beginPath();
    ctx.moveTo(x + bodyWidth/2, y);
    ctx.lineTo(x + bodyWidth/2 + headSize, y - headSize/2);
    ctx.lineTo(x + bodyWidth/2 + headSize, y + headSize/2);
    ctx.closePath();
    ctx.fill();
    
    ctx.fillStyle = "#000000";
    ctx.beginPath();
    ctx.arc(x + bodyWidth/2 + headSize/2, y - headSize/4, 1, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(x + bodyWidth/2 + headSize/2, y + headSize/4, 1, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = "#666666";
    const wingLength = 15;
    const wingHeight = 8 + wingFlapOffset;
    
    const leftWingX = x - bodyWidth/2 - wingLength;
    const leftWingY = y - wingHeight/2;
    ctx.fillRect(leftWingX, leftWingY, wingLength, wingHeight);
    
    const rightWingX = x + bodyWidth/2;
    const rightWingY = y - wingHeight/2;
    ctx.fillRect(rightWingX, rightWingY, wingLength, wingHeight);
    
    ctx.restore();
}

function drawOwlBird(bird) {
    const baseSize = 20;
    const birdSize = baseSize * bird.size;
    
    ctx.save();
    drawOwlFrontNew(bird);
    
    if (bird.caughtPrey) {
        drawOwlPrey(bird);
    }
    
    ctx.restore();
}

function drawOwlFrontNew(bird) {
  const baseSize = 20;
  const birdSize = baseSize * bird.size;
  let bodyDiameter, headRadius, bodyRadius;
  
  if (bird.name === "ÈõïÈ∏Æ") {
    headRadius = birdSize * 0.4 * 1.2;
    bodyDiameter = headRadius * 1.1 * 2;
    bodyRadius = bodyDiameter / 2;
  } else if (bird.name === "Áü≠ËÄ≥È∏Æ") {
    // ‰øÆÊîπÔºöÂ∞ÜÁü≠ËÄ≥È∏ÆÁöÑÂ§¥ÈÉ®Â¢ûÂ§ßËá≥‰∏éË∫´‰Ωì‰∏ÄÊ†∑
    // ÂÖàËÆ°ÁÆóË∫´‰ΩìÂçäÂæÑ
    bodyRadius = birdSize * 0.4 * 1.3;
    bodyDiameter = bodyRadius * 2;
    // Â§¥ÈÉ®ÂçäÂæÑ‰∏éË∫´‰ΩìÂçäÂæÑÁõ∏Âêå
    headRadius = bodyRadius;
  } else {
    bodyDiameter = birdSize * 0.8 * 1.2;
    headRadius = bodyDiameter / 2 * 0.8 * 1.2;
    bodyRadius = bodyDiameter / 2;
  }
  
  // ËÆ°ÁÆóÂü∫Á°ÄÁøÖËÜÄÈ´òÂ∫¶
  let wingHeight = bodyDiameter * 0.25 * 2;
  const wingLength = bodyDiameter * 3 * 0.5;
  
  // ‰øÆÊîπÔºöÁü≠ËÄ≥È∏ÆÁöÑÁøÖËÜÄÈ´òÂ∫¶ÂáèÂ∞ë1/5
  if (bird.name === "Áü≠ËÄ≥È∏Æ") {
    wingHeight = wingHeight * 0.8; // ÂáèÂ∞ë1/5ÔºåÂç≥ÂéüÊù•ÁöÑ80%
  }
  
  ctx.save();
  const x = bird.x;
  const y = bird.y;
  
  let bodyCenterX = x;
  let bodyCenterY = y;
  let headCenterX = x;
  let headCenterY;
  
  if (bird.name === "ÈõïÈ∏Æ") {
    headCenterY = y;
  } else if (bird.name === "Áü≠ËÄ≥È∏Æ") {
    headCenterY = y;
    bodyCenterY = y;
  } else {
    headCenterY = y - bodyRadius * 0.3;
    bodyCenterY = y;
  }
  
  // ÁªòÂà∂Ë∫´‰Ωì
  if (bird.name === "ÈõïÈ∏Æ") {
    ctx.fillStyle = "#666666";
  } else if (bird.name === "Áü≠ËÄ≥È∏Æ") {
    ctx.fillStyle = "#FFFFFF";
  } else {
    ctx.fillStyle = bird.type.bodyColor;
  }
  
  ctx.beginPath();
  ctx.arc(bodyCenterX, bodyCenterY, bodyRadius, 0, Math.PI * 2);
  ctx.fill();
  
  // ÁªòÂà∂ÁøÖËÜÄ
  ctx.fillStyle = bird.type.wingColor;
  const leftWingX = bodyCenterX - bodyRadius - wingLength;
  const leftWingY = bodyCenterY - bodyRadius + (bird.wingOffset || 0) * bodyDiameter;
  ctx.fillRect(leftWingX, leftWingY, wingLength, wingHeight);
  
  const rightWingX = bodyCenterX + bodyRadius;
  const rightWingY = bodyCenterY - bodyRadius + (bird.wingOffset || 0) * bodyDiameter;
  ctx.fillRect(rightWingX, rightWingY, wingLength, wingHeight);
  
  // ÁªòÂà∂Â§¥ÈÉ®
  ctx.fillStyle = bird.type.headColor;
  ctx.beginPath();
  ctx.arc(headCenterX, headCenterY, headRadius, 0, Math.PI * 2);
  ctx.fill();
  
  // ‰øÆÊîπÔºöÈáçÊñ∞ËÆ°ÁÆóÁúºÁùõÂçäÂæÑÔºàÂü∫‰∫éÁº©Â∞è1/4ÂêéÁöÑÂ§¥ÈÉ®ÂçäÂæÑÔºâ
  const originalEyeRadius = headRadius * 0.2 * 1.2;
  const smallEyeRadius = originalEyeRadius * 0.75; // Áº©Â∞è1/4
  
  const eyeSpacing = headRadius * 0.4;
  const eyeY = headCenterY - headRadius * 0.1;
  
// === Áü≠ËÄ≥È∏ÆÁöÑÁúºÁùõÂíåÁúºÂë®Áü©ÂΩ¢ÊïàÊûúÔºàÂú®ÁôΩËâ≤Ë¶ÜÁõñÂ±Ç‰πãÂâçÔºâ===
if (bird.name === "Áü≠ËÄ≥È∏Æ" && bird.type.blackEyeRing) {
  // ‰øÆÊîπÔºö‰ΩøÁî®Êñ∞ÁöÑÂ§¥ÈÉ®ÂçäÂæÑËÆ°ÁÆóÈªëËâ≤ÁúºÁéØ
  const outerRadius = headRadius * 1.15 * 1.2;
  const innerRadius = headRadius * 0.8;
  const headGradient = ctx.createRadialGradient(
    headCenterX, headCenterY, innerRadius * 0.5,
    headCenterX, headCenterY, outerRadius
  );
  // ‰øÆÊîπÔºöÈôç‰ΩéÁôΩËâ≤Ê∏êÂèòÁöÑÈÄèÊòéÂ∫¶
  headGradient.addColorStop(0, 'rgba(255, 255, 255, 0.60)'); // Èôç‰ΩéÂà∞60%ÈÄèÊòéÂ∫¶
  headGradient.addColorStop(0.4, 'rgba(240, 240, 240, 0.50)'); // Èôç‰ΩéÂà∞50%ÈÄèÊòéÂ∫¶
  headGradient.addColorStop(0.8, 'rgba(220, 220, 220, 0.40)'); // Èôç‰ΩéÂà∞40%ÈÄèÊòéÂ∫¶
  headGradient.addColorStop(1, 'rgba(200, 200, 200, 0.30)'); // Èôç‰ΩéÂà∞30%ÈÄèÊòéÂ∫¶
  ctx.fillStyle = headGradient;
  ctx.beginPath();
  ctx.arc(headCenterX, headCenterY, outerRadius, 0, Math.PI * 2);
  ctx.fill();
  
  // ÁªòÂà∂ÈªÑËâ≤ÁúºÁùõ
  ctx.fillStyle = bird.type.eyeColor; // #FFFF99 ÈªÑËâ≤
  ctx.beginPath();
  ctx.arc(headCenterX - eyeSpacing, eyeY, smallEyeRadius, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(headCenterX + eyeSpacing, eyeY, smallEyeRadius, 0, Math.PI * 2);
  ctx.fill();
}
  
  // === ÈõïÈ∏ÆÁöÑÁúºÁùõÔºàÂú®ÁôΩËâ≤Ë¶ÜÁõñÂ±Ç‰πãÂâçÔºâ===
  if (bird.name === "ÈõïÈ∏Æ") {
    // ‰øÆÊîπÔºö‰ΩøÁî®Áº©Â∞èÂêéÁöÑÁúºÁùõÂçäÂæÑ
    ctx.fillStyle = bird.type.eyeColor;
    ctx.beginPath();
    ctx.arc(headCenterX - eyeSpacing, eyeY, smallEyeRadius, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(headCenterX + eyeSpacing, eyeY, smallEyeRadius, 0, Math.PI * 2);
    ctx.fill();
  }
  
  // === ÂñôÈÉ®ÔºàÂú®ÁôΩËâ≤Ë¶ÜÁõñÂ±Ç‰πãÂâçÔºâ===
  ctx.fillStyle = "#8B4513";
  const beakWidth = originalEyeRadius * 1.5; // ‰ΩøÁî®ÂéüÂßãÁúºÁùõÂçäÂæÑËÆ°ÁÆóÂñôÈÉ®Â§ßÂ∞è
  const beakHeight = originalEyeRadius * 1.2; // ‰ΩøÁî®ÂéüÂßãÁúºÁùõÂçäÂæÑËÆ°ÁÆóÂñôÈÉ®Â§ßÂ∞è
  const beakY = headCenterY + originalEyeRadius * 0.5; // ‰ΩøÁî®ÂéüÂßãÁúºÁùõÂçäÂæÑËÆ°ÁÆóÂñôÈÉ®‰ΩçÁΩÆ
  ctx.beginPath();
  ctx.moveTo(headCenterX - beakWidth/2, beakY);
  ctx.lineTo(headCenterX + beakWidth/2, beakY);
  ctx.lineTo(headCenterX, beakY + beakHeight);
  ctx.closePath();
  ctx.fill();
  
  // ÈõïÈ∏ÆÁöÑËÄ≥Á∞áÁæΩ
  if (bird.name === "ÈõïÈ∏Æ") {
    const earLength = headRadius * 0.8;
    const earWidth = headRadius * 0.3;
    
    ctx.save();
    ctx.translate(headCenterX, headCenterY - headRadius * 0.5);
    ctx.rotate(-Math.PI/4);
    ctx.fillStyle = bird.type.headColor;
    ctx.beginPath();
    ctx.ellipse(0, -earLength/2, earWidth/2, earLength/2, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
    
    ctx.save();
    ctx.translate(headCenterX, headCenterY - headRadius * 0.5);
    ctx.rotate(Math.PI/4);
    ctx.fillStyle = bird.type.headColor;
    ctx.beginPath();
    ctx.ellipse(0, -earLength/2, earWidth/2, earLength/2, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
  
  // === Áü≠ËÄ≥È∏ÆÁöÑÁúºÁùõÔºàÂú®ÁôΩËâ≤Ë¶ÜÁõñÂ±Ç‰πãÂâçÔºâ===
  if (bird.name === "Áü≠ËÄ≥È∏Æ") {
    // ‰øÆÊîπÔºö‰ΩøÁî®Áº©Â∞èÂêéÁöÑÁúºÁùõÂçäÂæÑ
    ctx.fillStyle = bird.type.eyeColor;
    ctx.beginPath();
    ctx.arc(headCenterX - eyeSpacing, eyeY, smallEyeRadius, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(headCenterX + eyeSpacing, eyeY, smallEyeRadius, 0, Math.PI * 2);
    ctx.fill();
  }
  
  // === ‰∏∫ÈõïÈ∏ÆÂíåÁü≠ËÄ≥È∏ÆÁöÑÊ≠£Èù¢ËÑ∏ÈÉ®Ê∑ªÂä†30%ÈÄèÊòéÂ∫¶ÁöÑ#FCFCFCË¶ÜÁõñÂ±ÇÔºàË¶ÜÁõñÂ§¥ÈÉ®ÂíåÁøÖËÜÄÔºâ===
  if (bird.name === "ÈõïÈ∏Æ" || bird.name === "Áü≠ËÄ≥È∏Æ") {
    // ‰øùÂ≠òÂΩìÂâçÁªòÂõæÁä∂ÊÄÅ
    ctx.save();
    
    // 1. È¶ñÂÖàÁªòÂà∂ÁøÖËÜÄÁöÑË¶ÜÁõñÂ±Ç
    ctx.fillStyle = 'rgba(252, 252, 252, 0.3)';
    
    // Â∑¶‰æßÁøÖËÜÄË¶ÜÁõñ
    ctx.fillRect(leftWingX, leftWingY, wingLength, wingHeight);
    
    // Âè≥‰æßÁøÖËÜÄË¶ÜÁõñ
    ctx.fillRect(rightWingX, rightWingY, wingLength, wingHeight);
    
    // 2. ÁÑ∂ÂêéÁªòÂà∂Â§¥ÈÉ®ÁöÑË¶ÜÁõñÂ±Ç
    const overlayGradient = ctx.createRadialGradient(
      headCenterX, headCenterY, headRadius * 0.5,
      headCenterX, headCenterY, headRadius
    );
    
    if (bird.name === "ÈõïÈ∏Æ") {
      overlayGradient.addColorStop(0, 'rgba(252, 252, 252, 0.25)');
      overlayGradient.addColorStop(0.7, 'rgba(252, 252, 252, 0.30)');
      overlayGradient.addColorStop(1, 'rgba(252, 252, 252, 0.35)');
    } else {
      overlayGradient.addColorStop(0, 'rgba(252, 252, 252, 0.20)');
      overlayGradient.addColorStop(0.7, 'rgba(252, 252, 252, 0.25)');
      overlayGradient.addColorStop(1, 'rgba(252, 252, 252, 0.30)');
    }
    
    ctx.fillStyle = overlayGradient;
    ctx.beginPath();
    ctx.arc(headCenterX, headCenterY, headRadius, 0, Math.PI * 2);
    ctx.fill();
    
    // ÊÅ¢Â§çÁªòÂõæÁä∂ÊÄÅ
    ctx.restore();
  }
  
  ctx.restore();
}

function drawOwlPrey(bird) {
    if (!bird.caughtPrey) return;
    
    ctx.save();
    const prey = bird.caughtPrey;
    const preyX = bird.x + (bird.direction === 1 ? 30 : -30);
    const preyY = bird.y + 20;
    
    if (prey.type === "mouse") {
        ctx.fillStyle = "#D3D3D3";
        const bodyWidth = 10;
        const bodyHeight = 6;
        ctx.beginPath();
        ctx.ellipse(preyX, preyY, bodyWidth/2, bodyHeight/2, 0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = "#D3D3D3";
        const headSize = 4;
        ctx.beginPath();
        ctx.moveTo(preyX + bodyWidth/2, preyY);
        ctx.lineTo(preyX + bodyWidth/2 + headSize, preyY - headSize/2);
        ctx.lineTo(preyX + bodyWidth/2 + headSize, preyY + headSize/2);
        ctx.closePath();
        ctx.fill();
        
        ctx.fillStyle = "#000000";
        ctx.beginPath();
        ctx.arc(preyX + bodyWidth/2 + headSize/2, preyY - headSize/4, 1, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(preyX + bodyWidth/2 + headSize/2, preyY + headSize/4, 1, 0, Math.PI * 2);
        ctx.fill();
    } else if (prey.type === "hedgehog") {
        ctx.fillStyle = "#A0522D";
        const bodySize = 8;
        ctx.beginPath();
        ctx.arc(preyX, preyY, bodySize, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = "#A0522D";
        ctx.beginPath();
        ctx.moveTo(preyX + bodySize, preyY);
        ctx.lineTo(preyX + bodySize * 1.5, preyY - bodySize * 0.5);
        ctx.lineTo(preyX + bodySize * 1.5, preyY + bodySize * 0.5);
        ctx.closePath();
        ctx.fill();
        
        ctx.strokeStyle = "#8B4513";
        ctx.lineWidth = 2;
        ctx.lineCap = "round";
        for (let i = 0; i < 24; i++) {
            const angle = (i / 24) * Math.PI * 2;
            const length = 3 + Math.random() * 1.5;
            const startX = preyX + Math.cos(angle) * bodySize;
            const startY = preyY + Math.sin(angle) * bodySize;
            const endX = preyX + Math.cos(angle) * (bodySize + length);
            const endY = preyY + Math.sin(angle) * (bodySize + length);
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.stroke();
        }
        
        ctx.fillStyle = "#000000";
        ctx.beginPath();
        ctx.arc(preyX + bodySize * 1.2, preyY - bodySize * 0.2, 1, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = "#000000";
        ctx.beginPath();
        ctx.arc(preyX + bodySize * 1.5, preyY, 0.8, 0, Math.PI * 2);
        ctx.fill();
    }
    
    ctx.restore();
}

function drawOwl(bird) {
  const baseSize = 20;
  const birdSize = baseSize * bird.size;
  ctx.save();
  
  // Ê†πÊçÆÊòØÂê¶ÊòØÂ§úÈó¥ÈÄâÊã©ÁúºÁùõÈ¢úËâ≤
  let eyeColor = bird.isNight ? "#FFFF99" : "#FFA500"; // Â§úÈó¥‰∫ÆÈªÑËâ≤ÔºåÊó•Èó¥Ê©ôÈªÑËâ≤
  
  ctx.fillStyle = "#8B4513";
  ctx.beginPath();
  ctx.arc(bird.x, bird.y, birdSize/2, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.fillStyle = eyeColor;
  ctx.beginPath();
  ctx.arc(bird.x - 8, bird.y - 5, 4, 0, Math.PI * 2);
  ctx.arc(bird.x + 8, bird.y - 5, 4, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.fillStyle = "#FFFF00";
  ctx.beginPath();
  ctx.moveTo(bird.x - 3, bird.y + 5);
  ctx.lineTo(bird.x + 3, bird.y + 5);
  ctx.lineTo(bird.x, bird.y + 10);
  ctx.closePath();
  ctx.fill();
  
  ctx.fillStyle = "#8B4513";
  ctx.beginPath();
  ctx.moveTo(bird.x - 8, bird.y - birdSize/2 - 16);
  ctx.lineTo(bird.x - 12, bird.y - birdSize/2 + 20 - 16);
  ctx.lineTo(bird.x - 4, bird.y - birdSize/2 + 15 - 16);
  ctx.closePath();
  ctx.fill();
  
  ctx.beginPath();
  ctx.moveTo(bird.x + 8, bird.y - birdSize/2 - 16);
  ctx.lineTo(bird.x + 12, bird.y - birdSize/2 + 20 - 16);
  ctx.lineTo(bird.x + 4, bird.y - birdSize/2 + 15 - 16);
  ctx.closePath();
  ctx.fill();
  
  ctx.restore();
}

function drawBird(bird) {
    ctx.save();
    
    // ‚úÖ Áªü‰∏ÄÂ§ÑÁêÜÂêëÂ∑¶È£ûË°åÁöÑÈïúÂÉè
    if (bird.direction === -1 && bird.state !== 'perching') {
        ctx.translate(bird.x * 2, 0);
        ctx.scale(-1, 1);
    }
  // Ê£ÄÊü•ÊòØÂê¶‰∏∫Áø†È∏ü
  if (bird.isKingfisher) {
    drawKingfisher(bird);
        ctx.restore();
    return;
  }
    if (bird.name === "Â∞èÈ∏Æ") {
        drawLittleOwl(bird);
        ctx.restore();
        return;
    }
    
    if (bird.isBat) {
        drawBat(bird);
        ctx.restore();
        return;
    }
    
    if (bird.isOwl) {
        drawOwlBird(bird);
        ctx.restore();
        return;
    }
    
    if ((bird.name === "ÂïÑÊú®È∏ü" || bird.name === "Â§úÈπ≠") && bird.state === 'perching') {
        drawPerchingWoodpeckerOrHeron(bird);
        ctx.restore();
        return;
    }
    
    if (bird.name === "Êà¥Ëèä" && bird.state === 'perching' && bird.riceBallAppearance) {
        drawRiceBallBird(bird);
        ctx.restore();
        return;
    }
    
// Êñ∞Â¢ûÔºöÈïøÂ∞æÈõÄ„ÄÅËú°Âò¥ÈõÄ„ÄÅÁáïÈõÄ„ÄÅÁΩóÂÆæÁöÑÁâπÊÆäÁªòÂà∂
  if (bird.name === "ÈïøÂ∞æÈõÄ") {
    drawLongtailedFinch(bird);
    ctx.restore();
    return;
  } else if (bird.name === "Ëú°Âò¥ÈõÄ") {
    drawHawfinch(bird);
    ctx.restore();
    return;
  } else if (bird.name === "ÁáïÈõÄ") {
    drawBrambling(bird);
    ctx.restore();
    return;
  } else if (bird.name === "ÁΩóÂÆæ") {
    drawRobin(bird);
    ctx.restore();
    return;
  }

    if ((bird.name === "Á∫¢Èöº" || bird.name === "ÈªëÁøÖÈ∏¢") && bird.caughtMouse) {
        drawMouseInClaws(bird);
    }
    
    if (bird.name === "ÈïøËÄ≥È∏Æ" && bird.faceScreen) {
        drawOwl(bird);
        ctx.restore();
        return;
    }
    
    const baseSize = 20;
    let birdSize = baseSize * bird.size;
    const headSize = birdSize * 0.5;
    const bodySize = birdSize;
    
    ctx.save();
    
    let headOffsetY = 0;
    if (bird.isEating && bird.eatAnimationOffset) {
        headOffsetY = bird.eatAnimationOffset;
    }
    
    // Internal flip removed (handled globally)
    
    let bodyColor = bird.type.bodyColor;
    let headColor = bird.type.headColor;
    let wingColor = bird.type.wingColor;
    let tailColor = bird.type.tailColor;
    
    if (bird.name === "Â§úÈπ≠" && bird.isNight) {
        bodyColor = bird.nightBodyColor || "#808080";
        headColor = bird.nightBodyColor || "#808080";
        wingColor = bird.nightWingColor || "#4682B4";
        tailColor = bird.nightBodyColor || "#808080";
    } else if (bird.name !== "ÁªøÂ§¥È∏≠") {
        if (bodyColor === "#00AA00") bodyColor = "#90EE90";
        if (headColor === "#00AA00") headColor = "#90EE90";
        if (wingColor === "#00AA00") wingColor = "#90EE90";
        if (tailColor === "#00AA00") tailColor = "#90EE90";
    }
    
    if (bird.type.variant && bird.variant !== undefined) {
        if (bird.name === "ÁªøÂ§¥È∏≠") {
            if (bird.variant) {
                bodyColor = "#8B4513";
                headColor = "#8B4513";
                wingColor = "#8B4513";
            } else {
                bodyColor = "#FFFFFF";
                headColor = "#00AA00";
                wingColor = "#FF0000";
            }
        } else if (bird.name === "Â±±Ê§íÈ∏ü") {
            bodyColor = bird.variant ? "#FFFF00" : "#FF0000";
        }
    }
    
    ctx.fillStyle = bodyColor;
    ctx.beginPath();
    ctx.arc(bird.x, bird.y, bodySize/2, 0, Math.PI * 2);
    ctx.fill();
    
    if (bird.name === "ÁôΩÈπ°È∏∞" && bird.hasHeart) {
        const heartX = bird.x;
        const heartY = bird.y - birdSize/6;
        const heartSize = 5;
        
        ctx.fillStyle = "#000000";
        ctx.save();
        ctx.translate(heartX, heartY);
        ctx.scale(1, 0.8);
        ctx.beginPath();
        ctx.moveTo(0, -heartSize/2);
        ctx.bezierCurveTo(
            heartSize/2, -heartSize/2,
            heartSize/2, heartSize/2,
            0, heartSize/2
        );
        ctx.bezierCurveTo(
            -heartSize/2, heartSize/2,
            -heartSize/2, -heartSize/2,
            0, -heartSize/2
        );
        ctx.fill();
        ctx.restore();
    }
    
    ctx.fillStyle = headColor || '#000000';
    ctx.beginPath();
    ctx.arc(
        bird.x + bodySize/2 - headSize/2,
        bird.y - bodySize/2 + headSize/2 + headOffsetY,
        headSize/2, 0, Math.PI * 2
    );
    ctx.fill();
    
    ctx.fillStyle = bird.type.color || '#000000';
    ctx.beginPath();
    
    const beakStartX = bird.x + bodySize/2 - headSize/2 + headSize/2;
    const beakStartY = bird.y - bodySize/2 + headSize/2 + headOffsetY;
    
    let beakLength = 8;
    let beakHeight = 5;
    
    if (bird.isEating) {
        beakHeight = 6;
        beakLength = 9;
    }
    
    if (bird.name === "Â∞èÂåó" && bird.fifthBeak) {
        beakLength = 1.6;
        beakHeight = 1;
        ctx.moveTo(beakStartX, beakStartY);
        ctx.lineTo(beakStartX + beakLength, beakStartY);
        ctx.lineTo(beakStartX, beakStartY + beakHeight);
    } else if (bird.name === "ÁªøÂ§¥È∏≠" && bird.doubleBeak) {
        if (bird.beakOnePointFive) {
            beakLength = 8 * 1.5;
        } else {
            beakLength = 16;
        }
        beakHeight = 4;
        ctx.fillRect(beakStartX, beakStartY - beakHeight/2, beakLength, beakHeight);
    } else if (bird.name === "Ëµ§È∫ªÈ∏≠" && bird.beakOnePointThree) {
        beakLength = 8 * 1.3;
        beakHeight = 4;
        ctx.fillRect(beakStartX, beakStartY - beakHeight/2, beakLength, beakHeight);
    } else if (bird.name === "È∫ªÈõÄ") {
        beakLength = 4;
        beakHeight = 3;
        ctx.moveTo(beakStartX, beakStartY);
        ctx.lineTo(beakStartX + beakLength, beakStartY);
        ctx.lineTo(beakStartX, beakStartY + beakHeight);
    } else if (bird.name === "Â§úÈπ≠") {
        beakLength = 24;
        beakHeight = 6;
        ctx.moveTo(beakStartX, beakStartY);
        ctx.lineTo(beakStartX + beakLength, beakStartY);
        ctx.lineTo(beakStartX, beakStartY + beakHeight);
    } else if (bird.name === "ÂïÑÊú®È∏ü" && bird.doubleBeak) {
        beakLength = 8;
        beakHeight = 5;
        ctx.moveTo(beakStartX, beakStartY);
        ctx.lineTo(beakStartX + beakLength, beakStartY);
        ctx.lineTo(beakStartX, beakStartY + beakHeight);
    } else if (bird.name === "Êà¥ËÉú" && bird.beakOnePointFive) {
        beakLength = 8 * 1.5;
        beakHeight = 5;
        ctx.moveTo(beakStartX, beakStartY);
        ctx.lineTo(beakStartX + beakLength, beakStartY);
        ctx.lineTo(beakStartX, beakStartY + beakHeight);
    } else if (bird.name === "Êà¥Ëèä" && bird.state !== 'perching' && bird.halfBeakFlying) {
        beakLength = 4 * 0.5;
        beakHeight = 3;
        ctx.moveTo(beakStartX, beakStartY);
        ctx.lineTo(beakStartX + beakLength, beakStartY);
        ctx.lineTo(beakStartX, beakStartY + beakHeight);
    } else if (bird.name === "Â±±ÈõÄ" && bird.halfBeak) {
        beakLength = 4;
        beakHeight = 3;
        ctx.moveTo(beakStartX, beakStartY);
        ctx.lineTo(beakStartX + beakLength, beakStartY);
        ctx.lineTo(beakStartX, beakStartY + beakHeight);
    } else if (bird.name === "Ê£ïÂ§¥È∏¶ÈõÄ" && bird.quarterBeak) {
        beakLength = 2;
        beakHeight = 2;
        ctx.moveTo(beakStartX, beakStartY);
        ctx.lineTo(beakStartX + beakLength, beakStartY);
        ctx.lineTo(beakStartX, beakStartY + beakHeight);
    } else if (bird.name === "ÊüêÁßçÊü≥Ëé∫" && bird.halfBeak) {
        beakLength = 4;
        beakHeight = 3;
        ctx.moveTo(beakStartX, beakStartY);
        ctx.lineTo(beakStartX + beakLength, beakStartY);
        ctx.lineTo(beakStartX, beakStartY + beakHeight);
    } else if ((bird.name === "ÈáëÁú∂È∏ª" || bird.name === "12000È∏ª") && bird.beakOnePointFive) {
        beakLength = 6 * 1.5;
        beakHeight = 3;
        ctx.moveTo(beakStartX, beakStartY);
        ctx.lineTo(beakStartX + beakLength, beakStartY);
        ctx.lineTo(beakStartX, beakStartY + beakHeight);
    } else if (bird.name === "ÈáëÁøÖÈõÄ" && bird.halfBeak) {
        beakLength = 4;
        beakHeight = 3;
        ctx.moveTo(beakStartX, beakStartY);
        ctx.lineTo(beakStartX + beakLength, beakStartY);
        ctx.lineTo(beakStartX, beakStartY + beakHeight);
    } else {
        ctx.moveTo(beakStartX, beakStartY);
        ctx.lineTo(beakStartX + beakLength, beakStartY);
        ctx.lineTo(beakStartX, beakStartY + beakHeight);
    }
    
    if (!((bird.name === "ÁªøÂ§¥È∏≠" && bird.doubleBeak) || (bird.name === "Ëµ§È∫ªÈ∏≠" && bird.beakOnePointThree))) {
        ctx.closePath();
        ctx.fill();
    }
    
    const eyeColor = bird.type.eyeColor || '#000000';
    const eyeX = bird.x + bodySize/2 - headSize/2 + headSize/4;
    const eyeY = bird.y - bodySize/2 + headSize/3 + headOffsetY;
    
    if (bird.yellowEyeRing) {
        ctx.fillStyle = '#FFFF00';
        ctx.beginPath();
        ctx.arc(eyeX, eyeY, 4, 0, Math.PI * 2);
        ctx.fill();
    } else if (bird.whiteEyeRing) {
        ctx.fillStyle = '#FFFFFF';
        ctx.beginPath();
        ctx.arc(eyeX, eyeY, 3, 0, Math.PI * 2);
        ctx.fill();
    }
    
    if (bird.name === "ÊñëÈ∏†" && bird.brownEyeRing) {
        ctx.fillStyle = '#8B4513';
        ctx.beginPath();
        ctx.arc(eyeX, eyeY, 4, 0, Math.PI * 2);
        ctx.fill();
    }
    
    if (bird.name === "Â∞èÂåó") {
        ctx.fillStyle = eyeColor;
        ctx.beginPath();
        ctx.arc(eyeX, eyeY, 1, 0, Math.PI * 2);
        ctx.fill();
    } else {
        ctx.fillStyle = eyeColor;
        ctx.beginPath();
        ctx.arc(eyeX, eyeY, 2, 0, Math.PI * 2);
        ctx.fill();
    }
    
    ctx.fillStyle = wingColor || '#000000';
    ctx.fillRect(
        bird.x - bodySize/4 - headSize/2,
        bird.y - bodySize/2,
        bodySize/2,
        bodySize/3
    );
    
    if (bird.name === "ÂñúÈπä" && bird.longBlackTail) {
        ctx.fillStyle = "#000000";
        const tailWidth = 8;
        const tailLength = bodySize;
        const tailStartX = bird.x - bodySize/2;
        const tailStartY = bird.y;
        ctx.fillRect(tailStartX, tailStartY - tailWidth/2, -tailLength, tailWidth);
    } else if (bird.name === "ÁôΩÈπ°È∏∞" && bird.longBlackTail) {
        ctx.fillStyle = "#000000";
        const tailWidth = 3;
        const tailLength = 20;
        const tailStartX = bird.x - bodySize/2;
        const tailStartY = bird.y - bodySize/8;
        ctx.fillRect(tailStartX, tailStartY - tailWidth/2, -tailLength, tailWidth);
        
        ctx.fillStyle = "#000000";
        const blackLineY = tailStartY + tailWidth/2 + 1;
        ctx.fillRect(tailStartX, blackLineY, -tailLength, 1);
    } else if (bird.name === "Ê£ïÂ§¥È∏¶ÈõÄ" && bird.longBrownTail) {
        ctx.fillStyle = tailColor || "#8B4513";
        const tailWidth = 2;
        const tailLength = bodySize;
        const tailStartX = bird.x - bodySize/2;
        const tailStartY = bird.y;
        ctx.fillRect(tailStartX, tailStartY - tailWidth/2, -tailLength, tailWidth);
    } else if (bird.name === "ÈªëÁøÖÈ∏¢") {
        ctx.fillStyle = "#FFFFFF";
        const tailStartX = bird.x - bodySize/2;
        const tailStartY = bird.y - bodySize/8;
        const tailHeight = bodySize/4;
        ctx.beginPath();
        ctx.moveTo(tailStartX, tailStartY);
        ctx.lineTo(tailStartX - 8, tailStartY - tailHeight/2);
        ctx.lineTo(tailStartX - 8, tailStartY + tailHeight/2);
        ctx.lineTo(tailStartX, tailStartY);
        ctx.closePath();
        ctx.fill();
    } else if (bird.name === "ÈáëÁøÖÈõÄ") {
        ctx.fillStyle = tailColor || "#FFD700";
        const tailStartX = bird.x - bodySize/2;
        const tailStartY = bird.y - bodySize/8;
        const tailHeight = bodySize/4;
        ctx.beginPath();
        ctx.moveTo(tailStartX, tailStartY);
        ctx.lineTo(tailStartX - 8, tailStartY - tailHeight/2);
        ctx.lineTo(tailStartX - 8, tailStartY + tailHeight/2);
        ctx.lineTo(tailStartX, tailStartY);
        ctx.closePath();
        ctx.fill();
    } else if (bird.name === "ÈáëÁú∂È∏ª" || bird.name === "12000È∏ª") {
        ctx.fillStyle = tailColor || "#D2B48C";
        const tailStartX = bird.x - bodySize/2;
        const tailStartY = bird.y - bodySize/8;
        const tailHeight = bodySize/4;
        ctx.beginPath();
        ctx.moveTo(tailStartX, tailStartY);
        ctx.lineTo(tailStartX - 8, tailStartY - tailHeight/2);
        ctx.lineTo(tailStartX - 8, tailStartY + tailHeight/2);
        ctx.lineTo(tailStartX, tailStartY);
        ctx.closePath();
        ctx.fill();
    } else {
        ctx.fillStyle = tailColor || "#000000";
        const tailStartX = bird.x - bodySize/2;
        const tailStartY = bird.y - bodySize/8;
        const tailHeight = bodySize/4;
        ctx.beginPath();
        ctx.moveTo(tailStartX, tailStartY);
        ctx.lineTo(tailStartX - 8, tailStartY - tailHeight/2);
        ctx.lineTo(tailStartX - 8, tailStartY + tailHeight/2);
        ctx.lineTo(tailStartX, tailStartY);
        ctx.closePath();
        ctx.fill();
    }
    
    if (bird.hasCrest && bird.crestColor) {
        ctx.fillStyle = bird.crestColor || '#D2B48C';
        ctx.beginPath();
        const centerX = bird.x;
        const centerY = bird.y - bodySize/2;
        const radius = 10;
        const startAngle = -Math.PI/2 - Math.PI/9 - Math.PI/18;
        const endAngle = -Math.PI/2 + Math.PI/3.6 - Math.PI/18;
        
        ctx.moveTo(centerX, centerY);
        for (let i = 0; i <= 6; i++) {
            const angle = startAngle + (endAngle - startAngle) * (i / 6);
            const x = centerX + Math.cos(angle) * radius;
            const y = centerY + Math.sin(angle) * radius;
            ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.fill();
        
        for (let i = 0; i < 5; i++) {
            const pointAngle = startAngle + (endAngle - startAngle) * ((i+1)/6);
            const pointRadius = radius * 0.6;
            const pointX = centerX + Math.cos(pointAngle) * pointRadius;
            const pointY = centerY + Math.sin(pointAngle) * pointRadius;
            const pointSize = 2;
            
            if (i % 2 === 0) {
                ctx.fillStyle = "#000000";
            } else {
                ctx.fillStyle = "#FFFFFF";
            }
            
            ctx.beginPath();
            ctx.arc(pointX, pointY, pointSize, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    
    ctx.restore();
    
    if ((bird.name === "ÈªëÁøÖÈ∏¢" || bird.name === "Á∫¢Èöº") && bird.caughtMouse) {
        drawMouseInClaws(bird);
    }
    
    if (bird.name === "Ê∏∏Èöº" && bird.caughtBird) {
        ctx.save();
        ctx.fillStyle = "#A0522D";
        const preySize = 10;
        const preyX = bird.x + (bird.direction === 1 ? 20 : -20);
        const preyY = bird.y + 15;
        ctx.beginPath();
        ctx.arc(preyX, preyY, preySize, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }
    
    if (bird.name === "Á∫¢Èöº" && bird.caughtDove) {
        ctx.save();
        ctx.fillStyle = "#808080";
        const doveSize = 12;
        const doveX = bird.x + (bird.direction === 1 ? 20 : -20);
        const doveY = bird.y + 15;
        ctx.beginPath();
        ctx.arc(doveX, doveY, doveSize, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = "#A0522D";
        const wingWidth = doveSize * 0.8;
        const wingHeight = doveSize * 0.4;
        ctx.fillRect(doveX - wingWidth/2, doveY - wingHeight/2, wingWidth, wingHeight);
        ctx.restore();
    }
    
    if (bird.isEating && bird.eatingFruit) {
        const timeSinceStart = bird.eatingTime;
        const pulse = Math.sin(timeSinceStart * 0.01) * 0.5 + 0.5;
        
        ctx.save();
        ctx.fillStyle = `rgba(255, 200, 0, ${0.3 * pulse})`;
        ctx.beginPath();
        ctx.arc(
            bird.x + (bird.direction === 1 ? 30 : -30),
            bird.y - 10,
            3 + pulse * 2,
            0, Math.PI * 2
        );
        ctx.fill();
        ctx.restore();
    }
    
    ctx.restore();
}

function drawPerchingWoodpeckerOrHeron(bird) {
    const baseSize = 20;
    const birdSize = baseSize * bird.size;
    const bodySize = birdSize;
    
    ctx.save();
    
    let beakDirection = 1;
    if (bird.targetTree && bird.targetTree.side === 'right') {
        beakDirection = -1;
    }
    
    let bodyColor = bird.type.bodyColor;
    let headColor = bird.type.headColor || '#000000';
    let wingColor = bird.type.wingColor || '#000000';
    let tailColor = bird.type.tailColor || "#000000";
    
    if (bird.name === "Â§úÈπ≠" && bird.isNight) {
        bodyColor = bird.nightBodyColor || "#808080";
        headColor = bird.nightBodyColor || "#808080";
        wingColor = bird.nightWingColor || "#4682B4";
        tailColor = bird.nightBodyColor || "#808080";
    }
    
    ctx.fillStyle = bodyColor;
    ctx.beginPath();
    ctx.ellipse(bird.x, bird.y, bodySize/3, bodySize/2, 0, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = headColor;
    const headSize = bodySize * 0.4;
    const headY = bird.y - bodySize/2 - headSize/2;
    const headX = bird.x + (bird.headOffsetX || 0);
    
    ctx.beginPath();
    ctx.arc(headX, headY, headSize/2, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = bird.type.color || '#000000';
    ctx.beginPath();
    
    let beakLength = 8;
    let beakHeight = 5;
    
    if (bird.name === "Â§úÈπ≠") {
        beakLength = 24;
        beakHeight = 6;
    } else if (bird.name === "ÂïÑÊú®È∏ü" && bird.doubleBeak) {
        beakLength = 8;
        beakHeight = 5;
    }
    
    const beakStartX = headX + (headSize/2 * beakDirection);
    const beakStartY = headY;
    const beakEndX = beakStartX + beakLength * beakDirection + (bird.headOffsetX || 0);
    
    ctx.moveTo(beakStartX, beakStartY);
    ctx.lineTo(beakEndX, beakStartY);
    ctx.lineTo(beakStartX, beakStartY + beakHeight);
    ctx.closePath();
    ctx.fill();
    
    const eyeColor = bird.type.eyeColor || '#000000';
    const eyeX = headX + headSize/4 * beakDirection;
    const eyeY = headY - headSize/8;
    
    if (bird.whiteEyeRing) {
        ctx.fillStyle = '#FFFFFF';
        ctx.beginPath();
        ctx.arc(eyeX, eyeY, 3, 0, Math.PI * 2);
        ctx.fill();
    }
    
    ctx.fillStyle = eyeColor;
    ctx.beginPath();
    ctx.arc(eyeX, eyeY, 2, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = wingColor;
    const wingWidth = bodySize/8;
    const wingHeight = bodySize/3;
    const wingY = bird.y - wingHeight/2;
    
    if (bird.name === "Â§úÈπ≠") {
        if (beakDirection === 1) {
            ctx.fillRect(
                bird.x - bodySize/3 - wingWidth/2,
                wingY,
                wingWidth,
                wingHeight
            );
        } else {
            ctx.fillRect(
                bird.x + bodySize/3 - wingWidth/2,
                wingY,
                wingWidth,
                wingHeight
            );
        }
    } else {
        if (bird.targetTree.side === 'left') {
            ctx.fillRect(
                bird.x + bodySize/2 - wingWidth/2,
                wingY,
                wingWidth,
                wingHeight
            );
        } else {
            ctx.fillRect(
                bird.x - bodySize/2 - wingWidth/2,
                wingY,
                wingWidth,
                wingHeight
            );
        }
    }
    
    ctx.fillStyle = tailColor;
    const tailStartX = bird.x;
    const tailStartY = bird.y + bodySize/2;
    const tailHeight = bodySize/4;
    const tailWidth = bodySize/3;
    
    ctx.beginPath();
    ctx.moveTo(tailStartX - tailWidth/2, tailStartY);
    ctx.lineTo(tailStartX + tailWidth/2, tailStartY);
    ctx.lineTo(tailStartX, tailStartY + tailHeight);
    ctx.closePath();
    ctx.fill();
    
    ctx.restore();
}

function drawRiceBallBird(bird) {
    const baseSize = 20;
    const birdSize = baseSize * bird.size;
    const bodySize = birdSize;
    
    ctx.save();
    
    let riceBallColor;
    let dotColor = "#000000";
    let eyeRingColor = "#FFFFFF";
    let topSquareColor = "#FF8C00";
    
    if (bird.name === "Êà¥Ëèä") {
        riceBallColor = "#90EE90";
    }
    
    ctx.fillStyle = riceBallColor;
    ctx.beginPath();
    ctx.arc(bird.x, bird.y, bodySize/2, 0, Math.PI * 2);
    ctx.fill();
    
    const highlightGradient = ctx.createRadialGradient(
        bird.x - bodySize/4, bird.y - bodySize/4, 0,
        bird.x, bird.y, bodySize
    );
    highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
    highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
    
    ctx.fillStyle = highlightGradient;
    ctx.beginPath();
    ctx.arc(bird.x, bird.y, bodySize/2, 0, Math.PI * 2);
    ctx.fill();
    
    const eyeSpacing = bodySize * 0.4;
    const leftEyeX = bird.x - eyeSpacing/2;
    const rightEyeX = bird.x + eyeSpacing/2;
    const eyeY = bird.y - bodySize/6;
    const mouthX = bird.x;
    const mouthY = bird.y + bodySize/6;
    
    const eyeRadius = 0.25;
    const mouthRadius = 0.25;
    
    if (bird.name === "Êà¥Ëèä") {
        ctx.fillStyle = eyeRingColor;
        ctx.beginPath();
        ctx.arc(leftEyeX, eyeY, eyeRadius + 0.125, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(rightEyeX, eyeY, eyeRadius + 0.125, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = dotColor;
        ctx.beginPath();
        ctx.arc(leftEyeX, eyeY, eyeRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(rightEyeX, eyeY, eyeRadius, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.beginPath();
        ctx.arc(mouthX, mouthY, mouthRadius, 0, Math.PI * 2);
        ctx.fill();
        
        const squareSize = bodySize * 0.3;
        ctx.fillStyle = topSquareColor;
        
        const roundRect = (x, y, width, height, radius) => {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            ctx.fill();
        };
        
        roundRect(bird.x - squareSize/2, bird.y - bodySize/2 - squareSize/2, squareSize, squareSize, 2);
    }
    
    ctx.fillStyle = riceBallColor;
    const tailWidth = bodySize * 0.15;
    const tailHeight = bodySize * 0.2;
    const tailX = bird.x + bodySize/2 - tailWidth/2;
    const tailY = bird.y + bodySize/2 - tailHeight/2;
    
    ctx.beginPath();
    ctx.moveTo(tailX, tailY);
    ctx.lineTo(tailX + tailWidth, tailY);
    ctx.lineTo(tailX + tailWidth/2, tailY + tailHeight);
    ctx.closePath();
    ctx.fill();
    
    ctx.restore();
}

function drawLongtailedFinch(bird) {
  const baseSize = 20;
  let birdSize = baseSize * bird.size;
  const headSize = birdSize * 0.5;
  const bodySize = birdSize;
  
  ctx.save();
  let headOffsetY = 0;
  
  ctx.fillStyle = bird.type.bodyColor;
  ctx.beginPath();
  ctx.arc(bird.x, bird.y, bodySize/2, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.fillStyle = bird.type.headColor;
  ctx.beginPath();
  ctx.arc(
    bird.x + bodySize/2 - headSize/2,
    bird.y - bodySize/2 + headSize/2,
    headSize/2, 0, Math.PI * 2
  );
  ctx.fill();
  
  ctx.fillStyle = bird.type.color;
  const beakLength = 8 * 0.5;
  const beakHeight = 4;
  const beakStartX = bird.x + bodySize/2 - headSize/2 + headSize/2;
  const beakStartY = bird.y - bodySize/2 + headSize/2;
  
  ctx.beginPath();
  ctx.moveTo(beakStartX, beakStartY);
  ctx.lineTo(beakStartX + beakLength, beakStartY);
  ctx.lineTo(beakStartX, beakStartY + beakHeight);
  ctx.closePath();
  ctx.fill();
  
  ctx.fillStyle = bird.type.eyeColor;
  const eyeX = bird.x + bodySize/2 - headSize/2 + headSize/4;
  const eyeY = bird.y - bodySize/2 + headSize/3;
  
  ctx.beginPath();
  ctx.arc(eyeX, eyeY, 2, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.fillStyle = bird.type.wingColor;
  ctx.fillRect(
    bird.x - bodySize/4 - headSize/2,
    bird.y - bodySize/2,
    bodySize/2, bodySize/3
  );
  
  // ‰øÆÊîπÂ∞æÂ∑¥Ê†∑Âºè‰∏∫ÁôΩÈπ°È∏∞Ê†∑Âºè
  ctx.fillStyle = "#000000"; // ‰ΩøÁî®ÈªëËâ≤Ôºå‰∏éÁôΩÈπ°È∏∞‰∏ÄËá¥
  const tailWidth = 3;
  const tailLength = 20; // ‰øùÊåÅ‰∏éÁôΩÈπ°È∏∞Áõ∏ÂêåÁöÑÈïøÂ∫¶
  const tailStartX = bird.x - bodySize/2;
  const tailStartY = bird.y - bodySize/8; // Ë∞ÉÊï¥‰ΩçÁΩÆ
  
  // ÁªòÂà∂Â∞æÂ∑¥‰∏ª‰Ωì
  ctx.fillRect(tailStartX, tailStartY - tailWidth/2, -tailLength, tailWidth);
  
  // ÁªòÂà∂Â∞æÂ∑¥‰∏ãÈù¢ÁöÑÊ®™Á∫øÔºàÁôΩÈπ°È∏∞Ê†∑ÂºèÔºâ
  ctx.fillStyle = "#000000";
  const blackLineY = tailStartY + tailWidth/2 + 1;
  ctx.fillRect(tailStartX, blackLineY, -tailLength, 1);
  
  ctx.restore();
}

function drawHawfinch(bird) {
    const baseSize = 20;
    let birdSize = baseSize * bird.size;
    const headSize = birdSize * 0.5;
    const bodySize = birdSize;
    
    // ‚úÖ ÁßªÈô§ÂéüÊúâÁöÑÊñπÂêëÂ§ÑÁêÜ
    ctx.fillStyle = bird.type.bodyColor;
    ctx.beginPath();
    ctx.arc(bird.x, bird.y, bodySize/2, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = bird.type.headColor;
    ctx.beginPath();
    ctx.arc(
        bird.x + bodySize/2 - headSize/2,
        bird.y - bodySize/2 + headSize/2,
        headSize/2,
        0,
        Math.PI * 2
    );
    ctx.fill();

    // Âñô
    ctx.fillStyle = bird.type.beakColor || bird.type.color || "#000000";
    const beakStartX = bird.x + bodySize/2 - headSize/2 + headSize/2;
    const beakStartY = bird.y - bodySize/2 + headSize/2;
    const beakLength = 4;
    const beakHeight = 6;
    ctx.beginPath();
    ctx.moveTo(beakStartX, beakStartY);
    ctx.lineTo(beakStartX + beakLength, beakStartY);
    ctx.lineTo(beakStartX, beakStartY + beakHeight);
    ctx.closePath();
    ctx.fill();

    // ÁúºÁùõ
    ctx.fillStyle = bird.type.eyeColor;
    const eyeX = bird.x + bodySize/2 - headSize/2 + headSize/4;
    const eyeY = bird.y - bodySize/2 + headSize/3;
    ctx.beginPath();
    ctx.arc(eyeX, eyeY, 2, 0, Math.PI * 2);
    ctx.fill();

    // ÁøÖËÜÄ
    ctx.fillStyle = bird.type.wingColor;
    ctx.fillRect(
        bird.x - bodySize/4 - headSize/2,
        bird.y - bodySize/2,
        bodySize/2,
        bodySize/3
    );

    // Â∞æÂ∑¥
    ctx.fillStyle = bird.type.tailColor;
    const tailStartX = bird.x - bodySize/2;
    const tailStartY = bird.y - bodySize/8;
    const tailHeight = bodySize/4;
    ctx.beginPath();
    ctx.moveTo(tailStartX, tailStartY);
    ctx.lineTo(tailStartX - 8, tailStartY - tailHeight/2);
    ctx.lineTo(tailStartX - 8, tailStartY + tailHeight/2);
    ctx.lineTo(tailStartX, tailStartY);
    ctx.closePath();
    ctx.fill();
}

function drawBrambling(bird) {
    const baseSize = 20;
    let birdSize = baseSize * bird.size;
    const headSize = birdSize * 0.5;
    const bodySize = birdSize;
    
    // ‚úÖ ÁßªÈô§ÂéüÊúâÁöÑÊñπÂêëÂ§ÑÁêÜÔºå‰ΩøÁî®Áªü‰∏ÄÁöÑÈïúÂÉèÈÄªËæë
    ctx.fillStyle = bird.type.bodyColor;
    ctx.beginPath();
    ctx.arc(bird.x, bird.y, bodySize/2, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = bird.type.headColor;
    ctx.beginPath();
    ctx.arc(
        bird.x + bodySize/2 - headSize/2,
        bird.y - bodySize/2 + headSize/2,
        headSize/2,
        0,
        Math.PI * 2
    );
    ctx.fill();

    // Âñô
    ctx.fillStyle = bird.type.beakColor || bird.type.color || "#000000";
    const beakStartX = bird.x + bodySize/2 - headSize/2 + headSize/2;
    const beakStartY = bird.y - bodySize/2 + headSize/2;
    const beakLength = 4;
    const beakHeight = 3;
    ctx.beginPath();
    ctx.moveTo(beakStartX, beakStartY);
    ctx.lineTo(beakStartX + beakLength, beakStartY);
    ctx.lineTo(beakStartX, beakStartY + beakHeight);
    ctx.closePath();
    ctx.fill();

    // ÁúºÁùõ
    ctx.fillStyle = bird.type.eyeColor;
    const eyeX = bird.x + bodySize/2 - headSize/2 + headSize/4;
    const eyeY = bird.y - bodySize/2 + headSize/3;
    ctx.beginPath();
    ctx.arc(eyeX, eyeY, 2, 0, Math.PI * 2);
    ctx.fill();

    // ÁøÖËÜÄ
    ctx.fillStyle = bird.type.wingColor;
    ctx.fillRect(
        bird.x - bodySize/4 - headSize/2,
        bird.y - bodySize/2,
        bodySize/2,
        bodySize/3
    );

    // Â∞æÂ∑¥
    ctx.fillStyle = bird.type.tailColor;
    const tailStartX = bird.x - bodySize/2;
    const tailStartY = bird.y - bodySize/8;
    const tailHeight = bodySize/4;
    ctx.beginPath();
    ctx.moveTo(tailStartX, tailStartY);
    ctx.lineTo(tailStartX - 8, tailStartY - tailHeight/2);
    ctx.lineTo(tailStartX - 8, tailStartY + tailHeight/2);
    ctx.lineTo(tailStartX, tailStartY);
    ctx.closePath();
    ctx.fill();
}

// Êñ∞Â¢ûÔºöÁΩóÂÆæÁªòÂà∂ÂáΩÊï∞
function drawRobin(bird) {
  const baseSize = 20;
  let birdSize = baseSize * bird.size;
  const headSize = birdSize * 0.5;
  const bodySize = birdSize;
  ctx.save();
  
  // Ë∫´‰Ωì - ÊµÖÁÅ∞Ëâ≤
  ctx.fillStyle = bird.type.bodyColor;
  ctx.beginPath();
  ctx.arc(bird.x, bird.y, bodySize/2, 0, Math.PI * 2);
  ctx.fill();
  
  // Â§¥ÈÉ® - Ê©ôËâ≤
  ctx.fillStyle = bird.type.headColor;
  ctx.beginPath();
  ctx.arc(
    bird.x + bodySize/2 - headSize/2,
    bird.y - bodySize/2 + headSize/2,
    headSize/2, 0, Math.PI * 2
  );
  ctx.fill();
  
  // Âò¥ - Ê£ïËâ≤Ôºå0.8ÂÄçÈïø
  ctx.fillStyle = bird.type.color;
  const beakLength = 8 * 0.8;
  const beakHeight = 4;
  const beakStartX = bird.x + bodySize/2 - headSize/2 + headSize/2;
  const beakStartY = bird.y - bodySize/2 + headSize/2;
  ctx.beginPath();
  ctx.moveTo(beakStartX, beakStartY);
  ctx.lineTo(beakStartX + beakLength, beakStartY);
  ctx.lineTo(beakStartX, beakStartY + beakHeight);
  ctx.closePath();
  ctx.fill();
  
  // ÁúºÁùõ - ÈªëËâ≤
  ctx.fillStyle = bird.type.eyeColor;
  const eyeX = bird.x + bodySize/2 - headSize/2 + headSize/4;
  const eyeY = bird.y - bodySize/2 + headSize/3;
  ctx.beginPath();
  ctx.arc(eyeX, eyeY, 2, 0, Math.PI * 2);
  ctx.fill();
  
  // ÁøÖËÜÄ - Ê£ïËâ≤
  ctx.fillStyle = bird.type.wingColor;
  ctx.fillRect(
    bird.x - bodySize/4 - headSize/2,
    bird.y - bodySize/2,
    bodySize/2,
    bodySize/3
  );
  
  // Â∞æÂ∑¥ - Ê£ïËâ≤
  ctx.fillStyle = bird.type.tailColor;
  const tailStartX = bird.x - bodySize/2;
  const tailStartY = bird.y - bodySize/8;
  const tailHeight = bodySize/4;
  ctx.beginPath();
  ctx.moveTo(tailStartX, tailStartY);
  ctx.lineTo(tailStartX - 8, tailStartY - tailHeight/2);
  ctx.lineTo(tailStartX - 8, tailStartY + tailHeight/2);
  ctx.lineTo(tailStartX, tailStartY);
  ctx.closePath();
  ctx.fill();
  
  ctx.restore();
}

function drawMouseInClaws(bird) {
    ctx.save();
    
    const clawOffsetX = 20;
    const clawOffsetY = 15;
    
    let mouseX = bird.x + clawOffsetX;
    let mouseY = bird.y + clawOffsetY;
    
    if (bird.mouseSwingAngle !== undefined) {
        bird.mouseSwingAngle += bird.mouseSwingSpeed || 0.05;
    }
    
    const swingOffset = Math.sin(bird.mouseSwingAngle || 0) * 3;
    mouseX += swingOffset;
    mouseY += Math.abs(swingOffset) * 0.5;
    
    ctx.fillStyle = "#D3D3D3";
    const bodyWidth = 12;
    const bodyHeight = 8;
    ctx.beginPath();
    ctx.ellipse(mouseX, mouseY, bodyWidth/2, bodyHeight/2, 0, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = "#D3D3D3";
    const headSize = 6;
    let headX, headY;
    
    headX = mouseX + bodyWidth/2;
    headY = mouseY;
    
    ctx.save();
    ctx.translate(headX, headY);
    ctx.rotate(swingOffset * 0.1);
    
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(headSize, -headSize/2);
    ctx.lineTo(headSize, headSize/2);
    ctx.closePath();
    ctx.fill();
    
    ctx.fillStyle = "#000000";
    const eyeX = headSize/2;
    ctx.beginPath();
    ctx.arc(eyeX, -headSize/4, 1.5, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(eyeX, headSize/4, 1.5, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.restore();
    
    ctx.save();
    ctx.translate(mouseX, mouseY);
    
    let tailStartX, tailStartY;
    tailStartX = -bodyWidth/2;
    tailStartY = 0;
    
    const tailLength = 15;
    const tailAngle = swingOffset * 0.2;
    
    let tailEndX, tailEndY;
    tailEndX = tailStartX - Math.cos(tailAngle) * tailLength;
    tailEndY = tailStartY + Math.sin(tailAngle) * tailLength;
    
    ctx.strokeStyle = "#D3D3D3";
    ctx.lineWidth = 2;
    ctx.lineCap = "round";
    ctx.beginPath();
    ctx.moveTo(tailStartX, tailStartY);
    ctx.lineTo(tailEndX, tailEndY);
    ctx.stroke();
    
    ctx.restore();
    ctx.restore();
}

function updateDayNight(deltaTime) {
    if (gamePaused) return;
    
    gameTime += deltaTime;

    if (gameTime - lastRareBirdTime >= RARE_BIRD_INTERVAL) {
        generateRareBird();
        lastRareBirdTime = gameTime;
    }
    
    if (gameMode === 'normal') {
        dayNightTimer += deltaTime;
        moonPhaseTimer += deltaTime;
        if (moonPhaseTimer >= MOON_PHASE_CYCLE) {
            moonPhaseTimer = 0;
        }
        
        updateGoldenFilter();
        
        if (dayNightTimer >= DAY_NIGHT_CYCLE_DURATION) {
            isDaytime = !isDaytime;
            dayNightTimer = 0;
            if (!isDaytime) {
                moonPhaseTimer = Math.random() * MOON_PHASE_CYCLE;
            }
            
            updateModeToggleButtons();
            showSpecialAlert(isDaytime ? "Â§©‰∫Æ‰∫ÜÔºÅ" : "Â§©Èªë‰∫ÜÔºÅ");
            
            if (!isDaytime) {
                for (let i = birds.length - 1; i >= 0; i--) {
                    if (!birds[i].isOwl && !birds[i].isBat && birds[i].name !== "Â∞èÈ∏Æ" && birds[i].name !== "Â§úÈπ≠") {
                        birds.splice(i, 1);
                    }
                }
                nightObjects = [];
            } else {
                for (let i = birds.length - 1; i >= 0; i--) {
                    if (birds[i].isOwl || birds[i].isBat) {
                        birds.splice(i, 1);
                    }
                }
                
                if (littleOwl) {
                    birds.splice(birds.indexOf(littleOwl), 1);
                    littleOwl = null;
                }
                nightObjects = [];
            }
        }
        
        sunMoonPosition = dayNightTimer / DAY_NIGHT_CYCLE_DURATION;
    } else if (gameMode === 'day') {
        dayModeTimeState += deltaTime;
        dayNightTimer = dayModeTimeState;
        
        const goldenFilter = document.getElementById('goldenFilter');
        goldenFilter.style.backgroundColor = 'rgba(255, 215, 0, 0.1)';
    } else if (gameMode === 'night') {
        nightModeTimeState += deltaTime;
        nightModeMoonPhaseTimer += deltaTime;
        dayNightTimer = nightModeTimeState;
        moonPhaseTimer = nightModeMoonPhaseTimer;
        
        if (moonPhaseTimer >= MOON_PHASE_CYCLE) {
            moonPhaseTimer = 0;
            nightModeMoonPhaseTimer = 0;
        }
        
        const goldenFilter = document.getElementById('goldenFilter');
        goldenFilter.style.backgroundColor = 'rgba(255, 215, 0, 0)';
    }
    
    updateTimeIndicator();
    
    if (!littleOwl) {
        let cooldown;
        if (gameMode === 'day') {
            cooldown = LITTLE_OWL_DAY_COOLDOWN;
        } else if (gameMode === 'night') {
            cooldown = LITTLE_OWL_NIGHT_COOLDOWN;
        } else {
            cooldown = isDaytime ? LITTLE_OWL_DAY_COOLDOWN : LITTLE_OWL_NIGHT_COOLDOWN;
        }
        
        if (gameTime - lastLittleOwlTime > cooldown) {
            generateLittleOwl(true);
        }
    }
    
    if ((gameMode === 'night' || (gameMode === 'normal' && !isDaytime)) && gameTime - lastOwlSpawnTime > NIGHT_OWL_SPAWN_INTERVAL) {
        spawnNightOwls();
        lastOwlSpawnTime = gameTime;
    }
}

function generateRareBird() {
  const isNightMode = gameMode === 'night' || (gameMode === 'normal' && !isDaytime);
  let availableRareBirds = RARE_BIRDS.filter(birdKey => {
    const birdType = BIRD_TYPES[birdKey];
    if (!birdType) return false; // Ê∑ªÂä†‰øùÊä§ÊÄßÊ£ÄÊü•
    if (birdType.isNocturnal || birdType.canAppearAtNight) {
      return isNightMode;
    }
    return !isNightMode;
  });
  
  if (availableRareBirds.length === 0) {
    if (isNightMode) {
      availableRareBirds = ['OWL'];
    } else {
      // Á°Æ‰øùÁôΩÂ§©ÂèØÁî®ÁöÑÁ®ÄÊúâÈ∏üÁ±ªÂåÖÂê´ÊâÄÊúâÁôΩÂ§©È∏üÁ±ª
      availableRareBirds = ['KENTISH_PLOVER', 'MINIVET', 'GOLDCREST', 'LITTLEGREBE', 'LONGTAILED_FINCH', 'ROBIN'];
    }
  }
  
  const capturedRareBirds = availableRareBirds.filter(birdKey => {
    const birdName = BIRD_TYPES[birdKey]?.name;
    return birdName && capturedBirds[birdName] && capturedBirds[birdName] > 0;
  });
  
  const uncapturedRareBirds = availableRareBirds.filter(birdKey => {
    const birdName = BIRD_TYPES[birdKey]?.name;
    return birdName && (!capturedBirds[birdName] || capturedBirds[birdName] === 0);
  });
  
  let randomBirdKey;
  if (uncapturedRareBirds.length > 0) {
    randomBirdKey = uncapturedRareBirds[Math.floor(Math.random() * uncapturedRareBirds.length)];
  } else {
    randomBirdKey = availableRareBirds[Math.floor(Math.random() * availableRareBirds.length)];
  }
  
  // Á°Æ‰øù randomBirdKey ÊúâÂØπÂ∫îÁöÑÂ§ÑÁêÜ
  switch (randomBirdKey) {
    case 'KENTISH_PLOVER':
      generateKentishPlover(false);
      showSpecialAlert("Á®ÄÊúâÈ∏üÁ±ªÂá∫Áé∞ÔºöÈáëÁú∂È∏ªÔºÅ");
      break;
    case 'MINIVET':
      generateMinivetRare(false);
      showSpecialAlert("Á®ÄÊúâÈ∏üÁ±ªÂá∫Áé∞ÔºöÂ±±Ê§íÈ∏üÔºÅ");
      break;
    case 'GOLDCREST':
      generateGoldcrest(false);
      showSpecialAlert("Á®ÄÊúâÈ∏üÁ±ªÂá∫Áé∞ÔºöÊà¥ËèäÔºÅ");
      break;
    case 'OWL':
      generateOwlRare(false);
      showSpecialAlert("Á®ÄÊúâÈ∏üÁ±ªÂá∫Áé∞ÔºöÈïøËÄ≥È∏ÆÔºÅ");
      break;
    case 'LITTLEGREBE':
      generateLittleGrebe(false);
      showSpecialAlert("Á®ÄÊúâÈ∏üÁ±ªÂá∫Áé∞ÔºöÂ∞èÂåóÔºÅ");
      break;
    case 'LONGTAILED_FINCH':
      generateLongtailedFinchRare(false);
      showSpecialAlert("Á®ÄÊúâÈ∏üÁ±ªÂá∫Áé∞ÔºöÈïøÂ∞æÈõÄÔºÅ");
      break;
    case 'ROBIN':
      generateRobinRare(false);
      showSpecialAlert("Á®ÄÊúâÈ∏üÁ±ªÂá∫Áé∞ÔºöÁΩóÂÆæÔºÅ");
      break;
default:
      console.log("Êú™Â§ÑÁêÜÁöÑÁ®ÄÊúâÈ∏üÁ±ªÈîÆ:", randomBirdKey);
      // ÈªòËÆ§ÁîüÊàê‰∏Ä‰∏™Â∑≤Áü•ÁöÑÁ®ÄÊúâÈ∏üÁ±ª
      generateKentishPlover(false);
      showSpecialAlert("Á®ÄÊúâÈ∏üÁ±ªÂá∫Áé∞ÔºöÈáëÁú∂È∏ªÔºÅ");
      break;
  }
}
// Êñ∞Â¢ûÔºöÈïøÂ∞æÈõÄÁ®ÄÊúâÁîüÊàêÂáΩÊï∞
function generateLongtailedFinchRare(countStats = true) {
  const longtailedFinchType = BIRD_TYPES.LONGTAILED_FINCH;
  if (countStats) {
    appearedBirds[longtailedFinchType.name]++;
    updateTextStats();
  }
  
  const fromLeft = Math.random() > 0.5;
  const birdCount = getRandomGroupSize(longtailedFinchType);
  const groupId = nextGroupId++;
  birdGroupInfo[groupId] = { direction: fromLeft ? 1 : -1, birds: [] };
  
  for (let i = 0; i < birdCount; i++) {
    const startX = fromLeft ? -50 : GAME_WIDTH + 50;
    const startY = Math.random() * (GAME_HEIGHT * 0.6) + GAME_HEIGHT * 0.2;
    const bird = createCommonBird(
      longtailedFinchType,
      startX,
      startY,
      fromLeft,
      "landOnTreeTop",
      longtailedFinchType.stayTime,
      2 + Math.random(),
      groupId
    );
    bird.halfBeak = true;
    bird.isVulnerableToRaptors = true;
    bird.noStats = !countStats;
    bird.isNight = !isDaytime;
    birds.push(bird);
    birdGroupInfo[groupId].birds.push(bird);
  }
}

// Êñ∞Â¢ûÔºöÁΩóÂÆæÁ®ÄÊúâÁîüÊàêÂáΩÊï∞
function generateRobinRare(countStats = true) {
  const robinType = BIRD_TYPES.ROBIN;
  if (countStats) {
    appearedBirds[robinType.name]++;
    updateTextStats();
  }
  
  const fromLeft = Math.random() > 0.5;
  const birdCount = getRandomGroupSize(robinType);
  const groupId = nextGroupId++;
  birdGroupInfo[groupId] = { direction: fromLeft ? 1 : -1, birds: [] };
  
  for (let i = 0; i < birdCount; i++) {
    const startX = fromLeft ? -50 : GAME_WIDTH + 50;
    const startY = Math.random() * (GAME_HEIGHT * 0.6) + GAME_HEIGHT * 0.2;
    const bird = createCommonBird(
      robinType,
      startX,
      startY,
      fromLeft,
      "landOnTreeBottom",
      robinType.stayTime,
      2 + Math.random(),
      groupId
    );
    bird.beakLengthMultiplier = 0.8;
    bird.isVulnerableToRaptors = true;
    bird.noStats = !countStats;
    bird.isNight = !isDaytime;
    birds.push(bird);
    birdGroupInfo[groupId].birds.push(bird);
  }
}

function generateMinivetRare(countStats = true) {
    const minivetType = BIRD_TYPES.MINIVET;
    if (countStats) {
        appearedBirds[minivetType.name]++;
        updateTextStats();
    }
    
    const fromLeft = Math.random() > 0.5;
    const birdCount = getRandomGroupSize(minivetType);
    const groupId = nextGroupId++;
    birdGroupInfo[groupId] = { direction: fromLeft ? 1 : -1, birds: [] };
    
    for (let i = 0; i < birdCount; i++) {
        let startX, startY;
        const behavior = minivetType.behavior;
        const stayTime = minivetType.stayTime || 10;
        
        startX = fromLeft ? -50 : GAME_WIDTH + 50;
        startY = Math.random() * (GAME_HEIGHT * 0.6) + GAME_HEIGHT * 0.2;
        
        let baseSpeed = (1.6 + Math.random() * 0.8);
        const speedMultiplier = minivetType.speedMultiplier || 1;
        const finalSpeed = baseSpeed * speedMultiplier;
        
        const bird = createCommonBird(minivetType, startX, startY, fromLeft, behavior, stayTime, finalSpeed, groupId);
        bird.variant = Math.random() > 0.5;
        bird.iconColor = bird.variant ? "#FFFF00" : "#FF0000";
        bird.noStats = !countStats;
        bird.isNight = !isDaytime;
        
        birds.push(bird);
        birdGroupInfo[groupId].birds.push(bird);
    }
}

function generateOwlRare(countStats = true) {
    const owlType = BIRD_TYPES.OWL;
    if (countStats) {
        appearedBirds[owlType.name]++;
        updateTextStats();
    }
    
    const targetTree = treePositions[Math.floor(Math.random() * treePositions.length)];
    const x = targetTree.x + targetTree.width * 0.4 + Math.random() * targetTree.width * 0.2;
    const y = targetTree.y + targetTree.height * 0.2 + Math.random() * targetTree.height * 0.3;
    
    const isNightMode = gameMode === 'night' || (gameMode === 'normal' && !isDaytime);
    
    const bird = {
        type: owlType,
        name: owlType.name,
        x: x,
        y: y,
        size: owlType.size,
        speed: 0,
        direction: targetTree.side === 'left' ? 1 : -1,
        state: 'perching',
        stateTime: 0,
        stayTime: owlType.stayTime || 15,
        faceScreen: true,
        iconColor: owlType.iconColor,
        eyeColor: isNightMode ? "#FFFF99" : "#FFA500", // Â§úÊôöÈªÑËâ≤ÔºåÁôΩÂ§©Ê©ôËâ≤
        whiteEyeRing: true,
        noStats: !countStats,
        isNight: isNightMode,
        // ‚úÖ Êñ∞Â¢ûÔºöÊ†áËÆ∞‰∏∫Áõ¥Êé•Ê∂àÂ§±ÁöÑÈ∏üÁ±ª
        shouldVanishInsteadOfFlying: true,
        behavior: "appearOnTree" // ÊòéÁ°ÆË°å‰∏∫Á±ªÂûã
    };
    
    birds.push(bird);
    showSpecialAlert("Á®ÄÊúâÈ∏üÁ±ªÂá∫Áé∞ÔºöÈïøËÄ≥È∏ÆÔºÅ");
    return bird;
}

function updateGoldenFilter() {
    const goldenFilter = document.getElementById('goldenFilter');
    
    if (gameMode === 'normal' && isDaytime) {
        const oneMinute = 1 * 60 * 1000;
        const dayDuration = DAY_NIGHT_CYCLE_DURATION;
        const currentDayTime = dayNightTimer;
        
        let intensity = 0;
        if (currentDayTime < oneMinute) {
            intensity = 0.3 * (1 - currentDayTime / oneMinute);
        } else if (currentDayTime > dayDuration - oneMinute) {
            const timeLeft = dayDuration - currentDayTime;
            intensity = 0.3 * (1 - timeLeft / oneMinute);
        } else {
            intensity = 0;
        }
        
        goldenFilter.style.backgroundColor = `rgba(255, 215, 0, ${intensity})`;
        isGoldenFilterActive = intensity > 0.01;
    } else {
        goldenFilter.style.backgroundColor = 'rgba(255, 215, 0, 0)';
        isGoldenFilterActive = false;
    }
}

function updateBirds(deltaTime) {
    if (gamePaused) return;
    
    raptorsPresent = birds.filter(bird => bird.name === "Ê∏∏Èöº" || bird.name === "Á∫¢Èöº" || bird.name === "ÈªëÁøÖÈ∏¢");
    
    raptorsPresent.forEach(raptor => {
        if (!raptor.hasBeenNearCenter) {
            const centerX = GAME_WIDTH / 2;
            const centerY = GAME_HEIGHT / 2;
            const distanceX = Math.abs(raptor.x - centerX);
            const distanceY = Math.abs(raptor.y - centerY);
            if (distanceX < 400 && distanceY < 300) {
                raptor.hasBeenNearCenter = true;
                raptor.centerArrivalTime = gameTime;
            }
        }
    });
    
    const isNightMode = gameMode === 'night' || (gameMode === 'normal' && !isDaytime);
    const qualifiedRaptors = raptorsPresent.filter(raptor => raptor.hasBeenNearCenter && gameTime - raptor.centerArrivalTime >= 1000);
    
    if (qualifiedRaptors.length > 0) {
        birds.forEach(bird => {
            const exemptBirds = [
                "ÂñúÈπä", "‰πåÈ∏¶", "Â§úÈπ≠", "ÁªøÂ§¥È∏≠", "Ëµ§È∫ªÈ∏≠", "Â∞èÂåó", "Êà¥Ëèä", "Â±±ÈõÄ", 
                "Ê£ïÂ§¥È∏¶ÈõÄ", "ÈáëÁú∂È∏ª", "12000È∏ª", "Ê∏∏Èöº", "Á∫¢Èöº", "ÈªëÁøÖÈ∏¢", 
                "ÈïøËÄ≥È∏Æ", "ÈõïÈ∏Æ", "Áü≠ËÄ≥È∏Æ", "Â∞èÈ∏Æ", "ËùôËù†"
            ];
            
            if (exemptBirds.includes(bird.name)) {
                return;
            }
            
            if (!bird.isFleeingFromRaptor) {
                bird.isFleeingFromRaptor = true;
                bird.originalState = bird.state;
                bird.originalSpeed = bird.speed;
                bird.fleeFromRaptorStartTime = gameTime;
                bird.speed = bird.originalSpeed * 1.5;
                
                let nearestRaptor = null;
                let minDistance = Infinity;
                qualifiedRaptors.forEach(raptor => {
                    const dx = raptor.x - bird.x;
                    const dy = raptor.y - bird.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < minDistance) {
                        minDistance = distance;
                        nearestRaptor = raptor;
                    }
                });
                
                if (nearestRaptor) {
                    bird.direction = nearestRaptor.x > bird.x ? -1 : 1;
                }
                bird.state = 'flying';
            }
        });
        
        birds.forEach(bird => {
            if (bird.name === "ÈáëÁú∂È∏ª" || bird.name === "12000È∏ª") {
                if (bird.state === 'flying' || bird.state === 'landingOnReeds' || bird.state === 'takingOff') {
                    if (!bird.isFleeingFromRaptor) {
                        bird.isFleeingFromRaptor = true;
                        bird.originalState = bird.state;
                        bird.originalSpeed = bird.speed;
                        bird.speed = bird.originalSpeed * 3;
                        bird.state = 'flying';
                        bird.direction = Math.random() > 0.5 ? 1 : -1;
                    }
                } else if (bird.state === 'onReedsGround') {
                    if (!bird.isHidingFromRaptor) {
                        bird.isHidingFromRaptor = true;
                        bird.originalY = bird.y;
                        bird.originalSpeed = bird.speed;
                        bird.speed = 0;
                        bird.y = bird.originalY + (20 * bird.size * 0.5);
                    }
                }
            }
        });
        
        // Âè™Âú®ÁåõÁ¶ΩÊ≤°ÊúâË¢´ËøΩÈÄêÂ∑°ÈÄªÊó∂Ëß¶ÂèëÊñ∞ÁöÑËøΩÈÄê
        if (Math.random() > 1/3) {
            if (raptorsPresent.length > 0) {
                const availableMagpiesCrows = birds.filter(bird => 
                    (bird.name === "ÂñúÈπä" || bird.name === "‰πåÈ∏¶") && 
                    !bird.isChasingRaptor && 
                    !bird.isFleeingFromRaptor && 
                    !bird.isFleeingFromChasers
                );
                
                raptorsPresent.forEach(raptor => {
                    // Â¶ÇÊûúÁåõÁ¶ΩÂ∑≤ÁªèÂú®Ë¢´ËøΩÈÄêÂ∑°ÈÄª‰∏≠ÔºåÊàñËÄÖÊ≠£Âú®ÈÄÉÁ¶ªËøΩÈÄêÔºåÊàñËÄÖÂ∑≤ÁªèË¢´ËøΩÈÄêËøáÔºàÂÖçÁñ´Áä∂ÊÄÅÔºâÔºå‰∏çÈáçÊñ∞Ëß¶Âèë
                    if (raptor.isChasedPatrolling || raptor.isFleeingFromChasers || raptor.hasBeenChased) {
                        return;
                    }
                    
                    const currentChasers = chasingMagpiesCrows.filter(chaser => chaser.chasingTarget === raptor);
                    const neededChasers = raptor.name === "Ê∏∏Èöº" ? 2 : 1;
                    
                    if (currentChasers.length < neededChasers) {
                        const potentialChasers = availableMagpiesCrows.filter(bird => !bird.chasingTarget);
                        const newChasers = potentialChasers.slice(0, neededChasers - currentChasers.length);
                        
                        if (newChasers.length > 0 && !raptor.hasPatrolStarted) {
                            // Ê†áËÆ∞‰∏∫Â∑≤ÂºÄÂßãÂ∑°ÈÄªÔºåÈò≤Ê≠¢ÈáçÂ§çËß¶Âèë
                            raptor.hasPatrolStarted = true;
                            
                            newChasers.forEach(chaser => {
                                if (chaser.state === 'perching' || chaser.state === 'landing') {
                                    chaser.state = 'takingOff';
                                    chaser.speed = 2.0;
                                    setTimeout(() => {
                                        if (birds.includes(chaser) && birds.includes(raptor)) {
                                            chaser.chasingTarget = raptor;
                                            chaser.isChasingRaptor = true;
                                            chaser.originalState = chaser.state;
                                            chaser.originalSpeed = chaser.speed;
                                            chaser.chaseStartTime = gameTime;
                                            chaser.willFollowCircles = true;
                                            chaser.circleFollowingCount = 0;
                                            chaser.state = 'chasingRaptor';
                                            chasingMagpiesCrows.push(chaser);
                                        }
                                    }, 500);
                                } else {
                                    chaser.chasingTarget = raptor;
                                    chaser.isChasingRaptor = true;
                                    chaser.originalState = chaser.state;
                                    chaser.originalSpeed = chaser.speed;
                                    chaser.chaseStartTime = gameTime;
                                    chaser.willFollowCircles = true;
                                    chaser.circleFollowingCount = 0;
                                    chaser.state = 'chasingRaptor';
                                    chasingMagpiesCrows.push(chaser);
                                }
                            });
                            
                            // ÂêØÂä®ËøΩÈÄêÂ∑°ÈÄª
                            raptor.isChasedPatrolling = true;
                            raptor.originalState = raptor.state;
                            raptor.originalSpeed = raptor.speed;
                            raptor.chasedPatrolStartTime = gameTime;
                            raptor.chasedPatrolStage = 0; // 0: ‰ªé‰∏≠Â§ÆÈ£ûÂá∫Âè≥‰æß
                            raptor.chasedPatrolLoops = 0;
                            raptor.maxPatrolLoops = 2 + Math.floor(Math.random() * 3); // 2-4Ê¨°Âæ™ÁéØ
                            raptor.state = 'chasedPatrolling';
                            raptor.forcedToLeave = false;
                            
                            // a) ‰ªé‰∏≠Â§ÆÈ£ûÂá∫Âè≥‰æß
                            raptor.x = GAME_WIDTH / 2;
                            raptor.y = GAME_HEIGHT * 0.3 + Math.random() * (GAME_HEIGHT * 0.2);
                            raptor.direction = 1; // ÂêëÂè≥
                            raptor.speed = 2.0;
                            console.log("ÁåõÁ¶ΩÂºÄÂßãËøΩÈÄêÂ∑°ÈÄªÔºåÈò∂ÊÆµ0: ‰ªé‰∏≠Â§ÆÈ£ûÂá∫Âè≥‰æßÔºåÊúÄÂ§ßÂæ™ÁéØÊ¨°Êï∞: " + raptor.maxPatrolLoops);
                        }
                    }
                });
            }
        }
    } else {
        for (let i = chasingMagpiesCrows.length - 1; i >= 0; i--) {
            const chaser = chasingMagpiesCrows[i];
            chaser.isChasingRaptor = false;
            chaser.chasingTarget = null;
            if (chaser.originalState) {
                chaser.state = chaser.originalState;
            }
            if (chaser.originalSpeed) {
                chaser.speed = chaser.originalSpeed;
            }
        }
        chasingMagpiesCrows = [];
    }
    
    for (let i = chasingMagpiesCrows.length - 1; i >= 0; i--) {
        const chaser = chasingMagpiesCrows[i];
        if (chaser.chasingTarget && birds.includes(chaser.chasingTarget)) {
            const raptor = chaser.chasingTarget;
            const dx = raptor.x - chaser.x;
            const dy = raptor.y - chaser.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const baseSize = 20;
            const birdSize = baseSize * chaser.size;
            const minDistance = birdSize * 0.5;
            const maxDistance = birdSize * 0.8;
            const targetDistance = minDistance + Math.random() * (maxDistance - minDistance);
            
            if (chaser.isChasingRaptor && chaser.state === 'chasingRaptor') {
                const chaseDuration = gameTime - chaser.chaseStartTime;
                
                // Ê£ÄÊü•ÂñúÈπä/‰πåÈ∏¶ÊòØÂê¶ÊîæÂºÉËøΩÈÄê - ‰øÆÊîπÔºöÂè™Âú®ÁåõÁ¶ΩÂú®Â±èÂπïÂÜÖÊó∂ÊâçÂèØËÉΩÊîæÂºÉ
                if (chaseDuration > 3000) {
                    const timeSinceLastCheck = chaseDuration % 2000;
                    if (timeSinceLastCheck < 50) {
                        // Ê£ÄÊü•ÁåõÁ¶ΩÊòØÂê¶Âú®Â±èÂπïÂÜÖ
                        const isRaptorOnScreen = raptor.x >= -250 && raptor.x <= GAME_WIDTH + 250 && 
                                                raptor.y >= -250 && raptor.y <= GAME_HEIGHT + 250;
                        
                        // Âè™Âú®ÁåõÁ¶ΩÂú®Â±èÂπïÂÜÖÊó∂ÊâçÂèØËÉΩÊîæÂºÉËøΩÈÄê
                        if (isRaptorOnScreen) {
                            let abandonChance = 0;
                            if (chaser.name === "ÂñúÈπä") {
                                abandonChance = 0.03;
                            } else if (chaser.name === "‰πåÈ∏¶") {
                                abandonChance = 0.01;
                            }
                            
                            if (Math.random() < abandonChance) {
                                chaser.isChasingRaptor = false;
                                chaser.chasingTarget = null;
                                if (chaser.originalState) {
                                    chaser.state = chaser.originalState;
                                }
                                if (chaser.originalSpeed) {
                                    chaser.speed = chaser.originalSpeed;
                                }
                                const index = chasingMagpiesCrows.indexOf(chaser);
                                if (index !== -1) {
                                    chasingMagpiesCrows.splice(index, 1);
                                }
                                
                                // Â¶ÇÊûúÊâÄÊúâËøΩÈÄêËÄÖÈÉΩÊîæÂºÉ‰∫ÜÔºåÁåõÁ¶ΩÊÅ¢Â§çÊ≠£Â∏∏Âπ∂Ê†áËÆ∞‰∏∫Â∑≤Ë¢´ËøΩÈÄêËøá
                                if (raptor && raptor.isChasedPatrolling) {
                                    const remainingChasers = chasingMagpiesCrows.filter(c => c.chasingTarget === raptor);
                                    if (remainingChasers.length === 0) {
                                        raptor.isChasedPatrolling = false;
                                        raptor.isFleeingFromChasers = false;
                                        raptor.forcedToLeave = false;
                                        raptor.hasPatrolStarted = false;
                                        raptor.hasBeenChased = true; // Ê†áËÆ∞‰∏∫Â∑≤Ë¢´ËøΩÈÄêËøá
                                        if (raptor.originalState) {
                                            raptor.state = raptor.originalState;
                                        }
                                        if (raptor.originalSpeed) {
                                            raptor.speed = raptor.originalSpeed;
                                        }
                                        console.log("ÊâÄÊúâËøΩÈÄêËÄÖÊîæÂºÉÔºåÁåõÁ¶ΩÊÅ¢Â§çÊ≠£Â∏∏ÔºåÊ†áËÆ∞‰∏∫Â∑≤Ë¢´ËøΩÈÄêËøá");
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            // Êõ¥Êñ∞ËøΩÈÄêËÄÖ‰ΩçÁΩÆ
            let dynamicTargetDistance = targetDistance;
            if (distance > birdSize * 1.5) {
                dynamicTargetDistance = birdSize * 0.4;
            } else if (distance < birdSize * 0.3) {
                dynamicTargetDistance = birdSize * 1.0;
            }
            
            const angle = Math.atan2(dy, dx);
            const targetX = raptor.x - Math.cos(angle) * dynamicTargetDistance;
            const targetY = raptor.y - Math.sin(angle) * dynamicTargetDistance;
            const targetDx = targetX - chaser.x;
            const targetDy = targetY - chaser.y;
            const targetDist = Math.sqrt(targetDx * targetDx + targetDy * targetDy);
            
            if (targetDist > 5) {
                const moveSpeed = chaser.speed;
                chaser.x += (targetDx / targetDist) * moveSpeed;
                chaser.y += (targetDy / targetDist) * moveSpeed;
                chaser.direction = targetDx > 0 ? 1 : -1;
            } else {
                chaser.x = targetX;
                chaser.y = targetY;
                chaser.direction = raptor.direction;
            }
            
            // Â¶ÇÊûúÁåõÁ¶ΩÂ∑≤ÁªèÈ£ûÁ¶ªÔºåËøΩÈÄêËÄÖÊîæÂºÉ
            if (!birds.includes(raptor)) {
                chaser.isChasingRaptor = false;
                chaser.chasingTarget = null;
                chaser.state = 'fleeing';
                chaser.speed = 2.0;
                chaser.direction = -1;
                const index = chasingMagpiesCrows.indexOf(chaser);
                if (index !== -1) {
                    chasingMagpiesCrows.splice(index, 1);
                }
            }
        } else {
            chaser.isChasingRaptor = false;
            chaser.chasingTarget = null;
            if (chaser.originalState) {
                chaser.state = chaser.originalState;
            }
            if (chaser.originalSpeed) {
                chaser.speed = chaser.originalSpeed;
            }
            chasingMagpiesCrows.splice(i, 1);
        }
    }
    
    // Êõ¥Êñ∞ÁåõÁ¶ΩÁöÑËøΩÈÄêÂ∑°ÈÄªË°å‰∏∫
    raptorsPresent.forEach(raptor => {
        if (raptor.state === 'chasedPatrolling' && raptor.isChasedPatrolling) {
            const patrolDuration = gameTime - raptor.chasedPatrolStartTime;
            
            switch (raptor.chasedPatrolStage) {
                case 0: // a) ‰ªé‰∏≠Â§ÆÈ£ûÂá∫Âè≥‰æß
                    raptor.x += raptor.speed * raptor.direction;
                    raptor.y += Math.sin(gameTime * 0.005) * 1; // ËΩªÂæÆ‰∏ä‰∏ãÊ≥¢Âä®
                    
                    // È£ûÂá∫Âè≥‰æßÂêéËøõÂÖ•‰∏ã‰∏ÄÈò∂ÊÆµ
                    if (raptor.x > GAME_WIDTH + 100) {
                        raptor.chasedPatrolStage = 1;
                        raptor.chasedPatrolStartTime = gameTime;
                        // b) 1-2ÁßíÂêéÂÜç‰ªéÂè≥‰æßÈ£ûÂÖ•
                        raptor.chasedPatrolDelay = 1000 + Math.random() * 1000;
                        raptor.direction = -1; // ÂêëÂ∑¶È£û
                        raptor.x = GAME_WIDTH + 100; // ÈáçÁΩÆÂà∞Âè≥‰æßÂ§ñ
                        raptor.y = GAME_HEIGHT * 0.3 + Math.random() * (GAME_HEIGHT * 0.2);
                        console.log("ÁåõÁ¶ΩËøõÂÖ•Èò∂ÊÆµ1: Á≠âÂæÖÂêé‰ªéÂè≥‰æßÈ£ûÂÖ•");
                    }
                    break;
                    
                case 1: // b) ‰ªéÂè≥‰æßÈ£ûÂÖ•Ëá≥Â∑¶‰æßÈ£ûÂá∫
                    if (patrolDuration < raptor.chasedPatrolDelay) {
                        // Á≠âÂæÖÂª∂Ëøü
                        // ‰ΩçÁΩÆÂ∑≤ÁªèÂú®‰∏ä‰∏Ä‰∏™Èò∂ÊÆµËÆæÁΩÆÂ•Ω‰∫Ü
                    } else {
                        // ‰ªéÂè≥‰æßÈ£ûÂÖ•
                        raptor.x += raptor.speed * raptor.direction;
                        raptor.y += Math.sin(gameTime * 0.005) * 1;
                        
                        // È£ûÂá∫Â∑¶‰æßÂêéËøõÂÖ•‰∏ã‰∏ÄÈò∂ÊÆµ
                        if (raptor.x < -100) {
                            raptor.chasedPatrolStage = 2;
                            raptor.chasedPatrolStartTime = gameTime;
                            // c) 0.5-1ÁßíÂÜç‰ªéÂ∑¶‰æßÈ£ûÂÖ•
                            raptor.chasedPatrolDelay = 500 + Math.random() * 500;
                            raptor.direction = 1; // ÂêëÂè≥È£û
                            raptor.x = -100; // ÈáçÁΩÆÂà∞Â∑¶‰æßÂ§ñ
                            raptor.y = GAME_HEIGHT * 0.3 + Math.random() * (GAME_HEIGHT * 0.2);
                            
                            // ËøôÈáå‰∏çÂ¢ûÂä†Âæ™ÁéØÊ¨°Êï∞ÔºåÂõ†‰∏∫ËøôÊòØ‰∏Ä‰∏™ÂÆåÊï¥ÁöÑÊù•Âõû
                            console.log("ÁåõÁ¶ΩËøõÂÖ•Èò∂ÊÆµ2: Á≠âÂæÖÂêé‰ªéÂ∑¶‰æßÈ£ûÂÖ•");
                        }
                    }
                    break;
                    
                case 2: // c) ‰ªéÂ∑¶‰æßÈ£ûÂÖ•Ëá≥Âè≥‰æßÈ£ûÂá∫
                    if (patrolDuration < raptor.chasedPatrolDelay) {
                        // Á≠âÂæÖÂª∂Ëøü
                        // ‰ΩçÁΩÆÂ∑≤ÁªèÂú®‰∏ä‰∏Ä‰∏™Èò∂ÊÆµËÆæÁΩÆÂ•Ω‰∫Ü
                    } else {
                        // ‰ªéÂ∑¶‰æßÈ£ûÂÖ•
                        raptor.x += raptor.speed * raptor.direction;
                        raptor.y += Math.sin(gameTime * 0.005) * 1;
                        
                        // È£ûÂá∫Âè≥‰æßÂêéÂõûÂà∞Èò∂ÊÆµ1ÔºåÂ¢ûÂä†Âæ™ÁéØÊ¨°Êï∞
                        if (raptor.x > GAME_WIDTH + 100) {
                            raptor.chasedPatrolStage = 1;
                            raptor.chasedPatrolStartTime = gameTime;
                            raptor.chasedPatrolDelay = 1000 + Math.random() * 1000;
                            raptor.chasedPatrolLoops++;
                            raptor.direction = -1; // ÂêëÂ∑¶È£û
                            raptor.x = GAME_WIDTH + 100; // ÈáçÁΩÆÂà∞Âè≥‰æßÂ§ñ
                            raptor.y = GAME_HEIGHT * 0.3 + Math.random() * (GAME_HEIGHT * 0.2);
                            console.log("ÁåõÁ¶ΩÂõûÂà∞Èò∂ÊÆµ1: Á≠âÂæÖÂêé‰ªéÂè≥‰æßÈ£ûÂÖ•ÔºåÂæ™ÁéØÊ¨°Êï∞: " + raptor.chasedPatrolLoops + "/" + raptor.maxPatrolLoops);
                            
                            // Ê£ÄÊü•Âæ™ÁéØÊ¨°Êï∞
                            if (raptor.chasedPatrolLoops >= raptor.maxPatrolLoops) {
                                // Â¶ÇÊûúÂñúÈπäÊàñ‰πåÈ∏¶ËøòÊ≤°ÊúâÊîæÂºÉËøΩÈÄêÔºåÁåõÁ¶ΩÈ£ûÁ¶ª
                                const remainingChasers = chasingMagpiesCrows.filter(c => c.chasingTarget === raptor);
                                if (remainingChasers.length > 0) {
                                    raptor.isChasedPatrolling = false;
                                    raptor.isFleeingFromChasers = true;
                                    raptor.fleeFromChasersStartTime = gameTime;
                                    raptor.fleeDirection = -1;
                                    raptor.fleeSpeed = raptor.originalSpeed * 1.2;
                                    raptor.state = 'fleeingFromChasers';
                                    raptor.hasPatrolStarted = false;
                                    raptor.hasBeenChased = true; // Ê†áËÆ∞‰∏∫Â∑≤Ë¢´ËøΩÈÄêËøá
                                    
                                    // Ê∏ÖÈô§ËøΩÈÄêËÄÖ
                                    for (let j = chasingMagpiesCrows.length - 1; j >= 0; j--) {
                                        const chaser = chasingMagpiesCrows[j];
                                        if (chaser.chasingTarget === raptor) {
                                            chaser.isChasingRaptor = false;
                                            chaser.chasingTarget = null;
                                            if (chaser.originalState) {
                                                chaser.state = chaser.originalState;
                                            }
                                            if (chaser.originalSpeed) {
                                                chaser.speed = chaser.originalSpeed;
                                            }
                                            chasingMagpiesCrows.splice(j, 1);
                                        }
                                    }
                                    console.log("ÁåõÁ¶ΩÈ£ûÁ¶ªÔºåÂæ™ÁéØÂÆåÊàêÔºåÊ†áËÆ∞‰∏∫Â∑≤Ë¢´ËøΩÈÄêËøá");
                                } else {
                                    // Ê≤°ÊúâËøΩÈÄêËÄÖ‰∫ÜÔºåÊÅ¢Â§çÊ≠£Â∏∏Âπ∂Ê†áËÆ∞‰∏∫Â∑≤Ë¢´ËøΩÈÄêËøá
                                    raptor.isChasedPatrolling = false;
                                    raptor.hasPatrolStarted = false;
                                    raptor.hasBeenChased = true; // Ê†áËÆ∞‰∏∫Â∑≤Ë¢´ËøΩÈÄêËøá
                                    if (raptor.originalState) {
                                        raptor.state = raptor.originalState;
                                    }
                                    if (raptor.originalSpeed) {
                                        raptor.speed = raptor.originalSpeed;
                                    }
                                    console.log("ÁåõÁ¶ΩÊÅ¢Â§çÊ≠£Â∏∏ÔºåÊó†ËøΩÈÄêËÄÖÔºåÊ†áËÆ∞‰∏∫Â∑≤Ë¢´ËøΩÈÄêËøá");
                                }
                            }
                        }
                    }
                    break;
            }
        }
        
        if (raptor.isFleeingFromChasers && raptor.state === 'fleeingFromChasers') {
            const fleeAngle = (15 + Math.random() * 10) * Math.PI / 180;
            raptor.x += raptor.fleeSpeed * raptor.fleeDirection * Math.cos(fleeAngle);
            raptor.y -= raptor.fleeSpeed * Math.sin(fleeAngle);
            
            // È£ûÂá∫Â±èÂπïÂêéÁßªÈô§
            if (raptor.x < -500 || raptor.x > GAME_WIDTH + 500 || raptor.y < -500) {
                const index = birds.indexOf(raptor);
                if (index !== -1) {
                    birds.splice(index, 1);
                    console.log("ÁåõÁ¶ΩÈ£ûÂá∫Â±èÂπïË¢´ÁßªÈô§");
                }
            }
        }
    });
    
    // Êõ¥Êñ∞ËøΩÈÄêËÄÖ‰ΩçÁΩÆÔºàÈíàÂØπÊ≠£Âú®ËøΩÈÄêÁöÑÁåõÁ¶ΩÔºâ
    chasingMagpiesCrows.forEach(chaser => {
        if (chaser.chasingTarget && birds.includes(chaser.chasingTarget)) {
            const raptor = chaser.chasingTarget;
            const dx = raptor.x - chaser.x;
            const dy = raptor.y - chaser.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const birdSize = 20 * chaser.size;
            const targetDistance = birdSize * 1.5;
            
            const angle = Math.atan2(dy, dx);
            const targetX = raptor.x - Math.cos(angle) * targetDistance;
            const targetY = raptor.y - Math.sin(angle) * targetDistance;
            const targetDx = targetX - chaser.x;
            const targetDy = targetY - chaser.y;
            const targetDist = Math.sqrt(targetDx * targetDx + targetDy * targetDy);
            
            if (targetDist > 5) {
                chaser.x += (targetDx / targetDist) * chaser.speed;
                chaser.y += (targetDy / targetDist) * chaser.speed;
                chaser.direction = targetDx > 0 ? 1 : -1;
            } else {
                chaser.speed = raptor.speed;
                chaser.x = targetX;
                chaser.y = targetY;
                chaser.direction = raptor.direction;
            }
        }
    });
    
    let hasKestrel = false;
    for (const bird of birds) {
        if (bird.name === "Á∫¢Èöº") {
            hasKestrel = true;
            break;
        }
    }
    
    if (!isNightMode && gameTime - lastDoveSummonCheck > DOVE_SUMMON_INTERVAL && !hasKestrel) {
        let doveCount = 0;
        for (const bird of birds) {
            if (bird.name === "ÊñëÈ∏†") {
                doveCount++;
            }
        }
        if (doveCount >= 2 && Math.random() < 0.8) {
            generateKestrel(true);
        }
        lastDoveSummonCheck = gameTime;
    }
    
    // Êõ¥Êñ∞ÊôÆÈÄöÈ∏üÁ±ªÁöÑË°å‰∏∫
    for (let i = birds.length - 1; i >= 0; i--) {
        const bird = birds[i];
    
    // Áø†È∏üÁâπÊÆäË°å‰∏∫ÈÄªËæë
    if (bird.isKingfisher) {
      updateKingfisher(bird, deltaTime);
      continue;
    }
        // ÈïøËÄ≥È∏ÆÁöÑÁâπÊÆäÊ∂àÂ§±ÈÄªËæë
    if (bird.name === "ÈïøËÄ≥È∏Æ" && bird.state === 'perching') {
      bird.stateTime += deltaTime;
      
      // ÂÅúÁïôÊó∂Èó¥ÁªìÊùüÂêéÁõ¥Êé•Ê∂àÂ§±Ôºà‰∏çÊòØÈ£ûÁ¶ªÔºâ
      if (bird.stateTime >= (bird.stayTime * 1000)) {
        // Áõ¥Êé•ÁßªÈô§Ôºå‰∏ç‰ªéÊ†ë‰∏äÈ£ûÁ¶ª
        birds.splice(i, 1);
        continue;
 // Á¨¨3È°π‰øÆÊîπÂºÄÂßãÔºöÂ∞èÁªÑÂçèË∞ÉÈÄªËæë
    if (bird.groupId && birdGroupInfo[bird.groupId]) {
        const group = birdGroupInfo[bird.groupId];

        // ‰∏∫ÈáëÁú∂È∏ªÂíå12000È∏ªÊ∑ªÂä†Â∞èÁªÑÂçèË∞É
        if ((bird.name === "ÈáëÁú∂È∏ª" || bird.name === "12000È∏ª") && group.behavior) {
            // Â¶ÇÊûúÂ∞èÁªÑÂÜ≥ÂÆöÈôçËêΩËä¶ËãáÔºåÁ°Æ‰øùÊâÄÊúâÊàêÂëòÈÉΩÊâßË°å
            if (group.behavior === "landOnReeds" && reedZone) {
                // Â¶ÇÊûúËøôÂè™È∏ü‰∏çÂú®ÈôçËêΩÁä∂ÊÄÅÔºå‰ΩÜÂ∞èÁªÑÂú®ÈôçËêΩÔºåÂàôËÆ©ÂÆÉ‰πüÂºÄÂßãÈôçËêΩ
                if (!bird.isLandingOnReeds && bird.state !== 'landingOnReeds' && bird.state !== 'onReedsGround') {
                    bird.reedTargetX = group.reedTargetX + (Math.random() - 0.5) * 40;
                    bird.reedTargetY = group.reedTargetY + (Math.random() - 0.5) * 15;
                    bird.state = 'landingOnReeds';
                    bird.groundDirection = group.groundDirection;
                    bird.isLandingOnReeds = true;
                }
            }

            // Â¶ÇÊûúÂ∞èÁªÑÂÜ≥ÂÆöÈ£ûËµ∞ÔºåÁ°Æ‰øùÊâÄÊúâÊàêÂëòÈÉΩÁ¶ªÂºÄ
            if (group.behavior === "flyThrough") {
                // Á°Æ‰øùÊâÄÊúâÊàêÂëòÈÉΩÂú®È£ûË°åÁä∂ÊÄÅ
                if (bird.state === 'landingOnReeds' || bird.state === 'onReedsGround') {
                    bird.state = 'takingOff';
                    bird.stateTime = 0;
                    bird.speed = 2.5 + Math.random();
                    bird.direction = group.direction;
                    bird.isLandingOnReeds = false;
                }
            }
        }
    }
      }
    }
        // Ë∑≥ËøáÁâπÊÆäÁä∂ÊÄÅÁöÑÈ∏ü
        if (bird.isChasingRaptor || bird.isFleeingFromChasers || bird.isChasedPatrolling) {
            continue;
        }
        
        // Â§ÑÁêÜË¢´ÁåõÁ¶ΩÊÉäÂêìÁöÑÈ∏ü
        if (bird.isFleeingFromRaptor && !(bird.name === "ÈáëÁú∂È∏ª" || bird.name === "12000È∏ª")) {
            const fleeAngle = (10 + Math.random() * 10) * Math.PI / 180;
            bird.x += bird.speed * bird.direction * Math.cos(fleeAngle);
            bird.y -= bird.speed * Math.sin(fleeAngle);
            
            if (bird.x < -500 || bird.x > GAME_WIDTH + 500 || bird.y < -500 || bird.y > GAME_HEIGHT + 500) {
                birds.splice(i, 1);
            }
            continue;
        }
                     
    
    
    if (bird.isHidingFromRaptor) {
        continue;
    }
    
    if (bird.isChasingRaptor) {
        continue;
    }
    
    if (bird.isFleeingFromChasers) {
        continue;
    }
    
    bird.stateTime += deltaTime;
    
    if (bird.name === "Â∞èÈ∏Æ") {
        if (bird.state === 'appearing') {
            bird.state = 'perching';
        }
        
        if (bird.stateTime > (bird.stayTime || 15) * 1000) {
            if (littleOwl === bird) {
                littleOwl = null;
            }
            birds.splice(i, 1);
            continue;
        }
        continue;
    }
    
    if (bird.isBat) {
        updateBat(bird, deltaTime);
        continue;
    }
    
    if (bird.isOwl) {
        updateOwlBird(bird, deltaTime);
        continue;
    }
    
    const behavior = bird.actualBehavior || bird.type.behavior;
    
    if (bird.state === 'perching' && bird.eatFruits && !bird.isEating) {
            if (Math.random() < bird.eatProbability * (deltaTime / 1000)) {
                startEatingFruit(bird);
            }
        }
        
        if (bird.isEating && bird.eatingFruit) {
            bird.eatingTime += deltaTime;
            bird.eatAnimationOffset = Math.sin(bird.eatingTime * 0.01) * 3;
            bird.size = bird.originalSize + Math.sin(bird.eatingTime * 0.005) * 0.1;
            
            if (bird.eatingTime > bird.eatDuration) {
                finishEatingFruit(bird);
            }
        }
        
if (bird.name === "‰πåÈ∏´" && bird.state === 'flying') {
            if (!bird.lastPoopTime) {
                bird.lastPoopTime = gameTime;
            }
            
            // Ê£ÄÊü•ÊòØÂê¶Âà∞‰∫ÜÊãâÂ±éÁöÑÊó∂Èó¥Èó¥Èöî
            if (gameTime - bird.lastPoopTime > bird.poopInterval) {
                // Ê£ÄÊü•Ê¶ÇÁéá
                if (Math.random() < bird.poopProbability) {
                    // ËÆ°ÁÆóÁ≤™‰æø‰ΩçÁΩÆ
                    let poopX, poopY;
                    const baseSize = 20;
                    const birdSize = baseSize * bird.size;
                    const bodyRadius = birdSize / 2;
                    
                    // ÂàõÂª∫Á≤™‰æø
                    const poopSize = (2.5 + Math.random());
                    const poop = {
                        x: bird.x,
            y: bird.y + bodyRadius,
                        size: poopSize,
                        color: bird.poopColor || "#FFFFFF",
                        speed: 1 + Math.random() * 0.5,
                        createdAt: gameTime,
                        lifetime: 10000, // 10ÁßíÂêéÊ∂àÂ§±
                        direction: bird.direction
                    };
                    
                    poops.push(poop);
                }
                // Êó†ËÆ∫ÊòØÂê¶ÊãâÂ±éÔºåÈÉΩÈáçÁΩÆËÆ°Êó∂Âô®
                bird.lastPoopTime = gameTime;
            }
        }
        
        if (bird.name === "ÂïÑÊú®È∏ü" && bird.state === 'perching') {
            if (bird.stateTime % 1000 < 200) {
                bird.headOffsetX = 5 * (bird.targetTree.side === 'left' ? 1 : -1);
            } else {
                bird.headOffsetX = 0;
            }
        }
  
// ‰øÆÂ§çÔºöÁ°Æ‰øùËßÇÈ∏üÊ®°Âºè‰∏ãÊ†ëÊ†ñÈ∏üÁöÑÁ¶ªÂºÄË°å‰∏∫Ê≠£Â∏∏Â∑•‰Ωú
if (bird.state === 'perching' && bird.targetTree) {
  // Á°Æ‰øùËßÇÈ∏üÊ®°Âºè‰∏çÂΩ±ÂìçÁ¶ªÂºÄÊó∂Èó¥
  if (bird.stateTime > (bird.stayTime || 10) * 1000) {
// Â¶ÇÊûúÊòØÈïøËÄ≥È∏ÆÔºåÂàôË∑≥ËøáÈÄöÁî®Â§ÑÁêÜ
        if (bird.name === "ÈïøËÄ≥È∏Æ") {
            continue;
        }
    // Â¶ÇÊûúÈ∏üÊúâÁ¶ªÂºÄÊù°‰ª∂ÔºàÊØîÂ¶ÇÂêÉÂÆåÊûúÂÆûÔºâÔºåÂ∞±Á¶ªÂºÄ
    if (!bird.isEating || bird.eatingTime > (bird.eatDuration || 2000)) {
      bird.state = 'takingOff';
      bird.speed = 2.0;
      bird.direction = bird.targetTree.side === 'left' ? 1 : -1;
      bird.stateTime = 0;
      // ‰øÆÂ§çÔºöÁ°Æ‰øùÈ∏ü‰∏ç‰ºöÂú®ËßÇÈ∏üÊ®°Âºè‰∏ãÂç°‰Ωè
      bird.isChasingRaptor = false;
      bird.isFleeingFromRaptor = false;
      bird.isFleeingFromChasers = false;
    }
  }
}      
        // Âú® updateBirds ÂáΩÊï∞‰∏≠ÔºåÊâæÂà∞Ê£ïÂ§¥È∏¶ÈõÄÁöÑÂ§ÑÁêÜÈÉ®ÂàÜÔºå‰øÆÊîπÂ¶Ç‰∏ãÔºö

if (bird.name === "Ê£ïÂ§¥È∏¶ÈõÄ" && behavior === "flyInReedsAndStay") {
    // Á°Æ‰øùÊØèÂè™È∏üÈÉΩÊúâÈÄüÂ∫¶Â∑ÆÂºÇÂèÇÊï∞ÔºàÂú®ËøõÂÖ•Ëä¶ËãáÂå∫Êó∂ÂàùÂßãÂåñÔºâ
    if (!bird.reedSpeedFactor) {
        // ‰∏∫ÊØèÂè™È∏üÁîüÊàêÈöèÊú∫ÈÄüÂ∫¶Â∑ÆÂºÇÂèÇÊï∞Ôºà¬±25%ÔºåÊúÄÂ§ß50%Â∑ÆÂºÇÔºâ
        bird.reedSpeedFactor = 0.75 + Math.random() * 0.5; // 0.75 ~ 1.25
    }
    
    if (bird.state === 'flying') {
        if (bird.y < reedZone.y) {
            bird.y = reedZone.y + Math.random() * 10;
        } else if (bird.y > reedZone.y + reedZone.height) {
            bird.y = reedZone.y + reedZone.height - Math.random() * 10;
        }
        
        if (bird.x > reedZone.x && bird.x < reedZone.x + reedZone.width) {
            bird.state = 'stayingInReeds';
            bird.stateTime = 0;
            // Â∫îÁî®‰∏™‰ΩìÈÄüÂ∫¶Â∑ÆÂºÇ
            bird.speed = 0.5 * bird.reedSpeedFactor; // Âü∫ÂáÜÈÄüÂ∫¶0.5Ôºå‰πò‰ª•ÈÄüÂ∫¶Âõ†Â≠ê
        }
    } else if (bird.state === 'stayingInReeds') {
        // Â∫îÁî®‰∏™‰ΩìÈÄüÂ∫¶Â∑ÆÂºÇÁöÑÊ®™ÂêëÁßªÂä®
        bird.x += bird.speed * bird.direction;
        bird.y += Math.sin(bird.stateTime * 0.005) * 0.3;
        
        if (bird.x < reedZone.x || bird.x > reedZone.x + reedZone.width) {
            bird.state = 'takingOff';
            // Ëµ∑È£ûÈÄüÂ∫¶‰πüÂ∫îÁî®‰∏™‰ΩìÂ∑ÆÂºÇ
            bird.speed = 1.0 * bird.reedSpeedFactor;
            if (bird.groupId && birdGroupInfo[bird.groupId]) {
                bird.direction = birdGroupInfo[bird.groupId].direction;
            }
        }
    }
}
        
// Âú® updateBirds ÂáΩÊï∞‰∏≠Ôºå‰øÆÊîπÈ∫ªÈõÄÂíåÂ∞èÂåóÁöÑÂ§ÑÁêÜÈÄªËæëÔºö

if ((bird.name === "È∫ªÈõÄ" || bird.name === "Â∞èÂåó") && 
    (bird.actualBehavior === "flyToReedsAndStay" || 
     bird.type.behavior === "flyToReedsAndStay")) {
    
    let reedStayTime = bird.reedStayTime;
    if (!reedStayTime) {
        reedStayTime = bird.name === "È∫ªÈõÄ" ? 15000 : 20000;
    }
    
    let reedMoveSpeed = bird.reedMoveSpeed;
    if (!reedMoveSpeed) {
        reedMoveSpeed = bird.name === "È∫ªÈõÄ" ? 0.5 * 0.2 : 0.6 * 0.2; // Èôç‰∏∫ÂéüÊù•ÁöÑ1/5
    }
    
    switch (bird.state) {
        case 'flying':
            // Âè™Âú®ËøõÂÖ•Ëä¶ËãáÂå∫ÂâçËÆæÁΩÆ‰∏ÄÊ¨°ÁõÆÊ†áÁÇπÔºåÈÅøÂÖçÈáçÂ§çËÆæÁΩÆÂØºËá¥Ë∑≥Âèò
            if (!bird.reedTargetX && reedZone) {
                // ËÆæÁΩÆÁõÆÊ†áÁÇπÂú®Ëä¶ËãáÂå∫‰∏≠ÂøÉ‰∏âÂàÜ‰πã‰∏ÄÂå∫ÂüüÂÜÖ
                const centerThirdWidth = reedZone.width / 3;
                const centerThirdLeft = reedZone.x + reedZone.width / 3;
                
                bird.reedTargetX = centerThirdLeft + Math.random() * centerThirdWidth;
                bird.reedTargetY = reedZone.y + reedZone.height * 0.5 + Math.random() * reedZone.height * 0.3;
                
                // ËÆ∞ÂΩïÂºÄÂßãÈôçËêΩÁöÑÊó∂Èó¥ÔºåÁî®‰∫éÂπ≥ÊªëËøáÊ∏°
                bird.landingStartTime = gameTime;
                bird.landingDuration = (1000 + Math.random() * 500) * 5; // Âª∂Èïø5ÂÄçÔºåÈôç‰ΩéÈÄüÂ∫¶
                bird.landingStartX = bird.x;
                bird.landingStartY = bird.y;
                
                // Èôç‰ΩéÈ£ûË°åÈÄüÂ∫¶Âà∞ÂéüÊù•ÁöÑ1/5
                bird.speed *= 0.2;
            }
            
            if (bird.reedTargetX && bird.reedTargetY) {
                const elapsedTime = gameTime - bird.landingStartTime;
                const progress = Math.min(elapsedTime / bird.landingDuration, 1);
                
                // ‰ΩøÁî®ÁºìÂä®ÂáΩÊï∞ÂÆûÁé∞Âπ≥ÊªëÈôçËêΩ
                const easeProgress = easeInOutQuad(progress);
                
                // ËÆ°ÁÆóÂπ≥ÊªëÁöÑÈôçËêΩ‰ΩçÁΩÆ
                bird.x = bird.landingStartX + (bird.reedTargetX - bird.landingStartX) * easeProgress;
                bird.y = bird.landingStartY + (bird.reedTargetY - bird.landingStartY) * easeProgress;
                
                // Âú®ÈôçËêΩËøáÁ®ã‰∏≠‰øùÊåÅÂêàÁêÜÁöÑÈÄüÂ∫¶ÊÑü
                const speedFactor = 1 - (progress * 0.7); // Ë∂äÊé•ËøëÁõÆÊ†áÈÄüÂ∫¶Ë∂äÊÖ¢
                bird.direction = (bird.reedTargetX - bird.landingStartX) > 0 ? 1 : -1;
                
                // ÂΩìÈùûÂ∏∏Êé•ËøëÁõÆÊ†áÁÇπÊó∂ÔºåÂàáÊç¢Âà∞ÂÅúÁïôÁä∂ÊÄÅ
                if (progress >= 0.95 || elapsedTime > bird.landingDuration) {
                    // Á°Æ‰øùÊúÄÁªà‰ΩçÁΩÆÂú®Ëä¶ËãáÂå∫ÂÜÖ
                    const centerThirdWidth = reedZone.width / 3;
                    const centerThirdLeft = reedZone.x + reedZone.width / 3;
                    const centerThirdRight = centerThirdLeft + centerThirdWidth;
                    
                    bird.x = Math.max(centerThirdLeft, Math.min(centerThirdRight, bird.reedTargetX));
                    bird.y = Math.max(reedZone.y, Math.min(reedZone.y + reedZone.height, bird.reedTargetY));
                    
                    // Âπ≥ÊªëÂàáÊç¢Âà∞ÂÅúÁïôÁä∂ÊÄÅ
                    bird.state = 'stayingInReeds';
                    bird.stateTime = 0;
                    bird.speed = reedMoveSpeed;
                    bird.reedStayTime = reedStayTime;
                    
                    // ËÆæÁΩÆ‰∏Ä‰∏™Â∞èÁöÑÈöèÊú∫ÁßªÂä®ËåÉÂõ¥ÔºåÈÅøÂÖçÂÆåÂÖ®ÈùôÊ≠¢
                    bird.reedsMoveRangeX = 15;
                    bird.reedsMoveRangeY = 8;
                    bird.reedsMoveTimer = 0;
                    bird.reedsMoveSpeed = (0.2 + Math.random() * 0.3) * 1; 
                    
                    // Ê∏ÖÈô§ÈôçËêΩÊï∞ÊçÆ
                    bird.reedTargetX = null;
                    bird.reedTargetY = null;
                    bird.landingStartTime = null;
                }
            }
            break;
            
        case 'stayingInReeds':
    bird.stateTime += deltaTime;
    
    // ÂàùÂßãÂåñË∑≥Ë∑ÉÁõ∏ÂÖ≥Â±ûÊÄß
    if (bird.jumpInterval === undefined) {
        bird.jumpInterval = 2000 + Math.random() * 3000; // 2-5ÁßíÈöèÊú∫Èó¥Èöî
        bird.lastJumpTime = gameTime;
        bird.jumpDirection = bird.direction; // Â§¥ÈÉ®ÊúùÂêëÂÜ≥ÂÆöË∑≥Ë∑ÉÊñπÂêë
    }
    
    // Ê£ÄÊü•ÊòØÂê¶Âà∞ËææËä¶ËãáÈ°∂ÈÉ®
    const reedTopThreshold = reedZone.y + 20; // Ëä¶ËãáÈ°∂ÈÉ®ÈòàÂÄº
    if (bird.y <= reedTopThreshold && !bird.reachedTop) {
        bird.reachedTop = true;
        bird.topStayStartTime = gameTime;
        bird.speed = 0; // Âà∞ËææÈ°∂ÈÉ®ÂêéÂÅúÊ≠¢ÁßªÂä®
    }
    
    // Â¶ÇÊûúÂà∞ËææÈ°∂ÈÉ®ÔºåÂÅúÁïô5ÁßíÂêéÁ¶ªÂºÄ
    if (bird.reachedTop) {
        if (gameTime - bird.topStayStartTime > 5000) {
            bird.state = 'takingOffFromReeds';
            bird.stateTime = 0;
            bird.speed = (bird.name === "È∫ªÈõÄ" ? 1.5 : 1.3);
            bird.direction = Math.random() > 0.5 ? 1 : -1;
            bird.takeoffStartX = bird.x;
            bird.takeoffStartY = bird.y;
            bird.takeoffStartTime = gameTime;
            bird.takeoffDuration = (1000 + Math.random() * 500) * 3;
            bird.takeoffTargetX = bird.x + (bird.direction === 1 ? 300 : -300);
            bird.takeoffTargetY = -50;
        }
        continue;
    }
    
    // ÊØèÈöî1-5ÁßíË∑≥Ë∑É‰∏ÄÊ¨°
    if (gameTime - bird.lastJumpTime > bird.jumpInterval) {
        bird.lastJumpTime = gameTime;
        bird.jumpInterval = 1000 + Math.random() * 4000; // ÈáçÊñ∞ËÆæÁΩÆË∑≥Ë∑ÉÈó¥Èöî
        
        // Ê†πÊçÆÂ§¥ÈÉ®ÊúùÂêëÂÜ≥ÂÆöË∑≥Ë∑ÉÊñπÂêë
        const jumpAngle = bird.jumpDirection === 1 ? 
            -Math.PI/4 :  // ÂêëÂè≥‰∏äË∑≥Ôºà45Â∫¶ËßíÔºâ
            -3*Math.PI/4; // ÂêëÂ∑¶‰∏äË∑≥Ôºà135Â∫¶ËßíÔºâ
        
        // Ë∑≥Ë∑ÉË∑ùÁ¶ªÔºà‰∏Ä‰∏™Ë∫´‰ΩçÔºâ
        const jumpDistance = 40 * bird.size;
        
        // ËÆ°ÁÆóÊñ∞‰ΩçÁΩÆ
        const newX = bird.x + Math.cos(jumpAngle) * jumpDistance;
        const newY = bird.y + Math.sin(jumpAngle) * jumpDistance;
        
        // Ê£ÄÊü•ÊòØÂê¶Âú®Ëä¶ËãáÂå∫ÂüüÂÜÖ
        const centerThirdWidth = reedZone.width / 3;
        const centerThirdLeft = reedZone.x + reedZone.width / 3;
        const centerThirdRight = centerThirdLeft + centerThirdWidth;
        
        // ÈôêÂà∂Âú®Ëä¶ËãáÂå∫ÂüüÂÜÖ
        bird.x = Math.max(centerThirdLeft, Math.min(centerThirdRight, newX));
        bird.y = Math.max(reedZone.y, Math.min(reedZone.y + reedZone.height, newY));
        
        // Ë∑≥Ë∑ÉÂä®ÁîªÊïàÊûú
        bird.isJumping = true;
        bird.jumpStartTime = gameTime;
        bird.jumpDuration = 300; // Ë∑≥Ë∑ÉÂä®ÁîªÊåÅÁª≠Êó∂Èó¥
        bird.originalY = bird.y;
    }
    
    // Ë∑≥Ë∑ÉÂä®Áîª
    if (bird.isJumping) {
        const jumpElapsed = gameTime - bird.jumpStartTime;
        const jumpProgress = Math.min(jumpElapsed / bird.jumpDuration, 1);
        
        // ‰ΩøÁî®ÁºìÂä®ÂáΩÊï∞‰ΩøË∑≥Ë∑ÉÊõ¥Ëá™ÁÑ∂
        const easeProgress = easeInOutQuad(jumpProgress);
        
        // ËÆ°ÁÆóË∑≥Ë∑ÉÈ´òÂ∫¶ÔºàÊäõÁâ©Á∫øËΩ®ËøπÔºâ
        const maxJumpHeight = 10; // ÊúÄÂ§ßË∑≥Ë∑ÉÈ´òÂ∫¶
        const jumpHeight = 4 * maxJumpHeight * easeProgress * (1 - easeProgress);
        
        bird.y = bird.originalY - jumpHeight;
        
        // Ë∑≥Ë∑ÉÁªìÊùü
        if (jumpProgress >= 1) {
            bird.isJumping = false;
            bird.y = bird.originalY; // ÂõûÂà∞ÂéüÂßãÈ´òÂ∫¶
        }
    }
    
   
    // Ê£ÄÊü•ÊÄªÂÅúÁïôÊó∂Èó¥ÊòØÂê¶ÁªìÊùü
    if (bird.stateTime > bird.reedStayTime && !bird.reachedTop) {
        bird.state = 'takingOffFromReeds';
        bird.stateTime = 0;
        bird.speed = (bird.name === "È∫ªÈõÄ" ? 1.5 : 1.3);
        bird.direction = Math.random() > 0.5 ? 1 : -1;
        bird.takeoffStartX = bird.x;
        bird.takeoffStartY = bird.y;
        bird.takeoffStartTime = gameTime;
        bird.takeoffDuration = (1000 + Math.random() * 500) * 3;
        bird.takeoffTargetX = bird.x + (bird.direction === 1 ? 300 : -300);
        bird.takeoffTargetY = -50;
    }
    break;
            
// Âú® updateBirds ÂáΩÊï∞‰∏≠Ôºå‰øÆÊîπÈ∫ªÈõÄÂíåÂ∞èÂåóÁöÑËµ∑È£ûÈò∂ÊÆµÔºö

case 'takingOffFromReeds':
    bird.stateTime += deltaTime;
    if (!bird.takeoffInitialized) {
        bird.takeoffInitialized = true;
        bird.takeoffSpeed = bird.speed;
        // ‰øÆÊîπËøôÈáåÔºöËµ∑È£ûËßíÂ∫¶‰∏çË∂ÖËøá20Â∫¶
        bird.takeoffAngle = (10 + Math.random() * 10) * Math.PI / 180; // 10-20Â∫¶
        bird.takeoffVx = Math.cos(bird.takeoffAngle) * bird.takeoffSpeed * bird.direction;
        bird.takeoffVy = -Math.sin(bird.takeoffAngle) * bird.takeoffSpeed;
        bird.startTakeoffY = bird.y;
        bird.maxClimbHeight = Math.max(GAME_HEIGHT * 0.3, reedZone.y - 50);
    }
    bird.x += bird.takeoffVx;
    bird.y += bird.takeoffVy;
    if (bird.y < bird.maxClimbHeight) {
        bird.y = bird.maxClimbHeight;
        bird.takeoffVy = 0;
        if (bird.y < bird.startTakeoffY - 50) {
            bird.takeoffVy = -bird.takeoffSpeed * 0.1;
        }
    }
    const margin = 100;
    if (bird.x < -margin || bird.x > GAME_WIDTH + margin || bird.y < -margin || bird.y > GAME_HEIGHT + margin) {
        birds.splice(i, 1);
    }
    if (bird.stateTime > 15000) {
        birds.splice(i, 1);
    }
    break;
    }
    
    if (bird.state === 'stayingInReeds' || bird.state === 'takingOffFromReeds') {
        continue;
    }
}

// ‰øÆÊîπÂÖ∂‰ªñÈ∏üÁ±ªÂú®Ëä¶ËãáÂå∫ÁöÑË°å‰∏∫Ôºå‰ΩøÂÖ∂ÈÄÇÂ∫îÊñ∞ÁöÑËä¶ËãáÂå∫ÂÆΩÂ∫¶
if ((bird.name === "ÈáëÁú∂È∏ª" || bird.name === "12000È∏ª") && bird.isLandingOnReeds) {
    switch (bird.state) {
        case 'landingOnReeds':
            // Âú®ÈáëÁú∂È∏ªÂíå12000È∏ªÁöÑ‰ª£Á†Å‰∏≠Ôºå‰øÆÊîπÁõÆÊ†áÁÇπÈÄâÊã©Ôºö
if (!bird.reedTargetX && reedZone) {
    // Âú®Êï¥‰∏™Ëä¶ËãáÂå∫ÂÆΩÂ∫¶ÂÜÖÈÄâÊã©ÁõÆÊ†áÁÇπÔºàÊ≥®ÊÑèËä¶ËãáÂå∫Â∑¶‰æßÊúâ200ÂÉèÁ¥†Áº©ËøõÔºâ
    bird.reedTargetX = reedZone.x + Math.random() * reedZone.width;
    bird.reedTargetY = reedZone.y + reedZone.height - 3;
}
            
            if (bird.reedTargetX && bird.reedTargetY) {
                const dx = bird.reedTargetX - bird.x;
                const dy = bird.reedTargetY - bird.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 2) {
                    bird.state = 'onReedsGround';
                    bird.groundTime = 0;
                    bird.groundDirection = Math.random() > 0.5 ? 1 : -1;
                    bird.speed = bird.groundMoveSpeed || 0.3;
                } else {
                    bird.x += (dx / distance) * 2;
                    bird.y += (dy / distance) * 2;
                }
            }
            break;
            
case 'onReedsGround':
    bird.groundTime += deltaTime;
    
    // ‚úÖ Êñ∞Â¢ûÔºöÂ∞èÁªÑÂçèË∞ÉÂú∞Èù¢ÁßªÂä®
    // Â¶ÇÊûúÊúâÂ∞èÁªÑ‰ø°ÊÅØÔºå‰ΩøÁî®Â∞èÁªÑÁªü‰∏ÄÁöÑÂú∞Èù¢ÁßªÂä®ÊñπÂêë
    if (bird.groupId && birdGroupInfo[bird.groupId] && 
        (bird.name === "ÈáëÁú∂È∏ª" || bird.name === "12000È∏ª")) {
        
        const group = birdGroupInfo[bird.groupId];
        
        // ‰ΩøÁî®Â∞èÁªÑÁªü‰∏ÄÁöÑÂú∞Èù¢ÁßªÂä®ÊñπÂêë
        if (group.groundDirection) {
            bird.groundDirection = group.groundDirection;
        }
        
        // Â¶ÇÊûúÂ∞èÁªÑÊúâÁªü‰∏ÄÁöÑÁõÆÊ†á‰ΩçÁΩÆÔºåÁ°Æ‰øùÈ∏ü‰∏çË¶ÅÁ¶ªÂæóÂ§™Ëøú
        if (group.reedTargetX) {
            const distanceFromGroupCenter = Math.abs(bird.x - group.reedTargetX);
            
            // Â¶ÇÊûúÁ¶ªÂ∞èÁªÑ‰∏≠ÂøÉÂ§™ËøúÔºàË∂ÖËøá30ÂÉèÁ¥†ÔºâÔºåË∞ÉÊï¥ÊñπÂêëÂêë‰∏≠ÂøÉÁßªÂä®
            if (distanceFromGroupCenter > 30) {
                bird.groundDirection = bird.x > group.reedTargetX ? -1 : 1;
                // Êõ¥Êñ∞Â∞èÁªÑÊñπÂêëÔºåÁ°Æ‰øùÂÖ∂‰ªñÊàêÂëò‰πüË∑üÈöè
                group.groundDirection = bird.groundDirection;
            }
        }
        
        // ‚úÖ Â∞èÁªÑÁªü‰∏ÄÊîπÂèòÊñπÂêëÁöÑÈÄªËæë
        // ‰∏çÂÜçÊØèÂè™È∏üÁã¨Á´ãÊîπÂèòÊñπÂêëÔºåËÄåÊòØÁî±Â∞èÁªÑÁªü‰∏ÄÂÜ≥ÂÆö
        // ÂΩìÂ∞èÁªÑÁªü‰∏ÄÊîπÂèòÊñπÂêëÊó∂ÔºåÊâÄÊúâÊàêÂëò‰∏ÄËµ∑ÊîπÂèò
        if (group.lastDirectionChange && (bird.groundTime - group.lastDirectionChange) > 3000) {
            // ÊØè3ÁßíÂ∞èÁªÑÂèØËÉΩÊîπÂèòÊñπÂêë
            if (Math.random() < 0.3) { // 30%Ê¶ÇÁéáÊîπÂèòÊñπÂêë
                group.groundDirection *= -1;
                group.lastDirectionChange = bird.groundTime;
            }
        } else if (!group.lastDirectionChange) {
            group.lastDirectionChange = bird.groundTime;
        }
    } else {
        // ÂéüÊúâÁöÑÁã¨Á´ãË°å‰∏∫ÔºöÊØè3ÁßíÂèØËÉΩÁã¨Á´ãÊîπÂèòÊñπÂêë
        if (bird.groundTime % 3000 < deltaTime) {
            bird.groundDirection = Math.random() > 0.5 ? 1 : -1;
        }
    }
    
    // ÁºìÊÖ¢ÁßªÂä®Ôºà‰ΩøÁî®Â∞èÁªÑÂçèË∞ÉÂêéÁöÑÊñπÂêëÔºâ
    bird.x += (bird.groundMoveSpeed || 0.3) * bird.groundDirection;
    
    // ‰øùÊåÅÂú®Ëä¶ËãáÂå∫ÂÜÖÔºàËÄÉËôëÂ∞èÁªÑÂçèË∞ÉÔºâ
    if (bird.x < reedZone.x) {
        bird.x = reedZone.x;
        bird.groundDirection = 1;
        // Â¶ÇÊûúÊòØÂ∞èÁªÑÔºåÊõ¥Êñ∞Â∞èÁªÑÊñπÂêë
        if (bird.groupId && birdGroupInfo[bird.groupId]) {
            birdGroupInfo[bird.groupId].groundDirection = 1;
        }
    } else if (bird.x > reedZone.x + reedZone.width) {
        bird.x = reedZone.x + reedZone.width;
        bird.groundDirection = -1;
        // Â¶ÇÊûúÊòØÂ∞èÁªÑÔºåÊõ¥Êñ∞Â∞èÁªÑÊñπÂêë
        if (bird.groupId && birdGroupInfo[bird.groupId]) {
            birdGroupInfo[bird.groupId].groundDirection = -1;
        }
    }
    
    // ÂïÑÈ£üÂä®Áîª
    if (bird.groundTime % 1500 < deltaTime) {
        bird.peckingState = 1; // ÂºÄÂßãÂïÑÈ£ü
        bird.peckingTimer = 0;
    }
    
    if (bird.peckingState > 0) {
        bird.peckingTimer += deltaTime;
        if (bird.peckingTimer > 200) {
            bird.peckingState = 0; // ÂïÑÈ£üÁªìÊùü
        }
    }
    
    // ‚úÖ Êñ∞Â¢ûÔºöÂ∞èÁªÑÁªü‰∏ÄÂÅúÁïôÊó∂Èó¥ÔºåÈÅøÂÖçÊúâÁöÑÈ∏üÈ£ûËµ∞ÊúâÁöÑÁïô‰∏ã
    // ËÆ°ÁÆóÂÅúÁïôÊó∂Èó¥Êó∂ËÄÉËôëÂ∞èÁªÑÁªü‰∏ÄÊÄß
    let adjustedStayTime = (bird.stayTime || 30) * 1000;
    
    // Â¶ÇÊûúÊúâÂ∞èÁªÑÔºå‰ΩøÁî®Â∞èÁªÑÁªü‰∏ÄÁöÑÂÅúÁïôÊó∂Èó¥
    if (bird.groupId && birdGroupInfo[bird.groupId]) {
        const group = birdGroupInfo[bird.groupId];
        
        // ËÆ∞ÂΩïÂ∞èÁªÑÂºÄÂßãÂÅúÁïôÁöÑÊó∂Èó¥ÔºàÂ¶ÇÊûúÊ≤°ÊúâËÆ∞ÂΩïÁöÑËØùÔºâ
        if (!group.groundStartTime) {
            group.groundStartTime = bird.groundTime;
        }
        
        // ËÆ°ÁÆóÂ∞èÁªÑÂ∑≤ÁªèÂÅúÁïôÁöÑÊó∂Èó¥
        const groupStayTime = bird.groundTime - group.groundStartTime;
        
        // Â¶ÇÊûúÂ∞èÁªÑÂÅúÁïôÊó∂Èó¥Âà∞‰∫ÜÔºåÊâÄÊúâÊàêÂëò‰∏ÄËµ∑Ëµ∑È£û
        if (groupStayTime > adjustedStayTime) {
            bird.state = 'takingOff';
            bird.speed = 1.5 + Math.random() * 0.5;
            bird.direction = Math.random() > 0.5 ? 1 : -1;
            
            // Â¶ÇÊûúÊòØÂ∞èÁªÑÔºåÁ°Æ‰øùÊâÄÊúâÊàêÂëòÊúâÁõ∏ÂêåÁöÑËµ∑È£ûÊñπÂêë
            if (group.groundDirection) {
                bird.direction = group.groundDirection > 0 ? 1 : -1;
            }
            
            continue;
        }
    } else {
        // ÂéüÊúâÁöÑÁã¨Á´ãËµ∑È£ûÈÄªËæë
        if (bird.groundTime > adjustedStayTime) {
            bird.state = 'takingOff';
            bird.speed = 1.5;
            bird.direction = Math.random() > 0.5 ? 1 : -1;
        }
    }
    break;
    }
    
    if (bird.state === 'landingOnReeds' || bird.state === 'onReedsGround') {
        continue;
    }
}
        
        if (bird.name === "ÈªëÁøÖÈ∏¢" && bird.state === 'circling' && !bird.hasGeneratedMouse) {
            bird.mouseTarget = generateGroundMouseForPredator(bird.name);
            bird.hasGeneratedMouse = true;
            bird.circlingTime = 0;
        }
        
        switch (bird.state) {
            case 'circling':
                bird.circlingTime += deltaTime;
                
                
                bird.circlingAngle += 0.01;
                bird.x = bird.circlingCenterX + Math.cos(bird.circlingAngle) * bird.circlingRadius;
                bird.y = bird.circlingCenterY + Math.sin(bird.circlingAngle) * bird.circlingRadius;
                
                const tangentAngle = bird.circlingAngle + Math.PI / 2;
                bird.direction = Math.cos(tangentAngle) > 0 ? 1 : -1;
                
                if (bird.name === "Á∫¢Èöº" && !bird.mouseTarget) {
                    for (let j = groundObjects.length - 1; j >= 0; j--) {
                        const mouse = groundObjects[j];
                        if (mouse.type === "mouse" && mouse.predatorTarget === "Á∫¢Èöº") {
                            bird.mouseTarget = mouse;
                            bird.hasFoundMouse = true;
                            break;
                        }
                    }
                }
                
                if (bird.name === "ÈªëÁøÖÈ∏¢" && !bird.hasGeneratedMouse) {
                    bird.mouseTarget = generateGroundMouseForPredator(bird.name);
                    bird.hasGeneratedMouse = true;
                    bird.circlingTime = 0;
                }
                
                if (bird.name === "ÈªëÁøÖÈ∏¢" && bird.huntingMouse) {
                    if (bird.circlingTime > 2000 + Math.random() * 2000) {
                        bird.state = 'hovering';
                        bird.speed = 0;
                        bird.hoveringTime = 0;
                    }
                } else if (bird.name === "Á∫¢Èöº" && bird.isPredator) {
                    if (bird.circlingTime > 2000 + Math.random() * 2000) {
                        if (bird.mouseTarget) {
                            bird.state = 'hovering';
                            bird.speed = 0;
                            bird.hoveringTime = 0;
                        } else {
                            bird.state = 'hunting';
                            bird.speed = (3 + Math.random() * 2);
                            bird.direction = Math.random() > 0.5 ? 1 : -1;
                        }
                    }
                } else if (bird.name === "Ê∏∏Èöº" && bird.huntingBird) {
                    if (bird.circlingTime > 2000 + Math.random() * 2000) {
                        bird.state = 'huntingBird';
                        bird.speed = (3 + Math.random() * 2) * 3;
                        bird.direction = Math.random() > 0.5 ? 1 : -1;
                    }
                }
                break;
                
            case 'divingToMouse':
                if (bird.mouseTarget && bird.mouseTarget.type === "mouse") {
                    const dx = bird.mouseTarget.x - bird.x;
                    const dy = bird.mouseTarget.y - bird.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < 25) {
                        if (Math.random() < bird.catchMouseChance) {
                            bird.caughtMouse = { x: 0, y: 0, size: 8, type: "mouse" };
                            bird.state = 'flyingWithMouse';
                            bird.speed = 1.5;
                            bird.direction = 1;
                            
                            const index = groundObjects.indexOf(bird.mouseTarget);
                            if (index !== -1) {
                                groundObjects.splice(index, 1);
                            }
                            bird.mouseTarget = null;
                            
                            scareMode = true;
                            scareModeEndTime = gameTime + 5000;
                        } else {
                            const index = groundObjects.indexOf(bird.mouseTarget);
                            if (index !== -1) {
                                groundObjects.splice(index, 1);
                            }
                            bird.mouseTarget = null;
                            bird.state = 'takingOffToCircle';
                            bird.speed = 1.5;
                            bird.direction = 1;
                            bird.takeoffStartTime = gameTime;
                            bird.takeoffDuration = 3000;
                            bird.startX = bird.x;
                            bird.startY = bird.y;
                            bird.targetX = bird.circlingCenterX;
                            bird.targetY = bird.circlingCenterY;
                            bird.hasGeneratedMouse = false;
                        }
                    } else {
                        bird.x += (dx / distance) * bird.speed;
                        bird.y += (dy / distance) * bird.speed;
                        bird.direction = dx > 0 ? 1 : -1;
                    }
                } else {
                    bird.state = 'takingOffToCircle';
                    bird.speed = 1.5;
                    bird.direction = 1;
                    bird.takeoffStartTime = gameTime;
                    bird.takeoffDuration = 3000;
                    bird.startX = bird.x;
                    bird.startY = bird.y;
                    bird.targetX = bird.circlingCenterX;
                    bird.targetY = bird.circlingCenterY;
                    bird.mouseTarget = null;
                    bird.hasGeneratedMouse = false;
                }
                break;
                
            case 'takingOffToCircle':
                const elapsedTime = gameTime - bird.takeoffStartTime;
                const progress = Math.min(elapsedTime / bird.takeoffDuration, 1);
                const easeProgress = easeInOutQuad(progress);
                
                bird.x = bird.startX + (bird.targetX - bird.startX) * easeProgress;
                bird.y = bird.startY + (bird.targetY - bird.startY) * easeProgress;
                
                if (progress < 0.3) {
                    bird.y -= 1;
                } else if (progress < 0.7) {
                    bird.y -= 0.5;
                } else {
                    bird.y += 0.2;
                }
                
                bird.direction = (bird.targetX - bird.startX) > 0 ? 1 : -1;
                
                if (progress >= 1) {
                    bird.state = 'circling';
                    bird.circlingTime = 0;
                    bird.circlingAngle = Math.random() * Math.PI * 2;
                    bird.x = bird.targetX;
                    bird.y = bird.targetY;
                }
                break;
                
            case 'followingMousePath':
                if (bird.mouseFlightIndex < bird.mouseFlightPath.length) {
                    const targetPoint = bird.mouseFlightPath[bird.mouseFlightIndex];
                    const dx = targetPoint.x - bird.x;
                    const dy = targetPoint.y - bird.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < 5) {
                        bird.mouseFlightIndex++;
                    } else {
                        bird.x += (dx / distance) * bird.speed;
                        bird.y += (dy / distance) * bird.speed;
                        bird.direction = dx > 0 ? 1 : -1;
                    }
                    
                    if (bird.mouseFlightIndex >= bird.mouseFlightPath.length) {
                        if (bird.name === "ÈªëÁøÖÈ∏¢") {
                            bird.state = 'huntingMouse';
                            bird.hasLanded = false;
                            bird.groundTime = 0;
                        } else if (bird.name === "Ê∏∏Èöº") {
                            bird.state = 'huntingBird';
                        }
                    }
                }
                break;
                
            case 'hovering':
                bird.hoveringTime += deltaTime;
                bird.y += Math.sin(bird.hoveringTime * 0.005) * 0.5;
                
                if (bird.name === "Á∫¢Èöº") {
                    if (bird.hoveringTime > 3000) {
                        if (bird.mouseTarget && bird.mouseTarget.type === "mouse") {
                            bird.state = 'divingToMouse';
                            bird.speed = 3.0;
                        } else {
                            bird.state = 'hunting';
                            bird.speed = 3 + Math.random() * 2;
                            bird.direction = Math.random() > 0.5 ? 1 : -1;
                        }
                    }
                } else if (bird.hoveringTime > 5000) {
                    bird.state = 'huntingMouse';
                    bird.speed = 3 + Math.random() * 2;
                    bird.direction = Math.random() > 0.5 ? 1 : -1;
                }
                break;
                
            case 'huntingMouse':
                if (!bird.hasLanded) {
                    bird.x += bird.speed * bird.direction * 0.3;
                    bird.y += bird.speed * 1.5;
                    
                    if (bird.y >= GAME_HEIGHT - 50) {
                        bird.hasLanded = true;
                        bird.groundTime = 0;
                        bird.y = GAME_HEIGHT - 30;
                    }
                } else {
                    bird.groundTime += deltaTime;
                    if (bird.groundTime > 500 && !bird.caughtMouse) {
                        if (Math.random() < 0.5) {
                            bird.caughtMouse = { x: 0, y: 0, size: 8 };
                            bird.state = 'flyingWithMouse';
                            bird.speed = 1.5;
                            bird.direction = 1;
                            scareMode = true;
                            scareModeEndTime = gameTime + 5000;
                        } else {
                            bird.state = 'takingOff';
                            bird.speed = 1.5;
                            bird.direction = 1;
                        }
                    }
                }
                
                if (bird.y > GAME_HEIGHT + 100) {
                    birds.splice(i, 1);
                }
                break;
                
            case 'hunting':
                bird.x += bird.speed * bird.direction * 0.3;
                if (bird.y < GAME_HEIGHT - 50) {
                    bird.y += bird.speed * 1.5;
                }
                
                if (bird.y >= GAME_HEIGHT - 50 && !bird.caughtDove && !bird.caughtMouse) {
                    bird.y = GAME_HEIGHT - 50;
                    
                    if (Math.random() < bird.catchDoveChance) {
                        bird.caughtDove = { x: 0, y: 0, size: 12 };
                        bird.state = 'flyingWithDove';
                        bird.speed = 1.5;
                        bird.direction = 1;
                        scareMode = true;
                        scareModeEndTime = gameTime + 5000;
                    } else if (Math.random() < bird.catchMouseChance) {
                        bird.caughtMouse = { x: 0, y: 0, size: 8 };
                        bird.state = 'flyingWithMouse';
                        bird.speed = 1.5;
                        bird.direction = 1;
                        scareMode = true;
                        scareModeEndTime = gameTime + 5000;
                    } else if (Math.random() < bird.leaveChance) {
                        bird.state = 'flyingAway';
                        bird.speed = 1.5;
                        bird.direction = 1;
                    } else {
                        bird.state = 'flyingAway';
                        bird.speed = 1.5;
                        bird.direction = 1;
                    }
                }
                
                if (bird.y > GAME_HEIGHT + 100) {
                    birds.splice(i, 1);
                }
                break;
                
            case 'huntingBird':
                bird.x += bird.speed * bird.direction * 0.3;
                bird.y += bird.speed * 1.5;
                
                if (bird.y > GAME_HEIGHT - 100 && !bird.caughtBird && Math.random() < 0.8) {
                    bird.caughtBird = { x: 0, y: 0, size: 10 };
                    bird.state = 'flyingWithBird';
                    bird.speed = 1.5;
                    bird.direction = 1;
                    bird.y -= 50;
                    scareMode = true;
                    scareModeEndTime = gameTime + 5000;
                }
                
                if (bird.y > GAME_HEIGHT + 100) {
                    birds.splice(i, 1);
                }
                break;
                
            case 'flyingWithMouse':
case 'flyingWithBird':
case 'flyingWithDove':
    // Ê∞¥Âπ≥Êñú‰∏äÈ£ûÔºåËßíÂ∫¶‰∏çË∂ÖËøá20Â∫¶
    const flyingAwayAngle = (8 + Math.random() * 12) * Math.PI / 180; // 8-20Â∫¶
    bird.x += bird.speed * Math.cos(flyingAwayAngle);
    bird.y -= bird.speed * Math.sin(flyingAwayAngle);
    if (bird.x > GAME_WIDTH + 100 || bird.y < -100) {
        birds.splice(i, 1);
    }
    break;
                
            case 'flying':
                let speedFactor = 1;
                if (bird.direction === -1 && !bird.isChasing && !bird.isBeingChased) {
                    speedFactor = 0.3;
                }
                
                if (bird.name === "È∫ªÈõÄ") {
                    // È∫ªÈõÄÁöÑÂéüÊúâË°å‰∏∫ÔºöÁõ¥Êé•È£ûËøáÂ±èÂπï
                    bird.x += bird.speed * bird.direction * speedFactor;
                    if ((bird.direction === 1 && bird.x > GAME_WIDTH + 200) || (bird.direction === -1 && bird.x < -200)) {
                        birds.splice(i, 1);
                        continue;
                    }
                } else if (bird.hunting) {
                    bird.x += bird.speed * bird.direction * speedFactor;
                    bird.y += bird.speed * 0.7 * speedFactor;
                } else {
                    bird.x += bird.speed * bird.direction * speedFactor;
                    if (behavior === 'waveFlight') {
                        bird.y += Math.sin(bird.stateTime * 0.01) * 2 * speedFactor;
                    }
                }
                
                if ((behavior === 'landOnTree' || behavior === 'appearOnTree') && bird.targetTree) {
                    const treeCenterX = bird.targetTree.x + bird.targetTree.width / 2;
                    const distanceToTree = Math.abs(bird.x - treeCenterX);
                    
                    if (distanceToTree < 50) {
                        bird.state = 'landing';
                        const tree = bird.targetTree;
                        const crownTopArea = {
                            x: tree.x + tree.width * 0.2,
                            y: tree.y + tree.height * 0.1,
                            width: tree.width * 0.6,
                            height: tree.height * 0.25
                        };
                        
                        if (bird.name === "ÂñúÈπä" || bird.name === "‰πåÈ∏¶") {
                            const targetX = crownTopArea.x + Math.random() * crownTopArea.width;
                            const targetY = crownTopArea.y + Math.random() * crownTopArea.height;
                            bird.targetX = targetX;
                            bird.targetY = targetY;
                        } else {
                            const treeCenterY = tree.y + tree.height * 0.35;
                            const angle = Math.atan2(treeCenterY - bird.y, treeCenterX - bird.x);
                            const distance = 30 + Math.random() * 20;
                            bird.targetX = bird.x + Math.cos(angle) * distance;
                            bird.targetY = bird.y + Math.sin(angle) * distance;
                            
                            bird.targetX = Math.max(tree.x, Math.min(tree.x + tree.width, bird.targetX));
                            bird.targetY = Math.max(tree.y, Math.min(tree.y + tree.height * 0.7, bird.targetY));
                        }
                    }
                }
                
                if ((bird.direction === 1 && bird.x > GAME_WIDTH + 200) || (bird.direction === -1 && bird.x < -200) || bird.y > GAME_HEIGHT + 200) {
                    birds.splice(i, 1);
                    continue;
                }
                break;
                
            case 'landing':
                const dx = bird.targetX - bird.x;
                const dy = bird.targetY - bird.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 2) {
                    bird.state = 'perching';
                    bird.x = bird.targetX;
                    bird.y = bird.targetY;
                    bird.speed = 0;
                } else {
                    let landingSpeedFactor = 1;
                    if (bird.direction === -1 && !bird.isChasing && !bird.isBeingChased) {
                        landingSpeedFactor = 0.3;
                    }
                    
                    bird.x += (dx / distance) * 2 * landingSpeedFactor;
                    bird.y += (dy / distance) * 2 * landingSpeedFactor;
                }
                break;
                
            case 'perching':
                if (bird.name === "ÈïøËÄ≥È∏Æ") {
                    if (bird.stateTime > (bird.stayTime || 15) * 1000) {
                        birds.splice(i, 1);
                        continue;
                    }
                }
                
                if (behavior === 'landOnTreeThenMove') {
                    if (bird.stateTime > (bird.stayTimePerTree || 2000)) {
                        if (!bird.hasMovedToSecondTree) {
                            bird.state = 'movingToSecondTree';
                            bird.hasMovedToSecondTree = true;
                            bird.stateTime = 0;
                            
                            const currentTreeSide = bird.targetTree.side;
                            const oppositeTree = treePositions.find(tree => tree.side !== currentTreeSide);
                            
                            if (oppositeTree) {
                                bird.targetTree = oppositeTree;
                                const treeCenterX = oppositeTree.x + oppositeTree.width / 2;
                                const treeCenterY = oppositeTree.y + oppositeTree.height * 0.35;
                                const angle = Math.atan2(treeCenterY - bird.y, treeCenterX - bird.x);
                                const distance = 30 + Math.random() * 20;
                                
                                bird.targetX = bird.x + Math.cos(angle) * distance;
                                bird.targetY = bird.y + Math.sin(angle) * distance;
                                
                                bird.targetX = Math.max(oppositeTree.x, Math.min(oppositeTree.x + oppositeTree.width, bird.targetX));
                                bird.targetY = Math.max(oppositeTree.y, Math.min(oppositeTree.y + oppositeTree.height * 0.7, bird.targetY));
                                
                                bird.speed = 1.5;
                                bird.direction = bird.targetX > bird.x ? 1 : -1;
                            } else {
                                bird.state = 'takingOff';
                                bird.speed = 1;
                                if (bird.groupId && birdGroupInfo[bird.groupId]) {
                                    bird.direction = birdGroupInfo[bird.groupId].direction;
                                } else {
                                    bird.direction = Math.random() > 0.5 ? 1 : -1;
                                }
                            }
                        } else {
                            bird.state = 'takingOff';
                            bird.speed = 1;
                            if (bird.groupId && birdGroupInfo[bird.groupId]) {
                                bird.direction = birdGroupInfo[bird.groupId].direction;
                            } else {
                                bird.direction = Math.random() > 0.5 ? 1 : -1;
                            }
                        }
                    }
                } else {
                    if (bird.stateTime > (bird.stayTime || 10) * 1000) {
                        bird.state = 'takingOff';
                        bird.speed = 1;
                        if (bird.groupId && birdGroupInfo[bird.groupId]) {
                            bird.direction = birdGroupInfo[bird.groupId].direction;
                        } else {
                            bird.direction = Math.random() > 0.5 ? 1 : -1;
                        }
                    }
                }
                break;
                
            case 'takingOff':
    let takeoffSpeedFactor = 1;
    if (bird.direction === -1 && !bird.isChasing && !bird.isBeingChased) {
        takeoffSpeedFactor = 0.3;
    }
    // Ê∞¥Âπ≥Êñú‰∏äÈ£ûÔºåËßíÂ∫¶‰∏çË∂ÖËøá20Â∫¶
    const takeoffAngle = (5 + Math.random() * 15) * Math.PI / 180; // 5-20Â∫¶
    bird.x += bird.speed * bird.direction * takeoffSpeedFactor * Math.cos(takeoffAngle);
    bird.y -= bird.speed * takeoffSpeedFactor * Math.sin(takeoffAngle);
    if (bird.x < -100 || bird.x > GAME_WIDTH + 100 || bird.y < -100) {
        birds.splice(i, 1);
    }
    break;
                
            case 'movingToSecondTree':
                if (bird.targetTree) {
                    const moveDx = bird.targetX - bird.x;
                    const moveDy = bird.targetY - bird.y;
                    const moveDistance = Math.sqrt(moveDx * moveDx + moveDy * moveDy);
                    
                    let moveSpeedFactor = 1;
                    if (bird.direction === -1 && !bird.isChasing && !bird.isBeingChased) {
                        moveSpeedFactor = 0.3;
                    }
                    
                    if (moveDistance < 2) {
                        bird.state = 'perching';
                        bird.x = bird.targetX;
                        bird.y = bird.targetY;
                        bird.speed = 0;
                        bird.stateTime = 0;
                        bird.direction = bird.targetTree.side === 'left' ? 1 : -1;
                    } else {
                        bird.x += (moveDx / moveDistance) * bird.speed * moveSpeedFactor;
                        bird.y += (moveDy / moveDistance) * bird.speed * moveSpeedFactor;
                        bird.direction = moveDx > 0 ? 1 : -1;
                    }
                } else {
                    bird.state = 'takingOff';
                    bird.speed = 1;
                    if (bird.groupId && birdGroupInfo[bird.groupId]) {
                        bird.direction = birdGroupInfo[bird.groupId].direction;
                    } else {
                        bird.direction = Math.random() > 0.5 ? 1 : -1;
                    }
                }
                break;
                
            case 'stayingInReeds':
                if (bird.name === "Ê£ïÂ§¥È∏¶ÈõÄ") {
                    bird.y += Math.sin(bird.stateTime * 0.005) * 0.3;
                }
                break;
                
            case 'flyingAway':
    // Ê∞¥Âπ≥Êñú‰∏äÈ£ûÔºåËßíÂ∫¶‰∏çË∂ÖËøá20Â∫¶
    const flyingAwayAngle2 = (5 + Math.random() * 15) * Math.PI / 180; // 5-20Â∫¶
    bird.x += bird.speed * bird.direction * Math.cos(flyingAwayAngle2);
    bird.y -= bird.speed * Math.sin(flyingAwayAngle2);
    if ((bird.direction === 1 && bird.x > GAME_WIDTH + 200) || (bird.direction === -1 && bird.x < -200) || bird.y < -200) {
        birds.splice(i, 1);
    }
    break;
                
            case 'fleeing':
    // Ê∞¥Âπ≥Êñú‰∏äÈ£ûÔºåËßíÂ∫¶‰∏çË∂ÖËøá20Â∫¶
    const fleeVerticalAngle = (10 + Math.random() * 10) * Math.PI / 180; // 10-20Â∫¶
    bird.x += bird.speed * bird.direction * Math.cos(fleeVerticalAngle);
    bird.y -= bird.speed * Math.sin(fleeVerticalAngle);
    if (bird.y < -100) {
        birds.splice(i, 1);
    }
    break;
        }
    }
    
    if (scareMode && gameTime >= scareModeEndTime) {
        scareMode = false;
        birds.forEach(bird => {
            if (bird.isScared) {
                bird.speed = bird.speed / 1.5;
                bird.isScared = false;
            }
            if (bird.isChasing && !bird.chasingTarget) {
                bird.isChasing = false;
            }
        });
    }
}

// ‰øÆÊîπÁø†È∏üÁîüÊàêÂáΩÊï∞Ôºå‰ªéËæÉ‰ΩéÈ´òÂ∫¶Ê∞¥Âπ≥È£ûÂÖ•
function generateKingfisher(countStats = false) {
  const kingfisherType = BIRD_TYPES.KINGFISHER;
  
  if (countStats) {
    appearedBirds[kingfisherType.name] = (appearedBirds[kingfisherType.name] || 0) + 1;
    updateTextStats();
  }
  
  // ‰ªéÁîªÈù¢Â§ñÈ£ûÂÖ•ÔºåÁõ¥Êé•È£ûÂêëËä¶Ëãá‰∏õ
  const fromLeft = Math.random() > 0.5;
  const startX = fromLeft ? -50 : GAME_WIDTH + 50;
  
  // È£ûÂêëËä¶Ëãá‰∏õÂå∫Âüü
  const targetReedX = reedZone.x + Math.random() * reedZone.width;
  const targetReedY = reedZone.y + reedZone.height * 0.5; // ÂÅúÂú®Ëä¶Ëãá‰∏ä
  
  // ËÆæÁΩÆËæÉ‰ΩéÁöÑÈ£ûË°åÈ´òÂ∫¶ - ‰ªéËä¶ËãáÂå∫Âüü‰∏äÊñπ‰∏ÄÁÇπÈ£ûÂÖ•
  const startY = reedZone.y + reedZone.height * 0.5 + Math.random() * (GAME_HEIGHT * 0.1);
  
  const bird = {
    type: kingfisherType,
    name: kingfisherType.name,
    x: startX,
    y: startY, // ËæÉ‰ΩéÁöÑÂàùÂßãÈ´òÂ∫¶
    size: kingfisherType.size,
    speed: 2.0,
    direction: fromLeft ? 1 : -1, // 1=ÂêëÂè≥Ôºå-1=ÂêëÂ∑¶
    state: 'flyingToReed',
    stateTime: 0,
    targetX: targetReedX,
    targetY: targetReedY,
    
    // È£ûÂÖ•Êó∂Ê∞¥Âπ≥ÔºåheadAngle = 0
    headAngle: 0, // Ê∞¥Âπ≥
    
    // ÂàùÂßãÊúùÂêëÔºàÁúãÂêëÁöÑÊñπÂêëÔºâ
    facingDirection: fromLeft ? 1 : -1, // 1=ÂêëÂè≥Ôºå-1=ÂêëÂ∑¶
    
    // Êç¢ÂêëÁõ∏ÂÖ≥
    nextTurnTime: 0,
    turnInterval: kingfisherType.turnInterval[0] + 
                  Math.random() * (kingfisherType.turnInterval[1] - kingfisherType.turnInterval[0]),
    
    stayTime: kingfisherType.stayTime[0] + 
              Math.random() * (kingfisherType.stayTime[1] - kingfisherType.stayTime[0]),
    
    diveTargetX: 0,
    diveTargetY: 0,
    hasDived: false,
    hasCaughtFish: false,
    caughtFish: null,
    fishOffsetX: 0,
    fishOffsetY: 0,
    fishAngle: 0,
    beakLengthMultiplier: kingfisherType.beakLengthMultiplier,
    isVulnerableToRaptors: true,
    noStats: !countStats,
    isKingfisher: true,
    
    // Ë∫´‰ΩìÊòØÂê¶ÁøªËΩ¨ÁöÑÊ†áÂøóÔºàÁî®‰∫éÁªòÂà∂Ôºâ
    bodyFlipped: false
  };
  
  // ËÆæÁΩÆËΩ¨ÂêëÊó∂Èó¥
  bird.nextTurnTime = gameTime + bird.turnInterval;
  
  birds.push(bird);
  
  if (countStats) {
    showSpecialAlert(`ÂèëÁé∞${kingfisherType.name}ÔºÅ`);
  }
}

// ‰øÆÊîπÈ£ûË°åÈÄªËæëÔºåÁ°Æ‰øùÊ∞¥Âπ≥È£ûÂÖ•
function updateKingfisher(bird, deltaTime) {
  bird.stateTime += deltaTime;
  
  // Ê£ÄÊü•ÊòØÂê¶ÊúâÁåõÁ¶ΩÈù†ËøëÔºàÊÉäÂêìÊù°‰ª∂Ôºâ
  let raptorNearby = false;
  for (let otherBird of birds) {
    // Ê£ÄÊü•ÊòØÂê¶ÊòØÁåõÁ¶ΩÁ±ªÂûã
    if ((otherBird.name === "Ê∏∏Èöº" || otherBird.name === "Á∫¢Èöº" || otherBird.name === "ÈªëÁøÖÈ∏¢") && 
        otherBird.state !== 'fleeing') {
      const dx = otherBird.x - bird.x;
      const dy = otherBird.y - bird.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      // Â¶ÇÊûúÁåõÁ¶ΩÂú®1000ÂÉèÁ¥†ËåÉÂõ¥ÂÜÖ
      if (distance < 1000) {
        raptorNearby = true;
        break;
      }
    }
  }
  
  // Â¶ÇÊûúÁåõÁ¶ΩÈù†Ëøë‰∏îÁø†È∏ü‰∏çÂú®ÈÄÉË∑ëÁä∂ÊÄÅÔºåÁ´ãÂç≥ÂºÄÂßãÈÄÉË∑ë
  if (raptorNearby && bird.state !== 'fleeingFromRaptor' && bird.state !== 'flyingAway') {
    bird.state = 'fleeingFromRaptor';
    bird.stateTime = 0;
    bird.speed = 3.5; // ÊÉäÂêìÈÄÉË∑ëÈÄüÂ∫¶Êõ¥Âø´
    bird.direction = Math.random() > 0.5 ? 1 : -1; // ÈöèÊú∫ÊñπÂêëÈÄÉË∑ë
    bird.facingDirection = bird.direction;
    bird.headAngle = 0; // Ê∞¥Âπ≥È£ûË°å
    bird.bodyFlipped = (bird.facingDirection === -1);
    return; // Á´ãÂç≥ËøîÂõûÔºå‰∏çÊâßË°åÂêéÁª≠Áä∂ÊÄÅÈÄªËæë
  }
  
  switch (bird.state) {
    case 'flyingToReed':
      // È£ûÂêëËä¶Ëãá‰∏õ - ‰øùÊåÅÊ∞¥Âπ≥È£ûË°åÔºå‰∏çÊîπÂèòyÂùêÊ†á
      const dx = bird.targetX - bird.x;
      const horizontalDistance = Math.abs(dx);
      
      if (horizontalDistance < 5) {
        // Âà∞ËææÁõÆÊ†áxÂùêÊ†áÔºåÊ£ÄÊü•ÊòØÂê¶ÈúÄË¶Å‰∏ãÈôç
        if (Math.abs(bird.y - bird.targetY) < 5) {
          // Â∑≤ÁªèÂà∞ËææÁõÆÊ†á‰ΩçÁΩÆÔºåÂàáÊç¢Âà∞ÂÅúÁïôÁä∂ÊÄÅ
          bird.state = 'perchingOnReed';
          bird.stateTime = 0;
          bird.speed = 0;
          bird.x = bird.targetX;
          bird.y = bird.targetY;
          
          // Âà∞ËææËä¶ËãáÂêéÔºåÂ§¥ÂíåÂò¥ÊñúÂêë‰∏ã45Â∫¶
          bird.headAngle = Math.PI/4;
        } else {
          // ÈúÄË¶ÅÂûÇÁõ¥‰∏ãÈôç
          const dy = bird.targetY - bird.y;
          const verticalDistance = Math.abs(dy);
          
          if (verticalDistance < 2) {
            bird.y = bird.targetY;
          } else {
            // ÂûÇÁõ¥‰∏ãÈôç
            bird.y += (dy / verticalDistance) * bird.speed * 0.5;
          }
        }
      } else {
        // Ê∞¥Âπ≥È£ûÂêëÁõÆÊ†áxÂùêÊ†á
        bird.x += (dx / horizontalDistance) * bird.speed;
        // ‰øùÊåÅÊ∞¥Âπ≥È£ûË°åÔºå‰∏çÊîπÂèòyÂùêÊ†á
        bird.headAngle = 0; // È£ûË°åÊó∂‰øùÊåÅÊ∞¥Âπ≥
      }
      break;
      
    case 'perchingOnReed':
      // Âú®Ëä¶Ëãá‰∏äÂÅúÁïô
      if (bird.stateTime > bird.stayTime) {
        // ÂÅúÁïôÊó∂Èó¥ÁªìÊùüÔºåÂºÄÂßã‰øØÂÜ≤ÊçâÈ±º
        bird.state = 'divingForFish';
        bird.stateTime = 0;
        
        // ËÆæÁΩÆ‰øØÂÜ≤ÁõÆÊ†áÔºàÊ∞¥Èù¢‰ΩçÁΩÆÔºâ
        // Ê†πÊçÆÂΩìÂâçÊúùÂêëÂÜ≥ÂÆö‰øØÂÜ≤ÊñπÂêë
        bird.diveTargetX = bird.x + (bird.facingDirection > 0 ? 100 : -100);
        bird.diveTargetY = reedZone.y + reedZone.height - 10;
        bird.speed = bird.type.diveSpeed || 3.0;
      } else {
        // ÊØèÈöî‰∏ÄÊÆµÊó∂Èó¥Êç¢ÊñπÂêë
        if (gameTime > bird.nextTurnTime) {
          // Ê∞¥Âπ≥Êç¢ÂêëÔºöÊîπÂèòfacingDirectionÔºà‰ªéÂêëÂè≥ÂèòÊàêÂêëÂ∑¶ÔºåÊàñÂèç‰πãÔºâ
          bird.facingDirection *= -1;
          bird.direction = bird.facingDirection; // ÂêåÊ≠•Êõ¥Êñ∞ direction ‰ª•Ëß¶ÂèëÂÖ®Â±ÄÁøªËΩ¨
          bird.bodyFlipped = (bird.facingDirection === -1);
          
          // ‰∏çÈúÄË¶ÅÊîπÂèòheadAngleÔºåÂõ†‰∏∫ÁªòÂà∂Êó∂‰ºöÊ†πÊçÆfacingDirectionÁøªËΩ¨
          bird.nextTurnTime = gameTime + bird.turnInterval;
        }
      }
      break;
      
    case 'divingForFish':
      // ‰øØÂÜ≤ÊçâÈ±º
      const diveDx = bird.diveTargetX - bird.x;
      const diveDy = bird.diveTargetY - bird.y;
      const diveDistance = Math.sqrt(diveDx * diveDx + diveDy * diveDy);
      
      // Êõ¥Êñ∞ÊúùÂêëÔºöÊ†πÊçÆ‰øØÂÜ≤ÊñπÂêëËÆæÁΩÆ
      bird.direction = diveDx > 0 ? 1 : -1;
      
      if (diveDistance < 10 || bird.stateTime > 2000) {
        // Âà∞ËææÊ∞¥Èù¢ÔºåÊçâÂà∞È±º
        bird.state = 'caughtFish';
        bird.stateTime = 0;
        bird.hasCaughtFish = true;
        
        // ÂàõÂª∫È±ºÂØπË±°
        bird.caughtFish = {
          x: 0,
          y: 0,
          size: bird.type.fishSize,
          color: bird.type.fishColor,
          angle: Math.PI/2 // È±ºÊ®™ÂêëÂûÇÁõ¥‰∫éÂò¥
        };
        
        // Âêë‰∏äÈ£ûËµ∑
        bird.speed = 2.0;
        bird.direction = -1; // Âêë‰∏äÔºüËøôÈáådirectionÂ∫îËØ•ÊòØÂ∑¶Âè≥ÊñπÂêë„ÄÇ
        // Â¶ÇÊûúÊòØÂûÇÁõ¥Âêë‰∏äÔºådirection‰øùÊåÅÂéüÊ†∑ÊàñËÄÖÈöèÊú∫Ôºü
        // Âéü‰ª£Á†ÅÂÜôÁöÑÊòØ direction = -1ÔºåËøô‰ºöËÆ©ÂÆÉÂêëÂ∑¶È£û„ÄÇ
        // Â∫îËØ•ÊòØ‰øùÊåÅÂΩìÂâçÊúùÂêëÔºåÊàñËÄÖÈöèÊú∫ÈÄâ‰∏Ä‰∏™„ÄÇ
        // ËøôÈáåÊöÇÊó∂‰øùÊåÅÂéüÊ†∑ÔºåÊàñËÄÖ‰øÆÂ§çÂÆÉ„ÄÇ
        // ÂÅáËÆæÂêë‰∏äÈ£ûÊó∂‰øùÊåÅ‰πãÂâçÁöÑÊúùÂêë
        // bird.direction = bird.direction; 
        
        bird.headAngle = 0; // Âêë‰∏äÈ£ûÊó∂Ê∞¥Âπ≥
        bird.bodyFlipped = false; // ÂèñÊ∂àÁøªËΩ¨
      } else {
        // ÁªßÁª≠‰øØÂÜ≤
        // ËÆ°ÁÆóÁõ∏ÂØπ‰∫éË°åËøõÊñπÂêëÁöÑËßíÂ∫¶
        // ‰ΩøÁî® abs(diveDx) Á°Æ‰øùËßíÂ∫¶ÂßãÁªàÊåáÂêë‚ÄúÂâçÊñπ‚Äù
        const diveAngle = Math.atan2(diveDy, Math.abs(diveDx));
        
        // ÁßªÂä®ÈÄªËæë‰øùÊåÅ‰ΩøÁî®ÁúüÂÆûÁöÑ diveDx, diveDy
        // ÊàñËÄÖ‰ΩøÁî® angle * direction ? 
        // ÊúÄÁÆÄÂçïÁöÑÊòØÔºö
        const moveAngle = Math.atan2(diveDy, diveDx);
        bird.x += Math.cos(moveAngle) * bird.speed;
        bird.y += Math.sin(moveAngle) * bird.speed;
        
        // Â§¥ÈÉ®ÊúùÂêë‰øØÂÜ≤ÊñπÂêëÔºàÁõ∏ÂØπ‰∫éË∫´‰ΩìÔºâ
        bird.headAngle = diveAngle;
      }
      break;
      
    case 'caughtFish':
      // ÊçâÂà∞È±ºÂêéÂêë‰∏äÈ£û
      if (bird.stateTime < 600) {
        // Âêë‰∏äÈ£ûÂçä‰∏™Ëä¶ËãáÈ´ò
        bird.y -= bird.speed;
        
        // ËÆ°ÁÆóÈ±ºÁöÑÊ≠£Á°Æ‰ΩçÁΩÆÔºàÂú®Âò¥Â∞ñÔºâ
        const beakLength = 8 * bird.beakLengthMultiplier; // Âò¥ÁöÑÂÆûÈôÖÈïøÂ∫¶
        const fishDistance = beakLength + bird.caughtFish.size/2; // È±ºÂ∫îËØ•Âú®Âò¥Â∞ñÂ§ñ‰∏ÄÁÇπ
        
        // ËÆ°ÁÆóÈ±ºÁõ∏ÂØπ‰∫éÁø†È∏üË∫´‰Ωì‰∏≠ÂøÉÁöÑ‰ΩçÁΩÆ
        // Ê≥®ÊÑèÔºöÈ±ºÁöÑÊ®™ÂêëÂûÇÁõ¥‰∫éÂò¥ÔºåÊâÄ‰ª•ÈúÄË¶ÅÊóãËΩ¨90Â∫¶
        const angleForFish = bird.headAngle + Math.PI/2;
        
        // È±ºÁöÑÂÅèÁßªÈáèÔºà‰ªéÁø†È∏üË∫´‰Ωì‰∏≠ÂøÉÂà∞È±ºÁöÑ‰∏≠ÂøÉÔºâ
        bird.fishOffsetX = Math.cos(bird.headAngle) * fishDistance;
        bird.fishOffsetY = Math.sin(bird.headAngle) * fishDistance;
        
        // È±ºËá™Ë∫´ÁöÑËßíÂ∫¶ÔºàÊ®™ÂêëÂûÇÁõ¥‰∫éÂò¥Ôºâ
        bird.fishAngle = angleForFish;
      } else {
        // Âêë‰∏äÈ£ûÂêéÈ£ûËµ∞
        bird.state = 'flyingAway';
        bird.speed = 2.5;
        bird.direction = Math.random() > 0.5 ? 1 : -1;
        bird.facingDirection = bird.direction; // Èù¢ÂêëÈ£ûË°åÊñπÂêë
        bird.headAngle = 0; // Ê∞¥Âπ≥È£ûË°å
        bird.bodyFlipped = (bird.facingDirection === -1);
      }
      break;
      
    case 'flyingAway':
      // Ê≠£Â∏∏È£ûÁ¶ªÁîªÈù¢
      bird.x += bird.direction * bird.speed;
      bird.headAngle = 0; // Ê∞¥Âπ≥È£ûË°å
      
      if (bird.x < -100 || bird.x > GAME_WIDTH + 100) {
        // È£ûÂá∫ÁîªÈù¢ÔºåÁßªÈô§
        birds.splice(birds.indexOf(bird), 1);
      }
      break;
      
case 'fleeingFromRaptor':
  // ÂèóÊÉäÂêìÈ£ûËµ∞Ôºå‰ΩÜ‰øùÊåÅÂéüÊúâÁöÑÈ±º‰ΩçÁΩÆ
  bird.x += bird.direction * bird.speed;
  bird.headAngle = 0; // Ê∞¥Âπ≥È£ûË°å
  bird.bodyFlipped = (bird.direction === -1);
  
  // Êõ¥Êñ∞È±ºÁöÑ‰ΩçÁΩÆÔºà‰øùÊåÅÂéüÊúâÈÄªËæëÔºâ
  if (bird.caughtFish) {
    // ËÆ°ÁÆóÂò¥Â∞ñÁöÑÂÖ®Â±Ä‰ΩçÁΩÆ
    const beakLength = 10 * bird.beakLengthMultiplier;
    const localBeakTipX = bird.direction === 1 ? beakLength : -beakLength;
    const globalBeakTipX = bird.x + localBeakTipX;
    const globalBeakTipY = bird.y;
    
    // È±ºÁöÑ‰ΩçÁΩÆÂ∫îËØ•Âú®Âò¥ÈáåÈù¢‰∏ÄÁÇπ
    const fishDistance = -bird.caughtFish.size/3; // Ë¥üÂÄºË°®Á§∫ÂêëÈáåÔºàÂêëÁø†È∏üÂ§¥ÈÉ®ÊñπÂêëÔºâ
    const fishX = globalBeakTipX + Math.cos(bird.headAngle) * fishDistance;
    const fishY = globalBeakTipY + Math.sin(bird.headAngle) * fishDistance;
    
    bird.fishOffsetX = fishX - bird.x;
    bird.fishOffsetY = fishY - bird.y;
    bird.fishAngle = bird.headAngle + Math.PI/2;
  }
  
  if (bird.x < -100 || bird.x > GAME_WIDTH + 100) {
    // È£ûÂá∫ÁîªÈù¢ÔºåÁßªÈô§
    birds.splice(birds.indexOf(bird), 1);
  }
  break;
  }
  
  // Êõ¥Êñ∞Ë∫´‰ΩìÁøªËΩ¨Áä∂ÊÄÅ
  // ÂΩìÈù¢ÂêëÂ∑¶ËæπÊó∂ÔºåË∫´‰ΩìÈúÄË¶ÅÁøªËΩ¨
  if (bird.state !== 'fleeingFromRaptor' && bird.state !== 'flyingAway') {
    bird.bodyFlipped = (bird.facingDirection === -1);
  }
}

// ‰øÆÊîπÁø†È∏üÁªòÂà∂ÂáΩÊï∞ÔºåÂÆûÁé∞Êï¥‰ΩìÂ∑¶Âè≥ÁøªËΩ¨
function drawKingfisher(bird) {
  const baseSize = 20;
  const birdSize = baseSize * bird.size;
  
  ctx.save();
  
  // Áø†È∏üÁöÑÁâπÊÆäÂ§ÑÁêÜÔºöÂÜÖÈÉ®ÁøªËΩ¨ÈÄªËæëÁßªÈô§Ôºå‰æùËµñÂÖ®Â±ÄÁøªËΩ¨
  // if (bird.bodyFlipped) { ... } REMOVED
  
  // ÁªòÂà∂Ë∫´‰Ωì
  ctx.fillStyle = bird.type.bodyColor; // Ê©ôËâ≤Ë∫´‰Ωì
  ctx.beginPath();
  ctx.arc(bird.x, bird.y, birdSize/2, 0, Math.PI * 2);
  ctx.fill();
  
  // ‰øùÂ≠òÁîªÂ∏ÉÁä∂ÊÄÅÔºåÂáÜÂ§áÁªòÂà∂Â§¥ÈÉ®
  ctx.save();
  
  // Âπ≥ÁßªÁîªÂ∏ÉÂà∞Â§¥ÈÉ®‰ΩçÁΩÆ
  const headX = bird.x + birdSize/2 - (birdSize * 0.5)/2;
  const headY = bird.y - birdSize/2 + (birdSize * 0.5)/2;
  ctx.translate(headX, headY);
  
  // Ê†πÊçÆÂ§¥ÈÉ®ËßíÂ∫¶ÊóãËΩ¨ÁîªÂ∏ÉÔºàÂ§¥ÂíåÂò¥‰∏ÄËµ∑ÊóãËΩ¨Ôºâ
  ctx.rotate(bird.headAngle);
  
  // ÁªòÂà∂Â§¥ÈÉ®ÔºàÂú®ÊóãËΩ¨ÂêéÁöÑÂùêÊ†áÁ≥ª‰∏≠ÁªòÂà∂Ôºâ
  ctx.fillStyle = bird.type.headColor; // ÈùíËâ≤Â§¥ÈÉ®
  ctx.beginPath();
  ctx.arc(0, 0, (birdSize * 0.5)/2, 0, Math.PI * 2);
  ctx.fill();
  
  // ÁªòÂà∂ÈïøÂò¥
  const beakLength = 8 * bird.beakLengthMultiplier;
  const beakHeight = 3;
  
  ctx.fillStyle = bird.type.beakColor; // ÈªëËâ≤Âò¥
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(beakLength, 0);
  ctx.lineTo(0, beakHeight);
  ctx.closePath();
  ctx.fill();
  
  // ÁªòÂà∂ÁúºÁùõÂíåÊ©ôËâ≤ÁúºÂúà
  const eyeX = (birdSize * 0.5)/4;
  const eyeY = 0;
  
  // Ê©ôËâ≤ÁúºÂúà
  ctx.fillStyle = bird.type.eyeRingColor;
  ctx.beginPath();
  ctx.arc(eyeX, eyeY, 4, 0, Math.PI * 2);
  ctx.fill();
  
  // ÈªëËâ≤ÁúºÁùõ
  ctx.fillStyle = bird.type.eyeColor;
  ctx.beginPath();
  ctx.arc(eyeX, eyeY, 2, 0, Math.PI * 2);
  ctx.fill();
  
  // ÊÅ¢Â§çÁîªÂ∏ÉÁä∂ÊÄÅ
  ctx.restore();
  
  // ÁªòÂà∂ÁøÖËÜÄ
  ctx.fillStyle = bird.type.wingColor; // ËìùËâ≤ÁøÖËÜÄ
  ctx.fillRect(
    bird.x - birdSize/4 - (birdSize * 0.5)/2,
    bird.y - birdSize/2,
    birdSize/2,
    birdSize/3
  );
  
  // ÁªòÂà∂Â∞æÈÉ®
  ctx.fillStyle = bird.type.tailColor; // ÈùíËâ≤Â∞æÈÉ®
  const tailStartX = bird.x - birdSize/2;
  const tailStartY = bird.y - birdSize/8;
  const tailHeight = birdSize/4;
  
  ctx.beginPath();
  ctx.moveTo(tailStartX, tailStartY);
  ctx.lineTo(tailStartX - 8, tailStartY - tailHeight/2);
  ctx.lineTo(tailStartX - 8, tailStartY + tailHeight/2);
  ctx.lineTo(tailStartX, tailStartY);
  ctx.closePath();
  ctx.fill();
  
  // Â¶ÇÊûúÊçâÂà∞È±ºÔºåÁªòÂà∂È±º
  if (bird.hasCaughtFish && bird.caughtFish) {
    ctx.save();
    
    // ËÆ°ÁÆóÈ±ºÁöÑÊ≠£Á°Æ‰ΩçÁΩÆ
    // È¶ñÂÖàËÆ°ÁÆóÂò¥Â∞ñÁöÑ‰ΩçÁΩÆÔºàÂ§¥ÈÉ®‰ΩçÁΩÆ + Âò¥ÈïøÔºâ
    const headX = bird.x + birdSize/2 - (birdSize * 0.5)/2;
    const headY = bird.y - birdSize/2 + (birdSize * 0.5)/2;
    
    // Âò¥Â∞ñÂú®ÊóãËΩ¨ÂùêÊ†áÁ≥ª‰∏≠ÁöÑ‰ΩçÁΩÆ
    const beakTipX = Math.cos(bird.headAngle) * beakLength;
    const beakTipY = Math.sin(bird.headAngle) * beakLength;
    
    // È±ºÁöÑ‰ΩçÁΩÆÂ∫îËØ•Âú®Âò¥ÈáåÈù¢‰∏ÄÁÇπÔºå‰∏çÊòØÂò¥Â∞ñ
    const fishDistance = -bird.caughtFish.size/4; // Ë¥üÂÄºË°®Á§∫ÂêëÈáåÔºàÂêëÁø†È∏üÂ§¥ÈÉ®ÊñπÂêëÔºâ
    
    // Áõ¥Êé•‰ΩøÁî®ÂÖ®Â±ÄÂùêÊ†áÔºàÂÅáËÆæÈù¢ÊúùÂè≥ÔºâÔºåÂÖ®Â±ÄÁøªËΩ¨‰ºöËá™Âä®Â§ÑÁêÜÈù¢ÊúùÂ∑¶ÁöÑÊÉÖÂÜµ
    // Âò¥Â∞ñÂú®ÊóãËΩ¨ÂùêÊ†áÁ≥ª‰∏≠ÁöÑ‰ΩçÁΩÆÔºàÁõ∏ÂØπ‰∫éÂ§¥ÈÉ®‰∏≠ÂøÉÔºâ
    // Ê≥®ÊÑèÔºöÊàë‰ª¨ÈúÄË¶ÅÂÖàÊóãËΩ¨ÂÜçÂπ≥ÁßªÔºåÊàñËÄÖÁõ¥Êé•ËÆ°ÁÆóÊóãËΩ¨ÂêéÁöÑÂùêÊ†á
    // ËøôÈáåÊàë‰ª¨Áõ¥Êé•Âú®Â§¥ÈÉ®‰∏≠ÂøÉÁöÑÂü∫Á°Ä‰∏äÔºåÂä†‰∏äÊóãËΩ¨ÂêéÁöÑÂêëÈáè
    
    // Â§¥ÈÉ®‰∏≠ÂøÉÂùêÊ†á
    const headCenterX = bird.x + birdSize/2 - (birdSize * 0.5)/2;
    const headCenterY = bird.y - birdSize/2 + (birdSize * 0.5)/2;
    
    // È±ºÂú®Âò¥‰∏äÁöÑ‰ΩçÁΩÆÔºàÁõ∏ÂØπ‰∫éÂ§¥ÈÉ®‰∏≠ÂøÉÔºâ
    // Âò¥ÈïøÊòØ beakLength
    // È±ºÂú®Âò¥‰∏äÁöÑË∑ùÁ¶ªÊòØ beakLength + fishDistance (‰ªéÂ§¥‰∏≠ÂøÉÁÆóËµ∑ÂêóÔºü)
    // ‰πãÂâçÁöÑ beakTipX ÊòØÂò¥Â∞ñ„ÄÇ
    // ËÆ©Êàë‰ª¨ÈáçÊñ∞ËÆ°ÁÆóÔºö
    // Âò¥ÊòØ‰ªé (0,0) ÁîªÂà∞ (beakLength, 0) ÔºàÂú®Â§¥ÈÉ®Â±ÄÈÉ®ÂùêÊ†áÁ≥ª‰∏≠Ôºâ
    // È±ºÂ∫îËØ•Âú® (beakLength + fishDistance, 0) ÔºàÂú®Â§¥ÈÉ®Â±ÄÈÉ®ÂùêÊ†áÁ≥ª‰∏≠Ôºâ
    
    const fishLocalX = beakLength + fishDistance;
    const fishLocalY = 0;
    
    // Â∞ÜÂ±ÄÈÉ®ÂùêÊ†áËΩ¨Êç¢‰∏∫ÂÖ®Â±ÄÂùêÊ†áÔºàËÄÉËôë headAngleÔºâ
    const fishGlobalX = headCenterX + Math.cos(bird.headAngle) * fishLocalX - Math.sin(bird.headAngle) * fishLocalY;
    const fishGlobalY = headCenterY + Math.sin(bird.headAngle) * fishLocalX + Math.cos(bird.headAngle) * fishLocalY;
    
    let fishAngle = bird.headAngle + Math.PI/2;
    
    ctx.translate(fishGlobalX, fishGlobalY);
    ctx.rotate(fishAngle);
    
    // ÁªòÂà∂È±ºË∫´
    ctx.fillStyle = bird.caughtFish.color;
    ctx.beginPath();
    ctx.ellipse(0, 0, bird.caughtFish.size/2, bird.caughtFish.size/4, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // ÁªòÂà∂È±ºÂ∞æ
    ctx.beginPath();
    ctx.moveTo(-bird.caughtFish.size/3, 0);
    ctx.lineTo(-bird.caughtFish.size/2, -bird.caughtFish.size/4);
    ctx.lineTo(-bird.caughtFish.size/2, bird.caughtFish.size/4);
    ctx.closePath();
    ctx.fill();
    
    // ÁªòÂà∂È±ºÁúº
    ctx.fillStyle = "#000000";
    ctx.beginPath();
    ctx.arc(bird.caughtFish.size/4, 0, 1, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.restore();
  }
  
  ctx.restore();
}

function updateBat(bird, deltaTime) {
    if (gamePaused) return;
    bird.stateTime += deltaTime;
    bird.circlingTime += deltaTime;
    bird.wingFlapTimer += bird.wingFlapSpeed;
    if (gameMode === 'normal' && isDaytime) {
        bird.state = 'fleeing';
        bird.speed = bird.speed * 1.5;
        bird.direction = 1;
        bird.fleeStartTime = gameTime;
    }
    if (bird.circlingTime > bird.circleTime) {
        bird.state = 'leaving';
        bird.speed = 1.5;
        bird.direction = 1;
    }
    if (!bird.irregularParams) {
        bird.irregularParams = {
            radiusVariation: 0.3 + Math.random() * 0.4,
            angleVariation: 0.02 + Math.random() * 0.03,
            radiusChangeSpeed: 0.001 + Math.random() * 0.002,
            centerDriftSpeed: 0.05 + Math.random() * 0.1,
            verticalDriftSpeed: 0.02 + Math.random() * 0.03,
            currentRadius: bird.circlingRadius,
            targetRadius: bird.circlingRadius * (0.7 + Math.random() * 0.6),
            radiusDirection: Math.random() > 0.5 ? 1 : -1,
            centerDriftX: (Math.random() - 0.5) * 2,
            centerDriftY: (Math.random() - 0.5) * 2,
            verticalDrift: 0,
            verticalDirection: Math.random() > 0.5 ? 1 : -1
        };
    }
    const params = bird.irregularParams;
    switch (bird.state) {
        case 'circling':
            bird.circlingAngle += params.angleVariation * (bird.type.speedMultiplier || 1);
            params.currentRadius += params.radiusChangeSpeed * params.radiusDirection;
            if (Math.abs(params.currentRadius - params.targetRadius) < 5) {
                params.targetRadius = bird.circlingRadius * (0.7 + Math.random() * 0.6);
                params.radiusDirection *= -1;
            }
            params.currentRadius = Math.max(
                bird.circlingRadius * 0.5,
                Math.min(bird.circlingRadius * 1.5, params.currentRadius)
            );
            bird.circlingCenterX += params.centerDriftX * params.centerDriftSpeed;
            bird.circlingCenterY += params.centerDriftY * params.centerDriftSpeed;
            bird.circlingCenterX = Math.max(
                GAME_WIDTH * 0.3,
                Math.min(GAME_WIDTH * 0.7, bird.circlingCenterX)
            );
            bird.circlingCenterY = Math.max(
                GAME_HEIGHT * 0.2,
                Math.min(GAME_HEIGHT * 0.4, bird.circlingCenterY)
            );
            params.verticalDrift += params.verticalDriftSpeed * params.verticalDirection;
            if (Math.abs(params.verticalDrift) > 20) {
                params.verticalDirection *= -1;
            }
            const effectiveRadiusX = params.currentRadius * (1 + Math.sin(bird.circlingAngle * 0.5) * 0.2);
            const effectiveRadiusY = params.currentRadius * (1 + Math.cos(bird.circlingAngle * 0.3) * 0.2);
            bird.x = bird.circlingCenterX + Math.cos(bird.circlingAngle) * effectiveRadiusX;
            bird.y = bird.circlingCenterY + Math.sin(bird.circlingAngle) * effectiveRadiusY + params.verticalDrift;
            if (bird.y > GAME_HEIGHT * 0.5) {
                bird.y = GAME_HEIGHT * 0.5 - 10;
                bird.circlingAngle += Math.PI * 0.2;
                params.verticalDrift = -10;
                params.verticalDirection = -1;
            }
            if (bird.y < GAME_HEIGHT * 0.15) {
                bird.y = GAME_HEIGHT * 0.15 + 10;
                bird.circlingAngle += Math.PI * 0.2;
                params.verticalDrift = 10;
                params.verticalDirection = 1;
            }
            if (Math.random() < 0.01) {
                params.centerDriftX = (Math.random() - 0.5) * 2;
                params.centerDriftY = (Math.random() - 0.5) * 2;
            }
            if (Math.random() < 0.02) {
                params.verticalDirection *= -1;
            }
            const tangentAngle = bird.circlingAngle + Math.PI / 2;
            bird.direction = Math.cos(tangentAngle) > 0 ? 1 : -1;
            if (Math.random() < 0.005) {
                bird.direction *= -1;
                bird.circlingAngle += Math.PI * 0.5;
            }
            break;
        case 'leaving':
        case 'fleeing':
            // Ê∞¥Âπ≥Êñú‰∏äÈ£ûÔºåËßíÂ∫¶‰∏çË∂ÖËøá20Â∫¶
            const batLeavingAngle = (8 + Math.random() * 12) * Math.PI / 180; // 8-20Â∫¶
            bird.x += bird.speed * Math.cos(batLeavingAngle);
            bird.y -= bird.speed * Math.sin(batLeavingAngle);
            // ‰øùÊåÅÂéüÊúâÁöÑÊëÜÂä®ÊïàÊûúÔºå‰ΩÜÂáèÂ∞èÂπÖÂ∫¶
            bird.y += Math.sin(gameTime * 0.001) * 0.1; // ÂáèÂ∞èÂûÇÁõ¥ÊëÜÂä®ÂπÖÂ∫¶
            bird.x += Math.sin(gameTime * 0.002) * 0.2; // ÂáèÂ∞èÊ∞¥Âπ≥ÊëÜÂä®ÂπÖÂ∫¶
            if (bird.x > GAME_WIDTH + 100 || bird.y < -100) {
                birds.splice(birds.indexOf(bird), 1);
            }
            break;
    }
}

function updateOwlBird(bird, deltaTime) {
    bird.stateTime += deltaTime;
    bird.faceChangeTimer += deltaTime;
    if (bird.faceChangeTimer > bird.faceChangeInterval) {
        bird.faceChangeTimer = 0;
        bird.faceChangeInterval = 10000 + Math.random() * 10000;
    }
    if (bird.name !== "ÈõïÈ∏Æ" && bird.state !== 'fleeing') {
        for (const otherBird of birds) {
            if (otherBird.name === "ÈõïÈ∏Æ" && otherBird.state !== 'fleeing') {
                bird.state = 'fleeing';
                bird.speed = bird.speed * 2;
                bird.direction = Math.random() > 0.5 ? 1 : -1;
                bird.fleeStartTime = gameTime;
                break;
            }
        }
    }
    if (gameMode === 'normal' && isDaytime && bird.state !== 'fleeing') {
        bird.state = 'fleeing';
        bird.speed = bird.speed * 1.5;
        bird.direction = 1;
        bird.fleeStartTime = gameTime;
    }
    switch (bird.state) {
        case 'circling':
            bird.circlingTime += deltaTime;
            bird.circlingAngle += 0.01 * (bird.type.speedMultiplier || 1);
            bird.x = bird.circlingCenterX + Math.cos(bird.circlingAngle) * bird.circlingRadius;
            bird.y = bird.circlingCenterY + Math.sin(bird.circlingAngle) * bird.circlingRadius;
            const tangentAngle = bird.circlingAngle + Math.PI / 2;
            bird.direction = Math.cos(tangentAngle) > 0 ? 1 : -1;
            if (bird.circlingTime > bird.circleTime) {
                bird.state = 'glidingToGround';
                bird.speed = 0.8 * (bird.type.speedMultiplier || 1);
                bird.direction = Math.random() > 0.5 ? 1 : -1;
                bird.glidingStartY = bird.y;
            }
            break;
        case 'glidingToGround':
            bird.x += bird.speed * bird.direction * 0.3;
            bird.y += bird.speed * 1.5;
            if (bird.y >= GAME_HEIGHT - 60) {
                if (Math.random() < bird.catchPreyChance) {
                    if (bird.catchPreyType === "hedgehog") {
                        bird.caughtPrey = generateHedgehog();
                    } else if (bird.catchPreyType === "mouse") {
                        bird.caughtPrey = generateGroundMouseForPredator(bird.name);
                    }
                    if (bird.caughtPrey) {
                        const index = groundObjects.indexOf(bird.caughtPrey);
                        if (index !== -1) {
                            groundObjects.splice(index, 1);
                        }
                    }
                    bird.state = 'flyingWithPrey';
                    bird.speed = 1.5;
                    bird.direction = 1;
                    bird.y -= 50;
                } else {
                    bird.state = 'leaving';
                    bird.speed = 1.5;
                    bird.direction = 1;
                }
            }
            break;
        case 'flyingWithPrey':
        case 'leaving':
            // Ê∞¥Âπ≥Êñú‰∏äÈ£ûÔºåËßíÂ∫¶‰∏çË∂ÖËøá20Â∫¶
            const owlLeavingAngle = (10 + Math.random() * 10) * Math.PI / 180; // 10-20Â∫¶
            bird.x += bird.speed * Math.cos(owlLeavingAngle);
            bird.y -= bird.speed * Math.sin(owlLeavingAngle);
            if (bird.x > GAME_WIDTH + 100 || bird.y < -100) {
                birds.splice(birds.indexOf(bird), 1);
            }
            break;
        case 'fleeing':
            // Ê∞¥Âπ≥Êñú‰∏äÈ£ûÔºåËßíÂ∫¶‰∏çË∂ÖËøá20Â∫¶
            const owlFleeAngle = (12 + Math.random() * 8) * Math.PI / 180; // 12-20Â∫¶
            bird.x += bird.speed * bird.direction * Math.cos(owlFleeAngle);
            bird.y -= bird.speed * Math.sin(owlFleeAngle);
            if (bird.x < -100 || bird.x > GAME_WIDTH + 100 || bird.y < -100) {
                birds.splice(birds.indexOf(bird), 1);
            }
            break;
    }
}

function updatePoops(deltaTime) {
    if (gamePaused) return;
    
    // Êõ¥Êñ∞ÊâÄÊúâÁ≤™‰æøÁöÑ‰ΩçÁΩÆÔºà‰∏ãËêΩÔºâ
    for (let i = poops.length - 1; i >= 0; i--) {
        const poop = poops[i];
        
        // ‰∏ãËêΩÊïàÊûú
        poop.y += poop.speed * (deltaTime / 16); // Ê†áÂáÜÂåñÈÄüÂ∫¶
        
        // Ê∑ªÂä†‰∏ÄÁÇπÂ∑¶Âè≥ÊëÜÂä®ÊïàÊûúÔºå‰ΩøÁ≤™‰æøÁúãËµ∑Êù•Êõ¥Ëá™ÁÑ∂
        poop.x += Math.sin(gameTime * 0.001 + i) * 0.1;
        
        // Ê£ÄÊü•ÊòØÂê¶ËêΩÂú∞ÊàñËøáÊúü
        const isOutOfBounds = poop.y > GAME_HEIGHT || poop.x < 0 || poop.x > GAME_WIDTH;
        const isExpired = gameTime - poop.createdAt > poop.lifetime;
        
        if (isOutOfBounds || isExpired) {
            poops.splice(i, 1);
        }
    }
}

function drawPoops() {
    poopCtx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT); // Ê∏ÖÈô§‰πãÂâçÁöÑÁªòÂà∂
    poops.forEach(poop => {
        poopCtx.fillStyle = poop.color;
        poopCtx.beginPath();
        poopCtx.arc(poop.x, poop.y, poop.size, 0, Math.PI * 2);
        poopCtx.fill();
    });
}

function updateGroundObjects(deltaTime) {
    for (let i = groundObjects.length - 1; i >= 0; i--) {
        const obj = groundObjects[i];
        
        if (gameTime - obj.createdAt > obj.lifetime) {
            groundObjects.splice(i, 1);
        }
    }
}

function drawGroundObjects() {
    groundObjects.forEach(obj => {
        if (obj.type === "mouse") {
            ctx.fillStyle = obj.color;
            ctx.beginPath();
            ctx.ellipse(obj.x, obj.y, obj.size, obj.size/1.5, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = obj.color;
            ctx.beginPath();
            ctx.arc(obj.x + obj.size, obj.y, obj.size/2, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = "#000000";
            ctx.beginPath();
            ctx.arc(obj.x + obj.size + 2, obj.y - 1, 1, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = obj.color;
            ctx.lineWidth = 2;
            ctx.lineCap = "round";
            ctx.beginPath();
            ctx.moveTo(obj.x - obj.size, obj.y);
            ctx.lineTo(obj.x - obj.size - 10, obj.y + 3);
            ctx.stroke();
            
            obj.x += Math.sin(gameTime * 0.001) * 0.1;
        } else if (obj.type === "hedgehog") {
            ctx.fillStyle = obj.color;
            ctx.beginPath();
            ctx.arc(obj.x, obj.y, obj.size, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = obj.color;
            ctx.beginPath();
            ctx.moveTo(obj.x + obj.size, obj.y);
            ctx.lineTo(obj.x + obj.size * 1.5, obj.y - obj.size * 0.5);
            ctx.lineTo(obj.x + obj.size * 1.5, obj.y + obj.size * 0.5);
            ctx.closePath();
            ctx.fill();
            
            ctx.strokeStyle = "#8B4513";
            ctx.lineWidth = 2;
            ctx.lineCap = "round";
            for (let i = 0; i < 24; i++) {
                const angle = (i / 24) * Math.PI * 2;
                const length = 3 + Math.random() * 1.5;
                const startX = obj.x + Math.cos(angle) * obj.size;
                const startY = obj.y + Math.sin(angle) * obj.size;
                const endX = obj.x + Math.cos(angle) * (obj.size + length);
                const endY = obj.y + Math.sin(angle) * (obj.size + length);
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.stroke();
            }
            
            ctx.fillStyle = "#000000";
            ctx.beginPath();
            ctx.arc(obj.x + obj.size * 1.2, obj.y - obj.size * 0.2, 1, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = "#000000";
            ctx.beginPath();
            ctx.arc(obj.x + obj.size * 1.5, obj.y, 0.8, 0, Math.PI * 2);
            ctx.fill();
            
            obj.x += Math.sin(gameTime * 0.001) * 0.05;
        }
    });
}

function updateFruits(deltaTime) {
    fruits.forEach(fruit => {
        if (fruit.isEaten && gameTime - fruit.eatStartTime > 10000) {
            fruit.isEaten = false;
            fruit.color = fruit.originalColor;
            fruit.eatenBy = null;
        }
    });
}

function drawViewfinder() {
    const viewfinderSize = getViewfinderSize();
    const actualViewfinderWidth = viewfinderSize.width;
    const actualViewfinderHeight = viewfinderSize.height;
    
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
    ctx.lineWidth = 2;
    ctx.setLineDash([5, 5]);
    ctx.strokeRect(
        mouseX - actualViewfinderWidth / 2,
        mouseY - actualViewfinderHeight / 2,
        actualViewfinderWidth,
        actualViewfinderHeight
    );
    ctx.setLineDash([]);
}

// ‰øÆÊîπgameLoopÂáΩÊï∞ÔºåÂú®ÈôÄËû∫‰ª™Ê®°Âºè‰∏ãÊõ¥Êñ∞ÂèñÊôØÊ°Ü
function gameLoop(timestamp) {
  if (gamePaused) {
    requestAnimationFrame(gameLoop);
    return;
  }
    const deltaTime = timestamp - lastFrameTime;
    lastFrameTime = timestamp;
    
    updateDayNight(deltaTime);
    
    ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
    poopCtx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
// Êõ¥Êñ∞ËßÇÈ∏üÊ®°ÂºèÁä∂ÊÄÅÊåáÁ§∫Âô®
if (birdingModeActive) {
    const birdingStatusIndicator = document.getElementById('birdingStatusIndicator');
    const birdingDuration = gameTime - birdingModeStartTime;
    const birdingMinutes = Math.floor(birdingDuration / 60000);
    const birdingSeconds = Math.floor((birdingDuration % 60000) / 1000);
    
    // Âè™ÊòæÁ§∫ËßÇÈ∏üÂ∑≤ËøõË°åÁöÑÊó∂Èó¥Ôºå‰∏çÊòæÁ§∫ÂÄíËÆ°Êó∂
    birdingStatusIndicator.textContent = `ËøõË°å‰∏≠ ${birdingMinutes}:${birdingSeconds.toString().padStart(2, '0')}`;
 }
    if (gameMode === 'normal' && isDaytime) {
        updateGoldenFilter();
    }
    
    drawBackground();
    drawSunMoon();
    drawStars();
    drawClouds();
    
    updateNightObjects(deltaTime);
    
    drawMountains();
    nightObjects.forEach(obj => drawNightObject(obj));
    
    drawTrees();
    drawReeds();
    drawWallAndHole();
    drawGroundObjects();
    
    generateBird();
    
    updateBirds(deltaTime);
    updatePoops(deltaTime);
    updateGroundObjects(deltaTime);
    updateFruits(deltaTime);
      // Âú®ÈôÄËû∫‰ª™Ê®°Âºè‰∏ãÔºåÊàë‰ª¨ÈúÄË¶ÅÊåÅÁª≠Êõ¥Êñ∞ÂèñÊôØÊ°Ü‰ΩçÁΩÆ
  if (gyroModeActive) {
    updateViewfinderFromGyro();
  }
    birds.forEach(bird => drawBird(bird));
    drawPoops();
    
    drawViewfinder();
    
    requestAnimationFrame(gameLoop);
}

window.onload = init; </script></body></html>
