<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<title>è§‚é¸Ÿæ¨¡æ‹Ÿå™¨ - ä¸€ä¸‡ä¸¤åƒé¸»ä½¿ç”¨AIåˆ¶ä½œ</title>
<style>
html, body {
    width: 100%;
    height: 100%;
    margin: 0;
    padding: 0;
    overflow: hidden;
}

#gameContainer {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: #000;
    overflow: hidden;
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    user-select: none;
}

body {
    background-color: #000;
    overflow: hidden;
    font-family: 'SimSun', sans-serif;
    color: #333;
}

#gameContainer {
    position: relative;
    width: 100vw;
    height: 100vh;
    overflow: hidden;
}

#gameCanvas {
    display: block;
    background: linear-gradient(to bottom, #87CEEB 0%, #E0F7FF 100%);
    cursor: crosshair;
    width: 100%;
    height: 100%;
    object-fit: contain;
}

#poopCanvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 5;
}

#viewfinder {
    position: absolute;
    border: 2px dashed rgba(255, 255, 255, 0.8);
    background-color: rgba(255, 255, 255, 0.1);
    pointer-events: none;
    display: none;
    z-index: 100;
}

#photoPreview {
    position: absolute;
    top: 10px;
    left: 10px;
    width: 120px;
    height: 80px;
    border: 2px solid white;
    border-radius: 5px;
    background-color: rgba(0, 0, 0, 0.3);
    overflow: hidden;
    z-index: 60;
    cursor: pointer;
}

#photoPreview img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

#photoPreview .noPhoto {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100%;
    color: white;
    font-size: 12px;
    text-align: center;
}

#birdingToggleContainer {
    position: absolute;
    top: 10px;
    right: 10px;
    z-index: 70;
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 2px;
    padding-bottom: 30px;
}

#helpButton {
    position: absolute;
    top: 105px;
    right: 10px;
    background-color: rgba(0, 0, 0, 0.7);
    color: #FFD700;
    border: 2px solid #FFD700;
    border-radius: 50%;
    width: 30px;
    height: 30px;
    font-size: 16px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 72;
}

#helpButton:hover {
    background-color: rgba(255, 215, 0, 0.3);
    transform: scale(1.1);
}

#helpButton:active {
    transform: scale(0.95);
}

#birdingModeToggle {
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    border: 2px solid #90EE90;
    border-radius: 20px;
    padding: 6px 16px;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.3s;
    min-width: 120px;
    text-align: center;
    height: 36px;
    box-sizing: border-box;
    display: flex;
    align-items: center;
    justify-content: center;
}

#birdingModeToggle:hover {
    background-color: rgba(144, 238, 144, 0.3);
}

#birdingModeToggle.active {
    background-color: rgba(144, 238, 144, 0.5);
    border-color: #FFFFFF;
}

#birdingStatusIndicator {
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 3px 10px;
    border-radius: 10px;
    font-size: 12px;
    border: 1px solid #90EE90;
    text-align: center;
    min-width: 120px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
    box-sizing: border-box;
}

#birdingRecordIcon {
    background: rgba(0, 0, 0, 0.8);
    border: 2px solid #FFD700;
    border-radius: 8px;
    width: 120px;
    height: 20px;
    cursor: pointer;
    transition: all 0.3s;
    position: absolute;
    top: 75px;
    right: 0;
    overflow: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
    font-size: 10px;
    color: #FFD700;
    font-weight: bold;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
    z-index: 71;
}

#birdingRecordIcon:hover {
    background: rgba(255, 215, 0, 0.15);
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(255, 215, 0, 0.2);
}

#birdingRecordIcon:active {
    transform: translateY(0);
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
}

#birdingRecordIcon::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 3px;
    background: linear-gradient(90deg, #FFD700, #FFA500);
}

#birdingRecordIcon .iconNumber {
    font-size: 11px;
    font-weight: bold;
    color: #FFD700;
    margin-right: 4px;
}

#birdingRecordIcon .iconTime {
    font-size: 9px;
    color: #87CEEB;
    margin-right: 4px;
}

#birdingRecordIcon .iconBirdCount {
    font-size: 9px;
    color: #90EE90;
}

#birdingRecordNav {
    position: fixed;
    top: 50%;
    left: 0;
    right: 0;
    display: flex;
    justify-content: space-between;
    padding: 0 20px;
    z-index: 410;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.3s;
}

#birdingRecordNav.show {
    opacity: 1;
}

.birdingRecordNavButton {
    pointer-events: auto;
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    border: 2px solid #FFD700;
    border-radius: 50%;
    width: 50px;
    height: 50px;
    font-size: 24px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s;
}

.birdingRecordNavButton:hover {
    background-color: rgba(255, 215, 0, 0.3);
    transform: scale(1.1);
}

.birdingRecordNavButton:disabled {
    opacity: 0.3;
    cursor: not-allowed;
}

.birdingRecordNavButton:disabled:hover {
    background-color: rgba(0, 0, 0, 0.7);
    transform: none;
}

#birdingRecordCounter {
    position: fixed;
    bottom: 20px;
    left: 0;
    right: 0;
    text-align: center;
    color: white;
    font-size: 16px;
    z-index: 410;
    background-color: rgba(0, 0, 0, 0.5);
    padding: 10px;
    border-radius: 10px;
    margin: 0 auto;
    width: fit-content;
    opacity: 0;
    transition: opacity 0.3s;
}

#birdingRecordCounter.show {
    opacity: 1;
}

.swipe-hint {
    position: fixed;
    bottom: 80px;
    left: 0;
    right: 0;
    text-align: center;
    color: #FFD700;
    font-size: 14px;
    z-index: 410;
    opacity: 0.7;
    animation: pulse 2s infinite;
}

#textStats {
    position: absolute;
    top: 95px;
    left: 10px;
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 6px 12px;
    border-radius: 6px;
    z-index: 50;
    font-size: 12px;
    max-width: 90%;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

#textStats span {
    margin: 0 8px;
    color: #FFD700;
    font-weight: bold;
}

#albumModal {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.85);
    z-index: 200;
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
}

#albumTitle {
    color: white;
    margin-bottom: 10px;
    font-size: 24px;
}

#albumPromotion {
    color: #FFD700;
    margin-bottom: 20px;
    font-size: 16px;
    text-align: center;
}

#albumPhotos {
    display: flex;
    flex-wrap: wrap;
    justify-content: flex-start;
    align-content: flex-start;
    max-width: 90%;
    max-height: 70%;
    overflow-x: auto;
    overflow-y: auto;
    padding: 20px;
    width: 100%;
}

.albumPhoto {
    width: 160px;
    height: 140px;
    margin: 10px;
    border: 2px solid white;
    border-radius: 5px;
    overflow: hidden;
    position: relative;
    display: flex;
    flex-direction: column;
    flex-shrink: 0;
}

.albumPhoto img {
    width: 100%;
    height: 100px;
    object-fit: cover;
}

.photoInfo {
    background: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 5px;
    font-size: 12px;
    text-align: center;
    flex-grow: 1;
    display: flex;
    align-items: center;
    justify-content: center;
}

#albumStats {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    max-width: 90%;
    max-height: 20%;
    overflow-y: auto;
    padding: 10px;
    margin-top: 10px;
}

.albumStatItem {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 4px 8px;
    margin: 2px;
    border-radius: 4px;
    background-color: rgba(255, 255, 255, 0.1);
    color: white;
    font-size: 12px;
    min-width: 120px;
}

#closeAlbum {
    position: absolute;
    top: 20px;
    right: 20px;
    background-color: rgba(255, 255, 255, 0.2);
    color: white;
    border: none;
    border-radius: 50%;
    width: 40px;
    height: 40px;
    font-size: 20px;
    cursor: pointer;
}

#gameTitle {
    position: absolute;
    top: 100px;
    left: 0;
    width: 100%;
    text-align: center;
    color: white;
    font-size: 24px;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
    z-index: 10;
    display: none;
}

#creator {
    position: absolute;
    top: 5px;
    left: 0;
    width: 100%;
    text-align: center;
    color: white;
    font-size: 16px;
    text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.7);
    z-index: 10;
}

#specialAlert {
    position: absolute;
    top: 140px;
    left: 0;
    width: 100%;
    text-align: center;
    color: #FFD700;
    font-size: 20px;
    font-weight: bold;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
    z-index: 10;
    opacity: 0;
    transition: opacity 0.5s;
}

#captureAlert {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: #FFD700;
    text-align: center;
    font-size: 18px;
    font-weight: bold;
    z-index: 150;
    opacity: 0;
    transition: opacity 0.3s;
    pointer-events: none;
    text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.9);
    background-color: transparent;
    padding: 0;
}

#gameNote {
    position: absolute;
    bottom: 5px;
    left: 0;
    width: 100%;
    text-align: center;
    color: white;
    font-size: 12px;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
    z-index: 10;
    opacity: 0.7;
    padding: 0 10px;
}

#modeToggleContainer {
    position: absolute;
    bottom: 10px;
    right: 10px;
    display: flex;
    gap: 10px;
    z-index: 70;
}

.modeToggleButton {
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    border: 2px solid #FFD700;
    border-radius: 20px;
    padding: 8px 16px;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.3s;
}

.modeToggleButton:hover {
    background-color: rgba(255, 215, 0, 0.3);
}

.modeToggleButton.active {
    background-color: rgba(255, 215, 0, 0.5);
    border-color: #FFFFFF;
}

#timeIndicator {
    position: absolute;
    top: 30px;
    left: 50%;
    transform: translateX(-50%);
    color: white;
    font-size: 14px;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
    z-index: 10;
    opacity: 0.8;
}

#nightObjectAlert {
    position: absolute;
    top: 180px;
    left: 0;
    width: 100%;
    text-align: center;
    color: #87CEEB;
    font-size: 18px;
    font-weight: bold;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
    z-index: 10;
    opacity: 0;
    transition: opacity 0.5s;
}

.meteor-trail {
    position: absolute;
    background: linear-gradient(to right, rgba(255,255,255,0) 0%, rgba(255,255,255,0.8) 50%, rgba(255,255,255,0) 100%);
    border-radius: 2px;
    z-index: 2;
    pointer-events: none;
}

.comet-trail {
    position: absolute;
    background: radial-gradient(circle, rgba(173,216,230,0.8) 0%, rgba(173,216,230,0) 70%);
    border-radius: 50%;
    z-index: 2;
    pointer-events: none;
}

.ufo-beam {
    position: absolute;
    background: linear-gradient(to bottom, rgba(144,238,144,0.7) 0%, rgba(144,238,144,0) 100%);
    border-radius: 50%;
    z-index: 2;
    pointer-events: none;
}

#allBirdsAlert {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: rgba(0, 0, 0, 0.9);
    color: #FFD700;
    padding: 30px 40px;
    border-radius: 15px;
    border: 3px solid #FFD700;
    font-size: 24px;
    font-weight: bold;
    text-align: center;
    z-index: 300;
    max-width: 80%;
    box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
    animation: pulse 2s infinite;
}

@keyframes pulse {
    0% {
        transform: translate(-50%, -50%) scale(1);
    }
    50% {
        transform: translate(-50%, -50%) scale(1.05);
    }
    100% {
        transform: translate(-50%, -50%) scale(1);
    }
}

#lensToggleContainer {
    position: absolute;
    bottom: 10px;
    left: 10px;
    display: flex;
    gap: 10px;
    z-index: 70;
    background-color: rgba(0, 0, 0, 0.7);
    padding: 8px;
    border-radius: 20px;
    border: 2px solid #FFD700;
}

.lensToggleButton {
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    border: 1px solid #FFD700;
    border-radius: 15px;
    padding: 6px 12px;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.3s;
}

.lensToggleButton:hover {
    background-color: rgba(255, 215, 0, 0.3);
}

.lensToggleButton.active {
    background-color: rgba(255, 215, 0, 0.5);
    border-color: #FFFFFF;
}

#goldenFilter {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(255, 215, 0, 0);
    pointer-events: none;
    z-index: 5;
    transition: background-color 1s ease;
}

.birdingRecordIcon {
    background: rgba(0, 0, 0, 0.8);
    border: 2px solid #FFD700;
    border-radius: 10px;
    width: 60px;
    height: 60px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.3s;
    position: relative;
    overflow: hidden;
}

.birdingRecordIcon:hover {
    background: rgba(255, 215, 0, 0.2);
    transform: scale(1.05);
    box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
}

.birdingRecordIcon::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 5px;
    background: linear-gradient(90deg, #FFD700, #FFA500);
}

.birdingRecordIcon .iconNumber {
    font-size: 18px;
    font-weight: bold;
    color: #FFD700;
    margin-bottom: 2px;
}

.birdingRecordIcon .iconTime {
    font-size: 11px;
    color: #87CEEB;
}

.birdingRecordIcon .iconBirdCount {
    font-size: 10px;
    color: #90EE90;
    margin-top: 2px;
}

.birdRecordText {
    background: rgba(0, 0, 0, 0.7);
    border-radius: 8px;
    padding: 15px;
    margin-bottom: 10px;
    border-left: 4px solid #87CEEB;
}

.birdRecordText.highlight {
    border-left-color: #FFD700;
    background: rgba(255, 215, 0, 0.1);
}

.birdRecordText .birdName {
    color: white;
    font-size: 16px;
    font-weight: bold;
    margin-bottom: 5px;
}

.birdRecordText .birdStats {
    font-size: 14px;
    color: #87CEEB;
}

.birdRecordText .birdStats span {
    margin-right: 15px;
}

.birdRecordText.highlight .birdName {
    color: #FFD700;
}

.recordSummaryText {
    background: rgba(0, 0, 0, 0.5);
    border-radius: 8px;
    padding: 12px;
    margin-bottom: 15px;
    border-top: 2px solid #90EE90;
}

.recordSummaryText .summaryItem {
    display: inline-block;
    margin-right: 20px;
    font-size: 14px;
}

.recordSummaryText .summaryLabel {
    color: #87CEEB;
}

.recordSummaryText .summaryValue {
    color: white;
    font-weight: bold;
}

.rareBirdText {
    background: rgba(255, 215, 0, 0.15);
    border: 1px solid #FFD700;
    border-radius: 6px;
    padding: 8px 12px;
    margin: 5px 0;
    color: #FFD700;
    font-size: 14px;
}

.rareBirdText::before {
    content: 'â˜… ';
}

#gyroToggleContainer {
    position: absolute;
    left: 10px;
    top: 50%;
    transform: translateY(-50%);
    z-index: 70;
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 5px;
}

#gyroSensitivityContainer {
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 3px 8px;
    border-radius: 8px;
    border: 1px solid #FFA500;
    z-index: 70;
    width: 80px;
    margin-bottom: 5px;
    height: 35px;
    display: none;
}

#gyroSensitivityContainer.active {
    display: block;
}

#gyroSensitivityLabel {
    font-size: 10px;
    margin-bottom: 2px;
    text-align: center;
}

#gyroSensitivitySlider {
    width: 100%;
    height: 4px;
    -webkit-appearance: none;
    appearance: none;
    background: #555;
    border-radius: 2px;
    outline: none;
}

#gyroSensitivitySlider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 12px;
    height: 12px;
    background: #FFA500;
    border-radius: 50%;
    cursor: pointer;
}

#gyroSensitivityValue {
    font-size: 10px;
    margin-top: 1px;
    text-align: center;
}

#gyroModeToggle {
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    border: 2px solid #FFA500;
    border-radius: 20px;
    padding: 6px 12px;
    font-size: 12px;
    cursor: pointer;
    transition: all 0.3s;
    min-width: 60px;
    max-width: 80px;
    text-align: center;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

#gyroModeToggle:hover {
    background-color: rgba(255, 165, 0, 0.3);
}

#gyroModeToggle.active {
    background-color: rgba(255, 165, 0, 0.5);
    border-color: #FFFFFF;
}

#gyroStatusIndicator {
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 4px 8px;
    border-radius: 10px;
    font-size: 10px;
    border: 1px solid #FFA500;
    text-align: center;
    min-width: 60px;
    max-width: 80px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    margin-bottom: 5px;
}

#gyroCalibrateButton {
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    border: 2px solid #4CAF50;
    border-radius: 20px;
    padding: 4px 8px;
    font-size: 10px;
    cursor: pointer;
    transition: all 0.3s;
    min-width: 60px;
    max-width: 80px;
    text-align: center;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

#gyroCalibrateButton:hover {
    background-color: rgba(76, 175, 80, 0.3);
}

#cameraButton {
    position: absolute;
    right: 15px;
    top: 50%;
    transform: translateY(-50%);
    width: 70px;
    height: 70px;
    background-color: rgba(255, 255, 255, 0.9);
    border-radius: 50%;
    border: 4px solid #FFD700;
    cursor: pointer;
    z-index: 80;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}

#cameraButton:hover {
    background-color: rgba(255, 255, 255, 1);
    transform: translateY(-50%) scale(1.05);
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
}

#cameraButton:active {
    background-color: rgba(230, 230, 230, 1);
    transform: translateY(-50%) scale(0.95);
}

#cameraButton::after {
    content: '';
    width: 40px;
    height: 40px;
    background-color: #FFD700;
    border-radius: 50%;
    border: 3px solid #333;
}

#screenshotCanvas {
    position: fixed;
    top: -10000px;
    left: -10000px;
    width: 300px;
    height: 450px;
    z-index: 1000;
}

#screenshotButton {
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    border: 2px solid #87CEEB;
    border-radius: 20px;
    padding: 8px 16px;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.3s;
    position: absolute;
    top: 20px;
    right: 70px;
    z-index: 401;
    display: none;
}

#screenshotButton:hover {
    background-color: rgba(135, 206, 235, 0.3);
}

#screenshotButton:active {
    background-color: rgba(135, 206, 235, 0.5);
}

#screenshotPreviewModal {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.9);
    z-index: 500;
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    padding-top: 20px;
    overflow-y: auto;
}

#screenshotPreviewImage {
    max-height: 90vh;
    max-width: 90%;
    object-fit: contain;
    border: 3px solid #FFD700;
    border-radius: 10px;
    box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
    margin-bottom: 20px;
}

#screenshotPreviewControls {
    margin-top: 20px;
    display: flex;
    gap: 15px;
    margin-bottom: 20px;
}

.screenshotPreviewButton {
    background-color: rgba(255, 215, 0, 0.8);
    color: black;
    border: none;
    border-radius: 25px;
    padding: 10px 25px;
    font-size: 16px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s;
    min-width: 120px;
}

.screenshotPreviewButton:hover {
    background-color: rgba(255, 215, 0, 1);
    transform: scale(1.05);
}

.screenshotPreviewButton:active {
    transform: scale(0.95);
}

#screenshotPreviewClose {
    position: absolute;
    top: 20px;
    right: 20px;
    background-color: rgba(255, 255, 255, 0.2);
    color: white;
    border: none;
    border-radius: 50%;
    width: 40px;
    height: 40px;
    font-size: 20px;
    cursor: pointer;
}

#lensToggleContainer.hidden-by-gyro,
#modeToggleContainer.hidden-by-gyro {
    opacity: 0.3;
    background-color: rgba(0, 0, 0, 0.3);
    border-color: rgba(255, 215, 0, 0.3);
    cursor: pointer;
    transition: opacity 0.3s, background-color 0.3s;
}

#lensToggleContainer.hidden-by-gyro:hover,
#modeToggleContainer.hidden-by-gyro:hover {
    opacity: 0.7;
    background-color: rgba(0, 0, 0, 0.5);
}

#lensToggleContainer.hidden-by-gyro::after,
#modeToggleContainer.hidden-by-gyro::after {
    content: 'ç‚¹å‡»æ˜¾ç¤º';
    position: absolute;
    font-size: 10px;
    color: #FFD700;
    background: rgba(0, 0, 0, 0.7);
    padding: 2px 5px;
    border-radius: 3px;
    white-space: nowrap;
    z-index: 71;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.3s;
}

#lensToggleContainer.hidden-by-gyro:hover::after,
#modeToggleContainer.hidden-by-gyro:hover::after {
    opacity: 1;
}

#lensToggleContainer.hidden-by-gyro::after {
    bottom: -20px;
    left: 50%;
    transform: translateX(-50%);
}

#modeToggleContainer.hidden-by-gyro::after {
    bottom: -20px;
    right: 10px;
}

#lensToggleContainer.temporarily-show,
#modeToggleContainer.temporarily-show {
    opacity: 1 !important;
    background-color: rgba(0, 0, 0, 0.7) !important;
    border-color: #FFD700 !important;
    display: flex !important;
}

#campsite {
    pointer-events: none; /* é»˜è®¤ä¸æ•è·é¼ æ ‡äº‹ä»¶ */
    position: absolute;
    z-index: 25;
    cursor: pointer;
    display: none;
    width: 300px;
    height: 150px;
}

#campsite > div {
    width: 100%;
    height: 100%;
    position: relative;
}

#campsite > div > div:first-child {
    position: absolute;
    bottom: 0;
    right: 16.67%;
    width: 30%;
    height: 40%;
    z-index: 2;
}

#campsite > div > div:first-child > div {
    position: absolute;
    bottom: 0;
    left: 50%;
    transform: translateX(-50%);
    width: 0;
    height: 0;
    border-left: 15% solid transparent;
    border-right: 15% solid transparent;
    border-bottom: 40% solid #B22222;
}

#campsite > div > div:nth-child(2) {
    position: absolute;
    bottom: 0;
    left: 23.33%;
    width: 20%;
    height: 30%;
    z-index: 1;
}

#campsite > div > div:nth-child(2) > div:first-child {
    position: absolute;
    bottom: 0;
    left: 13.33%;
    width: 75%;
    height: 17.78%;
    background-color: #8B4513;
    transform: rotate(-15deg);
}

#campsite > div > div:nth-child(2) > div:nth-child(2) {
    position: absolute;
    bottom: 8.89%;
    left: 20%;
    width: 63.33%;
    height: 17.78%;
    background-color: #A0522D;
    transform: rotate(10deg);
}

#campfire-flame {
    pointer-events: auto; /* åªæœ‰ç¯ç«å¯ä»¥ç‚¹å‡» */
    cursor: pointer;
    position: absolute;
    bottom: 26.67%;
    left: 50%;
    transform: translateX(-50%);
    width: 50%;
    height: 66.67%;
    background: radial-gradient(circle, #FF4500 0%, #FF8C00 30%, #FFD700 70%);
    border-radius: 50% 50% 20% 20%;
    filter: blur(2px);
    animation: flame-flicker 0.5s infinite alternate;
    z-index: 3;
}

#campsite > div > div:last-child {
    position: absolute;
    bottom: 16.67%;
    left: 50%;
    transform: translateX(-50%);
    color: #FFD700;
    font-size: 12px;
    font-weight: bold;
    text-shadow: 1px 1px 3px rgba(0,0,0,0.8);
    text-align: center;
    background-color: rgba(0,0,0,0.5);
    padding: 2px 6px;
    border-radius: 4px;
    opacity: 0.8;
    white-space: nowrap;
    z-index: 4;
}

@keyframes flame-flicker {
    0% {
        transform: translateX(-50%) scale(1.0);
        opacity: 0.9;
    }
    100% {
        transform: translateX(-50%) scale(1.1);
        opacity: 1.0;
    }
}

#campfire-flame.extinguished {
    display: none !important;
    opacity: 0 !important;
    visibility: hidden !important;
}

#campfire-flame:not(.extinguished) {
    display: block !important;
    opacity: 1 !important;
    visibility: visible !important;
}

@media (orientation: landscape) {
    .gyro-active #lensToggleContainer,
    .gyro-active #modeToggleContainer {
        display: none;
    }
    
    .gyro-active #lensToggleContainer.hidden-by-gyro,
    .gyro-active #modeToggleContainer.hidden-by-gyro {
        display: flex;
        transform: scale(0.9);
    }
    
    .gyro-active #lensToggleContainer.hidden-by-gyro .lensToggleButton,
    .gyro-active #modeToggleContainer.hidden-by-gyro .modeToggleButton {
        pointer-events: none;
        opacity: 0.5;
    }
    
    #gyroToggleContainer {
        left: 10px;
        top: 50%;
        transform: translateY(-50%);
    }
    
    #cameraButton {
        right: 15px;
        top: 50%;
        transform: translateY(-50%);
        width: 70px;
        height: 70px;
    }
    
    #cameraButton::after {
        width: 40px;
        height: 40px;
    }
    
    #lensToggleContainer {
        bottom: 10px;
        left: 10px;
    }
    
    #modeToggleContainer {
        bottom: 10px;
        right: 10px;
    }
}

@media (orientation: portrait) {
    #photoPreview {
        top: 10px;
        left: 10px;
        width: 90px;
        height: 70px;
    }
    
    #photoPreview .noPhoto {
        font-size: 10px;
        padding: 3px;
    }
    
    #birdingToggleContainer {
        top: 10px;
        right: 10px;
        gap: 2px;
        padding-bottom: 25px;
    }
    
    #birdingModeToggle {
        height: 35px;
        padding: 5px 12px;
        font-size: 13px;
    }
    
    #birdingStatusIndicator {
        height: 28px;
        font-size: 11px;
    }
    
    #birdingRecordIcon {
        top: 70px;
        right: 0;
        width: 120px;
        height: 20px;
        font-size: 10px;
    }
    
    #birdingRecordIcon::before {
        height: 2px;
    }
    
    #birdingRecordIcon .iconNumber {
        font-size: 10px;
        margin-right: 3px;
    }
    
    #birdingRecordIcon .iconTime,
    #birdingRecordIcon .iconBirdCount {
        font-size: 8px;
        margin-right: 3px;
    }
    
    #textStats {
        top: 85px;
        left: 10px;
        padding: 5px 10px;
        font-size: 11px;
        max-width: 60%;
        white-space: normal;
        max-height: 70px;
        overflow-y: auto;
    }
    
    #textStats span {
        margin: 0 5px;
    }
    
    #lensToggleContainer {
        bottom: 170px;
        left: 10px;
        padding: 3px;
        gap: 3px;
        border-radius: 15px;
        border-width: 1px;
        min-width: auto;
        max-width: 200px;
        transform: scale(0.85);
        transform-origin: left bottom;
    }
    
    .lensToggleButton {
        padding: 4px 8px;
        font-size: 11px;
        border-radius: 8px;
        border-width: 0.5px;
        min-height: 24px;
        min-width: 60px;
    }
    
    #modeToggleContainer {
        bottom: 170px;
        right: 10px;
        flex-wrap: wrap;
        justify-content: flex-end;
        gap: 3px;
        max-width: 220px;
        transform: scale(0.85);
        transform-origin: right bottom;
    }
    
    .modeToggleButton {
        padding: 4px 8px;
        font-size: 11px;
        border-radius: 8px;
        border-width: 1px;
        min-height: 24px;
        flex-shrink: 1;
        min-width: 80px;
        text-align: center;
        line-height: 1.2;
    }
    
    #gyroToggleContainer {
        left: auto !important;
        right: 10px !important;
        top: 140px !important;
        transform: none !important;
        flex-direction: column !important;
        align-items: flex-end !important;
        z-index: 71 !important;
    }
    
    #gyroSensitivityContainer {
        width: 120px !important;
        height: 35px !important;
        margin-bottom: 5px !important;
    }
    
    #gyroSensitivityLabel {
        font-size: 10px;
        margin-bottom: 1px;
    }
    
    #gyroSensitivitySlider {
        height: 3px;
    }
    
    #gyroSensitivitySlider::-webkit-slider-thumb {
        width: 8px;
        height: 8px;
    }
    
    #gyroSensitivityValue {
        font-size: 10px;
        margin-top: 0;
    }
    
    #gyroModeToggle {
        padding: 3px 6px;
        font-size: 12px;
        min-width: 120px !important;
        max-width: 120px !important;
        border-width: 1px;
        border-radius: 10px;
    }
    
    #gyroStatusIndicator {
        font-size: 10px;
        padding: 2px 4px;
        min-width: 120px !important;
        max-width: 120px !important;
        border-width: 0.5px;
        border-radius: 5px;
    }
    
    #gyroCalibrateButton {
        padding: 3px 6px;
        font-size: 12px;
        min-width: 120px !important;
        max-width: 120px !important;
        border-width: 1px;
        border-radius: 10px;
    }
    
    #cameraButton {
        right: auto;
        top: auto;
        bottom: 80px;
        left: 50%;
        transform: translateX(-50%);
        width: 80px;
        height: 80px;
    }
    
    #cameraButton:hover {
        transform: translateX(-50%) scale(1.05);
    }
    
    #cameraButton:active {
        transform: translateX(-50%) scale(0.95);
    }
    
    #cameraButton::after {
        width: 45px;
        height: 45px;
    }
    
    #screenshotButton {
        top: 10px;
        right: 70px;
        padding: 5px 10px;
        font-size: 12px;
        border-width: 1px;
        border-radius: 15px;
    }
    
    .screenshotPreviewButton {
        padding: 8px 20px;
        font-size: 14px;
        min-width: 100px;
    }
    
    #campsite {
        width: 200px !important;
        height: 100px !important;
    }
    
    #campsite > div > div:last-child {
        font-size: 10px;
        padding: 1px 4px;
    }
    
    #campfire-flame {
        width: 50% !important;
        height: 66.67% !important;
        bottom: 26.67% !important;
    }
}

@media (orientation: portrait) and (max-width: 400px) {
    #photoPreview {
        width: 70px;
        height: 50px;
    }
    
    #textStats {
        font-size: 10px;
        padding: 4px 8px;
        top: 65px;
    }
    
    #birdingToggleContainer {
        gap: 2px;
        padding-bottom: 20px;
    }
    
    #birdingModeToggle {
        height: 30px;
        padding: 4px 8px;
        font-size: 11px;
        min-width: 100px;
    }
    
    #birdingStatusIndicator {
        height: 25px;
        font-size: 10px;
        min-width: 100px;
    }
    
    #birdingRecordIcon {
        top: 60px;
        right: 0;
        width: 80px;
        height: 16px;
        font-size: 8px;
    }
    
    #birdingRecordIcon .iconNumber {
        font-size: 9px;
        margin-right: 2px;
    }
    
    #birdingRecordIcon .iconTime,
    #birdingRecordIcon .iconBirdCount {
        font-size: 7px;
        margin-right: 2px;
    }
    
    #lensToggleContainer {
        bottom: 150px;
        max-width: 180px;
        transform: scale(0.75);
    }
    
    .lensToggleButton {
        padding: 1px 4px;
        font-size: 8px;
        border-radius: 6px;
        min-height: 20px;
        min-width: 30px;
    }
    
    #modeToggleContainer {
        bottom: 150px;
        max-width: 200px;
        transform: scale(0.75);
    }
    
    .modeToggleButton {
        padding: 1px 4px;
        font-size: 8px;
        border-radius: 6px;
        min-width: 40px;
        min-height: 20px;
    }
    
    #gyroToggleContainer {
        top: 120px !important;
        right: 5px !important;
    }
    
    #gyroSensitivityContainer {
        width: 100px !important;
        height: 30px !important;
    }
    
    #gyroModeToggle,
    #gyroCalibrateButton {
        min-width: 100px !important;
        max-width: 100px !important;
        font-size: 11px !important;
        padding: 3px 6px !important;
    }
    
    #gyroStatusIndicator {
        min-width: 100px !important;
        max-width: 100px !important;
        font-size: 11px !important;
        padding: 2px 4px !important;
    }
    
    #cameraButton {
        bottom: 70px;
        width: 70px;
        height: 70px;
    }
    
    #cameraButton::after {
        width: 40px;
        height: 40px;
    }
    
    #screenshotButton {
        right: 70px;
        padding: 4px 8px;
        font-size: 10px;
    }
    
    #campsite {
        width: 150px !important;
        height: 75px !important;
    }
    
    #campsite > div > div:last-child {
        font-size: 8px;
        padding: 1px 3px;
    }
}

@media (orientation: landscape) and (max-height: 500px) {
    #photoPreview {
        top: 5px;
        left: 5px;
        width: 80px;
        height: 60px;
    }
    
    #birdingToggleContainer {
        top: 5px;
        right: 5px;
        gap: 2px;
        padding-bottom: 20px;
    }
    
    #birdingModeToggle {
        height: 30px;
        padding: 4px 8px;
        font-size: 12px;
    }
    
    #birdingStatusIndicator {
        height: 25px;
        font-size: 10px;
    }
    
    #birdingRecordIcon {
        top: 60px;
        right: 0;
        width: 100px;
        height: 18px;
        font-size: 9px;
    }
    
    #birdingRecordIcon::before {
        height: 2px;
    }
    
    #textStats {
        top: 70px;
        left: 5px;
        font-size: 10px;
        padding: 4px 8px;
    }
    
    #lensToggleContainer {
        bottom: 10px;
        left: 5px;
        padding: 3px;
        gap: 3px;
        border-radius: 10px;
        border-width: 1px;
        transform: scale(0.9);
    }
    
    .lensToggleButton {
        padding: 3px 6px;
        font-size: 10px;
        border-radius: 6px;
        border-width: 0.5px;
        min-width: 50px;
    }
    
    #modeToggleContainer {
        bottom: 10px;
        right: 5px;
        gap: 3px;
        transform: scale(0.9);
    }
    
    .modeToggleButton {
        padding: 3px 6px;
        font-size: 10px;
        border-radius: 6px;
        border-width: 1px;
        min-width: 60px;
    }
    
    #gyroToggleContainer {
        left: 5px;
        top: 50%;
    }
    
    #gyroSensitivityContainer {
        width: 70px;
        padding: 3px 6px;
        height: 32px;
    }
    
    #gyroModeToggle {
        padding: 4px 8px;
        font-size: 11px;
        min-width: 55px;
        max-width: 70px;
    }
    
    #gyroStatusIndicator {
        font-size: 9px;
        padding: 2px 6px;
        min-width: 55px;
        max-width: 70px;
    }
    
    #gyroCalibrateButton {
        padding: 3px 6px;
        font-size: 9px;
        min-width: 55px;
        max-width: 70px;
    }
    
    #cameraButton {
        right: 10px;
        top: 50%;
        transform: translateY(-50%);
        width: 60px;
        height: 60px;
    }
    
    #cameraButton::after {
        width: 35px;
        height: 35px;
    }
}

#campfire-flame:not(.extinguished) {
    display: block !important;
    width: 50% !important;
    height: 66.67% !important;
}
</style>
</head>
<body>
<div id="textBrowserOverlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(255, 255, 255, 0.95); z-index: 10000; display: none; font-family: 'SimSun', monospace; pointer-events: none;">
    <div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; pointer-events: none;">
        <!-- é¡¶éƒ¨æ§åˆ¶æ  - ç™½è‰²åŠé€æ˜ -->
        <div style="background-color: rgba(255, 255, 255, 0.85); color: rgba(0, 0, 0, 0.85); padding: 10px 20px; display: flex; justify-content: space-between; align-items: center; border-bottom: 2px solid rgba(0, 0, 0, 0.3); pointer-events: auto;">
            <div style="font-size: 18px; font-weight: bold;">ğŸ“„ æ–‡æœ¬æµè§ˆå™¨</div>
            <div style="display: flex; gap: 10px; align-items: center;">
                <div style="font-size: 12px; color: rgba(0, 0, 0, 0.6);">æŒ‰ç©ºæ ¼é”®æ˜¾ç¤º/éšè—</div>
                <button id="loadTextFile" style="background-color: rgba(76, 175, 80, 0.9); color: white; border: none; padding: 8px 15px; border-radius: 4px; cursor: pointer; font-size: 14px;">ğŸ“‚ åŠ è½½æ–‡ä»¶</button>
                <input type="file" id="textFileInput" accept=".txt,.md,.html,.js,.css,.json" style="display: none;">
                <button id="closeTextBrowser" style="background-color: rgba(0, 0, 0, 0.1); color: rgba(0, 0, 0, 0.85); border: 1px solid rgba(0, 0, 0, 0.2); padding: 8px 15px; border-radius: 4px; cursor: pointer; font-size: 14px;">âœ• å…³é—­</button>
            </div>
        </div>
        
        <!-- å†…å®¹åŒºåŸŸ - 80%ä¸é€æ˜çš„ç™½è‰² -->
        <div id="textContentContainer" style="flex: 1; overflow-y: auto; padding: 20px; background-color: rgba(255, 255, 255, 0.8); pointer-events: auto;">
            <!-- æ–‡æœ¬åŒºåŸŸ - 85%ä¸é€æ˜çš„ç™½è‰² -->
            <div id="textBrowserContent" style="white-space: pre-wrap; font-size: 16px; line-height: 1.6; color: rgba(0, 0, 0, 0.85); max-width: 1200px; margin: 0 auto; font-family: 'Courier New', monospace; background-color: rgba(255, 255, 255, 0.85); padding: 20px; border-radius: 8px; border: 1px solid rgba(0, 0, 0, 0.1);">
                <!-- ç§»é™¤åˆå§‹æ–‡æœ¬æç¤ºï¼Œä¿æŒç©ºç™½ -->
            </div>
        </div>
        
        <!-- åº•éƒ¨çŠ¶æ€æ  - ç™½è‰²åŠé€æ˜ -->
        <div style="background-color: rgba(255, 255, 255, 0.95); padding: 8px 20px; border-top: 1px solid rgba(0, 0, 0, 0.1); font-size: 12px; color: rgba(0, 0, 0, 0.6); display: flex; justify-content: space-between; pointer-events: auto;">
            <div id="fileInfo">æœªåŠ è½½æ–‡ä»¶</div>
            <div id="characterCount">å­—ç¬¦æ•°: 0</div>
        </div>
    </div>
</div>
<div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    <canvas id="poopCanvas"></canvas>
    <div id="goldenFilter"></div>
    <div id="viewfinder"></div>
    <div id="photoPreview" onclick="openAlbum()">
        <div class="noPhoto">ç‚¹å‡»æŸ¥çœ‹ç›¸å†Œ<br>æš‚æ— ç…§ç‰‡</div>
    </div>
    <canvas id="screenshotCanvas"></canvas>
    <div id="screenshotPreviewModal">
        <button id="screenshotPreviewClose" onclick="closeScreenshotPreview()">Ã—</button>
        <img id="screenshotPreviewImage" src="" alt="æˆªå›¾é¢„è§ˆ">
        <div id="screenshotPreviewControls">
            <button class="screenshotPreviewButton" onclick="saveScreenshot()">ğŸ’¾ ä¿å­˜å›¾ç‰‡</button>
            <button class="screenshotPreviewButton" onclick="closeScreenshotPreview()">âœ• å…³é—­</button>
        </div>
    </div>
<div id="campsite" style="display: none; z-index: 25; cursor: pointer;" onclick="extinguishCampfire()">
    <div style="position: relative; width: 100%; height: 100%;">
        <!-- å¸ç¯·ç»“æ„ - ç¡®ä¿è¿™éƒ¨åˆ†å­˜åœ¨ -->
        <div style="position: absolute; bottom: 0; right: 16.67%; width: 30%; height: 40%;">
            <div style="position: absolute; bottom: 0; left: 50%; transform: translateX(-50%); width: 0; height: 0; border-left: 15% solid transparent; border-right: 15% solid transparent; border-bottom: 40% solid #B22222;"></div>
        </div>
        <!-- æœ¨æŸ´ç»“æ„ -->
        <div style="position: absolute; bottom: 0; left: 23.33%; width: 20%; height: 30%;">
            <div style="position: absolute; bottom: 0; left: 13.33%; width: 75%; height: 17.78%; background-color: #8B4513; transform: rotate(-15deg);"></div>
            <div style="position: absolute; bottom: 8.89%; left: 20%; width: 63.33%; height: 17.78%; background-color: #A0522D; transform: rotate(10deg);"></div>
            <!-- ç«ç„° -->
            <div id="campfire-flame" style="position: absolute; bottom: 26.67%; left: 50%; transform: translateX(-50%); width: 50%; height: 66.67%; background: radial-gradient(circle, #FF4500 0%, #FF8C00 30%, #FFD700 70%); border-radius: 50% 50% 20% 20%; filter: blur(2px); animation: flame-flicker 0.5s infinite alternate;"></div>
        </div>
        <!-- æç¤ºæ–‡å­— -->
        <div style="position: absolute; bottom: 1.5%; left: 50%; transform: translateX(-50%); color: #FFD700; font-size: 0.67vw; font-weight: bold; text-shadow: 1px 1px 3px rgba(0,0,0,0.8); text-align: center; background-color: rgba(0,0,0,0.5); padding: 0.13vw 0.4vw; border-radius: 0.4vw; opacity: 0.8; white-space: nowrap;">
            ç‚¹å‡»ç†„ç­ç¯ç«
        </div>
    </div>
</div>
        
        <div id="gyroToggleContainer">
            <div id="gyroSensitivityContainer">
                <div id="gyroSensitivityLabel">çµæ•åº¦</div>
                <input type="range" id="gyroSensitivitySlider" min="5" max="20" value="10">
                <div id="gyroSensitivityValue">10</div>
            </div>
            <div id="gyroStatusIndicator">å…³é—­</div>
            <button id="gyroModeToggle">é™€èºä»ª</button>
            <button id="gyroCalibrateButton">æ ¡å‡†</button>
        </div>
        <div id="cameraButton" onclick="handleCameraButtonClick()"></div>
<div id="birdingToggleContainer">
    <button id="birdingModeToggle">è§‚é¸Ÿæ¨¡å¼</button>
    <div id="birdingStatusIndicator">æœªå¼€å§‹</div>
    <div id="birdingRecordIcon" style="display: none;"></div>
</div>
<button id="helpButton" class="help-button" title="æŸ¥çœ‹å¸®åŠ©">?</button>
        <div id="birdingRecordIconsContainer" style="position: absolute; top: 100px; right: 10px; display: flex; flex-direction: column; gap: 5px; z-index: 70; max-height: 200px; overflow-y: auto; display: none;"></div>
        <div id="textStats">
            å·²å‡ºç°é¸Ÿç±»: <span id="appearedCount">0</span> | å·²æ‹æ‘„é¸Ÿç±»: <span id="capturedCount">0</span>
        </div>
        <div id="modeToggleContainer">
            <button id="dayModeToggle" class="modeToggleButton">æ°¸ä¹…æ—¥é—´</button>
            <button id="normalModeToggle" class="modeToggleButton active">æ™®é€šæ¨¡å¼</button>
            <button id="nightModeToggle" class="modeToggleButton">æ°¸ä¹…å¤œé—´</button>
        </div>
        <div id="timeIndicator">ç™½å¤© 30:00 / 30:00 | 00:00</div>
        <div id="lensToggleContainer">
            <button id="lens600Toggle" class="lensToggleButton active">600é•œå¤´</button>
            <button id="lens800Toggle" class="lensToggleButton">800é•œå¤´</button>
            <button id="lens1200Toggle" class="lensToggleButton">1200é•œå¤´</button>
        </div>
        <div id="gameTitle">è§‚é¸Ÿæ¨¡æ‹Ÿå™¨-ä¸€ä¸‡ä¸¤åƒé¸»AIåˆ¶ä½œ</div>
        <div id="specialAlert"></div>
        <div id="nightObjectAlert"></div>
        <div id="captureAlert"></div>
        <div id="creator">æ­£åœ¨åŠ è½½åˆ›ä½œè€…ä¿¡æ¯...</div>
        <div id="albumModal">
            <h2 id="albumTitle">æˆ‘çš„ç›¸å†Œ - ä¸€ä¸‡ä¸¤åƒé¸»</h2>
            <div id="albumPhotos"></div>
            <div id="albumStats"></div>
            <button id="closeAlbum" onclick="closeAlbum()">Ã—</button>
        </div>
        <div id="birdingRecordModal" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.95); z-index: 400; display: none; color: white; font-family: 'SimSun', monospace; overflow-y: auto; white-space: pre-wrap;">
            <div style="position: fixed; top: 0; left: 0; right: 0; background: rgba(0, 0, 0, 0.9); border-bottom: 2px solid #FFD700; padding: 12px 20px; z-index: 10; display: flex; justify-content: space-between; align-items: center; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);">
                <div style="font-size: 20px; font-weight: bold; color: #FFD700;">ğŸ“– è§‚é¸Ÿè®°å½•</div>
                <div id="birdingRecordCounter" style="color: white; font-size: 14px; background: rgba(255, 215, 0, 0.2); padding: 4px 12px; border-radius: 12px; border: 1px solid #FFD700;">è®°å½• 1 / 1</div>
                <div style="display: flex; gap: 10px;">
                    <button id="screenshotButton" onclick="captureBirdingRecord()" style="background: rgba(255, 215, 0, 0.8); color: black; border: none; border-radius: 15px; padding: 8px 15px; font-size: 14px; font-weight: bold; cursor: pointer; transition: all 0.3s;">ğŸ“¸ æˆªå›¾</button>
                    <button id="closeBirdingRecord" onclick="closeBirdingRecord()" style="background: rgba(255, 255, 255, 0.2); color: white; border: none; border-radius: 50%; width: 36px; height: 36px; font-size: 18px; cursor: pointer; transition: all 0.3s;">Ã—</button>
                </div>
            </div>
            <div id="birdingRecordNav" style="position: fixed; top: 50%; left: 0; right: 0; display: flex; justify-content: space-between; padding: 0 15px; z-index: 5; pointer-events: none; opacity: 0; transition: opacity 0.3s;">
                <button id="prevRecordButton" class="birdingRecordNavButton" onclick="switchBirdingRecord(-1)" style="pointer-events: auto; background-color: rgba(0, 0, 0, 0.7); color: white; border: 2px solid #FFD700; border-radius: 50%; width: 45px; height: 45px; font-size: 22px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.3s;">â†</button>
                <button id="nextRecordButton" class="birdingRecordNavButton" onclick="switchBirdingRecord(1)" style="pointer-events: auto; background-color: rgba(0, 0, 0, 0.7); color: white; border: 2px solid #FFD700; border-radius: 50%; width: 45px; height: 45px; font-size: 22px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.3s;">â†’</button>
            </div>
            <div id="birdingRecordContent" style="margin-top: 80px; font-size: 16px; line-height: 1.6; padding: 0 20px 30px 20px;"></div>
            <div id="swipeHint" class="swipe-hint" style="display: none; position: fixed; bottom: 15px; left: 0; right: 0; text-align: center; color: #FFD700; font-size: 14px; z-index: 410; opacity: 0.7; animation: pulse 2s infinite;">ä½¿ç”¨æ»šè½®æˆ–æ»‘åŠ¨åˆ‡æ¢è®°å½•</div>
        </div>
        <div id="helpModal" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.85); z-index: 450; display: none; color: white; font-family: 'SimSun', monospace; overflow-y: auto; padding: 20px; box-sizing: border-box;">
            <div style="position: absolute; top: 20px; right: 20px; background-color: rgba(255, 255, 255, 0.2); color: white; border: none; border-radius: 50%; width: 40px; height: 40px; font-size: 20px; cursor: pointer; display: flex; align-items: center; justify-content: center;" onclick="closeHelpModal()">Ã—</div>
            <div id="helpContent" style="margin-top: 40px; font-size: 16px; line-height: 1.6; white-space: pre-wrap; max-width: 800px; margin-left: auto; margin-right: auto;"></div>
        </div>
    </div>
<script>

const GAME_WIDTH = 1600;
const GAME_HEIGHT = 900;
const ASPECT_RATIO = 16/9;

const WHEEL_COOLDOWN = 500; // æ»šè½®å†·å´æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰

window.addEventListener('orientationchange', () => {
  requestCalibration = true;
});

let fullscreenLongPressTimer = null;
let isFullscreen = false;
const LONG_PRESS_DURATION = 800; // é•¿æŒ‰800æ¯«ç§’è§¦å‘å…¨å±

    // è¥åœ°ç›¸å…³å˜é‡
    let isCampfireExtinguished = false; // ç¯ç«æ˜¯å¦å·²ç†„ç­
    let isNightAccelerated = false;
    let nightAccelerationMultiplier = 60;
    let actualNightTimePassed = 0;
    let birdingRecordRealDuration = 0;
    let rareBirdRealInterval = 0;
    
    // ç„¶åå®šä¹‰å…¶ä»–å˜é‡
    let gyroModeActive = false;
    let isGyroCalibrated = false;
    let lastGyroUpdate = 0;
    let gyroSensitivity = 10;
    let gyroX = GAME_WIDTH / 2;
    let gyroY = GAME_HEIGHT / 2;
    let gyroAlpha = 0;
    let gyroBeta = 0;
    let gyroGamma = 0;
    let gyroCenterBeta = 0;
    let gyroCenterGamma = 0;
    let requestCalibration = true;
    let currentRecordIndex = 0;
    let isNavigatingRecords = false;
    let touchStartY = 0;
    let touchStartX = 0;
    let lastWheelTime = 0;
    
    window.addEventListener('orientationchange', () => {
        requestCalibration = true;
    });
    
    let gamePaused = false;
    let pausedTimeState = {
        gameTime: 0,
        dayNightTimer: 0,
        moonPhaseTimer: 0,
        dayModeTimeState: 0,
        nightModeTimeState: 0,
        nightModeMoonPhaseTimer: 0,
        lastFrameTime: 0,
        lastBirdTime: 0,
        lastRareBirdTime: 0,
        lastLittleOwlTime: 0,
        lastOwlSpawnTime: 0,
        lastDoveSummonCheck: 0,
        pauseStartTime: 0,
        pauseDeltaOffset: 0
    };

const LENS_SETTINGS = {
  '600': { name: '600mm', multiplier: 2.0, viewfinderScale: 1.0 },
  '800': { name: '800mm', multiplier: 1.42, viewfinderScale: 1.0 },
  '1200': { name: '1200mm', multiplier: 1.0, viewfinderScale: 1.0 }
};

let currentLens = '600';
const viewfinderBaseWidth = GAME_WIDTH / 15;  // å¤§çº¦æ˜¯æ¸¸æˆå®½åº¦çš„1/15
const viewfinderBaseHeight = viewfinderBaseWidth * 2/3;  // ä¿æŒ2:3çš„å®½é«˜æ¯”

const BIRD_COMMON_PROPS = {
  base: {
    color: "#000000",
    eyeColor: "#000000",
    whiteEyeRing: false,
    groupSize: 1,
    probability: 0.05,
    size: 1.0,
    behavior: "flyThrough",
    stayTime: 10
  },
  props: {
    BLACKBIRD_POOP: {
      poopInterval: 3000,
      poopProbability: 0.33,
      poopColor: "#FFFFFF"
    },
    EAT_FRUITS: {
      eatFruits: true,
      eatProbability: 0.1,
      eatDuration: 2000
    },
    EYE_RING: {
      white: { whiteEyeRing: true },
      yellow: { yellowEyeRing: true },
      brown: { brownEyeRing: true }
    },
    BEAK: {
      onePointFive: { beakOnePointFive: true },
      onePointThree: { beakOnePointThree: true },
      half: { halfBeak: true },
      quarter: { quarterBeak: true },
      fifth: { fifthBeak: true },
      double: { doubleBeak: true },
      long: { longBeak: true },
      reducedQuarter: { beakReducedQuarter: true }
    },
    TAIL: {
      longBlack: { longBlackTail: true },
      longBrown: { longBrownTail: true },
      longWhite: { longWhiteTail: true }
    },
    NOCTURNAL: {
      canAppearAtNight: true,
      nightProbability: 0.01
    }
  }
};

const NIGHT_OBJECTS = {
  METEOR: {
    name: "æµæ˜Ÿ",
    type: "meteor",
    probability: 0.02,
    duration: 2000,
    size: 0.1,
    speed: 5.0,
    color: "#FFFFFF",
    trailLength: 100,
    trailColor: "rgba(255, 255, 200, 0.7)",
    summonProbability: 0.67
  },
  COMET: {
    name: "å½—æ˜Ÿ",
    type: "comet",
    probability: 0.001,
    duration: 1800000,
    size: 0.5,
    speed: 0.01,
    color: "#4682B4",
    tailLength: 50,
    tailColor: "rgba(135, 206, 235, 0.4)",
    angle: 2 * Math.PI / 3
  },
  UFO: {
    name: "UFO",
    type: "ufo",
    probability: 0.001,
    duration: 8000,
    size: 1.0,
    speed: GAME_WIDTH / 8,
    color: "#00FF00",
    beamLength: 100,
    beamColor: "rgba(144, 238, 144, 0.3)"
  }
};

const BIRD_TYPES = {
  MAGPIE: {
    name: "å–œé¹Š",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#FFFFFF",
    headColor: "#000000",
    wingColor: "#3333FF",
    tailColor: "#3333FF",
    groupSize: [2, 5],
    probability: 0.057,
    size: 1.8,
    behavior: "landOnTree",
    stayTime: 100,
    whiteEyeRing: true,
    longBlackTail: true,
    eatFruits: true,
    eatProbability: 0.1,
    eatDuration: 2000,
    originalSize: 1.8
  },
  CROW: {
    name: "ä¹Œé¸¦",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#000000",
    headColor: "#000000",
    wingColor: "#000000",
    tailColor: "#000000",
    groupSize: [1, 3],
    probability: 0.041,
    size: 1.8,
    behavior: "landOnTree",
    stayTime: 50,
    whiteEyeRing: true,
    speedMultiplier: 1.5
  },
  BULBUL: {
    name: "ç™½å¤´é¹",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#90EE90",
    headColor: "#FFFFFF",
    wingColor: "#000000",
    tailColor: "#000000",
    groupSize: [5, 10],
    probability: 0.05,
    size: 1.2,
    behavior: "flyThrough",
    whiteEyeRing: true,
    eatFruits: true,
    eatProbability: 0.15,
    eatDuration: 1500,
    originalSize: 1.2,
    speedMultiplier: 1.5
  },
  HOOPOE: {
    name: "æˆ´èƒœ",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#D2B48C",
    headColor: "#D2B48C",
    wingColor: "#000000",
    tailColor: "#000000",
    groupSize: 1,
    probability: 0.025,
    size: 1.3,
    behavior: "waveFlight",
    hasCrest: true,
    crestColor: "#D2B48C",
    whiteEyeRing: true,
    beakOnePointFive: true,
    speedMultiplier: 2.0
  },
  DOVE: {
    name: "æ–‘é¸ ",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#808080",
    headColor: "#808080",
    wingColor: "#A0522D",
    tailColor: "#A0522D",
    groupSize: [1, 3],
    probability: 0.045,
    size: 1.5,
    behavior: "flyThrough",
    whiteEyeRing: false,
    brownEyeRing: true,
    eatFruits: true,
    eatProbability: 0.08,
    eatDuration: 1800,
    originalSize: 1.5
  },
  BLACKBIRD: {
    name: "ä¹Œé¸«",
    color: "#FFFF00",
    eyeColor: "#000000",
    bodyColor: "#000000",
    headColor: "#000000",
    wingColor: "#000000",
    tailColor: "#000000",
    groupSize: 1,
    probability: 0.044,
    size: 1.3,
    behavior: "flyThrough",
    whiteEyeRing: false,
    yellowEyeRing: true,
    eatFruits: true,
    eatProbability: 0.12,
    eatDuration: 1600,
    originalSize: 1.3,
    poopInterval: 3000,
    poopProbability: 0.33,
    poopColor: "#FFFFFF",
    speedMultiplier: 1.5
  },
  DUCK: {
    name: "ç»¿å¤´é¸­",
    color: "#FFFF00",
    eyeColor: "#000000",
    bodyColor: "#FFFFFF",
    headColor: "#00AA00",
    wingColor: "#FF0000",
    tailColor: "#8B4513",
    groupSize: [5, 7],
    probability: 0.032,
    size: 2.0,
    behavior: "flyThrough",
    variant: true,
    whiteEyeRing: true,
    doubleBeak: true,
    beakOnePointFive: true
  },
  WAGTAIL: {
    name: "ç™½é¹¡é¸°",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#FFFFFF",
    headColor: "#FFFFFF",
    wingColor: "#000000",
    tailColor: "#000000",
    groupSize: 2,
    probability: 0.029,
    size: 1.2,
    behavior: "waveFlight",
    whiteEyeRing: true,
    longBlackTail: true,
    hasHeart: true
  },
  WOODPECKER: {
    name: "å•„æœ¨é¸Ÿ",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#8B4513",
    headColor: "#FF0000",
    wingColor: "#000000",
    tailColor: "#000000",
    groupSize: 1,
    probability: 0.046,
    size: 1.7,
    behavior: "landOnTree",
    stayTime: 10,
    whiteEyeRing: true,
    doubleBeak: true,
    peckingAction: true,
    speedMultiplier: 1.5
  },
  HERON: {
    name: "å¤œé¹­",
    color: "#000000",
    eyeColor: "#FF0000",
    bodyColor: "#FFFFFF",
    headColor: "#FFFFFF",
    wingColor: "#1E90FF",
    tailColor: "#FFFFFF",
    groupSize: [1, 3],
    probability: 0.03,
    size: 3.0,
    behavior: "landOnTree",
    stayTime: 20,
    whiteEyeRing: false,
    longBeak: true,
    beakReducedQuarter: true,
    canAppearAtNight: true,
    nightBodyColor: "#808080",
    nightWingColor: "#4682B4",
    nightProbability: 0.01
  },
  TIT: {
    name: "å±±é›€",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#EEEEE0",
    headColor: "#000000",
    wingColor: "#000000",
    tailColor: "#000000",
    groupSize: [2, 5],
    probability: 0.04,
    size: 0.8,
    behavior: "landOnTreeThenMove",
    whiteEyeRing: true,
    halfBeak: true,
    stayTimePerTree: 2000,
    speedMultiplier: 1.5
  },
  PARROTBILL: {
    name: "æ£•å¤´é¸¦é›€",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#8B4513",
    headColor: "#8B4513",
    wingColor: "#8B4513",
    tailColor: "#8B4513",
    groupSize: [5, 10],
    probability: 0.023,
    size: 0.5,
    behavior: "flyInReedsAndStay",
    whiteEyeRing: true,
    quarterBeak: true,
    longBrownTail: true,
    stayTimeInReeds: 10000,
    speedMultiplier: 1.5
  },
  WARBLER: {
    name: "æŸç§æŸ³èº",
    color: "#FFFF00",
    eyeColor: "#000000",
    bodyColor: "#EEEEE0",
    headColor: "#90EE90",
    wingColor: "#339966",
    tailColor: "#339966",
    groupSize: 1,
    probability: 0.021,
    size: 0.5,
    behavior: "appearOnTree",
    stayTime: 2,
    whiteEyeRing: true,
    halfBeak: true,
    speedMultiplier: 2.0
  },
  SPARROW: {
    name: "éº»é›€",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#D2B48C",
    headColor: "#8B4513",
    wingColor: "#808080",
    tailColor: "#8B4513",
    groupSize: [5, 10],
    probability: 0,
    size: 1.0,
    behavior: "flyThrough",
    whiteEyeRing: true,
    halfBeak: true,
    speedMultiplier: 2.0
  },
  GOLDFINCH: {
    name: "é‡‘ç¿…é›€",
    color: "#000000",
    eyeColor: "#8B4513",
    bodyColor: "#D2B48C",
    headColor: "#808080",
    wingColor: "#FFD700",
    tailColor: "#FFD700",
    groupSize: [2, 9],
    probability: 0.035,
    size: 1.0,
    behavior: "flyThrough",
    whiteEyeRing: true,
    halfBeak: true,
    eatFruits: true,
    eatProbability: 0.2,
    eatDuration: 1200,
    originalSize: 1.0,
    speedMultiplier: 2.0
  },
  KENTISH_PLOVER: {
    name: "é‡‘çœ¶é¸»",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#FFFFFF",
    headColor: "#D2B48C",
    wingColor: "#D2B48C",
    tailColor: "#D2B48C",
    groupSize: [2, 3],
    probability: 0.015,
    size: 1.3,
    behavior: "flyThrough",
    whiteEyeRing: false,
    yellowEyeRing: true,
    beakOnePointFive: true,
    landOnReedsChance: 0.8,
    landOnReedsTime: 10,
    groundPecking: true,
    groundMoveSpeed: 0.3
  },
  PEREGRINE: {
    name: "æ¸¸éš¼",
    color: "#FFFF00",
    eyeColor: "#000000",
    bodyColor: "#FFFFFF",
    headColor: "#000000",
    wingColor: "#808080",
    tailColor: "#808080",
    groupSize: 1,
    probability: 0.008,
    size: 2.0,
    behavior: "circleThenHuntBird",
    iconColor: "#FFFFFF",
    whiteEyeRing: true,
    yellowEyeRing: true
  },
  KESTREL: {
    name: "çº¢éš¼",
    color: "#FFFF00",
    eyeColor: "#000000",
    bodyColor: "#D2B48C",
    headColor: "#606060",
    wingColor: "#8B0000",
    tailColor: "#707070",
    groupSize: 1,
    probability: 0.014,
    size: 2.0,
    behavior: "circleThenHunt",
    iconColor: "#8B0000",
    whiteEyeRing: false,
    yellowEyeRing: true,
    isPredator: true,
    diveSpeedMultiplier: 2.0,
    catchDoveChance: 0.3,
    catchMouseChance: 0.5,
    leaveChance: 0.2,
    scareOtherBirds: true
  },
  RUDDYSHELDUCK: {
    name: "èµ¤éº»é¸­",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#FF8C00",
    headColor: "#FFFFFF",
    wingColor: "#FF8C00",
    tailColor: "#FF8C00",
    groupSize: 2,
    probability: 0.021,
    size: 3.0,
    behavior: "flyThrough",
    iconColor: "#FF8C00",
    whiteEyeRing: true,
    beakOnePointThree: true,
    speedMultiplier: 2.0
  },
  MINIVET: {
    name: "å±±æ¤’é¸Ÿ",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#FF0000",
    headColor: "#000000",
    wingColor: "#000000",
    tailColor: "#000000",
    groupSize: [8, 10],
    probability: 0.007,
    size: 1.2,
    behavior: "flyThrough",
    variant: true,
    iconColor: "#FF0000",
    whiteEyeRing: true
  },
  KINGFISHER: {
    name: "ç¿ é¸Ÿ",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#FF9933", // èº«ä½“æ©™è‰²
    headColor: "#33CCCC", // å¤´éƒ¨é’è‰²
    wingColor: "#3399FF", // ç¿…è†€è“è‰²
    tailColor: "#33CCCC", // å°¾éƒ¨é’è‰²
    beakColor: "#000000", // å˜´é»‘è‰²
    eyeRingColor: "#FFA500", // çœ¼åœˆæ©™è‰²
    groupSize: 1,
    probability: 0.023,
    size: 1.2, // 1.2å€éº»é›€å¤§å°
    behavior: "flyToReedAndPerch",
    stayTime: [45000, 60000], // åœç•™45-60ç§’
    headAngle: Math.PI/4, // å¤´æ–œå‘ä¸‹45åº¦
    turnInterval: [15000, 25000], // æ¯15-25ç§’æ¢å‘
    diveSpeed: 3.0,
    beakLengthMultiplier: 3, // å˜´é•¿ä¸º3å€
    isVulnerableToRaptors: true,
    canAppearAtNight: false, // åªåœ¨ç™½å¤©å‡ºç°
    isKingfisher: true, // ç‰¹æ®Šæ ‡è®°
    fishSize: 15, // é±¼çš„å¤§å°
    fishColor: "#3399FF", // é±¼çš„é¢œè‰²
    originalSize: 1.2
  },
  GOLDCREST: {
    name: "æˆ´èŠ",
    color: "#000000",
    eyeColor: "#FFFFFF",
    bodyColor: "#90EE90",
    headColor: "#FFFF00",
    wingColor: "#00FF00",
    tailColor: "#00FF00",
    groupSize: 1,
    probability: 0.01,
    size: 0.5,
    behavior: "appearOnTree",
    stayTime: 5,
    iconColor: "#FFFF00",
    whiteEyeRing: false,
    riceBallAppearance: true,
    halfBeakFlying: true,
    halfBeak: true
  },
  OWL: {
    name: "é•¿è€³é¸®",
    color: "#000000",
    bodyColor: "#8B4513",
    groupSize: 1,
    probability: 0.011,
    size: 2.5,
    behavior: "appearOnTree",
    stayTime: 15,
    faceScreen: true,
    iconColor: "#8B4513",
    eyeColor: "#FFA500",
    whiteEyeRing: true
  },
  LITTLEGREBE: {
    name: "å°åŒ—",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#FFFFFF",
    headColor: "#FFFFFF",
    wingColor: "#000000",
    tailColor: "#000000",
    groupSize: [2, 5],
    probability: 0.013,
    size: 0.5,
    behavior: "flyToReedsAndStay",
    stayTime: 30,
    iconColor: "#FFFFFF",
    whiteEyeRing: false,
    longBlackTail: true,
    fifthBeak: true,
    reedStayTime: 20000,
    reedMoveSpeed: 0.6
  },
  BLACKWINGEDKITE: {
    name: "é»‘ç¿…é¸¢",
    color: "#000000",
    eyeColor: "#FF0000",
    bodyColor: "#FFFFFF",
    headColor: "#FFFFFF",
    wingColor: "#808080",
    tailColor: "#FFFFFF",
    groupSize: 1,
    probability: 0.02,
    size: 2.0,
    behavior: "circleThenHoverThenHuntMouse",
    iconColor: "#000000",
    whiteEyeRing: true
  },
  TWELVE_THOUSAND_PLOVER: {
    name: "12000é¸»",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#FFFFFF",
    headColor: "#D2B48C",
    wingColor: "#D2B48C",
    tailColor: "#D2B48C",
    groupSize: [10, 20],
    probability: 0.00008333,
    size: 1.3,
    behavior: "flyThrough",
    whiteEyeRing: false,
    yellowEyeRing: true,
    beakOnePointFive: true,
    landOnReedsChance: 0.8,
    landOnReedsTime: 10,
    groundPecking: true,
    groundMoveSpeed: 0.3,
    isSpecial: true
  },
  LITTLE_OWL: {
    name: "å°é¸®",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#D2B48C",
    headColor: "#D2B48C",
    wingColor: "#D2B48C",
    tailColor: "#D2B48C",
    groupSize: 1,
    probability: 0.014,
    size: 1.28,
    behavior: "appearInWallHole",
    stayTime: 15,
    iconColor: "#D2B48C",
    whiteEyeRing: true,
    isNocturnal: true,
    nightEyeColor: "#FFFF99",
    nightEyeRingColor: "#FFFF99"
  },
  EAGLE_OWL: {
    name: "é›•é¸®",
    color: "#6B4F37",
    eyeColor: "#FFFF99",
    bodyColor: "#666666",
    headColor: "#6B4F37",
    wingColor: "#5A422E",
    tailColor: "#5A422E",
    groupSize: 1,
    probability: 0.03,
    size: 3.2,
    behavior: "circleThenGlideToGround",
    iconColor: "#6B4F37",
    whiteEyeRing: false,
    isNocturnal: true,
    isOwl: true,
    speedMultiplier: 0.6,
    circleTime: 30000,
    catchPreyChance: 0.3,
    catchPreyType: "hedgehog",
    scareOtherOwls: true,
    wingOffset: -0.33
  },
  SHORT_EARED_OWL: {
    name: "çŸ­è€³é¸®",
    color: "#8B7D6B",
    eyeColor: "#FFFF99",
    bodyColor: "#8B7D6B",
    headColor: "#8B7D6B",
    wingColor: "#7A6D5C",
    tailColor: "#7A6D5C",
    groupSize: 1,
    probability: 0.05,
    size: 1.8,
    behavior: "circleThenGlideToGround",
    iconColor: "#8B7D6B",
    whiteEyeRing: false,
    blackEyeRing: true,
    isNocturnal: true,
    isOwl: true,
    speedMultiplier: 0.5,
    circleTime: 50000,
    catchPreyChance: 0.5,
    catchPreyType: "mouse",
    scaredByEagleOwl: true,
    wingOffset: -0.33,
    flyInLowerHalf: true
  },
  LONGTAILED_FINCH: {
    name: "é•¿å°¾é›€",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#FF3366",
    headColor: "#EED2EE",
    wingColor: "#A0522D",
    tailColor: "#000000",
    groupSize: [1, 2],
    probability: 0.012,
    size: 1.0,
    behavior: "landOnTreeTop",
    stayTime: 10,
    whiteEyeRing: false,
    halfBeak: true,
    isVulnerableToRaptors: true
  },
  ROBIN: {
    name: "ç½—å®¾",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#F4F4F4",
    headColor: "#FF6600",
    wingColor: "#A0522D",
    tailColor: "#000000",
    groupSize: [1, 2],
    probability: 0.004,
    size: 1.0,
    behavior: "landOnTreeBottom",
    stayTime: 5,
    whiteEyeRing: false,
    beakLengthMultiplier: 0.8,
    isVulnerableToRaptors: true
  },
  HAWFINCH: {
    name: "èœ¡å˜´é›€",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#D9D9D9",
    headColor: "#000000",
    wingColor: "#000000",
    tailColor: "#000000",
    beakColor: "#FF8C00",
    groupSize: [2, 6],
    probability: 0.029,
    size: 1.2,
    behavior: "landOnTreeTop",
    stayTime: 15,
    whiteEyeRing: false,
    quarterBeak: true,
    beakLengthMultiplier: 0.25,
    isVulnerableToRaptors: true,
    eatFruits: true,
    eatProbability: 0.15,
    eatDuration: 2000,
    originalSize: 1.2,
    iconColor: "#8B4513"
  },
  BRAMBLING: {
    name: "ç‡•é›€",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#FCFCFC",
    headColor: "#D9D9D9",
    wingColor: "#FFA500",
    tailColor: "#000000",
    beakColor: "#FF4500",
    groupSize: [2, 8],
    probability: 0.035,
    size: 1.0,
    behavior: "flyThrough",
    stayTime: 10,
    whiteEyeRing: false,
    halfBeak: true,
    isVulnerableToRaptors: true,
    eatFruits: true,
    eatProbability: 0.1,
    eatDuration: 1800,
    originalSize: 1.0,
    iconColor: "#FFA500"
  },
  BAT: {
    name: "è™è ",
    color: "#333333",
    eyeColor: "#000000",
    bodyColor: "#333333",
    headColor: "#333333",
    wingColor: "#666666",
    tailColor: "#333333",
    groupSize: [1, 2],
    probability: 0.09,
    size: 1.0,
    behavior: "circleThenLeave",
    iconColor: "#333333",
    whiteEyeRing: false,
    isNocturnal: true,
    isBat: true,
    speedMultiplier: 0.7,
    circleTime: 15000,
    maxConcurrent: 3,
    flyInUpperHalf: true
  }
};

let raptorsPresent = [];
let chasingMagpiesCrows = [];

let totalProbability = 0;
Object.values(BIRD_TYPES).forEach(bird => {
  if (bird.name !== "éº»é›€" && !bird.isSpecial && !bird.isOwl && !bird.isBat) {
    totalProbability += bird.probability;
  }
});
BIRD_TYPES.SPARROW.probability = Math.max(0, 1 - totalProbability);

let canvas, ctx, poopCanvas, poopCtx;
let trees = [];
let birds = [];
let nightObjects = [];
let photos = [];
let capturedBirds = {};
let appearedBirds = {};
let mouseX = GAME_WIDTH / 2, mouseY = GAME_HEIGHT / 2;
let viewfinderVisible = false;
let viewfinderWidth = 90, viewfinderHeight = 60;
let lastBirdTime = 0;
let birdInterval = 15000;
let birdIntervalVariation = 500;
let gameTime = 0;
let treePositions = [];
let reedZone = null;
let isHunting = false;
let birdSpeedMultiplier = 1;
let specialBirdAlertTimeout = null;
let nightObjectAlertTimeout = null;
let captureAlertTimeout = null;
let isTakingPhoto = false;
let lastFrameTime = 0;
let fixedLeaves = [];
let scareMode = false;
let scareModeEndTime = 0;
let chasingBirds = [];
let reedBends = [];
let birdGroupInfo = {};
let nextGroupId = 1;
let poops = [];
let groundObjects = [];
let fruits = [];
let lastDoveSummonCheck = 0;
const DOVE_SUMMON_INTERVAL = 5000;
let stars = [];
const STARS_COUNT = 50;
let hasShownAllBirdsAlert = false;
const ALL_BIRDS = Object.values(BIRD_TYPES).filter(bird => !bird.isSpecial && !bird.isBat).map(bird => bird.name);

let isDaytime = true;
let dayNightTimer = 0;
const DAY_NIGHT_CYCLE_DURATION = 15 * 60 * 1000;
const RARE_BIRDS = ['KENTISH_PLOVER', 'MINIVET', 'GOLDCREST', 'OWL', 'LITTLEGREBE', 'LONGTAILED_FINCH', 'ROBIN'];
let lastRareBirdTime = 0;
const RARE_BIRD_INTERVAL = 60 * 60 * 1000;
let sunMoonPosition = 0;
let sunMoonX = 0;
let sunMoonY = 0;
let moonPhase = 0;
const MOON_PHASE_CYCLE = 354 * 60 * 1000;
let moonPhaseTimer = 0;
let wall = null;
let hole = null;
let littleOwl = null;
let lastLittleOwlTime = 0;
const LITTLE_OWL_DAY_COOLDOWN = 300000;
const LITTLE_OWL_NIGHT_COOLDOWN = 180000;
const NIGHT_OWL_SPAWN_INTERVAL = 30000;
let lastOwlSpawnTime = 0;
const MAX_SHORT_EARED_OWL_COUNT = 3;
const MAX_BAT_COUNT = 3;

let gameMode = 'normal';
let normalModeTimeState = { isDaytime: true, dayNightTimer: 0, moonPhaseTimer: 0 };
let dayModeTimeState = 0;
let nightModeTimeState = 0;
let nightModeMoonPhaseTimer = 0;

let isGoldenFilterActive = false;

let birdingRecords = [];
let lastBirdingRecordTime = 0;
let currentBirdingRecord = null;
let birdingModeActive = false;
let birdingModeStartTime = 0;
let birdingModeDuration = 0;
let birdingModeEndTime = 0;
let isDaytimeAtStart = true;
let birdingModeStartSnapshot = {};
let birdingModeBirdTracker = {};
let birdingObservedSpecies = new Set();
let birdingModeRecordedBirds = new Set();
let birdingModeUpdateInterval = null;
let birdingModeCapturedSpecies = null; // ç”¨äºè®°å½•æœ¬æ¬¡è§‚é¸ŸæœŸé—´æ‹æ‘„çš„é¸Ÿç§

// æˆªå›¾ç›¸å…³å˜é‡
let screenshotCanvas, screenshotCtx;
let currentScreenshotDataURL = null;

function initFullscreenTouch() {
    const gameContainer = document.getElementById('gameContainer');
    
    // è§¦æ‘¸å¼€å§‹äº‹ä»¶
    gameContainer.addEventListener('touchstart', function(e) {
        if (fullscreenLongPressTimer) {
            clearTimeout(fullscreenLongPressTimer);
        }
        
        fullscreenLongPressTimer = setTimeout(function() {
            toggleFullscreen();
        }, LONG_PRESS_DURATION);
    });
    
    // è§¦æ‘¸ç»“æŸæˆ–ç§»åŠ¨æ—¶å–æ¶ˆè®¡æ—¶å™¨
    gameContainer.addEventListener('touchend', function(e) {
        if (fullscreenLongPressTimer) {
            clearTimeout(fullscreenLongPressTimer);
            fullscreenLongPressTimer = null;
        }
    });
    
    gameContainer.addEventListener('touchmove', function(e) {
        if (fullscreenLongPressTimer) {
            clearTimeout(fullscreenLongPressTimer);
            fullscreenLongPressTimer = null;
        }
    });
    
    // ç›‘å¬å…¨å±å˜åŒ–äº‹ä»¶
    document.addEventListener('fullscreenchange', handleFullscreenChange);
    document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
    document.addEventListener('mozfullscreenchange', handleFullscreenChange);
    document.addEventListener('MSFullscreenChange', handleFullscreenChange);
}

function toggleFullscreen() {
    const gameContainer = document.getElementById('gameContainer');
    
    if (!isFullscreen) {
        // è¿›å…¥å…¨å±
        if (gameContainer.requestFullscreen) {
            gameContainer.requestFullscreen();
        } else if (gameContainer.webkitRequestFullscreen) {
            gameContainer.webkitRequestFullscreen();
        } else if (gameContainer.mozRequestFullScreen) {
            gameContainer.mozRequestFullScreen();
        } else if (gameContainer.msRequestFullscreen) {
            gameContainer.msRequestFullscreen();
        }
    } else {
        // é€€å‡ºå…¨å±
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.mozCancelFullScreen) {
            document.mozCancelFullScreen();
        } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
        }
    }
    
    // æ˜¾ç¤ºæç¤º
    showSpecialAlert(isFullscreen ? "å·²é€€å‡ºå…¨å±" : "å·²è¿›å…¥å…¨å±");
}

function handleFullscreenChange() {
    const isNowFullscreen = !!(document.fullscreenElement || 
                               document.webkitFullscreenElement || 
                               document.mozFullScreenElement || 
                               document.msFullscreenElement);
    
    isFullscreen = isNowFullscreen;
    
    // å…¨å±æ—¶è°ƒæ•´ä¸€äº›UIå…ƒç´ 
    if (isFullscreen) {
        document.body.style.overflow = 'hidden';
    } else {
        document.body.style.overflow = 'auto';
    }
    
    // é‡æ–°è°ƒæ•´ç”»å¸ƒå¤§å°
    setTimeout(resizeCanvas, 100);
    
    // å¦‚æœè¥åœ°å¯è§ï¼Œæ›´æ–°å…¶ä½ç½®
    if (gameMode === 'normal' && !isDaytime) {
        setTimeout(updateCampsiteVisibility, 150);
    }
}

// æ‰“å¼€å¸®åŠ©æ¨¡æ€æ¡†
function openHelpModal() {
    if (gamePaused) return;
    pauseGame();
    
    const helpModal = document.getElementById('helpModal');
    const helpContent = document.getElementById('helpContent');
    
    // æ˜¾ç¤ºåŠ è½½ä¸­
    helpContent.innerHTML = '<div style="text-align: center; color: #FFD700; font-size: 18px;">åŠ è½½å¸®åŠ©å†…å®¹ä¸­...</div>';
    
    // æ˜¾ç¤ºæ¨¡æ€æ¡†
    helpModal.style.display = 'block';
    
    // å°è¯•åŠ è½½readme.txt
    fetch('readme.txt')
        .then(response => {
            if (!response.ok) {
                throw new Error('æ— æ³•åŠ è½½å¸®åŠ©æ–‡ä»¶');
            }
            return response.text();
        })
        .then(text => {
            // æˆåŠŸåŠ è½½ï¼Œæ˜¾ç¤ºå†…å®¹
            displayHelpContent(text);
        })
        .catch(error => {
            console.error('åŠ è½½å¸®åŠ©æ–‡ä»¶å¤±è´¥:', error);
            // å¦‚æœè¯»å–å¤±è´¥ï¼Œæ˜¾ç¤ºé»˜è®¤å¸®åŠ©å†…å®¹
            displayDefaultHelp();
        });
}

// æ˜¾ç¤ºå¸®åŠ©å†…å®¹
function displayHelpContent(text) {
    const helpContent = document.getElementById('helpContent');
    
    // è§£ææ–‡æœ¬å†…å®¹ï¼Œå¯ä»¥æ·»åŠ åŸºæœ¬çš„Markdownæ ·å¼æ”¯æŒ
    let htmlContent = '<div class="help-title">è§‚é¸Ÿæ¨¡æ‹Ÿå™¨ ä½¿ç”¨å¸®åŠ©</div>';
    
    // ç®€å•çš„æ–‡æœ¬è§£æï¼Œå°†æ–‡æœ¬è½¬æ¢ä¸ºå¸¦æ ¼å¼çš„HTML
    const lines = text.split('\n');
    let inSection = false;
    let currentSection = '';
    
    lines.forEach(line => {
        const trimmedLine = line.trim();
        
        if (trimmedLine === '') {
            return; // è·³è¿‡ç©ºè¡Œ
        }
        
        // æ£€æµ‹æ ‡é¢˜
        if (trimmedLine.startsWith('# ')) {
            htmlContent += `<h2 style="color: #FFD700; margin: 20px 0 10px 0;">${trimmedLine.substring(2)}</h2>`;
        } else if (trimmedLine.startsWith('## ')) {
            htmlContent += `<h3 style="color: #87CEEB; margin: 15px 0 8px 0; border-left: 3px solid #87CEEB; padding-left: 10px;">${trimmedLine.substring(3)}</h3>`;
        } else if (trimmedLine.startsWith('### ')) {
            htmlContent += `<h4 style="color: #90EE90; margin: 10px 0 5px 0;">${trimmedLine.substring(4)}</h4>`;
        } else if (trimmedLine.startsWith('- ') || trimmedLine.startsWith('* ')) {
            // åˆ—è¡¨é¡¹
            if (!inSection) {
                htmlContent += '<ul style="margin: 8px 0 8px 20px;">';
                inSection = true;
            }
            htmlContent += `<li style="margin-bottom: 5px;">${trimmedLine.substring(2)}</li>`;
        } else if (trimmedLine.startsWith('  ')) {
            // ä»£ç æˆ–é”®ç›˜å¿«æ·é”®
            const keyMatch = trimmedLine.match(/`([^`]+)`/g);
            if (keyMatch) {
                let formattedLine = trimmedLine;
                keyMatch.forEach(match => {
                    const key = match.replace(/`/g, '');
                    formattedLine = formattedLine.replace(match, `<span class="help-key">${key}</span>`);
                });
                htmlContent += `<p style="font-family: monospace; background-color: rgba(0,0,0,0.3); padding: 5px 10px; border-radius: 4px; margin: 5px 0;">${formattedLine}</p>`;
            } else {
                htmlContent += `<p>${trimmedLine}</p>`;
            }
        } else {
            if (inSection) {
                htmlContent += '</ul>';
                inSection = false;
            }
            htmlContent += `<p>${trimmedLine}</p>`;
        }
    });
    
    if (inSection) {
        htmlContent += '</ul>';
    }
    
    // æ·»åŠ æ¸¸æˆæ§åˆ¶è¯´æ˜éƒ¨åˆ†
    htmlContent += `
        <div class="help-section">
            <h3>æ¸¸æˆæ§åˆ¶å¿«æ·é”®</h3>
            <p><span class="help-key">é¼ æ ‡ç‚¹å‡»</span> æˆ– <span class="help-key">ç›¸æœºæŒ‰é’®</span>: æ‹ç…§</p>
            <p><span class="help-key">M</span>: åˆ‡æ¢è§‚é¸Ÿæ¨¡å¼</p>
            <p><span class="help-key">V</span>: æŸ¥çœ‹è§‚é¸Ÿè®°å½•</p>
            <p><span class="help-key">P</span>: æˆªå›¾å½“å‰è®°å½•</p>
            <p><span class="help-key">ESC</span>: å…³é—­å½“å‰çª—å£</p>            
        </div>
        
        <div class="help-section">
            <h3>è§‚é¸Ÿæ¨¡å¼è¯´æ˜</h3>
            <p>1. ç‚¹å‡»"è§‚é¸Ÿæ¨¡å¼"æŒ‰é’®å¼€å§‹è®°å½•</p>
            <p>2. è§‚é¸Ÿæ¨¡å¼ä¸‹ä¼šè®°å½•æ‚¨è§‚å¯Ÿåˆ°çš„æ‰€æœ‰é¸Ÿç§</p>
            <p>3. å†æ¬¡ç‚¹å‡»æŒ‰é’®ç»“æŸè®°å½•</p>
            <p>4. ç»“æŸåä¼šç”Ÿæˆè§‚é¸Ÿè®°å½•ï¼Œå¯æˆªå›¾ä¿å­˜</p>
        </div>
        
        <div style="text-align: center; margin-top: 30px; color: #87CEEB; font-size: 14px;">
            <p>æ¸¸æˆåˆ¶ä½œ: å°çº¢ä¹¦å· S_Asuka_Langley</p>
            <p>ä¸€ä¸‡ä¸¤åƒé¸»ä½¿ç”¨AIåˆ¶ä½œ</p>
        </div>
    `;
    
    helpContent.innerHTML = htmlContent;
}

// æ˜¾ç¤ºé»˜è®¤å¸®åŠ©å†…å®¹ï¼ˆå½“readme.txtä¸å­˜åœ¨æ—¶ï¼‰
function displayDefaultHelp() {
    const helpContent = document.getElementById('helpContent');
    helpContent.innerHTML = `
        <div class="help-title">è§‚é¸Ÿæ¨¡æ‹Ÿå™¨ ä½¿ç”¨å¸®åŠ©</div>
        
        <div class="help-section">
            <h3>æ¸¸æˆç®€ä»‹</h3>
            <p>ã€Šè§‚é¸Ÿæ¨¡æ‹Ÿå™¨ã€‹æ˜¯ä¸€æ¬¾æ¨¡æ‹ŸçœŸå®è§‚é¸Ÿä½“éªŒçš„æ¸¸æˆã€‚æ‚¨å¯ä»¥åœ¨æ¸¸æˆä¸­è§‚å¯Ÿã€æ‹æ‘„å„ç§é¸Ÿç±»ï¼Œè®°å½•æ‚¨çš„è§‚é¸Ÿæˆæœã€‚</p>
        </div>
        
        <div class="help-section">
            <h3>åŸºæœ¬æ“ä½œ</h3>
            <p>1. ç§»åŠ¨é¼ æ ‡æˆ–å€¾æ–œè®¾å¤‡ï¼ˆé™€èºä»ªæ¨¡å¼ï¼‰æ¥ç„å‡†</p>
            <p>2. ç‚¹å‡»é¼ æ ‡æˆ–ç›¸æœºæŒ‰é’®è¿›è¡Œæ‹æ‘„</p>
            <p>3. ä½¿ç”¨ä¸åŒçš„é•œå¤´ï¼ˆ600mm, 800mm, 1200mmï¼‰è§‚å¯Ÿé¸Ÿç±»</p>
            <p>4. åˆ‡æ¢æ—¥é—´/å¤œé—´/æ™®é€šæ¨¡å¼è§‚å¯Ÿä¸åŒä¹ æ€§çš„é¸Ÿç±»</p>
        </div>
        
        <div class="help-section">
            <h3>è§‚é¸Ÿæ¨¡å¼</h3>
            <p>â€¢ ç‚¹å‡»"è§‚é¸Ÿæ¨¡å¼"æŒ‰é’®å¼€å§‹è®°å½•æ‚¨çš„è§‚é¸Ÿæ´»åŠ¨</p>
            <p>â€¢ è§‚é¸Ÿæ¨¡å¼ä¸‹ä¼šè®°å½•æ‚¨è§‚å¯Ÿåˆ°çš„æ‰€æœ‰é¸Ÿç§</p>
            <p>â€¢ ç»“æŸè§‚é¸Ÿæ¨¡å¼åï¼Œç³»ç»Ÿä¼šç”Ÿæˆè§‚é¸Ÿè®°å½•</p>
            <p>â€¢ æ‚¨å¯ä»¥åœ¨è§‚é¸Ÿè®°å½•ä¸­æˆªå›¾ä¿å­˜æ‚¨çš„æˆæœ</p>
        </div>
        
        <div class="help-section">
            <h3>é”®ç›˜å¿«æ·é”®</h3>
            <p><span class="help-key">é¼ æ ‡ç‚¹å‡»</span> / <span class="help-key">ç›¸æœºæŒ‰é’®</span>: æ‹æ‘„ç…§ç‰‡</p>
            <p><span class="help-key">M</span>: åˆ‡æ¢è§‚é¸Ÿæ¨¡å¼</p>
            <p><span class="help-key">V</span>: æŸ¥çœ‹è§‚é¸Ÿè®°å½•</p>
            <p><span class="help-key">P</span>: æˆªå›¾å½“å‰è®°å½•</p>
            <p><span class="help-key">ESC</span>: å…³é—­å½“å‰çª—å£</p>
        </div>
        
        <div class="help-section">
            <h3>é™€èºä»ªæ¨¡å¼</h3>
            <p>â€¢ ç‚¹å‡»"é™€èºä»ª"æŒ‰é’®å¯ç”¨è®¾å¤‡é™€èºä»ªæ§åˆ¶</p>
            <p>â€¢ ä½¿ç”¨é™€èºä»ªå¯ä»¥æ›´è‡ªç„¶åœ°ç§»åŠ¨è§†è§’</p>
            <p>â€¢ è°ƒæ•´çµæ•åº¦æ»‘å—ä»¥é€‚åº”æ‚¨çš„æ“ä½œä¹ æƒ¯</p>
            <p>â€¢ ç‚¹å‡»"æ ¡å‡†"æŒ‰é’®é‡æ–°æ ¡å‡†é™€èºä»ª</p>
        </div>
        
        <div class="help-section">
            <h3>é¸Ÿç±»å›¾é‰´</h3>
            <p>æ¸¸æˆä¸­å…±æœ‰è¶…è¿‡30ç§ä¸åŒçš„é¸Ÿç±»ï¼ŒåŒ…æ‹¬:</p>
            <ul>
                <li>å¸¸è§é¸Ÿç±»: å–œé¹Šã€ä¹Œé¸¦ã€éº»é›€ã€ç™½å¤´é¹ç­‰</li>
                <li>ç¨€æœ‰é¸Ÿç±»: é‡‘çœ¶é¸»ã€æˆ´èŠã€é•¿è€³é¸®ç­‰</li>
                <li>çŒ›ç¦½: æ¸¸éš¼ã€çº¢éš¼ã€é»‘ç¿…é¸¢ç­‰</li>
                <li>å¤œé—´é¸Ÿç±»: é›•é¸®ã€çŸ­è€³é¸®ç­‰</li>
            </ul>
            <p>å°è¯•é›†é½æ‰€æœ‰é¸Ÿç±»å®Œæˆå›¾é‰´ï¼</p>
        </div>
        
        <div class="help-section">
            <h3>ç›¸å†ŒåŠŸèƒ½</h3>
            <p>â€¢ ç‚¹å‡»å·¦ä¸Šè§’çš„ç…§ç‰‡é¢„è§ˆæ‰“å¼€ç›¸å†Œ</p>
            <p>â€¢ ç›¸å†Œä¸­ä¼šæ˜¾ç¤ºæ‚¨æ‹æ‘„çš„æ‰€æœ‰ç…§ç‰‡</p>
            <p>â€¢ ç›¸å†Œåº•éƒ¨ä¼šæ˜¾ç¤ºå·²æ‹æ‘„çš„é¸Ÿç±»ç»Ÿè®¡</p>
        </div>
        
        <div style="text-align: center; margin-top: 30px; color: #FFD700; font-size: 16px;">
            <p>ç¥æ‚¨è§‚é¸Ÿæ„‰å¿«ï¼</p>
            <p style="font-size: 14px; color: #87CEEB;">æ¸¸æˆåˆ¶ä½œ: å°çº¢ä¹¦å· S_Asuka_Langley<br>ä¸€ä¸‡ä¸¤åƒé¸»ä½¿ç”¨AIåˆ¶ä½œ</p>
        </div>
    `;
}

// å…³é—­å¸®åŠ©æ¨¡æ€æ¡†
function closeHelpModal() {
    const helpModal = document.getElementById('helpModal');
    helpModal.style.display = 'none';
    resumeGame();
}

function updateCampfirePosition() {
    const campsite = document.getElementById('campsite');
    if (!campsite || !canvas) {
        console.log("è¥åœ°æˆ–ç”»å¸ƒæœªåˆå§‹åŒ–");
        return;
    }
    
    const container = document.getElementById('gameContainer');
    const containerRect = container.getBoundingClientRect();
    const canvasRect = canvas.getBoundingClientRect();
    
    // è®¡ç®—ç”»å¸ƒåœ¨å®¹å™¨å†…çš„ç›¸å¯¹ä½ç½®
    const canvasInContainerLeft = canvasRect.left - containerRect.left;
    const canvasInContainerTop = canvasRect.top - containerRect.top;
    const canvasInContainerBottom = canvasInContainerTop + canvasRect.height;
    
    // è¥åœ°å°ºå¯¸ - æ³¨æ„ï¼šè¥åœ°å›¾ç‰‡æœ‰é€æ˜è¾¹è·
    const campsiteRect = campsite.getBoundingClientRect();
    const campsiteWidth = campsiteRect.width;
    const campsiteHeight = campsiteRect.height;
    
    // è®¡ç®—è¥åœ°åº•éƒ¨åº”è¯¥å¯¹é½çš„ä½ç½®
    // æ³¨æ„ï¼šè¥åœ°SVG/HTMLå…ƒç´ å¯èƒ½æœ‰å†…éƒ¨è¾¹è·æˆ–é€æ˜åŒºåŸŸ
    // åœ¨ç«–å±æ¨¡å¼ä¸‹ï¼Œæˆ‘ä»¬éœ€è¦è®©è¥åœ°"åº•éƒ¨"ç´§è´´ç”»å¸ƒåº•éƒ¨
    const isPortrait = window.matchMedia("(orientation: portrait)").matches;
    
    let campsiteTop;
    
    if (isPortrait) {
        // ç«–å±æ¨¡å¼ï¼šè¥åœ°ç´§è´´åœ°é¢
        // ç”±äºè¥åœ°å…ƒç´ å¯èƒ½æœ‰å†…éƒ¨å¸ƒå±€ï¼Œæˆ‘ä»¬éœ€è¦è®¡ç®—å®é™…å¯è§†åº•éƒ¨çš„ä½ç½®
        const visualBottomOffset = 0; // è¥åœ°åº•éƒ¨å°±æ˜¯å¯è§†åº•éƒ¨ï¼Œä¸éœ€è¦é¢å¤–åç§»
        
        campsiteTop = canvasInContainerBottom - campsiteHeight - visualBottomOffset;
        
        console.log("ç«–å±è¥åœ°ä½ç½®è®¡ç®—:", {
            canvasBottom: canvasInContainerBottom,
            campsiteHeight: campsiteHeight,
            visualBottomOffset: visualBottomOffset,
            calculatedTop: campsiteTop
        });
    } else {
        // æ¨ªå±æ¨¡å¼ï¼šè¥åœ°è·ç¦»ç”»å¸ƒåº•éƒ¨10åƒç´ 
        campsiteTop = canvasInContainerBottom - campsiteHeight - 10;
    }
    
    // è¥åœ°æ°´å¹³å±…ä¸­
    const campsiteLeft = canvasInContainerLeft + (canvasRect.width / 2) - (campsiteWidth / 2);
    
    // åº”ç”¨ä½ç½®
    campsite.style.position = 'absolute';
    campsite.style.top = campsiteTop + 'px';
    campsite.style.left = campsiteLeft + 'px';
    campsite.style.bottom = 'auto';
    campsite.style.transform = 'none';
    
    // è°ƒè¯•ä¿¡æ¯
    console.log("è¥åœ°ä½ç½®æ›´æ–°:", {
        orientation: isPortrait ? "portrait" : "landscape",
        container: `${containerRect.width}x${containerRect.height}`,
        canvas: {
            left: canvasRect.left,
            top: canvasRect.top,
            width: canvasRect.width,
            height: canvasRect.height,
            inContainer: {
                left: canvasInContainerLeft,
                top: canvasInContainerTop,
                bottom: canvasInContainerBottom
            }
        },
        campsite: {
            width: campsiteWidth,
            height: campsiteHeight,
            left: campsiteLeft,
            top: campsiteTop
        }
    });
        // ç¡®ä¿è¥åœ°ä¸ä¼šæ•è·é¼ æ ‡äº‹ä»¶
    campsite.style.pointerEvents = 'none';
}
    // é¢å¤–è°ƒè¯•ï¼šæ£€æŸ¥è¥åœ°å…ƒç´ çš„å®é™…æ ·å¼
    const computedStyle = window.getComputedStyle(campsite);
    console.log("è¥åœ°è®¡ç®—æ ·å¼:", {
        display: computedStyle.display,
        position: computedStyle.position,
        top: computedStyle.top,
        left: computedStyle.left,
        bottom: computedStyle.bottom,
        transform: computedStyle.transform,
        width: computedStyle.width,
        height: computedStyle.height
    });

function updateCampsiteVisibility() {
    const campsite = document.getElementById('campsite');
    if (!campsite) return;
    
    if (gameMode === 'normal' && !isDaytime) {
        campsite.style.display = 'block';
        const flame = document.getElementById('campfire-flame');
        const hint = document.querySelector('#campsite > div > div:last-child');
        
        if (flame && hint) {
            if (isCampfireExtinguished) {
                flame.classList.add('extinguished');
                hint.textContent = "ç¯ç«å·²ç†„ç­";
                hint.style.color = "#87CEEB";
                flame.style.pointerEvents = 'none'; // ç¯ç«ç†„ç­åä¸å¯ç‚¹å‡»
            } else {
                flame.classList.remove('extinguished');
                hint.textContent = "ç‚¹å‡»ç†„ç­ç¯ç«";
                hint.style.color = "#FFD700";
                flame.style.pointerEvents = 'auto'; // ç¯ç«æœªç†„ç­å¯ç‚¹å‡»
                flame.style.cursor = 'pointer';
            }
        }
        
        setTimeout(() => {
            updateCampfirePosition();
        }, 50);
    } else {
        campsite.style.display = 'none';
    }
}
// æ–°å¢ï¼šå¤„ç†è¥åœ°åŒºåŸŸçš„ç‚¹å‡»äº‹ä»¶
function handleCampsiteClick(e) {
    // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»çš„æ˜¯ç¯ç«å…ƒç´ 
    const flame = document.getElementById('campfire-flame');
    if (flame && e.target === flame) {
        // ç‚¹å‡»çš„æ˜¯ç¯ç«ï¼Œè§¦å‘ç†„ç­åŠŸèƒ½
        extinguishCampfire();
        e.stopPropagation(); // é˜»æ­¢äº‹ä»¶å†’æ³¡ï¼Œé¿å…è§¦å‘æ‹ç…§
        return;
    }
    // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»çš„æ˜¯ç¯ç«å…ƒç´ çš„å­å…ƒç´ 
    let target = e.target;
    while (target && target !== document) {
        if (target.id === 'campfire-flame') {
            extinguishCampfire();
            e.stopPropagation();
            return;
        }
        target = target.parentElement;
    }
    // ç‚¹å‡»çš„æ˜¯è¥åœ°å…¶ä»–åŒºåŸŸï¼Œä¸æ‰§è¡Œä»»ä½•æ“ä½œï¼Œè®©äº‹ä»¶ç»§ç»­å†’æ³¡
    // è¿™æ ·ç›¸æœºç‚¹å‡»åŠŸèƒ½å¯ä»¥æ­£å¸¸å·¥ä½œ
}

function extinguishCampfire() {
    if (gameMode !== 'normal' || isDaytime || isCampfireExtinguished) return;
    
    isCampfireExtinguished = true;
    isNightAccelerated = true;
    
    const flame = document.getElementById('campfire-flame');
    if (flame) {
        flame.classList.add('extinguished');
        flame.style.pointerEvents = 'none'; // ç†„ç­åä¸å¯ç‚¹å‡»
    }
    
    const hint = document.querySelector('#campsite > div > div:last-child');
    if (hint) {
        hint.textContent = "ç¯ç«å·²ç†„ç­";
        hint.style.color = "#87CEEB";
    }
    
    showSpecialAlert("ç¯ç«ç†„ç­ï¼Œå¤œæ™šåŠ é€Ÿæµé€...");
    checkNightAcceleration();
}

// ä¿®æ”¹checkNightAccelerationå‡½æ•°
function checkNightAcceleration() {
    if (!isNightAccelerated) return;
    
    // å¦‚æœå·²ç»å˜ä¸ºç™½å¤©ï¼Œåœæ­¢åŠ é€Ÿ
    if (isDaytime) {
        isNightAccelerated = false;
        // æ³¨æ„ï¼šè¿™é‡Œä¸è¦é‡ç½®isCampfireExtinguishedï¼Œè®©å®ƒä¿æŒç›´åˆ°ç¬¬äºŒå¤©å¤œæ™š
        return;
    }
    
    // ç»§ç»­æ£€æŸ¥
    setTimeout(checkNightAcceleration, 1000);
}

function resetCampsite() {
  isNightAccelerated = false;
  isCampfireExtinguished = false;
  
  const flame = document.getElementById('campfire-flame');
  if (flame) {
    flame.classList.remove('extinguished');
  }
  
  const hint = document.querySelector('#campsite > div > div:last-child');
  if (hint) {
    hint.textContent = "ç‚¹å‡»ç†„ç­ç¯ç«";
    hint.style.color = "#FFD700";
  }
  
  showSpecialAlert("é»æ˜åˆ°æ¥ï¼Œæ¢å¤æ­£å¸¸æ—¶é—´æµé€Ÿ");
  updateCampsiteVisibility();
}
    
function updateDayNight(deltaTime) {
    if (gamePaused) return;
    
    gameTime += deltaTime;
    
    // åº”ç”¨æ—¶é—´åŠ é€Ÿ
    let effectiveDeltaTime = deltaTime;
    
    if (isNightAccelerated && gameMode === 'normal' && !isDaytime) {
        effectiveDeltaTime = deltaTime * nightAccelerationMultiplier;
    }
    
    // æ™®é€šæ¨¡å¼ï¼šæ—¥å¤œå¾ªç¯
    if (gameMode === 'normal') {
        dayNightTimer += effectiveDeltaTime;
        
        // æ£€æŸ¥æ—¥å¤œåˆ‡æ¢
        if (dayNightTimer >= DAY_NIGHT_CYCLE_DURATION) {
            isDaytime = !isDaytime;
            dayNightTimer = 0;
            
            // å¤œæ™šåˆ‡æ¢ä¸ºç™½å¤©æ—¶ï¼Œé‡ç½®ç¯ç«çŠ¶æ€
            if (isDaytime) {
                // é‡ç½®ç¯ç«çŠ¶æ€ï¼ˆé‡æ–°ç‚¹ç‡ƒï¼‰
                isCampfireExtinguished = false;
                isNightAccelerated = false;
                
                // æ˜¾ç¤ºæç¤º
                showSpecialAlert("é»æ˜åˆ°æ¥ï¼Œç¯ç«é‡æ–°ç‚¹ç‡ƒ");
            } else {
                // ç™½å¤©åˆ‡æ¢ä¸ºå¤œæ™šæ—¶ï¼Œç¡®ä¿ç¯ç«æ˜¯ç‚¹ç‡ƒçŠ¶æ€
                isCampfireExtinguished = false;
                moonPhaseTimer = Math.random() * MOON_PHASE_CYCLE;
                
                // æ˜¾ç¤ºæç¤º
                showSpecialAlert("å¤œå¹•é™ä¸´");
            }
            
            updateModeToggleButtons();
            updateCampsiteVisibility();
            
            // æ¸…ç†ä¸ç¬¦åˆå½“å‰æ—¶é—´çš„ç”Ÿç‰©
            if (!isDaytime) {
                for (let i = birds.length - 1; i >= 0; i--) {
                    if (!birds[i].isOwl && !birds[i].isBat && birds[i].name !== "å°é¸®" && birds[i].name !== "å¤œé¹­") {
                        birds.splice(i, 1);
                    }
                }
                nightObjects = [];
            } else {
                for (let i = birds.length - 1; i >= 0; i--) {
                    if (birds[i].isOwl || birds[i].isBat) {
                        birds.splice(i, 1);
                    }
                }
                
                if (littleOwl) {
                    birds.splice(birds.indexOf(littleOwl), 1);
                    littleOwl = null;
                }
                nightObjects = [];
            }
        }
            
            // æ›´æ–°å¤ªé˜³/æœˆäº®ä½ç½®
            sunMoonPosition = dayNightTimer / DAY_NIGHT_CYCLE_DURATION;
        } 
        // æ°¸ä¹…æ—¥é—´æ¨¡å¼
        else if (gameMode === 'day') {
            dayModeTimeState += deltaTime;
            dayNightTimer = dayModeTimeState;
            
            // ç¡®ä¿è¥åœ°çŠ¶æ€è¢«é‡ç½®
            resetCampsite();
            
            const goldenFilter = document.getElementById('goldenFilter');
            goldenFilter.style.backgroundColor = 'rgba(255, 215, 0, 0.1)';
            
            // æ›´æ–°è¥åœ°å¯è§æ€§
            updateCampsiteVisibility();
        } 
        // æ°¸ä¹…å¤œé—´æ¨¡å¼
        else if (gameMode === 'night') {
            nightModeTimeState += deltaTime;
            nightModeMoonPhaseTimer += deltaTime;
            dayNightTimer = nightModeTimeState;
            moonPhaseTimer = nightModeMoonPhaseTimer;
            
            if (moonPhaseTimer >= MOON_PHASE_CYCLE) {
                moonPhaseTimer = 0;
                nightModeMoonPhaseTimer = 0;
            }
            
            // ç¡®ä¿è¥åœ°çŠ¶æ€è¢«é‡ç½®
            resetCampsite();
            
            const goldenFilter = document.getElementById('goldenFilter');
            goldenFilter.style.backgroundColor = 'rgba(255, 215, 0, 0)';
            
    updateTimeIndicator();
    updateCampsiteVisibility(); // ç¡®ä¿è¥åœ°å¯è§æ€§æ›´æ–°
}
        
        // ç¨€æœ‰é¸Ÿç±»ç”Ÿæˆï¼ˆä½¿ç”¨å®é™…æ—¶é—´ï¼Œä¸å—åŠ é€Ÿå½±å“ï¼‰
        let rareBirdDelta = deltaTime;
        lastRareBirdTime += rareBirdDelta;
        
        if (gameTime - lastRareBirdTime >= RARE_BIRD_INTERVAL && !birdingModeActive) {
            generateRareBird();
            lastRareBirdTime = gameTime;
        }
        
        // å°é¸®ç”Ÿæˆé€»è¾‘ï¼ˆä½¿ç”¨å®é™…æ—¶é—´ï¼‰
        if (!littleOwl) {
            let cooldown;
            if (gameMode === 'day') {
                cooldown = LITTLE_OWL_DAY_COOLDOWN;
            } else if (gameMode === 'night') {
                cooldown = LITTLE_OWL_NIGHT_COOLDOWN;
            } else {
                cooldown = isDaytime ? LITTLE_OWL_DAY_COOLDOWN : LITTLE_OWL_NIGHT_COOLDOWN;
            }
            
            // ä½¿ç”¨å®é™…æ—¶é—´è®¡ç®—
            let actualTimePassed = deltaTime;
            lastLittleOwlTime += actualTimePassed;
            
            if (gameTime - lastLittleOwlTime > cooldown) {
                generateLittleOwl(true);
                lastLittleOwlTime = gameTime;
            }
        }
        
        // å¤œé—´çŒ«å¤´é¹°ç”Ÿæˆï¼ˆä½¿ç”¨å®é™…æ—¶é—´ï¼‰
        if ((gameMode === 'night' || (gameMode === 'normal' && !isDaytime))) {
            let actualTimePassed = deltaTime;
            lastOwlSpawnTime += actualTimePassed;
            
            if (gameTime - lastOwlSpawnTime > NIGHT_OWL_SPAWN_INTERVAL) {
                spawnNightOwls();
                lastOwlSpawnTime = gameTime;
            }
        }
    }

function initGyro() {
    const gyroModeButton = document.getElementById('gyroModeToggle');
    const gyroStatusIndicator = document.getElementById('gyroStatusIndicator');
    const sensitivitySlider = document.getElementById('gyroSensitivitySlider');
    const sensitivityValue = document.getElementById('gyroSensitivityValue');
    const sensitivityContainer = document.getElementById('gyroSensitivityContainer');
    const calibrateButton = document.getElementById('gyroCalibrateButton');
    const cameraButton = document.getElementById('cameraButton'); // è·å–å¿«é—¨æŒ‰é’®
    
    // è®¾ç½®é»˜è®¤çŠ¶æ€ï¼šåªæ˜¾ç¤ºé™€èºä»ªæŒ‰é’®ï¼Œå…¶ä»–å…ƒç´ éšè—
    gyroStatusIndicator.style.display = 'none';
    sensitivityContainer.style.display = 'none';
    calibrateButton.style.display = 'none';
    cameraButton.style.display = 'none'; // éšè—å¿«é—¨æŒ‰é’®
    
    // è®¾ç½®é™€èºä»ªæŒ‰é’®ä¸ºåŠé€æ˜
    gyroModeButton.style.opacity = '0.5';
    
    gyroModeButton.addEventListener('click', toggleGyroMode);
    calibrateButton.addEventListener('click', handleGyroCalibrate);
    sensitivitySlider.addEventListener('input', function() {
        gyroSensitivity = parseInt(this.value);
        sensitivityValue.textContent = gyroSensitivity;
    });
    
    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
        // iOSè®¾å¤‡éœ€è¦æƒé™
    } else if ('ondeviceorientation' in window) {
        // è®¾å¤‡æ”¯æŒé™€èºä»ª
    } else {
        // è®¾å¤‡ä¸æ”¯æŒé™€èºä»ª
        gyroModeButton.disabled = true;
        gyroModeButton.style.opacity = '0.3';
        gyroModeButton.title = "è®¾å¤‡ä¸æ”¯æŒé™€èºä»ª";
    }
}

function handleGyroCalibrate() {
  if (!gyroModeActive) {
    showSpecialAlert("è¯·å…ˆå¼€å¯é™€èºä»ªæ¨¡å¼");
    return;
  }
  calibrateGyro();
}

function toggleGyroMode() {
  if (gamePaused) return;
  
  if (!gyroModeActive) {
    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
      DeviceOrientationEvent.requestPermission()
        .then(permissionState => {
          if (permissionState === 'granted') {
            startGyroMode();
          } else {
            showSpecialAlert("é™€èºä»ªæƒé™è¢«æ‹’ç»");
          }
        })
        .catch(console.error);
    } else {
      startGyroMode();
    }
  } else {
    stopGyroMode();
  }
}

function startGyroMode() {
    gyroModeActive = true;
    isGyroCalibrated = false;
    const gyroModeButton = document.getElementById('gyroModeToggle');
    const gyroStatusIndicator = document.getElementById('gyroStatusIndicator');
    const sensitivityContainer = document.getElementById('gyroSensitivityContainer');
    const calibrateButton = document.getElementById('gyroCalibrateButton');
    const cameraButton = document.getElementById('cameraButton');
    const goldenFilter = document.getElementById('goldenFilter');
    const lensToggleContainer = document.getElementById('lensToggleContainer');
    const modeToggleContainer = document.getElementById('modeToggleContainer');
    
    goldenFilter.style.backgroundColor = 'rgba(255, 215, 0, 0)';
    gyroModeButton.classList.add('active');
    gyroModeButton.textContent = "å…³é—­é™€èºä»ª";
    gyroModeButton.style.opacity = '1';
    gyroStatusIndicator.style.display = 'block';
    sensitivityContainer.style.display = 'block';
    calibrateButton.style.display = 'block';
    cameraButton.style.display = 'flex'; // ç¡®ä¿å¿«é—¨æŒ‰é’®æ˜¾ç¤º
    
    // æ ¹æ®å½“å‰æ–¹å‘è®¾ç½®å¿«é—¨æŒ‰é’®ä½ç½®
    const isPortrait = window.matchMedia("(orientation: portrait)").matches;
    if (isPortrait) {
        // ç«–å±ä¸‹å¿«é—¨æŒ‰é’®åœ¨ä¸‹æ–¹ä¸­é—´
        cameraButton.style.right = 'auto';
        cameraButton.style.top = 'auto';
        cameraButton.style.bottom = '80px';
        cameraButton.style.left = '50%';
        cameraButton.style.transform = 'translateX(-50%)';
        cameraButton.style.width = '80px';
        cameraButton.style.height = '80px';
    } else {
        // æ¨ªå±ä¸‹å¿«é—¨æŒ‰é’®åœ¨å³ä¾§ä¸­é—´
        cameraButton.style.right = '15px';
        cameraButton.style.top = '50%';
        cameraButton.style.bottom = 'auto';
        cameraButton.style.left = 'auto';
        cameraButton.style.transform = 'translateY(-50%)';
        cameraButton.style.width = '70px';
        cameraButton.style.height = '70px';
    }
    
    gyroStatusIndicator.textContent = "æ ¡å‡†ä¸­...";
    
    if (window.matchMedia("(orientation: landscape)").matches) {
        if (lensToggleContainer) {
            lensToggleContainer.style.display = 'none';
            lensToggleContainer.classList.add('hidden-by-gyro');
        }
        if (modeToggleContainer) {
            modeToggleContainer.style.display = 'none';
            modeToggleContainer.classList.add('hidden-by-gyro');
        }
    }
    
    gyroX = GAME_WIDTH / 2;
    gyroY = GAME_HEIGHT / 2;
    mouseX = gyroX;
    mouseY = gyroY;
    
    showSpecialAlert("é™€èºä»ªæ¨¡å¼å·²å¯åŠ¨ï¼è¯·ä¿æŒè®¾å¤‡æ°´å¹³ä»¥è¿›è¡Œæ ¡å‡†ã€‚");
    
    setTimeout(() => {
        if (gyroModeActive && !isGyroCalibrated) {
            calibrateGyro();
        }
    }, 2000);
    
    window.addEventListener('deviceorientation', handleDeviceOrientation);
}

function stopGyroMode() {
    gyroModeActive = false;
    const gyroModeButton = document.getElementById('gyroModeToggle');
    const gyroStatusIndicator = document.getElementById('gyroStatusIndicator');
    const sensitivityContainer = document.getElementById('gyroSensitivityContainer');
    const calibrateButton = document.getElementById('gyroCalibrateButton');
    const cameraButton = document.getElementById('cameraButton');
    const lensToggleContainer = document.getElementById('lensToggleContainer');
    const modeToggleContainer = document.getElementById('modeToggleContainer');
    
    gyroModeButton.classList.remove('active');
    gyroModeButton.textContent = "é™€èºä»ª";
    gyroModeButton.style.opacity = '0.5';
    gyroStatusIndicator.style.display = 'none';
    sensitivityContainer.style.display = 'none';
    calibrateButton.style.display = 'none';
    cameraButton.style.display = 'none'; // å…³é—­é™€èºä»ªæ—¶éšè—å¿«é—¨æŒ‰é’®
    
    gyroStatusIndicator.textContent = "å…³é—­";
    
    if (lensToggleContainer) {
        lensToggleContainer.style.display = 'flex';
        lensToggleContainer.classList.remove('hidden-by-gyro');
    }
    if (modeToggleContainer) {
        modeToggleContainer.style.display = 'flex';
        modeToggleContainer.classList.remove('hidden-by-gyro');
    }
    
    window.removeEventListener('deviceorientation', handleDeviceOrientation);
    showSpecialAlert("é™€èºä»ªæ¨¡å¼å·²å…³é—­");
}

// æ·»åŠ ç‚¹å‡»äº‹ä»¶ç›‘å¬å™¨ï¼Œå…è®¸ç‚¹å‡»è¢«éšè—çš„åŒºåŸŸæ¥æ˜¾ç¤ºå®ƒä»¬
function addToggleAreaClickListeners() {
  const lensToggleContainer = document.getElementById('lensToggleContainer');
  const modeToggleContainer = document.getElementById('modeToggleContainer');
  
  if (lensToggleContainer) {
    lensToggleContainer.addEventListener('click', function(e) {
      // å¦‚æœè¿™ä¸ªåŒºåŸŸè¢«é™€èºä»ªéšè—äº†ï¼Œç‚¹å‡»æ—¶æ˜¾ç¤ºå®ƒ
      if (this.classList.contains('hidden-by-gyro') && gyroModeActive) {
        this.style.display = 'flex';
        this.classList.remove('hidden-by-gyro');
        e.stopPropagation();
        
        // 5ç§’åè‡ªåŠ¨éšè—
        setTimeout(() => {
          if (gyroModeActive && window.matchMedia("(orientation: landscape)").matches) {
            this.style.display = 'none';
            this.classList.add('hidden-by-gyro');
          }
        }, 5000);
      }
    });
  }
  
  if (modeToggleContainer) {
    modeToggleContainer.addEventListener('click', function(e) {
      // å¦‚æœè¿™ä¸ªåŒºåŸŸè¢«é™€èºä»ªéšè—äº†ï¼Œç‚¹å‡»æ—¶æ˜¾ç¤ºå®ƒ
      if (this.classList.contains('hidden-by-gyro') && gyroModeActive) {
        this.style.display = 'flex';
        this.classList.remove('hidden-by-gyro');
        e.stopPropagation();
        
        // 5ç§’åè‡ªåŠ¨éšè—
        setTimeout(() => {
          if (gyroModeActive && window.matchMedia("(orientation: landscape)").matches) {
            this.style.display = 'none';
            this.classList.add('hidden-by-gyro');
          }
        }, 5000);
      }
    });
  }
}

function calibrateGyro() {
    if (!gyroModeActive) return;
    requestCalibration = true;
    isGyroCalibrated = true;
    const gyroStatusIndicator = document.getElementById('gyroStatusIndicator');
    gyroStatusIndicator.textContent = "å·²æ ¡å‡†";
    showSpecialAlert("é™€èºä»ªæ ¡å‡†å®Œæˆï¼");
}

function handleDeviceOrientation(event) {
    if (!gyroModeActive || gamePaused) return;
    
    const now = Date.now();
    if (now - lastGyroUpdate < 16) return;
    lastGyroUpdate = now;
    
    const beta = event.beta;
    const gamma = event.gamma;
    if (beta === null || gamma === null) return;
    
    if (!isGyroCalibrated) {
        calibrateGyro();
        return;
    }
    
    if (requestCalibration) {
        gyroCenterBeta = beta;
        gyroCenterGamma = gamma;
        requestCalibration = false;
        return;
    }
    
    const sensitivityFactor = gyroSensitivity / 10;
    let orientation = window.orientation || 0;
    if (screen.orientation && screen.orientation.angle) {
        orientation = screen.orientation.angle;
    }
    
    let xAngle = 0;
    let yAngle = 0;
    
    if (orientation === 90) {
        xAngle = beta - gyroCenterBeta;
        yAngle = -(gamma - gyroCenterGamma);
    } else if (orientation === -90 || orientation === 270) {
        xAngle = -(beta - gyroCenterBeta);
        yAngle = gamma - gyroCenterGamma;
    } else if (orientation === 180) {
        xAngle = -(gamma - gyroCenterGamma);
        yAngle = -(beta - gyroCenterBeta);
    } else {
        xAngle = gamma - gyroCenterGamma;
        yAngle = beta - gyroCenterBeta;
    }
    
    const maxTiltAngle = 30;
    const xMultiplier = (GAME_WIDTH / 2) / maxTiltAngle;
    const yMultiplier = (GAME_HEIGHT / 2) / maxTiltAngle;
    
    const limitedXAngle = Math.max(-60, Math.min(60, xAngle));
    const limitedYAngle = Math.max(-60, Math.min(60, yAngle));
    
    const targetX = GAME_WIDTH / 2 + (limitedXAngle * xMultiplier * sensitivityFactor);
    const targetY = GAME_HEIGHT / 2 + (limitedYAngle * yMultiplier * sensitivityFactor);
    
    gyroX = gyroX + (targetX - gyroX) * 0.2;
    gyroY = gyroY + (targetY - gyroY) * 0.2;
    
    mouseX = Math.max(0, Math.min(GAME_WIDTH, gyroX));
    mouseY = Math.max(0, Math.min(GAME_HEIGHT, gyroY));
    
    updateViewfinderFromGyro();
}

function updateViewfinderFromGyro() {
    if (!gyroModeActive || gamePaused) return;
    
    const viewfinder = document.getElementById('viewfinder');
    const viewfinderSize = getViewfinderSize();
    
    const rect = canvas.getBoundingClientRect();
    const container = document.getElementById('gameContainer');
    const containerRect = container.getBoundingClientRect();
    
    // è®¡ç®—ç”»å¸ƒçš„å®é™…æ˜¾ç¤ºç¼©æ”¾æ¯”ä¾‹
    const displayScaleX = rect.width / GAME_WIDTH;
    const displayScaleY = rect.height / GAME_HEIGHT;
    
    // é¼ æ ‡ä½ç½®åœ¨å±å¹•ä¸Šçš„åæ ‡
    const screenX = mouseX * displayScaleX;
    const screenY = mouseY * displayScaleY;
    
    const canvasLeft = rect.left - containerRect.left;
    const canvasTop = rect.top - containerRect.top;
    
    // å–æ™¯å™¨åœ¨å±å¹•ä¸Šçš„æ˜¾ç¤ºå°ºå¯¸
    const viewfinderDisplayWidth = viewfinderSize.width * displayScaleX;
    const viewfinderDisplayHeight = viewfinderSize.height * displayScaleY;
    
    viewfinder.style.display = 'block';
    viewfinder.style.width = viewfinderDisplayWidth + 'px';
    viewfinder.style.height = viewfinderDisplayHeight + 'px';
    viewfinder.style.left = (canvasLeft + screenX - viewfinderDisplayWidth / 2) + 'px';
    viewfinder.style.top = (canvasTop + screenY - viewfinderDisplayHeight / 2) + 'px';
}

function handleCameraButtonClick() {
    // ç›´æ¥è°ƒç”¨æ‹ç…§é€»è¾‘ï¼Œè¥åœ°åŒºåŸŸçš„ç‚¹å‡»ç”±handleMouseClickå¤„ç†
    handleMouseClick();
    
    const cameraButton = document.getElementById('cameraButton');
    cameraButton.style.backgroundColor = 'rgba(200, 200, 200, 0.9)';
    setTimeout(() => {
        cameraButton.style.backgroundColor = 'rgba(255, 255, 255, 0.9)';
    }, 100);
}

function handleMouseMove(e) {
    if (gyroModeActive) return;
    
    const rect = canvas.getBoundingClientRect();
    
    // è®¡ç®—ä»å±å¹•åæ ‡åˆ°æ¸¸æˆé€»è¾‘åæ ‡çš„è½¬æ¢
    const scaleX = GAME_WIDTH / rect.width;
    const scaleY = GAME_HEIGHT / rect.height;
    
    mouseX = (e.clientX - rect.left) * scaleX;
    mouseY = (e.clientY - rect.top) * scaleY;
    
    // é™åˆ¶åœ¨æ¸¸æˆè¾¹ç•Œå†…
    mouseX = Math.max(0, Math.min(GAME_WIDTH, mouseX));
    mouseY = Math.max(0, Math.min(GAME_HEIGHT, mouseY));
    
    if (!gyroModeActive) {
        updateViewfinderFromMouse(e.clientX, e.clientY, rect);
    }
}
function updateViewfinderFromMouse(clientX, clientY, rect) {
    const viewfinder = document.getElementById('viewfinder');
    const viewfinderSize = getViewfinderSize();
    
    // è®¡ç®—ç”»å¸ƒçš„å®é™…æ˜¾ç¤ºç¼©æ”¾æ¯”ä¾‹
    const displayScaleX = rect.width / GAME_WIDTH;
    const displayScaleY = rect.height / GAME_HEIGHT;
    
    // å–æ™¯å™¨åœ¨å±å¹•ä¸Šçš„æ˜¾ç¤ºå°ºå¯¸
    const viewfinderDisplayWidth = viewfinderSize.width * displayScaleX;
    const viewfinderDisplayHeight = viewfinderSize.height * displayScaleY;
    
    viewfinder.style.display = 'block';
    viewfinder.style.width = viewfinderDisplayWidth + 'px';
    viewfinder.style.height = viewfinderDisplayHeight + 'px';
    viewfinder.style.left = (clientX - viewfinderDisplayWidth / 2) + 'px';
    viewfinder.style.top = (clientY - viewfinderDisplayHeight / 2) + 'px';
}
// åœ¨JavaScriptä¸­æ·»åŠ è¿™ä¸ªå‡½æ•°
function loadCreatorInfo() {
    fetch('creator.txt')
        .then(response => {
            if (!response.ok) {
                throw new Error('æ— æ³•åŠ è½½åˆ›ä½œè€…ä¿¡æ¯');
            }
            return response.text();
        })
        .then(text => {
            const creatorDiv = document.getElementById('creator');
            if (creatorDiv && text.trim()) {
                creatorDiv.textContent = text.trim();
            } else {
                creatorDiv.textContent = "é¸Ÿäººé¸Ÿè¯­";
            }
        })
        .catch(error => {
            console.error('åŠ è½½åˆ›ä½œè€…ä¿¡æ¯å¤±è´¥:', error);
            const creatorDiv = document.getElementById('creator');
            if (creatorDiv) {
                creatorDiv.textContent = "é¸Ÿäººé¸Ÿè¯­";
            }
        });
}


function init() {
  canvas = document.getElementById('gameCanvas');
  ctx = canvas.getContext('2d');
  poopCanvas = document.getElementById('poopCanvas');
  poopCtx = poopCanvas.getContext('2d');
  
  loadCreatorInfo();
  
  screenshotCanvas = document.getElementById('screenshotCanvas');
  screenshotCtx = screenshotCanvas.getContext('2d');
  screenshotCanvas.style.position = 'absolute';
  screenshotCanvas.style.left = '-9999px';
  screenshotCanvas.style.top = '-9999px';
  screenshotCanvas.style.width = '300px';
  screenshotCanvas.style.height = '450px';
  
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);
  
    // åˆå§‹åŒ–å…¨å±è§¦æ‘¸åŠŸèƒ½
    initFullscreenTouch();

  initStars();
  initTrees();
  initReeds();
  initFixedLeaves();
  initTextStats();
  initFruits();
  initWallAndHole();
  initModeToggleButtons();
  initLensToggleButtons();
  initGyro();
  
  window.addEventListener('orientationchange', function() {
    setTimeout(updateCampsiteVisibility, 100);
  });
   
    const campsite = document.getElementById('campsite');
    if (campsite) {
        // ç¡®ä¿è¥åœ°å…ƒç´ ä¸ä¼šæ•è·é¼ æ ‡äº‹ä»¶
        campsite.style.pointerEvents = 'none';
        
        campsite.style.position = 'absolute';
        campsite.style.top = 'auto';
        campsite.style.bottom = 'auto';
        campsite.style.left = 'auto';
        campsite.style.transform = 'none';
        campsite.style.display = 'none';
        
        console.log("è¥åœ°åˆå§‹åŒ–å®Œæˆï¼ŒæŒ‡é’ˆäº‹ä»¶å·²ç¦ç”¨");
    }
    
    // ç›´æ¥ä¸ºç¯ç«å…ƒç´ ç»‘å®šç‚¹å‡»äº‹ä»¶
    const flame = document.getElementById('campfire-flame');
    if (flame) {
        flame.onclick = function(e) {
            e.stopPropagation(); // é˜»æ­¢äº‹ä»¶å†’æ³¡åˆ°è¥åœ°
            extinguishCampfire();
        };
        flame.style.cursor = 'pointer';
        console.log("ç¯ç«ç‚¹å‡»äº‹ä»¶ç»‘å®šå®Œæˆ");
    }
  updateCampsiteVisibility();
  
  const birdingModeButton = document.getElementById('birdingModeToggle');
  birdingModeButton.addEventListener('click', toggleBirdingMode);
  
  const helpButton = document.getElementById('helpButton');
  if (helpButton) {
    helpButton.addEventListener('click', openHelpModal);
  }
  
  lastRareBirdTime = gameTime;
  
  canvas.addEventListener('mousemove', handleMouseMove);
  canvas.addEventListener('mousedown', handleMouseClick);
  
  document.addEventListener('keydown', handleKeyDown);
  
  lastFrameTime = performance.now();
  
  const goldenFilter = document.getElementById('goldenFilter');
  if (!gyroModeActive) {
    goldenFilter.style.backgroundColor = 'rgba(255, 215, 0, 0.1)';
  }
  
  addToggleAreaClickListeners();
  
  updateTimeIndicator();
  initBirdingRecords();
  updateBirdingModeButton();
  updateBirdingRecordIcons();
  
  requestAnimationFrame(gameLoop);
  
  const screenshotButton = document.getElementById('screenshotButton');
  if (screenshotButton) {
    const newScreenshotButton = screenshotButton.cloneNode(true);
    screenshotButton.parentNode.replaceChild(newScreenshotButton, screenshotButton);
    const updatedScreenshotButton = document.getElementById('screenshotButton');
    updatedScreenshotButton.onclick = function(e) {
      e.stopPropagation();
      captureBirdingRecord();
    };
  }
  
    // ç›‘å¬æ–¹å‘å˜åŒ–
window.addEventListener('orientationchange', function() {
    setTimeout(function() {
        if (gameMode === 'normal' && !isDaytime) {
            updateCampfirePosition();
            // é‡æ–°ç»‘å®šç¯ç«ç‚¹å‡»äº‹ä»¶
            const flame = document.getElementById('campfire-flame');
            if (flame && !isCampfireExtinguished) {
                flame.onclick = function(e) {
                    e.stopPropagation();
                    extinguishCampfire();
                };
                flame.style.pointerEvents = 'auto';
                flame.style.cursor = 'pointer';
            }
        }
    }, 300);
});
    
    // ç›‘å¬çª—å£å¤§å°å˜åŒ–
    window.addEventListener('resize', function() {
        clearTimeout(window.campfireResizeTimer);
        window.campfireResizeTimer = setTimeout(function() {
            if (gameMode === 'normal' && !isDaytime) {
                updateCampfirePosition();
            }
        }, 250);
    });
    
    // åˆå§‹è°ƒç”¨ä¸€æ¬¡
    setTimeout(() => {
        updateUIForOrientation();
        // åˆå§‹æ—¶å¦‚æœé™€èºä»ªæœªæ¿€æ´»ï¼Œéšè—å¿«é—¨æŒ‰é’®
        const cameraButton = document.getElementById('cameraButton');
        if (!gyroModeActive && cameraButton) {
            cameraButton.style.display = 'none';
        }
        
        if (gameMode === 'normal' && !isDaytime) {
            updateCampfirePosition();
        }
    }, 500);
}

// æ·»åŠ æ›´æ–°UIå¸ƒå±€çš„å‡½æ•°
function updateUIForOrientation() {
    const isPortrait = window.matchMedia("(orientation: portrait)").matches;
    const isSmallLandscape = window.matchMedia("(orientation: landscape) and (max-height: 500px)").matches;
    
    // è·å–å®é™…å…ƒç´ é«˜åº¦
    const getElementHeight = (elementId) => {
        const element = document.getElementById(elementId);
        if (element && element.offsetHeight) {
            return element.offsetHeight;
        }
        return 0;
    };
    
    // è®¡ç®—è§‚é¸Ÿè®°å½•å›¾æ ‡ä½ç½®
    const calculateRecordIconPosition = () => {
        const birdingModeHeight = getElementHeight('birdingModeToggle') || 36;
        const statusIndicatorHeight = getElementHeight('birdingStatusIndicator') || 30;
        const gap = 2; // é—´è·
        
        return birdingModeHeight + statusIndicatorHeight + gap;
    };
    
    // è®¡ç®—å¸®åŠ©æŒ‰é’®ä½ç½®
    const calculateHelpButtonPosition = () => {
        const recordIconTop = calculateRecordIconPosition();
        const recordIconHeight = getElementHeight('birdingRecordIcon') || 20;
        const gap = 10; // å¸®åŠ©æŒ‰é’®ä¸è§‚é¸Ÿè®°å½•å›¾æ ‡çš„é—´è·
        
        return recordIconTop + recordIconHeight + gap;
    };
    
    if (isPortrait) {
        // ç«–å±æ¨¡å¼
        const recordIconTop = calculateRecordIconPosition();
        const helpButtonTop = calculateHelpButtonPosition();
        
        // æ›´æ–°è§‚é¸Ÿè®°å½•å›¾æ ‡ä½ç½®
        const birdingRecordIcon = document.getElementById('birdingRecordIcon');
        if (birdingRecordIcon) {
            birdingRecordIcon.style.top = recordIconTop + 'px';
        }
        
        // æ›´æ–°å¸®åŠ©æŒ‰é’®ä½ç½®
        const helpButton = document.getElementById('helpButton');
        if (helpButton) {
            helpButton.style.top = helpButtonTop + 'px';
            helpButton.style.right = '10px';
        }
        
        // æ›´æ–°é™€èºä»ªæŒ‰é’®ä½ç½®ï¼ˆåœ¨å¸®åŠ©æŒ‰é’®ä¸‹æ–¹ï¼‰
        const gyroContainer = document.getElementById('gyroToggleContainer');
        if (gyroContainer) {
            const helpButtonHeight = getElementHeight('helpButton') || 25;
            gyroContainer.style.top = (helpButtonTop + helpButtonHeight + 5) + 'px';
            gyroContainer.style.right = '10px';
        }
        
        console.log("ç«–å±å¸ƒå±€ - è§‚é¸Ÿè®°å½•å›¾æ ‡:", recordIconTop, "å¸®åŠ©æŒ‰é’®:", helpButtonTop);
    } else if (isSmallLandscape) {
        // å°æ¨ªå±æ¨¡å¼
        const recordIconTop = calculateRecordIconPosition();
        const helpButtonTop = calculateHelpButtonPosition();
        
        // æ›´æ–°è§‚é¸Ÿè®°å½•å›¾æ ‡ä½ç½®
        const birdingRecordIcon = document.getElementById('birdingRecordIcon');
        if (birdingRecordIcon) {
            birdingRecordIcon.style.top = recordIconTop + 'px';
        }
        
        // æ›´æ–°å¸®åŠ©æŒ‰é’®ä½ç½®
        const helpButton = document.getElementById('helpButton');
        if (helpButton) {
            helpButton.style.top = helpButtonTop + 'px';
            helpButton.style.right = '5px';
        }
        
        console.log("å°æ¨ªå±å¸ƒå±€ - è§‚é¸Ÿè®°å½•å›¾æ ‡:", recordIconTop, "å¸®åŠ©æŒ‰é’®:", helpButtonTop);
    } else {
        // æ­£å¸¸æ¨ªå±æ¨¡å¼
        const recordIconTop = calculateRecordIconPosition();
        const helpButtonTop = calculateHelpButtonPosition();
        
        // æ›´æ–°è§‚é¸Ÿè®°å½•å›¾æ ‡ä½ç½®
        const birdingRecordIcon = document.getElementById('birdingRecordIcon');
        if (birdingRecordIcon) {
            birdingRecordIcon.style.top = recordIconTop + 'px';
        }
        
        // æ›´æ–°å¸®åŠ©æŒ‰é’®ä½ç½®
        const helpButton = document.getElementById('helpButton');
        if (helpButton) {
            helpButton.style.top = helpButtonTop + 'px';
            helpButton.style.right = '10px';
        }
        
        console.log("æ¨ªå±å¸ƒå±€ - è§‚é¸Ÿè®°å½•å›¾æ ‡:", recordIconTop, "å¸®åŠ©æŒ‰é’®:", helpButtonTop);
    }
    
    // æ›´æ–°ç¯ç«ä½ç½®
    if (gameMode === 'normal' && !isDaytime) {
        setTimeout(updateCampfirePosition, 100);
    }
}

function handleVisibilityChange() {
    if (document.hidden) {
        // é¡µé¢ä¸å¯è§æ—¶ï¼Œå¯ä»¥é€‚å½“é™ä½æ¸¸æˆå¾ªç¯é¢‘ç‡æˆ–æš‚åœéå¿…è¦æ›´æ–°
        console.log('é¡µé¢å¤±å»ç„¦ç‚¹');
    } else {
        // é¡µé¢é‡æ–°å¯è§æ—¶ï¼Œé‡ç½® lastFrameTime é¿å…æ—¶é—´è·³è·ƒ
        lastFrameTime = performance.now();
        console.log('é¡µé¢é‡æ–°è·å¾—ç„¦ç‚¹');
    }
}

function gameLoop(timestamp) {
    if (gamePaused) {
        requestAnimationFrame(gameLoop);
        return;
    }
    
    // é™åˆ¶æœ€å¤§ deltaTimeï¼Œé¿å…å¤±å»ç„¦ç‚¹åæ—¶é—´å·®è¿‡å¤§
    let deltaTime = timestamp - lastFrameTime;
    lastFrameTime = timestamp;
    
    // é™åˆ¶æœ€å¤§ deltaTime ä¸º 30ms
    if (deltaTime > 30) {
        deltaTime = 30;
    }
    
    updateDayNight(deltaTime);
    updateBirds(deltaTime);
    updateNightObjects(deltaTime);
    generateBird();
    
    if (gyroModeActive) {
        updateViewfinderFromGyro();
    }
    
    requestAnimationFrame(gameLoop);
}

function initBirdingRecords() {
  lastBirdingRecordTime = gameTime;
  birdingModeBirdTracker = {};
  birdingObservedSpecies = new Set();
  birdingModeRecordedBirds = new Set();
}

function getBirdsInView() {
  const viewBounds = {
    left: 0,
    right: GAME_WIDTH,
    top: 0,
    bottom: GAME_HEIGHT
  };
  
  const birdsInView = [];
  const countedGroups = new Set();
  
  birds.forEach(bird => {
    if (!bird.name || bird.isBat || bird.type?.isSpecial) return;
    
    const baseSize = 20;
    const birdSize = baseSize * bird.size;
    const birdRadius = birdSize / 2;
    
    const isInView = bird.x + birdRadius >= viewBounds.left &&
                    bird.x - birdRadius <= viewBounds.right &&
                    bird.y + birdRadius >= viewBounds.top &&
                    bird.y - birdRadius <= viewBounds.bottom;
    
    if (isInView) {
      birdsInView.push(bird);
      
      if (bird.groupId && birdGroupInfo[bird.groupId]) {
        if (!countedGroups.has(bird.groupId)) {
          countedGroups.add(bird.groupId);
        }
      }
    }
  });
  
  return birdsInView;
}

function countBirdsInView() {
  const birdsInView = getBirdsInView();
  const birdCounts = {};
  const countedGroups = new Set();
  
  birdsInView.forEach(bird => {
    const birdName = bird.name;
    if (!birdCounts[birdName]) {
      birdCounts[birdName] = 0;
    }
    
    if (bird.groupId && birdGroupInfo[bird.groupId]) {
      if (!countedGroups.has(bird.groupId)) {
        const group = birdGroupInfo[bird.groupId];
        if (group && group.birds) {
          let groupCount = 0;
          group.birds.forEach(groupBird => {
            if (groupBird && birds.includes(groupBird)) {
              const baseSize = 20;
              const groupBirdRadius = baseSize * groupBird.size / 2;
              const isGroupBirdInView = groupBird.x + groupBirdRadius >= 0 &&
                                        groupBird.x - groupBirdRadius <= GAME_WIDTH &&
                                        groupBird.y + groupBirdRadius >= 0 &&
                                        groupBird.y - groupBirdRadius <= GAME_HEIGHT;
              if (isGroupBirdInView) {
                groupCount++;
              }
            }
          });
          birdCounts[birdName] += groupCount;
          countedGroups.add(bird.groupId);
        }
      }
    } else {
      birdCounts[birdName]++;
    }
  });
  
  return birdCounts;
}

// æ›´æ–°è§‚é¸Ÿè®°å½•å›¾æ ‡æ˜¾ç¤º
function updateBirdingRecordIcons() {
    const iconElement = document.getElementById('birdingRecordIcon');
    if (!iconElement) return;
    
    // å¦‚æœæœ‰è§‚é¸Ÿè®°å½•ï¼Œæ˜¾ç¤ºå›¾æ ‡
    if (birdingRecords.length > 0) {
        const latestRecord = birdingRecords[birdingRecords.length - 1];
        
        const totalSeconds = Math.floor(latestRecord.birdingModeDuration / 1000);
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        
        // è®¾ç½®å›¾æ ‡å†…å®¹
        iconElement.innerHTML = `
            <span class="iconNumber">#${latestRecord.id}</span>
            <span class="iconTime">${minutes}:${seconds.toString().padStart(2, '0')}</span>
            <span class="iconBirdCount">${latestRecord.totalObservedSpecies}ç§</span>
        `;
        
        // æ·»åŠ ç‚¹å‡»äº‹ä»¶
        iconElement.onclick = function() {
            openBirdingRecord(birdingRecords.length - 1);
        };
        
        // æ˜¾ç¤ºå›¾æ ‡
        iconElement.style.display = 'flex';
    } else {
        // æ²¡æœ‰è®°å½•æ—¶éšè—å›¾æ ‡
        iconElement.style.display = 'none';
    }
}

    function createBirdingRecord(duration) {
        if (!birdingModeActive && birdingObservedSpecies.size === 0) {
            return null;
        }
        
        const capturedInSession = birdingModeCapturedSpecies ? birdingModeCapturedSpecies.size : 0;
        let rarestBird = null;
        let minProbability = Infinity;
        
        for (const birdName of birdingObservedSpecies) {
            const birdKey = Object.keys(BIRD_TYPES).find(key => BIRD_TYPES[key].name === birdName);
            if (birdKey && BIRD_TYPES[birdKey].probability > 0 && BIRD_TYPES[birdKey].probability < minProbability) {
                minProbability = BIRD_TYPES[birdKey].probability;
                rarestBird = birdName;
            }
        }
        
        const record = {
            id: birdingRecords.length + 1,
            time: gameTime,
            observedSpecies: Array.from(birdingObservedSpecies),
            totalObservedSpecies: birdingObservedSpecies.size,
            capturedInSession: capturedInSession,
            rarestBird: rarestBird,
            birdingModeDuration: duration, // ä½¿ç”¨ä¼ å…¥çš„å®é™…æ—¶é•¿
            startedAtDaytime: isDaytimeAtStart,
            endedAtDaytime: isDaytime
        };
        
        birdingRecords.push(record);
        if (birdingRecords.length > 20) {
            birdingRecords.shift();
        }
        
        updateBirdingRecordIcons();
        return record;
    }

function openBirdingRecord(recordIndex) {
  if (recordIndex < 0 || recordIndex >= birdingRecords.length) return;
  
  pauseGame();
  
  const modal = document.getElementById('birdingRecordModal');
  const content = document.getElementById('birdingRecordContent');
  const screenshotButton = document.getElementById('screenshotButton');
  const nav = document.getElementById('birdingRecordNav');
  const counter = document.getElementById('birdingRecordCounter');
  const swipeHint = document.getElementById('swipeHint');
  
  // è®¾ç½®å½“å‰è®°å½•ç´¢å¼•
  currentRecordIndex = recordIndex;
  
  modal.style.display = 'block';
  modal.style.zIndex = '400';
  
  // æ˜¾ç¤ºå¯¼èˆªæŒ‰é’®å’Œè®¡æ•°å™¨
  nav.classList.add('show');
  counter.classList.add('show');
  swipeHint.style.display = 'block';
  
  screenshotButton.style.display = 'block';
  screenshotButton.style.pointerEvents = 'auto';
  screenshotButton.style.opacity = '1';
  screenshotButton.style.zIndex = '401';
  screenshotButton.parentNode.appendChild(screenshotButton);
  
  // æ›´æ–°å¯¼èˆªæŒ‰é’®çŠ¶æ€
  updateRecordNavButtons();
  
  // æ›´æ–°è®°å½•å†…å®¹
  updateRecordContent(recordIndex);
  
  // æ·»åŠ äº‹ä»¶ç›‘å¬å™¨
  modal.addEventListener('wheel', handleRecordWheel, { passive: false });
  modal.addEventListener('touchstart', handleRecordTouchStart, { passive: true });
  modal.addEventListener('touchmove', handleRecordTouchMove, { passive: false });
  modal.addEventListener('touchend', handleRecordTouchEnd, { passive: true });
  
  screenshotButton.onclick = function(e) {
    e.stopPropagation();
    captureBirdingRecord();
  };
  
  // 3ç§’åéšè—æ»‘åŠ¨æç¤º
  setTimeout(() => {
    swipeHint.style.display = 'none';
  }, 3000);
}
  
  function updateRecordContent(recordIndex) {
  const record = birdingRecords[recordIndex];
  const content = document.getElementById('birdingRecordContent');
  const counter = document.getElementById('birdingRecordCounter');
  
  currentBirdingRecord = record;
  currentRecordIndex = recordIndex;
  
  const totalSeconds = Math.floor(record.birdingModeDuration / 1000);
  const minutes = Math.floor(totalSeconds / 60);
  const seconds = totalSeconds % 60;
  
  let recordText = `ç¬¬ ${record.id} æ¬¡è§‚é¸Ÿè®°å½•\n`;
  recordText += "=".repeat(50) + "\n\n";
  recordText += `è§‚é¸Ÿæ—¶é•¿: ${minutes}åˆ†${seconds}ç§’\n`;
  recordText += `æ—¶é—´è·¨åº¦: ${record.startedAtDaytime ? "ç™½å¤©" : "é»‘å¤œ"} â†’ ${record.endedAtDaytime ? "ç™½å¤©" : "é»‘å¤œ"}\n`;
  recordText += `è§‚å¯Ÿé¸Ÿç§: ${record.totalObservedSpecies} ç§\n`;
  recordText += `æ‹æ‘„é¸Ÿç§: ${record.capturedInSession} ç§\n`;
  
  if (record.rarestBird) {
    recordText += `æœ€ç¨€æœ‰é¸Ÿç§: ${record.rarestBird}\n`;
  }
  
  recordText += "=".repeat(50) + "\n\n";
  recordText += "è§‚å¯Ÿåˆ°çš„é¸Ÿç§:\n";
  recordText += "-".repeat(50) + "\n\n";
  
  record.observedSpecies.sort().forEach((birdName, index) => {
    const birdKey = Object.keys(BIRD_TYPES).find(key => BIRD_TYPES[key].name === birdName);
    const isRare = birdKey && BIRD_TYPES[birdKey].probability < 0.02;
    
    if (birdName === record.rarestBird) {
      recordText += `${index + 1}. ${birdName} â˜…\n`;
    } else if (isRare) {
      recordText += `${index + 1}. ${birdName} (ç¨€æœ‰)\n`;
    } else {
      recordText += `${index + 1}. ${birdName}\n`;
    }
  });
  
  content.textContent = recordText;
  
  // æ›´æ–°è®¡æ•°å™¨
  counter.textContent = `è®°å½• ${recordIndex + 1} / ${birdingRecords.length}`;
  
  // æ›´æ–°å¯¼èˆªæŒ‰é’®çŠ¶æ€
  updateRecordNavButtons();
}

function updateRecordNavButtons() {
  const prevButton = document.getElementById('prevRecordButton');
  const nextButton = document.getElementById('nextRecordButton');
  
  prevButton.disabled = currentRecordIndex <= 0;
  nextButton.disabled = currentRecordIndex >= birdingRecords.length - 1;
}

// åˆ‡æ¢è®°å½•
function switchBirdingRecord(direction) {
  if (isNavigatingRecords) return;
  
  const newIndex = currentRecordIndex + direction;
  
  if (newIndex >= 0 && newIndex < birdingRecords.length) {
    isNavigatingRecords = true;
    
    // æ·»åŠ åˆ‡æ¢åŠ¨ç”»æ•ˆæœ
    const content = document.getElementById('birdingRecordContent');
    content.style.opacity = '0.5';
    content.style.transition = 'opacity 0.2s';
    
    setTimeout(() => {
      updateRecordContent(newIndex);
      content.style.opacity = '1';
      
      setTimeout(() => {
        isNavigatingRecords = false;
      }, 100);
    }, 100);
  }
}

// å¤„ç†æ»šè½®äº‹ä»¶
function handleRecordWheel(event) {
  if (isNavigatingRecords) return;
  
  const now = Date.now();
  if (now - lastWheelTime < WHEEL_COOLDOWN) return;
  
  event.preventDefault();
  
  // åˆ¤æ–­æ»šè½®æ–¹å‘
  if (event.deltaY > 0) {
    // å‘ä¸‹æ»šåŠ¨ï¼Œåˆ‡æ¢åˆ°ä¸‹ä¸€æ¡è®°å½•
    switchBirdingRecord(1);
  } else if (event.deltaY < 0) {
    // å‘ä¸Šæ»šåŠ¨ï¼Œåˆ‡æ¢åˆ°ä¸Šä¸€æ¡è®°å½•
    switchBirdingRecord(-1);
  }
  
  lastWheelTime = now;
}

// å¤„ç†è§¦æ‘¸å¼€å§‹äº‹ä»¶
function handleRecordTouchStart(event) {
  if (event.touches.length === 1) {
    touchStartY = event.touches[0].clientY;
    touchStartX = event.touches[0].clientX;
  }
}

// å¤„ç†è§¦æ‘¸ç§»åŠ¨äº‹ä»¶
function handleRecordTouchMove(event) {
  if (isNavigatingRecords || event.touches.length !== 1) return;
  
  event.preventDefault();
  
  const touchY = event.touches[0].clientY;
  const touchX = event.touches[0].clientX;
  
  // è®¡ç®—å‚ç›´æ»‘åŠ¨è·ç¦»
  const deltaY = touchY - touchStartY;
  const deltaX = touchX - touchStartX;
  
  // å¦‚æœæ˜¯å‚ç›´æ»‘åŠ¨ä¸”è·ç¦»è¶³å¤Ÿå¤§ï¼Œåˆ™åˆ‡æ¢è®°å½•
  if (Math.abs(deltaY) > 50 && Math.abs(deltaY) > Math.abs(deltaX)) {
    if (deltaY > 0) {
      // å‘ä¸‹æ»‘åŠ¨ï¼Œåˆ‡æ¢åˆ°ä¸Šä¸€æ¡è®°å½•
      switchBirdingRecord(-1);
    } else {
      // å‘ä¸Šæ»‘åŠ¨ï¼Œåˆ‡æ¢åˆ°ä¸‹ä¸€æ¡è®°å½•
      switchBirdingRecord(1);
    }
    
    // é‡ç½®è§¦æ‘¸èµ·ç‚¹
    touchStartY = touchY;
    touchStartX = touchX;
  }
}

// å¤„ç†è§¦æ‘¸ç»“æŸäº‹ä»¶
function handleRecordTouchEnd() {
  touchStartY = 0;
  touchStartX = 0;
}

// ä¿®æ”¹ closeBirdingRecord å‡½æ•°
function closeBirdingRecord() {
  const modal = document.getElementById('birdingRecordModal');
  const screenshotButton = document.getElementById('screenshotButton');
  const nav = document.getElementById('birdingRecordNav');
  const counter = document.getElementById('birdingRecordCounter');
  
  // ç§»é™¤äº‹ä»¶ç›‘å¬å™¨
  modal.removeEventListener('wheel', handleRecordWheel);
  modal.removeEventListener('touchstart', handleRecordTouchStart);
  modal.removeEventListener('touchmove', handleRecordTouchMove);
  modal.removeEventListener('touchend', handleRecordTouchEnd);
  
  modal.style.display = 'none';
  nav.classList.remove('show');
  counter.classList.remove('show');
  
  screenshotButton.style.display = 'none';
  currentBirdingRecord = null;
  
  resumeGame();
}

function toggleBirdingMode() {
    if (gamePaused) return;
    
    if (!birdingModeActive) {
        birdingModeActive = true;
        birdingModeStartTime = gameTime;
        isDaytimeAtStart = isDaytime;
        birdingRecordRealDuration = 0; // é‡ç½®å®é™…è§‚é¸Ÿæ—¶é•¿
        
        const dayModeButton = document.getElementById('dayModeToggle');
        const normalModeButton = document.getElementById('normalModeToggle');
        const nightModeButton = document.getElementById('nightModeToggle');
        dayModeButton.disabled = true;
        normalModeButton.disabled = true;
        nightModeButton.disabled = true;
        dayModeButton.style.opacity = '0.5';
        normalModeButton.style.opacity = '0.5';
        nightModeButton.style.opacity = '0.5';
        
        birdingObservedSpecies = new Set();
        birdingModeRecordedBirds = new Set();
        birdingModeCapturedSpecies = new Set();
        
        const initialBirds = getBirdsInView();
        initialBirds.forEach(bird => {
            if (bird.noStats) return;
            const birdId = `${bird.name}_${bird.x}_${bird.y}_${bird.groupId || 'single'}`;
            if (!birdingModeRecordedBirds.has(birdId)) {
                birdingModeRecordedBirds.add(birdId);
                birdingObservedSpecies.add(bird.name);
            }
        });
        
        birdingModeStartSnapshot = {
            startTime: gameTime,
            startedAtDaytime: isDaytime,
            birdCounts: countBirdsInView(),
            captured: {...capturedBirds},
            birds: birds.map(bird => ({ 
                name: bird.name, 
                type: bird.type, 
                x: bird.x, 
                y: bird.y, 
                groupId: bird.groupId 
            }))
        };
        
        birdingModeBirdTracker = {};
        lastBirdingRecordTime = gameTime;
        showSpecialAlert("è§‚é¸Ÿæ¨¡å¼å·²å¯åŠ¨ï¼è®°å½•å·²å¼€å§‹ã€‚");
        updateBirdingModeButton();
        
        // ä¿å­˜åŸå§‹æ–‡æœ¬ç»Ÿè®¡å†…å®¹
        const textStatsElement = document.getElementById('textStats');
        if (textStatsElement) {
            // ä¿å­˜åŸå§‹å†…å®¹ä»¥ä¾¿æ¢å¤
            if (!textStatsElement.dataset.original) {
                textStatsElement.dataset.original = textStatsElement.innerHTML;
            }
            // æ›´æ–°ä¸ºè§‚é¸Ÿæ¨¡å¼ä¸‹çš„æ ‡ç­¾
            textStatsElement.innerHTML = `è§‚å¯Ÿé¸Ÿç§: <span id="appearedCount">${birdingObservedSpecies.size}</span> | æ‹æ‘„é¸Ÿç§: <span id="capturedCount">0</span>`;
        }
        
        // å¼€å§‹è®°å½•å®é™…è§‚é¸Ÿæ—¶é•¿
        if (birdingModeUpdateInterval) {
            clearInterval(birdingModeUpdateInterval);
        }
        birdingModeUpdateInterval = setInterval(() => {
            if (birdingModeActive) {
                // è®°å½•å®é™…æ—¶é—´ï¼ˆä¸å—åŠ é€Ÿå½±å“ï¼‰
                birdingRecordRealDuration += 1000;
                
                const currentBirds = getBirdsInView();
                currentBirds.forEach(bird => {
                    if (bird.noStats) return;
                    const birdId = `${bird.name}_${bird.x}_${bird.y}_${bird.groupId || 'single'}`;
                    if (!birdingModeRecordedBirds.has(birdId)) {
                        birdingModeRecordedBirds.add(birdId);
                        birdingObservedSpecies.add(bird.name);
                        
                        // æ›´æ–°è§‚å¯Ÿé¸Ÿç§ç»Ÿè®¡
                        const appearedCountElement = document.getElementById('appearedCount');
                        if (appearedCountElement) {
                            appearedCountElement.textContent = birdingObservedSpecies.size;
                        }
                    }
                });
            }
        }, 1000);
    } else {
        birdingModeActive = false;
        birdingModeEndTime = gameTime;
        
        const dayModeButton = document.getElementById('dayModeToggle');
        const normalModeButton = document.getElementById('normalModeToggle');
        const nightModeButton = document.getElementById('nightModeToggle');
        dayModeButton.disabled = false;
        normalModeButton.disabled = false;
            dayModeButton.disabled = false;
        normalModeButton.disabled = false;
        nightModeButton.disabled = false;
        dayModeButton.style.opacity = '1';
        normalModeButton.style.opacity = '1';
        nightModeButton.style.opacity = '1';
        
        // ä½¿ç”¨å®é™…è®°å½•çš„è§‚é¸Ÿæ—¶é•¿
        const recordDuration = birdingRecordRealDuration || (birdingModeEndTime - birdingModeStartTime);
        const record = createBirdingRecord(recordDuration);
        updateBirdingModeButton();
        
        if (record) {
            const elapsedMinutes = Math.floor(record.birdingModeDuration / 60000);
            const elapsedSeconds = Math.floor((record.birdingModeDuration % 60000) / 1000);
            showSpecialAlert(`è§‚é¸Ÿæ¨¡å¼ç»“æŸï¼æŒç»­${elapsedMinutes}åˆ†${elapsedSeconds}ç§’ï¼Œè§‚å¯Ÿ${record.totalObservedSpecies}ç§ï¼Œæ‹æ‘„${record.capturedInSession}ç§`);
            
            if (record.totalObservedSpecies > 0) {
                pauseGame();
                openBirdingRecord(record.id - 1);
            }
        } else {
            showSpecialAlert("è§‚é¸Ÿæ¨¡å¼ç»“æŸï¼Œæœªç”Ÿæˆè®°å½•æ•°æ®ã€‚");
        }
        
        birdingModeStartSnapshot = {};
        birdingObservedSpecies = new Set();
        birdingModeRecordedBirds = new Set();
        birdingModeCapturedSpecies = null;
        birdingRecordRealDuration = 0;
        
        // æ¢å¤åŸå§‹æ–‡æœ¬ç»Ÿè®¡å†…å®¹
        const textStatsElement = document.getElementById('textStats');
        if (textStatsElement && textStatsElement.dataset.original) {
            textStatsElement.innerHTML = textStatsElement.dataset.original;
            
            // æ¢å¤å…¨å±€ç»Ÿè®¡æ˜¾ç¤º
            const appearedCount = Object.values(appearedBirds).filter(count => count > 0).length;
            const capturedCount = Object.values(capturedBirds).filter(count => count > 0).length;
            
            document.getElementById('appearedCount').textContent = appearedCount;
            document.getElementById('capturedCount').textContent = capturedCount;
        }
        
        if (birdingModeUpdateInterval) {
            clearInterval(birdingModeUpdateInterval);
            birdingModeUpdateInterval = null;
        }
    }
}

function updateBirdingModeButton() {
  const birdingModeButton = document.getElementById('birdingModeToggle');
  const birdingStatusIndicator = document.getElementById('birdingStatusIndicator');
  
  if (birdingModeActive) {
    birdingModeButton.classList.add('active');
    birdingModeButton.style.borderColor = '#90EE90';
    birdingModeButton.textContent = "ç»“æŸè§‚é¸Ÿæ¨¡å¼";
    
    const birdingDuration = gameTime - birdingModeStartTime;
    const birdingMinutes = Math.floor(birdingDuration / 60000);
    const birdingSeconds = Math.floor((birdingDuration % 60000) / 1000);
    
    birdingStatusIndicator.textContent = `è¿›è¡Œä¸­ ${birdingMinutes}:${birdingSeconds.toString().padStart(2, '0')}`;
    birdingStatusIndicator.style.color = '#90EE90';
    
    if (birdingModeUpdateInterval) {
      clearInterval(birdingModeUpdateInterval);
      birdingModeUpdateInterval = null;
    }
    
birdingModeUpdateInterval = setInterval(() => {
    if (birdingModeActive) {
        const currentBirds = getBirdsInView();
        let hasNewBird = false;
        
        currentBirds.forEach(bird => {
            if (bird.noStats) return;
            const birdId = `${bird.name}_${bird.x}_${bird.y}_${bird.groupId || 'single'}`;
            if (!birdingModeRecordedBirds.has(birdId)) {
                birdingModeRecordedBirds.add(birdId);
                birdingObservedSpecies.add(bird.name);
                hasNewBird = true;
            }
        });
        
        if (hasNewBird) {
            updateTextStats(); // å½“è§‚å¯Ÿåˆ°æ–°é¸Ÿç§æ—¶æ›´æ–°æ˜¾ç¤º
        }
    }
}, 1000);
  } else {
    birdingModeButton.classList.remove('active');
    birdingModeButton.style.borderColor = '#90EE90';
    birdingModeButton.textContent = "è§‚é¸Ÿæ¨¡å¼";
    birdingStatusIndicator.textContent = "æœªå¼€å§‹";
    birdingStatusIndicator.style.color = "white";
    
    if (birdingModeUpdateInterval) {
      clearInterval(birdingModeUpdateInterval);
      birdingModeUpdateInterval = null;
    }
  }
}

function initLensToggleButtons() {
  const lens600Button = document.getElementById('lens600Toggle');
  const lens800Button = document.getElementById('lens800Toggle');
  const lens1200Button = document.getElementById('lens1200Toggle');
  
  lens600Button.addEventListener('click', () => setLens('600'));
  lens800Button.addEventListener('click', () => setLens('800'));
  lens1200Button.addEventListener('click', () => setLens('1200'));
  
  updateLensToggleButtons();
}

function setLens(lens) {
  if (currentLens === lens) return;
  
  currentLens = lens;
  showSpecialAlert(`åˆ‡æ¢åˆ°${LENS_SETTINGS[lens].name}é•œå¤´`);
  
  updateLensToggleButtons();
}

function updateLensToggleButtons() {
  const lens600Button = document.getElementById('lens600Toggle');
  const lens800Button = document.getElementById('lens800Toggle');
  const lens1200Button = document.getElementById('lens1200Toggle');
  
  lens600Button.classList.toggle('active', currentLens === '600');
  lens800Button.classList.toggle('active', currentLens === '800');
  lens1200Button.classList.toggle('active', currentLens === '1200');
}

function getViewfinderSize() {
    const lensMultiplier = LENS_SETTINGS[currentLens].multiplier;
    // è¿”å›æ¸¸æˆé€»è¾‘åæ ‡ç³»ä¸­çš„å–æ™¯å™¨å°ºå¯¸
    return {
        width: viewfinderBaseWidth * lensMultiplier,
        height: viewfinderBaseHeight * lensMultiplier
    };
}

function initFixedLeaves() {
  fixedLeaves = [];
  
  treePositions.forEach(tree => {
    for (let i = 0; i < 30; i++) {
      const leafX = tree.x + Math.random() * tree.width;
      const leafY = tree.y + Math.random() * tree.height * 0.8;
      const leafSize = 3 + Math.random() * 5;
      const leafType = Math.floor(Math.random() * 3);
      const leafColor = leafType === 0 ? '#228B22' : leafType === 1 ? '#2E8B57' : '#32CD32';
      
      fixedLeaves.push({
        treeIndex: treePositions.indexOf(tree),
        x: leafX,
        y: leafY,
        size: leafSize,
        color: leafColor,
        type: leafType,
        rotation: Math.random() * Math.PI * 2,
        offsetX: (Math.random() - 0.5) * 2,
        offsetY: (Math.random() - 0.5) * 2
      });
    }
  });
}

function initWallAndHole() {
  const wallWidth = 80;
  const wallHeight = 200;
  const wallX = GAME_WIDTH - wallWidth - 10;
  const wallY = GAME_HEIGHT - wallHeight;
  
  wall = {
    x: wallX,
    y: wallY,
    width: wallWidth,
    height: wallHeight,
    color: '#505050'
  };
  
  const sparrowSize = 20 * BIRD_TYPES.SPARROW.size;
  const holeDiameter = sparrowSize * 2;
  const holeX = wallX + wallWidth / 2;
  const holeY = wallY + wallHeight * 0.3;
  
  hole = {
    x: holeX,
    y: holeY,
    diameter: holeDiameter
  };
}

function initModeToggleButtons() {
  const dayModeButton = document.getElementById('dayModeToggle');
  const normalModeButton = document.getElementById('normalModeToggle');
  const nightModeButton = document.getElementById('nightModeToggle');
  
  dayModeButton.addEventListener('click', () => setGameMode('day'));
  normalModeButton.addEventListener('click', () => setGameMode('normal'));
  nightModeButton.addEventListener('click', () => setGameMode('night'));
  
  updateModeToggleButtons();
}

function easeInOutQuad(t) {
  return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
}

function setGameMode(mode) {
  if (gameMode === mode) return;
  const oldMode = gameMode;
  gameMode = mode;
    // é‡ç½®ç¯ç«çŠ¶æ€
    isCampfireExtinguished = false;
    isNightAccelerated = false;
        // é‡ç½®è¥åœ°çŠ¶æ€
        resetCampsite();
  
  if (mode === 'day') {
    if (oldMode === 'normal') {
      normalModeTimeState = {
        isDaytime: isDaytime,
        dayNightTimer: dayNightTimer,
        moonPhaseTimer: moonPhaseTimer
      };
    }
    
    isDaytime = true;
    dayNightTimer = dayModeTimeState;
    
    showSpecialAlert("åˆ‡æ¢åˆ°æ°¸ä¹…æ—¥é—´æ¨¡å¼");
    
    for (let i = birds.length - 1; i >= 0; i--) {
      if (birds[i].isOwl || birds[i].isBat) {
        birds.splice(i, 1);
      }
    }
    
    if (littleOwl) {
      birds.splice(birds.indexOf(littleOwl), 1);
      littleOwl = null;
    }
    
    nightObjects = [];
  } else if (mode === 'night') {
    if (oldMode === 'normal') {
      normalModeTimeState = {
        isDaytime: isDaytime,
        dayNightTimer: dayNightTimer,
        moonPhaseTimer: moonPhaseTimer
      };
    }
    
    isDaytime = false;
    dayNightTimer = nightModeTimeState;
    moonPhaseTimer = nightModeMoonPhaseTimer || Math.random() * MOON_PHASE_CYCLE;
    
    showSpecialAlert("åˆ‡æ¢åˆ°æ°¸ä¹…å¤œé—´æ¨¡å¼");
    
    for (let i = birds.length - 1; i >= 0; i--) {
      if (!birds[i].isOwl && !birds[i].isBat && birds[i].name !== "å°é¸®" && birds[i].name !== "å¤œé¹­") {
        birds.splice(i, 1);
      }
    }
    
    nightObjects = [];
  } else if (mode === 'normal') {
    if (oldMode === 'day') {
      dayModeTimeState = dayNightTimer;
      isDaytime = normalModeTimeState.isDaytime;
      dayNightTimer = normalModeTimeState.dayNightTimer;
      moonPhaseTimer = normalModeTimeState.moonPhaseTimer;
    } else if (oldMode === 'night') {
      nightModeTimeState = dayNightTimer;
      nightModeMoonPhaseTimer = moonPhaseTimer;
      isDaytime = normalModeTimeState.isDaytime;
      dayNightTimer = normalModeTimeState.dayNightTimer;
      moonPhaseTimer = normalModeTimeState.moonPhaseTimer;
    } else {
      if (normalModeTimeState) {
        isDaytime = normalModeTimeState.isDaytime;
        dayNightTimer = normalModeTimeState.dayNightTimer;
        moonPhaseTimer = normalModeTimeState.moonPhaseTimer;
      } else {
        isDaytime = true;
        dayNightTimer = 0;
        moonPhaseTimer = 0;
      }
    }
    
    showSpecialAlert("åˆ‡æ¢åˆ°æ™®é€šæ¨¡å¼");
    
    if (oldMode === 'night') {
      for (let i = birds.length - 1; i >= 0; i--) {
        if (birds[i].isOwl || birds[i].isBat) {
          birds.splice(i, 1);
        }
      }
      nightObjects = [];
    }
  }
        updateModeToggleButtons();
        updateCampsiteVisibility();
        updateTimeIndicator();
}

function updateModeToggleButtons() {
  const dayModeButton = document.getElementById('dayModeToggle');
  const normalModeButton = document.getElementById('normalModeToggle');
  const nightModeButton = document.getElementById('nightModeToggle');
  
  dayModeButton.classList.toggle('active', gameMode === 'day');
  normalModeButton.classList.toggle('active', gameMode === 'normal');
  nightModeButton.classList.toggle('active', gameMode === 'night');
}

function updateTimeIndicator() {
  const timeIndicator = document.getElementById('timeIndicator');
  const totalSeconds = Math.floor(gameTime / 1000);
  const minutes = Math.floor(totalSeconds / 60);
  const seconds = totalSeconds % 60;
  
  if (gameMode === 'normal') {
    const remainingTime = DAY_NIGHT_CYCLE_DURATION - dayNightTimer;
    const remainingMinutes = Math.floor(remainingTime / 60000);
    const remainingSeconds = Math.floor((remainingTime % 60000) / 1000);
    
let timeText = `${isDaytime ? "ç™½å¤©" : "é»‘å¤œ"} ${remainingMinutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')} / 15:00`;
            
            // æ·»åŠ åŠ é€ŸçŠ¶æ€æç¤º
            if (isNightAccelerated && !isDaytime) {
                timeText += " â© (åŠ é€Ÿä¸­)";
            }
            
            timeText += ` | ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            timeIndicator.textContent = timeText;
        } else if (gameMode === 'day') {
            const timeText = `æ°¸ä¹…æ—¥é—´ | ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            timeIndicator.textContent = timeText;
        } else if (gameMode === 'night') {
            const timeText = `æ°¸ä¹…å¤œé—´ | ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            timeIndicator.textContent = timeText;
        }
    }

// è§‚é¸Ÿè®°å½•æˆªå›¾å‡½æ•°
function captureBirdingRecord() {
    console.log("å¼€å§‹æˆªå›¾è®°å½•...");
    
    if (!currentBirdingRecord) {
        console.warn("æ²¡æœ‰å½“å‰è§‚é¸Ÿè®°å½•");
        showSpecialAlert("è¯·å…ˆæ‰“å¼€è§‚é¸Ÿè®°å½•ï¼");
        return;
    }
    
    const screenshotButton = document.getElementById('screenshotButton');
    screenshotButton.disabled = true;
    screenshotButton.style.opacity = '0.5';
    screenshotButton.textContent = "ç”Ÿæˆä¸­...";
    
// ä¸´æ—¶ç¦ç”¨æ»‘åŠ¨åŠŸèƒ½
  const originalNavigating = isNavigatingRecords;
  isNavigatingRecords = true;
  
  try {
    if (!gamePaused) {
      pauseGame();
    }
        
        const SCREENSHOT_WIDTH = 300;
        const lineHeight = 22;
        const record = currentBirdingRecord;
        const speciesCount = record.observedSpecies.length;
        
        // ç²¾ç¡®è®¡ç®—æ‰€éœ€é«˜åº¦
        const titleHeight = 50;
        const recordInfoHeight = 5 * lineHeight;
        const headerMargin = 35;
        const footerHeight = 30;
        const speciesListHeight = speciesCount * lineHeight;
        
        // åŠ¨æ€è®¡ç®—æ€»é«˜åº¦ï¼ˆæ”¯æŒå¤šåˆ—å¸ƒå±€ï¼‰
        const baseHeight = titleHeight + recordInfoHeight + headerMargin + footerHeight + 20;
        const dynamicHeight = baseHeight + Math.min(speciesListHeight, 800); // é™åˆ¶åˆ—è¡¨éƒ¨åˆ†é«˜åº¦
        
        // è®¾ç½®åˆç†çš„æœ€å¤§æœ€å°é«˜åº¦
        const MAX_SCREENSHOT_HEIGHT = 2000;
        const MIN_SCREENSHOT_HEIGHT = 650;
        
        const SCREENSHOT_HEIGHT = Math.max(MIN_SCREENSHOT_HEIGHT, 
                                          Math.min(MAX_SCREENSHOT_HEIGHT, dynamicHeight));
        
        screenshotCanvas.width = SCREENSHOT_WIDTH;
        screenshotCanvas.height = SCREENSHOT_HEIGHT;
        
        screenshotCtx.clearRect(0, 0, SCREENSHOT_WIDTH, SCREENSHOT_HEIGHT);
        
        // ç»˜åˆ¶èƒŒæ™¯
        const gradient = screenshotCtx.createLinearGradient(0, 0, 0, SCREENSHOT_HEIGHT);
        gradient.addColorStop(0, '#16213e');
        gradient.addColorStop(1, '#0f3460');
        screenshotCtx.fillStyle = gradient;
        screenshotCtx.fillRect(0, 0, SCREENSHOT_WIDTH, SCREENSHOT_HEIGHT);
        
        // ç»˜åˆ¶æ ‡é¢˜
        screenshotCtx.fillStyle = '#FFD700';
        screenshotCtx.font = 'bold 24px "AlimamaShuHeiTi-Bold.ttf", Arial, sans-serif';
        screenshotCtx.textAlign = 'center';
        screenshotCtx.fillText('è§‚é¸Ÿè®°å½•', SCREENSHOT_WIDTH / 2, 40);
        
        screenshotCtx.strokeStyle = '#87CEEB';
        screenshotCtx.lineWidth = 2;
        screenshotCtx.beginPath();
        screenshotCtx.moveTo(50, 55);
        screenshotCtx.lineTo(SCREENSHOT_WIDTH - 50, 55);
        screenshotCtx.stroke();
        
        // ç»˜åˆ¶å†…å®¹
        const startY = 85;
        const availableHeight = SCREENSHOT_HEIGHT - startY - footerHeight - 10;
        drawRecordInfoSingleColumn(record, startY, lineHeight, SCREENSHOT_WIDTH - 40, availableHeight);
        
        // ç»˜åˆ¶é¡µè„š
        screenshotCtx.fillStyle = '#FFD700';
        screenshotCtx.font = 'bold 14px "AlimamaShuHeiTi-Bold.ttf", Arial, sans-serif';
        screenshotCtx.textAlign = 'center';
        const bottomText = 'https://goseplover.github.io/12000h';
        screenshotCtx.fillText(bottomText, SCREENSHOT_WIDTH / 2, SCREENSHOT_HEIGHT - 15);
        
        currentScreenshotDataURL = screenshotCanvas.toDataURL('image/png');
    console.log("æˆªå›¾ç”Ÿæˆå®Œæˆï¼Œæ•°æ®URLé•¿åº¦:", currentScreenshotDataURL.length);
    
    setTimeout(() => {
      showScreenshotPreview();
      screenshotButton.disabled = false;
      screenshotButton.style.opacity = '1';
      screenshotButton.textContent = "ğŸ“¸ æˆªå›¾è®°å½•";
      isNavigatingRecords = originalNavigating; // æ¢å¤æ»‘åŠ¨åŠŸèƒ½
    }, 100);
    
  } catch (error) {
    console.error("æˆªå›¾ç»˜åˆ¶è¿‡ç¨‹ä¸­å‡ºé”™:", error);
    showSpecialAlert("æˆªå›¾ç»˜åˆ¶å¤±è´¥");
    screenshotButton.disabled = false;
    screenshotButton.style.opacity = '1';
    screenshotButton.textContent = "ğŸ“¸ æˆªå›¾è®°å½•";
    isNavigatingRecords = originalNavigating; // æ¢å¤æ»‘åŠ¨åŠŸèƒ½
    resumeGame();
  }
}

function drawRecordInfoSingleColumn(record, startY, lineHeight, columnWidth, maxHeight) {
  let y = startY;
  const x = 20;
  const speciesListStartY = y;
  
  screenshotCtx.fillStyle = '#FFFFFF';
  screenshotCtx.font = '16px "AlimamaShuHeiTi-Bold.ttf", Arial, sans-serif';
  screenshotCtx.textAlign = 'left';
  
  screenshotCtx.fillText(`è®°å½•ç¼–å·: #${record.id}`, x, y);
  y += lineHeight;
  
  const durationText = `è§‚é¸Ÿæ—¶é•¿: ${Math.floor(record.birdingModeDuration / 60000)}åˆ†${Math.floor((record.birdingModeDuration % 60000) / 1000)}ç§’`;
  screenshotCtx.fillText(durationText, x, y);
  y += lineHeight;
  
  screenshotCtx.fillText(`æ—¶é—´: ${record.startedAtDaytime ? "ç™½å¤©" : "é»‘å¤œ"} â†’ ${record.endedAtDaytime ? "ç™½å¤©" : "é»‘å¤œ"}`, x, y);
  y += lineHeight;
  
  screenshotCtx.fillText(`è§‚å¯Ÿé¸Ÿç§: ${record.totalObservedSpecies} ç§`, x, y);
  y += lineHeight;

  screenshotCtx.fillText(`æ‹æ‘„é¸Ÿç§: ${record.capturedInSession || 0} ç§`, x, y);
  y += lineHeight;
  
  if (record.rarestBird) {
    screenshotCtx.fillStyle = '#FFD700';
    screenshotCtx.fillText(`æœ€ç¨€æœ‰: ${record.rarestBird}`, x, y);
    screenshotCtx.fillStyle = '#FFFFFF';
    y += lineHeight;
  }
  
  y += lineHeight;
  
  screenshotCtx.fillStyle = '#87CEEB';
  screenshotCtx.fillText('è§‚å¯Ÿåˆ°çš„é¸Ÿç§:', x, y);
  y += lineHeight;
  
  screenshotCtx.strokeStyle = '#87CEEB';
  screenshotCtx.lineWidth = 1;
  screenshotCtx.beginPath();
  screenshotCtx.moveTo(x, y - 5);
  screenshotCtx.lineTo(x + 120, y - 5);
  screenshotCtx.stroke();
  
  y += 5;
  
  const sortedSpecies = [...record.observedSpecies].sort();
  
  // æ¯åˆ—æ˜¾ç¤º15ä¸ªé¸Ÿç§
  const itemsPerColumn = 15;
  const columnCount = Math.ceil(sortedSpecies.length / itemsPerColumn);
  
  // è®¡ç®—åˆ—å®½ï¼ˆå‡è®¾æœ‰3åˆ—ç©ºé—´ï¼Œå®é™…æ ¹æ®åˆ—æ•°è°ƒæ•´ï¼‰
  const maxColumns = 3; // æœ€å¤§3åˆ—
  const actualColumnCount = Math.min(columnCount, maxColumns);
  const actualColumnWidth = (screenshotCanvas.width - 40) / actualColumnCount;
  
  // æŒ‰åˆ—ä¼˜å…ˆæ’åˆ—ï¼ˆå…ˆç«–æ’ï¼Œå¡«æ»¡ä¸€åˆ—åå†æ¢ä¸‹ä¸€åˆ—ï¼‰
  for (let col = 0; col < actualColumnCount; col++) {
    const columnX = x + col * actualColumnWidth;
    let columnY = y;
    
    for (let row = 0; row < itemsPerColumn; row++) {
      const index = col * itemsPerColumn + row; // åˆ—ä¼˜å…ˆç´¢å¼•
      
      if (index >= sortedSpecies.length) {
        break;
      }
      
      const birdName = sortedSpecies[index];
      const birdKey = Object.keys(BIRD_TYPES).find(key => BIRD_TYPES[key].name === birdName);
      const isRare = birdKey && BIRD_TYPES[birdKey].probability < 0.02;
      const isRarest = birdName === record.rarestBird;
      
      if (isRarest) {
        screenshotCtx.fillStyle = '#FFD700';
        screenshotCtx.font = 'bold 14px "AlimamaShuHeiTi-Bold.ttf"';
        screenshotCtx.fillText(`${index + 1}. ${birdName} â˜…`, columnX, columnY);
        screenshotCtx.font = '14px "AlimamaShuHeiTi-Bold.ttf"';
      } else if (isRare) {
        screenshotCtx.fillStyle = '#FFA500';
        screenshotCtx.fillText(`${index + 1}. ${birdName} (ç¨€æœ‰)`, columnX, columnY);
      } else {
        screenshotCtx.fillStyle = '#FFFFFF';
        screenshotCtx.fillText(`${index + 1}. ${birdName}`, columnX, columnY);
      }
      
      columnY += lineHeight;
    }
  }
  
  // å¦‚æœé¸Ÿç§å¤ªå¤šï¼Œè¶…è¿‡æ˜¾ç¤ºç©ºé—´ï¼Œæ·»åŠ æç¤º
  if (sortedSpecies.length > itemsPerColumn * actualColumnCount) {
    const remainingCount = sortedSpecies.length - (itemsPerColumn * actualColumnCount);
    screenshotCtx.fillStyle = '#FFA500';
    screenshotCtx.font = '12px "AlimamaShuHeiTi-Bold.ttf"';
    screenshotCtx.fillText(`... è¿˜æœ‰ ${remainingCount} ç§æœªæ˜¾ç¤º`, x, y + itemsPerColumn * lineHeight + 10);
  }
  
  return y;
}

// æ˜¾ç¤ºæˆªå›¾é¢„è§ˆ
function showScreenshotPreview() {
    console.log("æ˜¾ç¤ºæˆªå›¾é¢„è§ˆ...");
    
    if (!currentScreenshotDataURL) {
        console.error("æ²¡æœ‰å¯ç”¨çš„æˆªå›¾æ•°æ®");
        showSpecialAlert("æ²¡æœ‰å¯ç”¨çš„æˆªå›¾æ•°æ®");
        return;
    }

    const previewModal = document.getElementById('screenshotPreviewModal');
    const previewImage = document.getElementById('screenshotPreviewImage');
    
    if (!previewModal || !previewImage) {
        console.error("é¢„è§ˆå…ƒç´ æœªæ‰¾åˆ°");
        showSpecialAlert("é¢„è§ˆå…ƒç´ æœªæ‰¾åˆ°");
        return;
    }

    // è®¾ç½®å›¾ç‰‡æº
    previewImage.src = currentScreenshotDataURL;
    
    // æ˜¾ç¤ºæ¨¡æ€æ¡†
    previewModal.style.display = 'flex';
    previewModal.style.zIndex = '500';
    
    console.log("é¢„è§ˆæ¨¡æ€æ¡†å·²æ˜¾ç¤º");
    
    // æ·»åŠ åŠ è½½å®Œæˆå’ŒåŠ è½½é”™è¯¯çš„å¤„ç†
    previewImage.onload = function() {
        console.log("é¢„è§ˆå›¾ç‰‡åŠ è½½æˆåŠŸ");
    };
    
    previewImage.onerror = function() {
        console.error("é¢„è§ˆå›¾ç‰‡åŠ è½½å¤±è´¥");
        showSpecialAlert("é¢„è§ˆå›¾ç‰‡åŠ è½½å¤±è´¥");
        previewModal.style.display = 'none';
    };
}

function closeScreenshotPreview() {
    const previewModal = document.getElementById('screenshotPreviewModal');
    previewModal.style.display = 'none';
    
    // æ¢å¤æ¸¸æˆ
    resumeGame();
}

function saveScreenshot() {
    console.log("å°è¯•ä¿å­˜æˆªå›¾...");
    
    if (!currentScreenshotDataURL) {
        console.error("æ²¡æœ‰å¯ç”¨çš„æˆªå›¾æ•°æ®");
        showSpecialAlert("æ²¡æœ‰å¯ç”¨çš„æˆªå›¾æ•°æ®");
        return;
    }
    
    try {
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const fileName = `è§‚é¸Ÿè®°å½•_${timestamp}.png`;
        
        const downloadLink = document.createElement('a');
        downloadLink.href = currentScreenshotDataURL;
        downloadLink.download = fileName;
        downloadLink.style.display = 'none';
        
        document.body.appendChild(downloadLink);
        downloadLink.click();
        
        setTimeout(() => {
            document.body.removeChild(downloadLink);
        }, 100);
        
        console.log("æˆªå›¾ä¿å­˜æˆåŠŸ");
        showSpecialAlert("æˆªå›¾å·²ä¿å­˜ï¼");
        closeScreenshotPreview();
        
    } catch (error) {
        console.error("ä¿å­˜æˆªå›¾æ—¶å‡ºé”™:", error);
        showSpecialAlert("ä¿å­˜å¤±è´¥: " + error.message);
    }
}

// åœ¨å±å¹•æ–¹å‘å˜åŒ–æ—¶ä¿å­˜å’Œæ¢å¤ç¯ç«çŠ¶æ€
window.addEventListener('orientationchange', function() {
    // ä¿å­˜å½“å‰ç¯ç«çŠ¶æ€
    const wasExtinguished = isCampfireExtinguished;
    const wasAccelerated = isNightAccelerated;
    
    // çŸ­æš‚å»¶è¿Ÿåæ¢å¤çŠ¶æ€
    setTimeout(function() {
        // é‡æ–°è·å–è¥åœ°å…ƒç´ 
        const campsite = document.getElementById('campsite');
        const flame = document.getElementById('campfire-flame');
        const hint = document.querySelector('#campsite > div > div:last-child');
        
        if (campsite && flame && hint) {
            // æ ¹æ®ä¿å­˜çš„çŠ¶æ€æ¢å¤ç¯ç«
            if (wasExtinguished) {
                // å¦‚æœæ˜¯ç†„ç­çŠ¶æ€
                flame.style.display = 'none';
                flame.style.opacity = '0';
                hint.textContent = "ç¯ç«å·²ç†„ç­";
                hint.style.color = "#87CEEB";
                
                // ç¡®ä¿åŠ é€ŸçŠ¶æ€ä¹Ÿæ¢å¤
                if (wasAccelerated) {
                    isNightAccelerated = true;
                }
            } else {
                // å¦‚æœæ˜¯ç‚¹ç‡ƒçŠ¶æ€
                flame.style.display = 'block';
                flame.style.opacity = '1';
                hint.textContent = "ç‚¹å‡»ç†„ç­ç¯ç«";
                hint.style.color = "#FFD700";
            }
            
            // æ›´æ–°è¥åœ°å¯è§æ€§
            updateCampsiteVisibility();
        }
    }, 300); // 300mså»¶è¿Ÿç¡®ä¿DOMå·²ç»æ›´æ–°
});

// åŒæ ·å¤„ç†çª—å£å¤§å°å˜åŒ–
window.addEventListener('resize', function() {
    // é˜²æŠ–å¤„ç†ï¼Œé¿å…é¢‘ç¹è§¦å‘
    clearTimeout(window.resizeTimer);
    window.resizeTimer = setTimeout(function() {
        restoreCampfireState();
    }, 250);
});

// æ¢å¤ç¯ç«çŠ¶æ€çš„å‡½æ•°
function restoreCampfireState() {
    const flame = document.getElementById('campfire-flame');
    const hint = document.querySelector('#campsite > div > div:last-child');
    
    if (flame && hint) {
        if (isCampfireExtinguished) {
            flame.style.display = 'none';
            flame.style.opacity = '0';
            hint.textContent = "ç¯ç«å·²ç†„ç­";
            hint.style.color = "#87CEEB";
        } else {
            flame.style.display = 'block';
            flame.style.opacity = '1';
            hint.textContent = "ç‚¹å‡»ç†„ç­ç¯ç«";
            hint.style.color = "#FFD700";
        }
    }
    
    // æ›´æ–°è¥åœ°å¯è§æ€§
    updateCampsiteVisibility();
}

// ä¿®æ”¹ handleKeyDown å‡½æ•°ï¼Œæ·»åŠ é”®ç›˜å¯¼èˆªæ”¯æŒ
function handleKeyDown(e) {
    // é˜²æ­¢åœ¨è¾“å…¥æ¡†ç­‰å…ƒç´ ä¸­è§¦å‘
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
        return;
    }else if (e.key === ' ' || e.key === 'Spacebar') {
    // é˜²æ­¢ç©ºæ ¼é”®æ»šåŠ¨é¡µé¢
    e.preventDefault();
    
    // åˆ‡æ¢æ–‡æœ¬æµè§ˆå™¨æ˜¾ç¤º/éšè—
    toggleTextBrowser();
    
    // è¿”å›falseé˜²æ­¢äº‹ä»¶å†’æ³¡
    return false;
}
    if (e.key === 'Escape') {
        closeAlbum();
        closeBirdingRecord();
        closeHelpModal();
    } else if (e.key === 'c' || e.key === 'C') {
        generateBlackWingedKite(false);
    } else if (e.key === 'x' || e.key === 'X') {
        generateComet(false);
    } else if (e.key === 'd' || e.key === 'D') {
        generateGoldcrest(false);
    } else if (e.key === '1') {
        generateTwelveThousandPlover(false);
    } else if (e.key === 'l' || e.key === 'L') {
        generateMeteor(false);
    } else if (e.key === 'u' || e.key === 'U') {
        generateUFO(false);
    } else if (e.key === 'q' || e.key === 'Q') {
        generateMagpie(false);
    } else if (e.key === 'k' || e.key === 'K') {
        generateKingfisher(false);
    } else if (e.key === 'r' || e.key === 'R') {
        createBirdingRecord();
    } else if (e.key === 'v' || e.key === 'V') {
        if (birdingRecords.length > 0) {
            openBirdingRecord(birdingRecords.length - 1);
        }
    } else if (e.key === 'm' || e.key === 'M') {
        toggleBirdingMode();
    } else if (e.key === '0') {
        generateRareBird();
    } else if (e.key === 'p' || e.key === 'P') {
        if (currentBirdingRecord) {
            captureBirdingRecord();
        }
    } else if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
        const modal = document.getElementById('birdingRecordModal');
        if (modal.style.display === 'block') {
            e.preventDefault();
            switchBirdingRecord(-1);
        }
    } else if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {
        const modal = document.getElementById('birdingRecordModal');
        if (modal.style.display === 'block') {
            e.preventDefault();
            switchBirdingRecord(1);
        }
}

function skipToNight() {
    // åªæœ‰åœ¨æ™®é€šæ¨¡å¼ä¸”æ˜¯ç™½å¤©æ—¶æ‰æœ‰æ•ˆ
    if (gameMode !== 'normal' || !isDaytime) {
        showSpecialAlert("åªèƒ½åœ¨æ™®é€šæ¨¡å¼çš„ç™½å¤©è·³è¿‡");
        return;
    }
    
    // ä¿å­˜å½“å‰æ—¶é—´çŠ¶æ€
    const savedTimeState = {
        gameTime: gameTime,
        dayNightTimer: dayNightTimer,
        moonPhaseTimer: moonPhaseTimer
    };
    
    // è®¡ç®—è·³è¿‡çš„æ—¶é—´
    const timeToSkip = DAY_NIGHT_CYCLE_DURATION - dayNightTimer;
    
    // ç›´æ¥åˆ‡æ¢åˆ°å¤œæ™š
    isDaytime = false;
    dayNightTimer = 0; // é‡ç½®ä¸ºå¤œæ™šå¼€å§‹
    
    // æ›´æ–°ç¯ç«çŠ¶æ€
    isCampfireExtinguished = false;
    isNightAccelerated = false;
    
    // æ¸…é™¤ç™½å¤©çš„é¸Ÿç±»ï¼ˆé™¤äº†å¤œé—´å¯ä»¥å‡ºç°çš„ï¼‰
    for (let i = birds.length - 1; i >= 0; i--) {
        const bird = birds[i];
        // ä¿ç•™å¤œé¹­ã€çŒ«å¤´é¹°ã€è™è ç­‰å¤œé—´é¸Ÿç±»
        const isNocturnal = bird.isOwl || bird.isBat || 
                           bird.name === "å°é¸®" || 
                           bird.name === "å¤œé¹­" ||
                           bird.name === "é›•é¸®" ||
                           bird.name === "çŸ­è€³é¸®";
        
        if (!isNocturnal) {
            birds.splice(i, 1);
        }
    }
    
    // æ¸…ç©ºç™½å¤©ç‰©ä½“
    nightObjects = [];
    
    // ç”Ÿæˆä¸€äº›å¤œé—´é¸Ÿç±»
    if (Math.random() < 0.3) {
        spawnNightOwls();
    }
    
    // æ˜¾ç¤ºæç¤º
    const skippedMinutes = Math.floor(timeToSkip / 60000);
    const skippedSeconds = Math.floor((timeToSkip % 60000) / 1000);
    showSpecialAlert(`è·³è¿‡äº† ${skippedMinutes}åˆ†${skippedSeconds}ç§’ï¼Œå·²åˆ‡æ¢åˆ°å¤œæ™š`);
    
    // æ›´æ–°UI
    updateModeToggleButtons();
    updateCampsiteVisibility();
    updateTimeIndicator();
    
    // æ’­æ”¾éŸ³æ•ˆï¼ˆå¯é€‰ï¼‰
    playTimeSkipSound();
    
    // è®°å½•è·³è¿‡æ“ä½œï¼ˆç”¨äºè°ƒè¯•ï¼‰
    console.log("è·³è¿‡ç™½å¤©:", {
        skippedTime: timeToSkip,
        skippedMinutes,
        skippedSeconds,
        previousTimeState: savedTimeState,
        newTimeState: {
            isDaytime: isDaytime,
            dayNightTimer: dayNightTimer
        }
    });
}

function generateBlackbird(countStats = false) {
    const blackbirdType = BIRD_TYPES.BLACKBIRD;
    if (countStats) {
        appearedBirds[blackbirdType.name]++;
        updateTextStats();
    }
    
    const fromLeft = Math.random() > 0.5;
    const startX = fromLeft ? -50 : GAME_WIDTH + 50;
    const startY = Math.random() * (GAME_HEIGHT * 0.6) + GAME_HEIGHT * 0.2;
    
    const bird = {
        type: blackbirdType,
        name: blackbirdType.name,
        x: startX,
        y: startY,
        size: blackbirdType.size,
        speed: (1 + Math.random()) * 1.5,
        direction: fromLeft ? 1 : -1,
        state: 'flying',
        stateTime: 0,
        whiteEyeRing: false,
        yellowEyeRing: true,
        eatFruits: true,
        eatProbability: 0.12,
        eatDuration: 1600,
        originalSize: 1.3,
        poopInterval: 3000,
        poopProbability: 0.33,
        poopColor: "#FFFFFF",
        lastPoopTime: 0,
        noStats: !countStats,
        isNight: !isDaytime
    };
    
    birds.push(bird);
}

function generateTwelveThousandPlover(countStats = false) {
    const ploverType = BIRD_TYPES.TWELVE_THOUSAND_PLOVER;
    if (countStats) {
        // ä¸ç»Ÿè®¡
    }
    
    const fromLeft = Math.random() > 0.5;
    const birdCount = getRandomGroupSize(ploverType);
    const groupId = nextGroupId++;
    birdGroupInfo[groupId] = { direction: fromLeft ? 1 : -1, birds: [] };
    
    for (let i = 0; i < birdCount; i++) {
        let startX, startY;
        let behavior = ploverType.behavior;
        let stayTime = ploverType.stayTime || 10;
        
        if (Math.random() < ploverType.landOnReedsChance) {
            behavior = "landOnReeds";
            stayTime = ploverType.landOnReedsTime;
        }
        
        startX = fromLeft ? -50 : GAME_WIDTH + 50;
        startY = Math.random() * (GAME_HEIGHT * 0.6) + GAME_HEIGHT * 0.2;
        
        let baseSpeed = (1.6 + Math.random() * 0.8);
        const speedMultiplier = ploverType.speedMultiplier || 1;
        const finalSpeed = baseSpeed * speedMultiplier;
        
        const bird = createCommonBird(ploverType, startX, startY, fromLeft, behavior, stayTime, finalSpeed, groupId);
        bird.noStats = true;
        bird.yellowEyeRing = true;
        
        if (behavior === "landOnReeds" && reedZone) {
            bird.reedTargetX = reedZone.x + Math.random() * reedZone.width;
            bird.reedTargetY = reedZone.y + reedZone.height - 3;
            bird.state = 'landingOnReeds';
            bird.groundDirection = Math.random() > 0.5 ? 1 : -1;
            bird.isLandingOnReeds = true;
        }
        
        birds.push(bird);
        birdGroupInfo[groupId].birds.push(bird);
    }
}

function generateGoldcrest(countStats = true) {
    const goldcrestType = BIRD_TYPES.GOLDCREST;
    if (countStats) {
        appearedBirds[goldcrestType.name]++;
        updateTextStats();
    }
    
    const targetTree = treePositions[Math.floor(Math.random() * treePositions.length)];
    const x = targetTree.x + targetTree.width * 0.4 + Math.random() * targetTree.width * 0.2;
    const y = targetTree.y + targetTree.height * 0.2 + Math.random() * targetTree.height * 0.3;
    
    const bird = {
        type: goldcrestType,
        name: goldcrestType.name,
        x: x,
        y: y,
        size: goldcrestType.size,
        speed: 0,
        direction: targetTree.side === 'left' ? 1 : -1,
        state: 'perching',
        stateTime: 0,
        stayTime: 5,
        riceBallAppearance: true,
        halfBeakFlying: true,
        halfBeak: true,
        noStats: !countStats,
        isNight: !isDaytime
    };
    
    birds.push(bird);
}

function generateLittleGrebe(countStats = false) {
    const littleGrebeType = BIRD_TYPES.LITTLEGREBE;
    if (countStats) {
        appearedBirds[littleGrebeType.name]++;
        updateTextStats();
    }
    
    const fromLeft = Math.random() > 0.5;
    const birdCount = getRandomGroupSize(littleGrebeType);
    const groupId = nextGroupId++;
    birdGroupInfo[groupId] = { direction: fromLeft ? 1 : -1, birds: [] };
    
    for (let i = 0; i < birdCount; i++) {
        const startX = fromLeft ? -50 : GAME_WIDTH + 50;
        const startY = reedZone.y + reedZone.height * 0.5 + Math.random() * reedZone.height * 0.3;
        
        let baseSpeed = (1.6 + Math.random() * 0.8);
        
        const bird = {
            type: littleGrebeType,
            name: littleGrebeType.name,
            x: startX,
            y: startY,
            size: littleGrebeType.size,
            speed: baseSpeed,
            direction: fromLeft ? 1 : -1,
            state: 'flying',
            stateTime: 0,
            circlingTime: 0,
            hoveringTime: 0,
            circlingRadius: 100 + Math.random() * 50,
            circlingAngle: Math.random() * Math.PI * 2,
            circlingCenterX: 0,
            circlingCenterY: 0,
            actualBehavior: "flyToReedsAndStay",
            stayTime: littleGrebeType.stayTime,
            originalBehavior: littleGrebeType.behavior,
            groupId: groupId,
            targetX: fromLeft ? GAME_WIDTH + 100 : -100,
            reedStayTime: littleGrebeType.reedStayTime || 20000,
            reedMoveSpeed: littleGrebeType.reedMoveSpeed || 0.6,
            reedTargetX: 0,
            reedTargetY: 0,
            whiteEyeRing: false,
            longBlackTail: true,
            fifthBeak: true,
            noStats: !countStats,
            isNight: !isDaytime
        };
        
        birds.push(bird);
        birdGroupInfo[groupId].birds.push(bird);
    }
}

function generateMeteor(countStats = false, summoned = false, intersectionPoint = null) {
    const isNightMode = gameMode === 'night' || (gameMode === 'normal' && !isDaytime);
    if (!isNightMode) {
        return;
    }
    
    const meteorType = NIGHT_OBJECTS.METEOR;
    
    let startX, startY, angle;
    
    if (!summoned) {
        const intersectionX = GAME_WIDTH * 0.5 + (Math.random() - 0.5) * GAME_WIDTH * 0.5;
        const intersectionY = -500 - Math.random() * 500;
        
        startX = intersectionX;
        startY = intersectionY;
        
        const targetX = -100 + Math.random() * (GAME_WIDTH + 200);
        const targetY = -100 + Math.random() * (GAME_HEIGHT * 0.55 + 100);
        angle = Math.atan2(targetY - startY, targetX - startX);
        
        const meteor = {
            type: meteorType,
            name: meteorType.name,
            x: startX,
            y: startY,
            size: meteorType.size,
            speed: meteorType.speed,
            angle: angle,
            state: 'flying',
            createdAt: gameTime,
            duration: meteorType.duration,
            color: meteorType.color,
            trailLength: meteorType.trailLength,
            trailColor: meteorType.trailColor,
            summonProbability: meteorType.summonProbability,
            hasSummoned: false,
            summoned: summoned,
            isNightObject: true,
            intersectionPoint: { x: intersectionX, y: intersectionY },
            targetPoint: { x: targetX, y: targetY }
        };
        
        nightObjects.push(meteor);
        return meteor;
    } else {
        if (!intersectionPoint) {
            intersectionPoint = { x: -1800 + Math.random() * (GAME_WIDTH + 3600), y: -1800 + Math.random() * (GAME_HEIGHT * 0.55 + 1800) };
        }
        
        startX = intersectionPoint.x;
        startY = intersectionPoint.y;
        
        const targetX = -100 + Math.random() * (GAME_WIDTH + 200);
        const targetY = -100 + Math.random() * (GAME_HEIGHT * 0.55 + 100);
        angle = Math.atan2(targetY - startY, targetX - startX);
        
        const meteor = {
            type: meteorType,
            name: meteorType.name,
            x: startX,
            y: startY,
            size: meteorType.size,
            speed: meteorType.speed,
            angle: angle,
            state: 'flying',
            createdAt: gameTime,
            duration: meteorType.duration,
            color: meteorType.color,
            trailLength: meteorType.trailLength,
            trailColor: meteorType.trailColor,
            summonProbability: meteorType.summonProbability,
            hasSummoned: false,
            summoned: summoned,
            isNightObject: true,
            intersectionPoint: intersectionPoint,
            targetPoint: { x: targetX, y: targetY }
        };
        
        nightObjects.push(meteor);
        return meteor;
    }
}

function generateComet(countStats = false) {
    const isNightMode = gameMode === 'night' || (gameMode === 'normal' && !isDaytime);
    if (!isNightMode) {
        return;
    }
    
    const cometType = NIGHT_OBJECTS.COMET;
    const startX = GAME_WIDTH / 2;
    const startY = GAME_HEIGHT * 0.55 - 100;
    
    const comet = {
        type: cometType,
        name: cometType.name,
        x: startX,
        y: startY,
        size: cometType.size * (1/3),
        speed: cometType.speed,
        state: 'flying',
        createdAt: gameTime,
        duration: cometType.duration,
        color: cometType.color,
        tailLength: cometType.tailLength,
        tailColor: cometType.tailColor,
        angle: cometType.angle,
        isNightObject: true
    };
    
    nightObjects.push(comet);
}

function generateUFO(countStats = false) {
    const isNightMode = gameMode === 'night' || (gameMode === 'normal' && !isDaytime);
    if (!isNightMode) {
        return;
    }
    
    const ufoType = NIGHT_OBJECTS.UFO;
    const startX = GAME_WIDTH + 50;
    const startY = Math.random() * (GAME_HEIGHT * 0.5) + GAME_HEIGHT * 0.2;
    
    const ufo = {
        type: ufoType,
        name: ufoType.name,
        x: startX,
        y: startY,
        size: ufoType.size,
        speed: ufoType.speed,
        state: 'flying',
        direction: -1,
        createdAt: gameTime,
        duration: ufoType.duration,
        color: ufoType.color,
        beamLength: ufoType.beamLength,
        beamColor: ufoType.beamColor,
        beamActive: Math.random() > 0.5,
        beamPhase: Math.random() * Math.PI * 2,
        isNightObject: true
    };
    
    nightObjects.push(ufo);
}

function showNightObjectAlert(text) {
    // å®ç°å¤œæ‹ç‰©ä½“æç¤º
}

function initTrees() {
    treePositions.push({
        x: 0,
        y: GAME_HEIGHT * 0.3,
        width: GAME_WIDTH * 0.25,
        height: GAME_HEIGHT * 0.7,
        side: 'left',
        fruits: []
    });
    
    const wallWidth = 80;
    const wallMargin = 10;
    const rightTreeWidth = GAME_WIDTH * 0.25;
    
    treePositions.push({
        x: GAME_WIDTH - wallWidth - wallMargin - rightTreeWidth - 20,
        y: GAME_HEIGHT * 0.3,
        width: rightTreeWidth,
        height: GAME_HEIGHT * 0.7,
        side: 'right',
        fruits: []
    });
}

function resizeCanvas() {
    const container = document.getElementById('gameContainer');
    const containerWidth = container.clientWidth;
    const containerHeight = container.clientHeight;
    
    // å§‹ç»ˆä¿æŒæ¸¸æˆé€»è¾‘å°ºå¯¸ä¸å˜
    canvas.width = GAME_WIDTH;
    canvas.height = GAME_HEIGHT;
    poopCanvas.width = GAME_WIDTH;
    poopCanvas.height = GAME_HEIGHT;
    
    // è®¡ç®—ç¼©æ”¾æ¯”ä¾‹ä»¥é€‚åº”å®¹å™¨
    const containerAspect = containerWidth / containerHeight;
    const gameAspect = GAME_WIDTH / GAME_HEIGHT;
    
    let displayWidth, displayHeight;
    
    if (containerAspect > gameAspect) {
        // å®¹å™¨æ›´å®½ï¼ŒæŒ‰é«˜åº¦é€‚é…
        displayHeight = containerHeight;
        displayWidth = displayHeight * gameAspect;
    } else {
        // å®¹å™¨æ›´é«˜æˆ–æ¯”ä¾‹ç›¸åŒï¼ŒæŒ‰å®½åº¦é€‚é…
        displayWidth = containerWidth;
        displayHeight = displayWidth / gameAspect;
    }
    
    // è®¾ç½®ç”»å¸ƒæ˜¾ç¤ºå°ºå¯¸
    canvas.style.width = displayWidth + 'px';
    canvas.style.height = displayHeight + 'px';
    poopCanvas.style.width = displayWidth + 'px';
    poopCanvas.style.height = displayHeight + 'px';
    
    // å±…ä¸­æ˜¾ç¤º
    canvas.style.position = 'absolute';
    canvas.style.left = (containerWidth - displayWidth) / 2 + 'px';
    canvas.style.top = (containerHeight - displayHeight) / 2 + 'px';
    
    poopCanvas.style.position = 'absolute';
    poopCanvas.style.left = canvas.style.left;
    poopCanvas.style.top = canvas.style.top;
    
    console.log("ç”»å¸ƒé‡ç½®:", {
        container: `${containerWidth}x${containerHeight}`,
        display: `${displayWidth}x${displayHeight}`,
        gameLogic: `${GAME_WIDTH}x${GAME_HEIGHT}`,
        aspectRatio: gameAspect.toFixed(2)
    });
    
    // æ›´æ–°è¥åœ°ä½ç½®
    if (gameMode === 'normal' && !isDaytime) {
        setTimeout(updateCampfirePosition, 100);
    }
}

function debugCoordinateSystem() {
    console.log("=== åæ ‡ç³»è°ƒè¯• ===");
    console.log("æ¸¸æˆé€»è¾‘å°ºå¯¸:", GAME_WIDTH, "x", GAME_HEIGHT);
    console.log("ä¸»ç”»å¸ƒå°ºå¯¸:", canvas.width, "x", canvas.height);
    console.log("ç²ªä¾¿ç”»å¸ƒå°ºå¯¸:", poopCanvas.width, "x", poopCanvas.height);
    
    const canvasRect = canvas.getBoundingClientRect();
    console.log("ç”»å¸ƒå±å¹•å°ºå¯¸:", canvasRect.width, "x", canvasRect.height);
    console.log("ç¼©æ”¾æ¯”ä¾‹ X:", canvas.width / canvasRect.width, 
                "Y:", canvas.height / canvasRect.height);
    
    // æ£€æŸ¥ä¸€åªä¹Œé¸«çš„ä½ç½®
    const blackbird = birds.find(b => b.name === "ä¹Œé¸«");
    if (blackbird) {
        console.log("ä¹Œé¸«ä½ç½® - æ¸¸æˆåæ ‡:", blackbird.x, blackbird.y);
        console.log("ä¹Œé¸«ä½ç½® - å±å¹•åƒç´ :", 
                    blackbird.x * (canvas.width / canvasRect.width),
                    blackbird.y * (canvas.height / canvasRect.height));
    }
}

window.addEventListener('resize', function() {
    resizeCanvas();
    // çŸ­æš‚å»¶è¿Ÿåå†æ¬¡æ›´æ–°ä»¥ç¡®ä¿æ­£ç¡®æ¸²æŸ“
    setTimeout(resizeCanvas, 100);
});

// åˆå§‹åŠ è½½åä¹Ÿè°ƒç”¨ä¸€æ¬¡
setTimeout(resizeCanvas, 500);

function initFruits() {
    fruits = [];
    
    treePositions.forEach((tree, treeIndex) => {
        tree.fruits = [];
        
        const redCount = Math.floor((15 + Math.floor(Math.random() * 10)) / 4);
        const yellowCount = Math.floor((10 + Math.floor(Math.random() * 8)) / 4);
        
        for (let i = 0; i < redCount; i++) {
            const fruit = createFruit(tree, treeIndex, "red");
            fruits.push(fruit);
            tree.fruits.push(fruit);
        }
        
        for (let i = 0; i < yellowCount; i++) {
            const fruit = createFruit(tree, treeIndex, "yellow");
            fruits.push(fruit);
            tree.fruits.push(fruit);
        }
    });
}

function createFruit(tree, treeIndex, color) {
    const treeCrownX = tree.x + tree.width * 0.2;
    const treeCrownY = tree.y + tree.height * 0.2;
    const treeCrownWidth = tree.width * 0.6;
    const treeCrownHeight = tree.height * 0.25;
    
    const fruit = {
        id: fruits.length,
        treeIndex: treeIndex,
        x: treeCrownX + Math.random() * treeCrownWidth,
        y: treeCrownY + Math.random() * treeCrownHeight,
        size: 4,
        color: color,
        originalColor: color,
        isEaten: false,
        eatenBy: null,
        eatStartTime: 0
    };
    
    return fruit;
}

function initReeds() {
  // èŠ¦è‹‡é«˜åº¦
  const reedHeight = GAME_HEIGHT * 0.18; // èŠ¦è‹‡å ç”»é¢é«˜åº¦çš„18%
  
  const wallWidth = 80;
  const wallMargin = 10;
  const wallSpace = wallWidth + wallMargin;
  const leftIndent = 200;
  
  // èŠ¦è‹‡åŒºåŸŸä»åœ°é¢å¼€å§‹ï¼ˆGAME_HEIGHT - reedHeightï¼‰
  // è¿™æ ·èŠ¦è‹‡å°±ä¼šä»åœ°é¢ç”Ÿé•¿ï¼Œè¥åœ°ä¹Ÿå¯ä»¥æ”¾åœ¨èŠ¦è‹‡åœ°é¢ä¸Š
  reedZone = {
    x: leftIndent,
    y: GAME_HEIGHT - reedHeight, // ä»åœ°é¢å¼€å§‹
    width: GAME_WIDTH - leftIndent - wallSpace,
    height: reedHeight
  };
  
  reedBends = [];
  const reedCount = Math.floor(150 * (reedZone.width / (GAME_WIDTH - wallSpace)));
  
  for (let i = 0; i < reedCount; i++) {
    const reedType = Math.floor(Math.random() * 6);
    reedBends.push({
      bendAmount: (Math.random() - 0.5) * 35,
      bendPointRatio: 0.2 + Math.random() * 0.6,
      topBendAmount: (Math.random() - 0.5) * 40,
      reedType: reedType,
      reedColor: ['#8B4513', '#654321', '#A0522D'][Math.floor(Math.random() * 3)],
      topColor: ['#DAA520', '#B8860B', '#8B7355', '#A0522D'][Math.floor(Math.random() * 4)],
      reedWidth: 0.5 + Math.random() * 1.0
    });
  }
  
  console.log("èŠ¦è‹‡åŒºåŸŸåˆå§‹åŒ–å®Œæˆ:", reedZone);
}

function initTextStats() {
    for (const birdName of ALL_BIRDS) {
        capturedBirds[birdName] = 0;
        appearedBirds[birdName] = 0;
    }
    
    // åˆå§‹åŒ–è§‚é¸Ÿæ¨¡å¼çš„ç»Ÿè®¡
    birdingObservedSpecies = new Set();
    birdingModeCapturedSpecies = new Set();
    
    updateTextStats();
}

function updateTextStats() {
    if (birdingModeActive) {
        // è§‚é¸Ÿæ¨¡å¼ä¸‹æ˜¾ç¤ºè§‚é¸Ÿæ¨¡å¼ç›¸å…³çš„ç»Ÿè®¡
        const observedCount = birdingObservedSpecies.size;
        const capturedInSession = birdingModeCapturedSpecies ? birdingModeCapturedSpecies.size : 0;
        
        document.getElementById('appearedCount').textContent = observedCount;
        document.getElementById('capturedCount').textContent = capturedInSession;
    } else {
        // éè§‚é¸Ÿæ¨¡å¼ä¸‹æ˜¾ç¤ºå…¨å±€ç»Ÿè®¡
        const appearedCount = Object.values(appearedBirds).filter(count => count > 0).length;
        const capturedCount = Object.values(capturedBirds).filter(count => count > 0).length;
        
        document.getElementById('appearedCount').textContent = appearedCount;
        document.getElementById('capturedCount').textContent = capturedCount;
    }
}

function updateAlbumStats() {
    const albumStats = document.getElementById('albumStats');
    albumStats.innerHTML = '';
    
    const capturedBirdNames = Object.keys(capturedBirds).filter(name => capturedBirds[name] > 0);
    
    if (capturedBirdNames.length === 0) {
        albumStats.innerHTML = '<div style="color: white; font-size: 14px;">æš‚æ— å·²æ‹æ‘„é¸Ÿç±»</div>';
        return;
    }
    
    const recordInfo = document.createElement('div');
    recordInfo.className = 'albumStatItem';
    recordInfo.innerHTML = `
        <span>ğŸ“ è§‚é¸Ÿè®°å½•</span>
        <span class="statCount">${birdingRecords.length}</span>
    `;
    albumStats.appendChild(recordInfo);
    
    if (birdingModeActive) {
        const birdingModeInfo = document.createElement('div');
        birdingModeInfo.className = 'albumStatItem';
        birdingModeInfo.innerHTML = `
            <span>ğŸ” è§‚é¸Ÿæ¨¡å¼</span>
            <span class="statCount" style="color: #90EE90;">è¿›è¡Œä¸­</span>
        `;
        albumStats.appendChild(birdingModeInfo);
    }
    
    capturedBirdNames.forEach(birdName => {
        let birdType = null;
        for (const key in BIRD_TYPES) {
            if (BIRD_TYPES[key].name === birdName) {
                birdType = BIRD_TYPES[key];
                break;
            }
        }
        
        if (!birdType || birdType.isBat) return;
        
        const statItem = document.createElement('div');
        statItem.className = 'albumStatItem';
        statItem.innerHTML = `
            <span>
                <span class="birdIcon" style="background-color: ${birdType.iconColor || birdType.bodyColor || '#FFFFFF'}"></span>
                ${birdName}
            </span>
            <span class="statCount">${capturedBirds[birdName] || 0}</span>
        `;
        albumStats.appendChild(statItem);
    });
}

function handleMouseClick() {
    if (isTakingPhoto) return;
    isTakingPhoto = true;
    
    const viewfinderSize = getViewfinderSize();
    const actualViewfinderWidth = viewfinderSize.width;
    const actualViewfinderHeight = viewfinderSize.height;
    
    // å–æ™¯å™¨åœ¨æ¸¸æˆåæ ‡ç³»ä¸­çš„è¾¹ç•Œ
    const viewfinderLeft = mouseX - actualViewfinderWidth / 2;
    const viewfinderTop = mouseY - actualViewfinderHeight / 2;
    const viewfinderRight = viewfinderLeft + actualViewfinderWidth;
    const viewfinderBottom = viewfinderTop + actualViewfinderHeight;
       
    // ç¡®ä¿æ‹ç…§åŒºåŸŸåœ¨ç”»å¸ƒèŒƒå›´å†…ï¼Œé¿å…é»‘è¾¹
    // æ³¨æ„ï¼šcreatePhoto å†…éƒ¨ä¼šå¤„ç†è¾¹ç•Œå‰ªè£ï¼Œä½†å¦‚æœä¼ å…¥åæ ‡å®Œå…¨åœ¨ç”»å¸ƒå¤–ï¼Œå°±ä¼šå…¨é»‘
    // æˆ‘ä»¬ä¸»è¦ä¿è¯ mouseX/Y æ˜¯æ­£ç¡®çš„é€»è¾‘åæ ‡å³å¯
    
    const centerRegionWidth = actualViewfinderWidth * 0.7;
    const centerRegionHeight = actualViewfinderHeight * 0.7;
    const centerRegionLeft = mouseX - centerRegionWidth / 2;
    const centerRegionTop = mouseY - centerRegionHeight / 2;
    const centerRegionRight = centerRegionLeft + centerRegionWidth;
    const centerRegionBottom = centerRegionTop + centerRegionHeight;
    
    let capturedBird = null;
    let capturedNightObject = null;
    let maxSize = 0;
    
    for (const bird of birds) {
        const baseSize = 20;
        const birdSize = baseSize * bird.size;
        let birdDisplayX = bird.x;
        
        const isInCenterRegion = birdDisplayX >= centerRegionLeft && birdDisplayX <= centerRegionRight &&
                                  bird.y >= centerRegionTop && bird.y <= centerRegionBottom;
        
        if (isInCenterRegion) {
            if (birdSize > maxSize) {
                maxSize = birdSize;
                capturedBird = bird;
                capturedNightObject = null;
            }
        }
    }
    
    for (const obj of nightObjects) {
        const baseSize = 20;
        const objSize = baseSize * obj.size;
        
        const isInCenterRegion = obj.x >= centerRegionLeft && obj.x <= centerRegionRight &&
                                  obj.y >= centerRegionTop && obj.y <= centerRegionBottom;
        
        if (isInCenterRegion) {
            if (objSize > maxSize) {
                maxSize = objSize;
                capturedBird = null;
                capturedNightObject = obj;
            }
        }
    }
    
    if (!capturedBird && !capturedNightObject) {
        let fallbackCapturedBird = null;
        let fallbackCapturedNightObject = null;
        let fallbackMaxSize = 0;
        
        for (const bird of birds) {
            const baseSize = 20;
            const birdSize = baseSize * bird.size;
            const birdRadius = birdSize / 2;
            let birdDisplayX = bird.x;
            
            const birdLeft = birdDisplayX - birdRadius;
            const birdRight = birdDisplayX + birdRadius;
            const birdTop = bird.y - birdRadius;
            const birdBottom = bird.y + birdRadius;
            
            const overlapX = birdRight >= viewfinderLeft && birdLeft <= viewfinderRight;
            const overlapY = birdBottom >= viewfinderTop && birdTop <= viewfinderBottom;
            const isInViewfinder = overlapX && overlapY;
            
            if (isInViewfinder) {
                if (birdSize > fallbackMaxSize) {
                    fallbackMaxSize = birdSize;
                    fallbackCapturedBird = bird;
                    fallbackCapturedNightObject = null;
                }
            }
        }
        
        for (const obj of nightObjects) {
            const baseSize = 20;
            const objSize = baseSize * obj.size;
            const objRadius = objSize / 2;
            
            const objLeft = obj.x - objRadius;
            const objRight = obj.x + objRadius;
            const objTop = obj.y - objRadius;
            const objBottom = obj.y + objRadius;
            
            const overlapX = objRight >= viewfinderLeft && objLeft <= viewfinderRight;
            const overlapY = objBottom >= viewfinderTop && objTop <= viewfinderBottom;
            const isInViewfinder = overlapX && overlapY;
            
            if (isInViewfinder) {
                if (objSize > fallbackMaxSize) {
                    fallbackMaxSize = objSize;
                    fallbackCapturedBird = null;
                    fallbackCapturedNightObject = obj;
                }
            }
        }
        
        capturedBird = fallbackCapturedBird;
        capturedNightObject = fallbackCapturedNightObject;
    }
    
    // ç›´æ¥æ‰§è¡Œæ‹ç…§é€»è¾‘ï¼Œä¸å†æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†è¥åœ°
    createPhoto(viewfinderLeft, viewfinderTop, actualViewfinderWidth, actualViewfinderHeight, capturedBird, capturedNightObject);
    updateTextStats();
    playCameraSound();
    
    if (capturedBird) {
        showCaptureAlert(`æ‹æ‘„åˆ°${capturedBird.name}ï¼`);
    } else if (capturedNightObject) {
        showCaptureAlert(`æ‹æ‘„åˆ°${capturedNightObject.name}ï¼`);
    }
    
    setTimeout(() => {
        isTakingPhoto = false;
    }, 50);
}

function checkIfAllBirdsCollected() {
    for (const birdName of ALL_BIRDS) {
        if (!capturedBirds[birdName] || capturedBirds[birdName] === 0) {
            return false;
        }
    }
    return true;
}

function showAllBirdsAlert() {
    const allBirdsAlert = document.createElement('div');
    allBirdsAlert.id = 'allBirdsAlert';
    allBirdsAlert.innerHTML = `
        <div style="margin-bottom: 20px; font-size: 28px;">ğŸ‰ æ­å–œï¼ ğŸ‰</div>
        <div style="margin-bottom: 15px;">æ‚¨å·²é›†é½æ‰€æœ‰å°é¸Ÿï¼</div>
        <div style="margin-bottom: 25px; font-size: 20px;">æ„Ÿè°¢æ‚¨çš„æ¸¸ç©ï¼</div>
        <div style="font-size: 18px; color: #FF6347;">
            è¿™æ˜¯ç”±å°çº¢ä¹¦å·ï¼š<br>
            <span style="font-size: 22px; color: #FFD700; text-shadow: 0 0 10px rgba(255, 215, 0, 0.7);">S_Asuka_Langley</span>
            <div style="font-size: 18px; color: #FF6347;"> åˆ¶ä½œçš„<br></div>
        </div>
        <div style="margin-top: 25px; font-size: 16px; color: #87CEEB;">
            (æç¤ºï¼šæ‚¨ä»ç„¶å¯ä»¥ç»§ç»­æ‹æ‘„é¸Ÿç±»å’Œå¤œæ‹ç‰©ä½“)
        </div>
        <button id="closeAllBirdsAlert" style="
            margin-top: 20px;
            background-color: #FFD700;
            color: #000;
            border: none;
            padding: 10px 25px;
            border-radius: 25px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        ">ç¡®å®š</button>
    `;
    
    document.getElementById('gameContainer').appendChild(allBirdsAlert);
    
    document.getElementById('closeAllBirdsAlert').addEventListener('click', function() {
        document.getElementById('gameContainer').removeChild(allBirdsAlert);
    });
    
    setTimeout(() => {
        if (document.getElementById('allBirdsAlert')) {
            document.getElementById('gameContainer').removeChild(allBirdsAlert);
        }
    }, 5000);
}

function createPhoto(x, y, width, height, capturedBird, capturedNightObject) {
  const tempCanvas = document.createElement('canvas');
  tempCanvas.width = width;
  tempCanvas.height = height;
  const tempCtx = tempCanvas.getContext('2d');
    
    let sourceX = Math.max(0, Math.min(x, GAME_WIDTH));
    let sourceY = Math.max(0, Math.min(y, GAME_HEIGHT));
    let drawX = 0;
    let drawY = 0;
    let drawWidth = width;
    let drawHeight = height;
    
    if (x < 0) {
        drawX = -x;
        drawWidth = width + x;
    }
    if (y < 0) {
        drawY = -y;
        drawHeight = height + y;
    }
    if (x + width > GAME_WIDTH) {
        drawWidth = GAME_WIDTH - x;
    }
    if (y + height > GAME_HEIGHT) {
        drawHeight = GAME_HEIGHT - y;
    }
    
    sourceX = Math.max(0, sourceX);
    sourceY = Math.max(0, sourceY);
    drawWidth = Math.max(0, drawWidth);
    drawHeight = Math.max(0, drawHeight);
    
    if (drawWidth > 0 && drawHeight > 0) {
        tempCtx.drawImage(
            canvas,
            sourceX, sourceY, drawWidth, drawHeight,
            drawX, drawY, drawWidth, drawHeight
        );
    }
    
    const goldenFilter = document.getElementById('goldenFilter');
    const filterStyle = window.getComputedStyle(goldenFilter);
    const filterColor = filterStyle.backgroundColor;
    
    // åªåœ¨éé™€èºä»ªæ¨¡å¼ä¸‹åº”ç”¨æ»¤é•œï¼ˆé™€èºä»ªæ¨¡å¼ä¸‹ä¿æŒåŸè‰²ï¼‰
    if (!gyroModeActive && filterColor && filterColor !== 'rgba(0, 0, 0, 0)' && filterColor !== 'transparent') {
        tempCtx.fillStyle = filterColor;
        tempCtx.fillRect(0, 0, drawWidth, drawHeight);
    }
    
    const finalCanvas = document.createElement('canvas');
    finalCanvas.width = viewfinderBaseWidth;
    finalCanvas.height = viewfinderBaseHeight;
    const finalCtx = finalCanvas.getContext('2d');
    
    finalCtx.drawImage(tempCanvas, 0, 0, width, height, 0, 0, viewfinderBaseWidth, viewfinderBaseHeight);
    
    finalCtx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
    finalCtx.lineWidth = 2;
    finalCtx.strokeRect(0, 0, viewfinderBaseWidth, viewfinderBaseHeight);
    
if (capturedBird) {
    if (!capturedBird.type.isSpecial && !capturedBird.isBat && capturedBirds[capturedBird.name] !== undefined && !capturedBird.noStats) {
        capturedBirds[capturedBird.name]++;
        
        // è§‚é¸Ÿæ¨¡å¼ä¸‹æ›´æ–°æ‹æ‘„é¸Ÿç§ç»Ÿè®¡
        if (birdingModeActive && birdingModeCapturedSpecies) {
            birdingModeCapturedSpecies.add(capturedBird.name);
            // æ›´æ–°è§‚é¸Ÿæ¨¡å¼ä¸‹çš„æ‹æ‘„é¸Ÿç§ç»Ÿè®¡æ˜¾ç¤º
            const capturedCountElement = document.getElementById('capturedCount');
            if (capturedCountElement) {
                capturedCountElement.textContent = birdingModeCapturedSpecies.size;
            }
        }
    }
        
        const highlightColor = 'rgba(255, 255, 255, 0.1)';
        finalCtx.fillStyle = highlightColor;
        finalCtx.fillRect(0, 0, viewfinderBaseWidth, viewfinderBaseHeight);
        
        finalCtx.fillStyle = '#FFFFFF';
        finalCtx.font = '12px Arial';
        finalCtx.textAlign = 'left';
        finalCtx.fillText(capturedBird.name, 5, viewfinderBaseHeight - 5);
    } else if (capturedNightObject) {
        const highlightColor = 'rgba(173, 216, 230, 0.1)';
        finalCtx.fillStyle = highlightColor;
        finalCtx.fillRect(0, 0, viewfinderBaseWidth, viewfinderBaseHeight);
        
        finalCtx.fillStyle = '#87CEEB';
        finalCtx.font = '12px Arial';
        finalCtx.textAlign = 'left';
        finalCtx.fillText(capturedNightObject.name, 5, viewfinderBaseHeight - 5);
    }
    
  const hasCollectedAllBirds = checkIfAllBirdsCollected();
  if (hasCollectedAllBirds && !hasShownAllBirdsAlert) {
    showAllBirdsAlert();
    hasShownAllBirdsAlert = true;
  }
  
  const photo = {
    id: photos.length,
    x: x,
    y: y,
    width: width,
    height: height,
    lens: currentLens,
    time: gameTime,
    bird: capturedBird ? capturedBird.name : null,
    birdType: capturedBird ? capturedBird.type : null,
    nightObject: capturedNightObject ? capturedNightObject.name : null,
    nightObjectType: capturedNightObject ? capturedNightObject.type : null,
    imageData: finalCanvas.toDataURL('image/png')
  };
  
  photos.push(photo);
  
  // å¦‚æœæ‹æ‘„åˆ°é¸Ÿï¼Œå¹¶ä¸”å¤„äºè§‚é¸Ÿæ¨¡å¼ï¼Œè®°å½•åˆ°æœ¬æ¬¡è§‚é¸Ÿçš„æ‹æ‘„ç»Ÿè®¡ä¸­
  if (capturedBird && !capturedBird.type.isSpecial && !capturedBird.isBat && 
      capturedBirds[capturedBird.name] !== undefined && !capturedBird.noStats) {
    capturedBirds[capturedBird.name]++;
    
    // è®°å½•åˆ°æœ¬æ¬¡è§‚é¸Ÿçš„æ‹æ‘„ç»Ÿè®¡
    if (birdingModeActive && birdingModeCapturedSpecies) {
      birdingModeCapturedSpecies.add(capturedBird.name);
    }
  }
  
  updatePhotoPreview();
}

function updatePhotoPreview() {
    const photoPreview = document.getElementById('photoPreview');
    if (photos.length > 0) {
        const latestPhoto = photos[photos.length - 1];
        photoPreview.innerHTML = `<img src="${latestPhoto.imageData}" alt="ç…§ç‰‡">`;
    } else {
        photoPreview.innerHTML = '<div class="noPhoto">ç‚¹å‡»æŸ¥çœ‹ç›¸å†Œ<br>æš‚æ— ç…§ç‰‡</div>';
    }
}

function showSpecialAlert(text) {
    const alertElement = document.getElementById('specialAlert');
    alertElement.textContent = text;
    alertElement.style.opacity = 1;
    
    if (specialBirdAlertTimeout) {
        clearTimeout(specialBirdAlertTimeout);
    }
    specialBirdAlertTimeout = setTimeout(() => {
        alertElement.style.opacity = 0;
    }, 3000);
}

function showCaptureAlert(text) {
    const captureAlert = document.getElementById('captureAlert');
    captureAlert.textContent = text;
    captureAlert.style.opacity = 1;
    
    if (captureAlertTimeout) {
        clearTimeout(captureAlertTimeout);
    }
    captureAlertTimeout = setTimeout(() => {
        captureAlert.style.opacity = 0;
    }, 3000);
}

function playCameraSound() {
    try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator1 = audioContext.createOscillator();
        const oscillator2 = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator1.connect(gainNode);
        oscillator2.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator1.frequency.value = 800;
        oscillator1.type = 'sine';
        oscillator2.frequency.value = 1200;
        oscillator2.type = 'sine';
        
        const currentTime = audioContext.currentTime;
        gainNode.gain.setValueAtTime(0, currentTime);
        gainNode.gain.linearRampToValueAtTime(0.5, currentTime + 0.01);
        gainNode.gain.exponentialRampToValueAtTime(0.01, currentTime + 0.05);
        gainNode.gain.linearRampToValueAtTime(0, currentTime + 0.1);
        
        oscillator1.start(currentTime);
        oscillator2.start(currentTime);
        oscillator1.stop(currentTime + 0.1);
        oscillator2.stop(currentTime + 0.1);
    } catch (e) {
        console.log("éŸ³é¢‘ä¸Šä¸‹æ–‡ä¸æ”¯æŒï¼Œè·³è¿‡éŸ³æ•ˆ");
    }
}

function openAlbum() {
    if (!hasShownAllBirdsAlert && checkIfAllBirdsCollected()) {
        showAllBirdsAlert();
        hasShownAllBirdsAlert = true;
    }
    
    pauseGame();
    
    const albumModal = document.getElementById('albumModal');
    const albumPhotos = document.getElementById('albumPhotos');
    albumPhotos.innerHTML = '';
    
    if (photos.length === 0) {
        albumPhotos.innerHTML = '<div style="color: white; font-size: 18px;">æš‚æ— ç…§ç‰‡ï¼Œå¿«å»æ‹ç…§å§ï¼</div>';
    } else {
        const photosPerRow = Math.ceil(photos.length / 3);
        
        for (let row = 0; row < 3; row++) {
            const rowStart = row * photosPerRow;
            const rowEnd = Math.min((row + 1) * photosPerRow, photos.length);
            
            if (rowStart < photos.length) {
                for (let i = rowStart; i < rowEnd; i++) {
                    const photo = photos[i];
                    const photoDiv = document.createElement('div');
                    photoDiv.className = 'albumPhoto';
                    
                    const lensText = photo.lens ? ` (${LENS_SETTINGS[photo.lens].name})` : '';
                    
                    photoDiv.innerHTML = `
                        <img src="${photo.imageData}" alt="ç…§ç‰‡">
                        <div class="photoInfo">${i + 1}${photo.bird ? ` - ${photo.bird}${lensText}` : photo.nightObject ? ` - ${photo.nightObject}${lensText}` : lensText}</div>
                    `;
                    
                    albumPhotos.appendChild(photoDiv);
                }
            }
        }
    }
    
    updateAlbumStats();
    albumModal.style.display = 'flex';
}

function closeAlbum() {
    resumeGame();
    document.getElementById('albumModal').style.display = 'none';
}

function pauseGame() {
    gamePaused = true;
    pausedTimeState.gameTime = gameTime;
    pausedTimeState.dayNightTimer = dayNightTimer;
    pausedTimeState.moonPhaseTimer = moonPhaseTimer;
    pausedTimeState.dayModeTimeState = dayModeTimeState;
    pausedTimeState.nightModeTimeState = nightModeTimeState;
    pausedTimeState.nightModeMoonPhaseTimer = nightModeMoonPhaseTimer;
    pausedTimeState.lastFrameTime = lastFrameTime;
    pausedTimeState.lastBirdTime = lastBirdTime;
    pausedTimeState.lastRareBirdTime = lastRareBirdTime;
    pausedTimeState.lastLittleOwlTime = lastLittleOwlTime;
    pausedTimeState.lastOwlSpawnTime = lastOwlSpawnTime;
    pausedTimeState.lastDoveSummonCheck = lastDoveSummonCheck;
    pausedTimeState.pauseStartTime = performance.now();
    pausedTimeState.pauseDeltaOffset = 0;
}

function resumeGame() {
    if (!gamePaused) return;
    
    gamePaused = false;
    const pauseEndTime = performance.now();
    const pauseDuration = pauseEndTime - pausedTimeState.pauseStartTime;
    
    gameTime = pausedTimeState.gameTime;
    dayNightTimer = pausedTimeState.dayNightTimer;
    moonPhaseTimer = pausedTimeState.moonPhaseTimer;
    dayModeTimeState = pausedTimeState.dayModeTimeState;
    nightModeTimeState = pausedTimeState.nightModeTimeState;
    nightModeMoonPhaseTimer = pausedTimeState.nightModeMoonPhaseTimer;
    lastBirdTime = pausedTimeState.lastBirdTime;
    lastRareBirdTime = pausedTimeState.lastRareBirdTime;
    lastLittleOwlTime = pausedTimeState.lastLittleOwlTime;
    lastOwlSpawnTime = pausedTimeState.lastOwlSpawnTime;
    lastDoveSummonCheck = pausedTimeState.lastDoveSummonCheck;
    
    lastFrameTime = performance.now() - pauseDuration;
    
    updateTimeIndicator();
    requestAnimationFrame(gameLoop);
}

function getRandomGroupSize(birdType) {
    if (Array.isArray(birdType.groupSize)) {
        const [min, max] = birdType.groupSize;
        return min + Math.floor(Math.random() * (max - min + 1));
    } else {
        return birdType.groupSize || 1;
    }
}

function generateBird() {
    if (gamePaused) return;
    
    const now = Date.now();
    // æ ¹æ®è§‚é¸Ÿæ¨¡å¼è°ƒæ•´ç”Ÿæˆé—´éš”
    let currentInterval = birdInterval;
    let currentVariation = birdIntervalVariation;
    
    if (birdingModeActive) {
        // è§‚é¸Ÿæ¨¡å¼ï¼š15~25ç§’
        currentInterval = 30000;  // 30ç§’åŸºç¡€
        currentVariation = 5000;  // Â±5ç§’å˜åŒ–
    }
    // ä½¿ç”¨å®é™…æ—¶é—´è®¡ç®—é—´éš”
        let actualTimePassed = now - lastBirdTime;
        
        if (actualTimePassed < currentInterval + (Math.random() - 0.5) * currentVariation) {
            return;
        }
    lastBirdTime = now;
    
    const isNightMode = gameMode === 'night' || (gameMode === 'normal' && !isDaytime);
    
    if (isNightMode) {
        const rand = Math.random();
        if (rand < NIGHT_OBJECTS.METEOR.probability) {
            generateMeteor(true);
            return;
        }
        if (rand < NIGHT_OBJECTS.METEOR.probability + NIGHT_OBJECTS.COMET.probability) {
            generateComet(true);
            return;
        }
        if (rand < NIGHT_OBJECTS.METEOR.probability + NIGHT_OBJECTS.COMET.probability + NIGHT_OBJECTS.UFO.probability) {
            generateUFO(true);
            return;
        }
    }
    
    if (isNightMode) {
        let eagleOwlPresent = false;
        let eagleOwlCount = 0;
        for (const bird of birds) {
            if (bird.name === "é›•é¸®") {
                eagleOwlPresent = true;
                eagleOwlCount++;
                break;
            }
        }
        
        if (eagleOwlPresent) {
            for (const bird of birds) {
                if (bird.name === "çŸ­è€³é¸®" && !bird.isFleeing && bird.state !== 'fleeing') {
                    bird.state = 'fleeing';
                    bird.speed = bird.speed * 3;
                    bird.direction = bird.direction === 1 ? -1 : 1;
                    bird.fleeStartTime = gameTime;
                }
            }
        }
        
        let shortEaredOwlCount = 0;
        for (const bird of birds) {
            if (bird.name === "çŸ­è€³é¸®") {
                shortEaredOwlCount++;
            }
        }
        
        let batCount = 0;
        for (const bird of birds) {
            if (bird.isBat) {
                batCount++;
            }
        }
        
        if (batCount < MAX_BAT_COUNT) {
            const batProbability = (gameMode === 'normal' && !isDaytime) ? 0.10 : 0.20;
            if (Math.random() < batProbability) {
                const batType = BIRD_TYPES.BAT;
                const bat = createBat(batType);
                birds.push(bat);
                return;
            }
        }
        
        const rand = Math.random();
        let cumulativeProbability = 0;
        let selectedBirdType = null;
        
        const nocturnalBirds = {};
        for (const key in BIRD_TYPES) {
            if (BIRD_TYPES[key].isOwl || BIRD_TYPES[key].canAppearAtNight || BIRD_TYPES[key].name === "å°é¸®") {
                nocturnalBirds[key] = BIRD_TYPES[key];
            }
        }
        
        const adjustedProbabilities = {};
        for (const key in nocturnalBirds) {
            let probability = nocturnalBirds[key].probability;
            
            if (gameMode === 'normal' && !isDaytime) {
                probability = probability * 0.5;
            }
            
            if (nocturnalBirds[key].name === "é›•é¸®" && eagleOwlCount > 0) {
                probability = 0;
            }
            
            if (nocturnalBirds[key].name === "çŸ­è€³é¸®" && shortEaredOwlCount >= MAX_SHORT_EARED_OWL_COUNT) {
                probability *= 0.1;
            }
            
            if (nocturnalBirds[key].name === "å¤œé¹­" && nocturnalBirds[key].nightProbability !== undefined) {
                probability = nocturnalBirds[key].nightProbability;
                if (gameMode === 'normal' && !isDaytime) {
                    probability = probability * 0.5;
                }
            }
            
            adjustedProbabilities[key] = probability;
        }
        
        let totalAdjustedProbability = 0;
        for (const key in adjustedProbabilities) {
            totalAdjustedProbability += adjustedProbabilities[key];
        }
        
        if (rand > totalAdjustedProbability) {
            return;
        }
        
        let normalizedCumulative = 0;
        for (const key in adjustedProbabilities) {
            const normalizedProbability = adjustedProbabilities[key] / totalAdjustedProbability;
            normalizedCumulative += normalizedProbability;
            if (rand <= normalizedCumulative) {
                selectedBirdType = nocturnalBirds[key];
                break;
            }
        }
        
        if (!selectedBirdType) {
            return;
        }
        
        const goldenFilter = document.getElementById('goldenFilter');
        const filterStyle = window.getComputedStyle(goldenFilter);
        const filterColor = filterStyle.backgroundColor;
        let filterAlpha = 0;
        
        if (filterColor && filterColor !== 'rgba(0, 0, 0, 0)' && filterColor !== 'transparent') {
            const rgbaMatch = filterColor.match(/rgba?\((\d+),\s*(\d+),\s*(\d+),\s*([\d.]+)\)/);
            if (rgbaMatch) {
                filterAlpha = parseFloat(rgbaMatch[4]);
            }
        }
        
        if (filterAlpha > 0.01) {
            const dawnDuskRand = Math.random();
            if (dawnDuskRand < 0.10) {
                const raptorChoice = Math.random();
                if (raptorChoice < 0.1) {
                    generatePeregrine();
                    return;
                } else if (raptorChoice < 0.5) {
                    generateKestrel();
                    return;
                } else {
                    generateBlackWingedKite();
                    return;
                }
            }
        }
        
        appearedBirds[selectedBirdType.name]++;
        updateTextStats();
        
        if (selectedBirdType.isOwl || selectedBirdType.name === "å°é¸®") {
            const fromLeft = Math.random() > 0.5;
            const birdCount = getRandomGroupSize(selectedBirdType);
            const groupId = nextGroupId++;
            birdGroupInfo[groupId] = { direction: fromLeft ? 1 : -1, birds: [] };
            
            for (let i = 0; i < birdCount; i++) {
                let startX, startY;
                
                if (selectedBirdType.flyInLowerHalf) {
                    startX = GAME_WIDTH * 0.5 + (Math.random() - 0.5) * 200;
                    startY = GAME_HEIGHT * 0.7 + Math.random() * 100;
                } else {
                    startX = GAME_WIDTH * 0.5 + (Math.random() - 0.5) * 200;
                    startY = -50;
                }
                
                let baseSpeed = (1.6 + Math.random() * 0.8);
                const speedMultiplier = selectedBirdType.speedMultiplier || 1;
                const finalSpeed = baseSpeed * speedMultiplier;
                
                const bird = {
                    type: selectedBirdType,
                    name: selectedBirdType.name,
                    x: startX,
                    y: startY,
                    size: selectedBirdType.size,
                    speed: finalSpeed,
                    direction: Math.random() > 0.5 ? 1 : -1,
                    state: 'circling',
                    stateTime: 0,
                    circlingTime: 0,
                    circlingRadius: 150 + Math.random() * 50,
                    circlingAngle: Math.random() * Math.PI * 2,
                    circlingCenterX: selectedBirdType.flyInLowerHalf ? GAME_WIDTH * 0.5 : GAME_WIDTH * 0.5,
                    circlingCenterY: selectedBirdType.flyInLowerHalf ? GAME_HEIGHT * 0.7 : GAME_HEIGHT * 0.3,
                    isOwl: selectedBirdType.isOwl || false,
                    circleTime: selectedBirdType.circleTime || 30000,
                    catchPreyChance: selectedBirdType.catchPreyChance || 0,
                    catchPreyType: selectedBirdType.catchPreyType || null,
                    caughtPrey: null,
                    hasGlided: false,
                    glidingStartY: 0,
                    faceDirection: -1,
                    faceChangeTimer: 0,
                    faceChangeInterval: 10000 + Math.random() * 10000,
                    wingsOpen: true,
                    isFleeing: false,
                    fleeStartTime: 0,
                    isEagleOwl: selectedBirdType.name === "é›•é¸®",
                    wingOffset: selectedBirdType.wingOffset || 0,
                    isNight: true
                };
                
                birds.push(bird);
                birdGroupInfo[groupId].birds.push(bird);
            }
        } else {
            const fromLeft = Math.random() > 0.5;
            const birdCount = getRandomGroupSize(selectedBirdType);
            const groupId = nextGroupId++;
            birdGroupInfo[groupId] = { direction: fromLeft ? 1 : -1, birds: [] };
            
            for (let i = 0; i < birdCount; i++) {
                let startX, startY;
                let behavior = selectedBirdType.behavior;
                let stayTime = selectedBirdType.stayTime || 10;
                
                startX = fromLeft ? -50 : GAME_WIDTH + 50;
                startY = Math.random() * (GAME_HEIGHT * 0.6) + GAME_HEIGHT * 0.2;
                
                let baseSpeed = (1.6 + Math.random() * 0.8);
                const speedMultiplier = selectedBirdType.speedMultiplier || 1;
                const finalSpeed = baseSpeed * speedMultiplier;
                
                const bird = createCommonBird(selectedBirdType, startX, startY, fromLeft, behavior, stayTime, finalSpeed, groupId);
                bird.isNight = true;
                
                birds.push(bird);
                birdGroupInfo[groupId].birds.push(bird);
            }
        }
        
        return;
    }
    
    if (Math.random() < 0.003) {
        generatePeregrine();
        return;
    }
    
    if (Math.random() < 0.01) {
        generateBlackWingedKite();
        return;
    }
    
  // ç¿ é¸Ÿæ£€æŸ¥ï¼ˆæ–°å¢ï¼‰
  // åªåœ¨ç™½å¤©å‡ºç°ï¼Œæ¦‚ç‡ä¸º0.023
  if (gameMode !== 'night') {
    const kingfisherChance = Math.random();
    // ä½¿ç”¨é…ç½®ä¸­çš„æ¦‚ç‡
    const kingfisherProb = BIRD_TYPES.KINGFISHER.probability || 0.023;
    if (kingfisherChance < kingfisherProb) {
      generateKingfisher(true);
      return;
    }
  }

    const rand = Math.random();
    let cumulativeProbability = 0;
    let selectedBirdType = null;
    
    const availableBirds = {};
    for (const key in BIRD_TYPES) {
        if (key !== "PEREGRINE" && key !== "BLACKWINGEDKITE" && !BIRD_TYPES[key].isSpecial && !BIRD_TYPES[key].isOwl && !BIRD_TYPES[key].isBat) {
            availableBirds[key] = BIRD_TYPES[key];
        }
    }
    
    for (const key in availableBirds) {
        cumulativeProbability += availableBirds[key].probability;
        if (rand <= cumulativeProbability) {
            selectedBirdType = availableBirds[key];
            break;
        }
    }
    
    if (!selectedBirdType) {
        selectedBirdType = BIRD_TYPES.SPARROW;
    }
    
    appearedBirds[selectedBirdType.name]++;
    updateTextStats();
    
    const fromLeft = Math.random() > 0.5;
    const birdCount = getRandomGroupSize(selectedBirdType);
    const groupId = nextGroupId++;
    birdGroupInfo[groupId] = { direction: fromLeft ? 1 : -1, birds: [] };
    
    for (let i = 0; i < birdCount; i++) {
        let startX, startY;
        let behavior = selectedBirdType.behavior;
        let stayTime = selectedBirdType.stayTime || 10;
        
        // ä¿®æ”¹ï¼šç™½å¤´é¹æœ‰30%æ¦‚ç‡åœç•™åœ¨æ ‘ä¸Š15ç§’
if (selectedBirdType.name === "ç™½å¤´é¹") {
    if (Math.random() < 0.3) {
        behavior = "landOnTree";
        stayTime = 15;
    }
}

// ä¿®æ”¹éº»é›€è¡Œä¸ºï¼š30%æ¦‚ç‡é£å‘èŠ¦è‹‡åŒºå¹¶åœç•™ï¼Œ70%æ¦‚ç‡ä¿æŒåŸæœ‰è¡Œä¸º
if (selectedBirdType.name === "éº»é›€") {
    if (Math.random() < 0.3) {
        behavior = "flyToReedsAndStay";
    } else {
        behavior = "flyThrough";
    }
}

    // æ–°é¸Ÿç±»ï¼šé•¿å°¾é›€ã€èœ¡å˜´é›€ã€ç‡•é›€ã€ç½—å®¾çš„æ ‘é¡¶éƒ¨/åº•éƒ¨åœç•™è¡Œä¸º
    if (selectedBirdType.name === "é•¿å°¾é›€" || selectedBirdType.name === "èœ¡å˜´é›€" || selectedBirdType.name === "ç‡•é›€") {
      behavior = "landOnTreeTop";
      stayTime = 10;
    } else if (selectedBirdType.name === "ç½—å®¾") {
      behavior = "landOnTreeBottom";
      stayTime = 5;
    }
        
        if ((selectedBirdType.name === "é‡‘çœ¶é¸»" || selectedBirdType.name === "12000é¸»") && Math.random() < selectedBirdType.landOnReedsChance) {
                   }
        
        if (selectedBirdType.behavior === 'circleThenHuntBird' || selectedBirdType.behavior === 'circleThenHunt') {
            startX = GAME_WIDTH * 0.5 + (Math.random() - 0.5) * 200;
            startY = -50;
        } else if (selectedBirdType.behavior === 'hunt') {
            startX = fromLeft ? -100 : GAME_WIDTH + 100;
            startY = GAME_HEIGHT * 0.3 + Math.random() * (GAME_HEIGHT * 0.4);
        } else if (selectedBirdType.behavior === 'flyInReedsAndStay') {
            startX = fromLeft ? -50 : GAME_WIDTH + 50;
            startY = reedZone.y + Math.random() * reedZone.height;
        } else {
            startX = fromLeft ? -50 : GAME_WIDTH + 50;
            startY = Math.random() * (GAME_HEIGHT * 0.6) + GAME_HEIGHT * 0.2;
        }
        
        let baseSpeed = (1.6 + Math.random() * 0.8);
        if (selectedBirdType.name === "æ–‘é¸ ") {
            baseSpeed *= 0.8;
        }
        
        const speedMultiplier = selectedBirdType.speedMultiplier || 1;
        const finalSpeed = baseSpeed * speedMultiplier;
        
        const bird = createCommonBird(selectedBirdType, startX, startY, fromLeft, behavior, stayTime, finalSpeed, groupId);

// é’ˆå¯¹æ–°é¸Ÿç±»çš„ç‰¹æ®Šè®¾ç½®
    if (selectedBirdType.name === "é•¿å°¾é›€" || selectedBirdType.name === "èœ¡å˜´é›€" || selectedBirdType.name === "ç‡•é›€" || selectedBirdType.name === "ç½—å®¾") {
      bird.isVulnerableToRaptors = true;
    }
        
// è®¾ç½®åƒæ°´æœçš„é¸Ÿç±»
    if (selectedBirdType.name === "èœ¡å˜´é›€" || selectedBirdType.name === "ç‡•é›€") {
      bird.eatFruits = true;
      bird.eatProbability = 0.1;
      bird.eatDuration = 2000;
      bird.originalSize = selectedBirdType.size;
    }

        if (selectedBirdType.behavior === 'appearOnTree' && bird.targetTree) {
            if (bird.name === "å°åŒ—" || bird.name === "æˆ´èŠ" || bird.name === "æŸç§æŸ³èº") {
                bird.x = bird.targetTree.x + bird.targetTree.width * 0.4 + Math.random() * bird.targetTree.width * 0.2;
                bird.y = bird.targetTree.y + bird.targetTree.height * 0.2 + Math.random() * bird.targetTree.height * 0.3;
            } else {
                bird.x = bird.targetTree.x + Math.random() * bird.targetTree.width;
                bird.y = bird.targetTree.y + Math.random() * (bird.targetTree.height * 0.7);
            }
            bird.state = 'perching';
            bird.stateTime = 0;
            bird.speed = 0;
            bird.direction = bird.targetTree.side === 'left' ? 1 : -1;
        }
        
        if (behavior === "landOnReeds" && reedZone) {
            bird.reedTargetX = reedZone.x + Math.random() * reedZone.width;
            bird.reedTargetY = reedZone.y + reedZone.height - 3;
            bird.state = 'landingOnReeds';
            bird.groundDirection = Math.random() > 0.5 ? 1 : -1;
            bird.isLandingOnReeds = true;
        }
        
        birds.push(bird);
        birdGroupInfo[groupId].birds.push(bird);
    }
}

function createCommonBird(birdType, startX, startY, fromLeft, behavior, stayTime, speed, groupId) {
    // å¯¹äºéº»é›€çš„ç‰¹æ®Šå¤„ç†ï¼šå¦‚æœè¡Œä¸ºæ˜¯é£å‘èŠ¦è‹‡åŒºï¼Œè®¾ç½®åˆå§‹çŠ¶æ€ä¸ºé£å‘èŠ¦è‹‡åŒº
    if (birdType.name === "éº»é›€" && behavior === "flyToReedsAndStay") {
        behavior = "flyToReedsAndStay";
    }
    
    const bird = {
        type: birdType,
        name: birdType.name,
        x: startX,
        y: startY,
        size: birdType.size,
        speed: speed,
        direction: fromLeft ? 1 : -1,
        state: 'flying',
        stateTime: 0,
        circlingTime: 0,
        hoveringTime: 0,
        circlingRadius: 100 + Math.random() * 50,
        circlingAngle: Math.random() * Math.PI * 2,
        circlingCenterX: 0,
        circlingCenterY: 0,
        variant: birdType.variant ? Math.random() > 0.5 : false,
        whiteEyeRing: birdType.whiteEyeRing || false,
        brownEyeRing: birdType.brownEyeRing || false,
        yellowEyeRing: birdType.yellowEyeRing || false,
        longBlackTail: birdType.longBlackTail || false,
        longWhiteTail: birdType.longWhiteTail || false,
        longBrownTail: birdType.longBrownTail || false,
        targetTree: (behavior === 'landOnTree' || behavior === 'appearOnTree' || behavior === 'landOnTreeThenMove') ? treePositions[Math.floor(Math.random() * treePositions.length)] : null,
        originalBehavior: birdType.behavior,
        actualBehavior: (birdType.name === "å–œé¹Š" || birdType.name === "ä¹Œé¸¦" || birdType.name === "ç™½å¤´é¹") ? "landOnTree" : behavior,
        stayTime: stayTime,
        hasMovedToSecondTree: false,
        isScared: false,
        isChasing: false,
        originalX: undefined,
        spreadDirection: undefined,
        headOffsetX: 0,
        hasLanded: false,
        groundTime: 0,
        isLandingOnReeds: behavior === "landOnReeds",
        reedTargetX: 0,
        reedTargetY: 0,
        peckingState: 0,
        peckingTimer: 0,
        groundDirection: 0,
        chasingTarget: null,
        isBeingChased: false,
        escapeDirection: 0,
        escapeSpeed: 0,
        isEscaping: false,
        escapeStartTime: 0,
        originalState: '',
        originalSpeed: 0,
        groupId: groupId,
        targetX: fromLeft ? GAME_WIDTH + 100 : -100,
        isEating: false,
        eatingFruit: null,
        eatingTime: 0,
        eatAnimationOffset: 0,
        lastPoopTime: 0,
        isFleeingFromRaptor: false,
        isHidingFromRaptor: false,
        isChasingRaptor: false,
        chasingTarget: null,
        isFleeingFromChasers: false,
        originalState: '',
        originalSpeed: 0,
        fleeFromRaptorStartTime: 0,
        fleeFromChasersStartTime: 0,
        chaseStartTime: 0,
        originalY: 0,
        hasCrest: birdType.hasCrest || false,
        crestColor: birdType.crestColor || null,
        doubleBeak: birdType.doubleBeak || false,
        beakOnePointFive: birdType.beakOnePointFive || false,
        beakOnePointThree: birdType.beakOnePointThree || false,
    beakLengthMultiplier: birdType.beakLengthMultiplier || 1,
    isVulnerableToRaptors: birdType.isVulnerableToRaptors || false,
    hideFromRaptors: birdType.hideFromRaptors || false,
    specialSummon: birdType.specialSummon || null,
    summonInterval: birdType.summonInterval || 0,
    summonProbability: birdType.summonProbability || 0,
    headOffsetY: birdType.headOffsetY || 0,
        fifthBeak: birdType.fifthBeak || false,
        riceBallAppearance: birdType.riceBallAppearance || false,
        halfBeakFlying: birdType.halfBeakFlying || false,
        peckingAction: birdType.peckingAction || false,
        hasHeart: birdType.hasHeart || false,
        groundPecking: birdType.groundPecking || false,
        groundMoveSpeed: birdType.groundMoveSpeed || 0.3,
        landOnReedsChance: birdType.landOnReedsChance || 0,
        landOnReedsTime: birdType.landOnReedsTime || 10,
        stayTimePerTree: birdType.stayTimePerTree || 2000,
        eatFruits: birdType.eatFruits || false,
        eatProbability: birdType.eatProbability || 0,
        eatDuration: birdType.eatDuration || 0,
        originalSize: birdType.originalSize || birdType.size,
        poopInterval: birdType.poopInterval || 0,
        poopProbability: birdType.poopProbability || 0,
        poopColor: birdType.poopColor || null,
        isPredator: birdType.isPredator || false,
        diveSpeedMultiplier: birdType.diveSpeedMultiplier || 1,
        catchDoveChance: birdType.catchDoveChance || 0,
        catchMouseChance: birdType.catchMouseChance || 0,
        leaveChance: birdType.leaveChance || 0,
        scareOtherBirds: birdType.scareOtherBirds || false,
        longBeak: birdType.longBeak || false,
        beakReducedQuarter: birdType.beakReducedQuarter || false,
        halfBeak: birdType.halfBeak || false,
        quarterBeak: birdType.quarterBeak || false,
        huntingBird: birdType.behavior === 'circleThenHuntBird',
        huntingMouse: birdType.behavior === 'circleThenHoverThenHuntMouse',
        faceScreen: birdType.faceScreen || false,
        isNight: false
    };
    
    if (birdType.name === "å¤œé¹­") {
        bird.isNight = false;
    }
    
    if (birdType.behavior === 'circleThenHuntBird' || birdType.behavior === 'circleThenHunt' || birdType.behavior === 'circleThenHoverThenHuntMouse') {
        bird.circlingCenterX = GAME_WIDTH * 0.5;
        bird.circlingCenterY = GAME_HEIGHT * 0.3;
        bird.state = 'circling';
        bird.speed = 1.5;
    }
    
    if (birdType.isKingfisher) {
        bird.state = 'flyingToReed';
        bird.targetX = reedZone.x + Math.random() * reedZone.width;
        bird.targetY = reedZone.y + reedZone.height * 0.7;
        // é‡æ–°è°ƒæ•´åˆå§‹Yåæ ‡ï¼Œé¿å…ç›´æ¥ç”Ÿæˆåœ¨ç›®æ ‡ä½ç½®
        bird.y = reedZone.y + reedZone.height * 0.5 + Math.random() * (GAME_HEIGHT * 0.1);
        bird.headAngle = 0;
        bird.turnInterval = birdType.turnInterval[0] + Math.random() * (birdType.turnInterval[1] - birdType.turnInterval[0]);
        bird.stayTime = birdType.stayTime[0] + Math.random() * (birdType.stayTime[1] - birdType.stayTime[0]);
        bird.nextTurnTime = gameTime + bird.turnInterval;
        bird.facingDirection = bird.direction;
    }
    
    return bird;
}

function generateMagpie(countStats = false) {
    const magpieType = BIRD_TYPES.MAGPIE;
    if (countStats) {
        appearedBirds[magpieType.name]++;
        updateTextStats();
    }
    
    const fromLeft = Math.random() > 0.5;
    const birdCount = getRandomGroupSize(magpieType);
    const groupId = nextGroupId++;
    birdGroupInfo[groupId] = { direction: fromLeft ? 1 : -1, birds: [] };
    
    for (let i = 0; i < birdCount; i++) {
        const startX = fromLeft ? -50 : GAME_WIDTH + 50;
        const startY = Math.random() * (GAME_HEIGHT * 0.6) + GAME_HEIGHT * 0.2;
        
        const bird = createCommonBird(
            magpieType, 
            startX, 
            startY, 
            fromLeft, 
            "landOnTree", 
            magpieType.stayTime, 
            (2 + Math.random()) * 2,
            groupId
        );
        
        bird.whiteEyeRing = true;
        bird.longBlackTail = true;
        bird.eatFruits = true;
        bird.eatProbability = 0.1;
        bird.eatDuration = 2000;
        bird.noStats = !countStats;
        bird.isNight = !isDaytime;
        
        birds.push(bird);
        birdGroupInfo[groupId].birds.push(bird);
    }
}

function generateHawfinchManual(countStats = false) {
    const hawfinchType = BIRD_TYPES.HAWFINCH;
    
    if (countStats) {
        appearedBirds[hawfinchType.name] = (appearedBirds[hawfinchType.name] || 0) + 1;
        updateTextStats();
    }
    
    const fromLeft = Math.random() > 0.5;
    const birdCount = getRandomGroupSize(hawfinchType);
    const groupId = nextGroupId++;
    
    birdGroupInfo[groupId] = {
        direction: fromLeft ? 1 : -1,
        birds: []
    };
    
    for (let i = 0; i < birdCount; i++) {
        const startX = fromLeft ? -50 : GAME_WIDTH + 50;
        const startY = Math.random() * (GAME_HEIGHT * 0.6) + GAME_HEIGHT * 0.2;
        
        // èœ¡å˜´é›€çš„è¡Œä¸ºé€šå¸¸æ˜¯åœåœ¨æ ‘ä¸Š
        let behavior = "landOnTreeTop";
        let stayTime = 15;
        
        // å°æ¦‚ç‡é£è¡Œ
        if (Math.random() < 0.2) {
            behavior = "flyThrough";
        }
        
        let baseSpeed = 1.6 + Math.random() * 0.8;
        const speedMultiplier = hawfinchType.speedMultiplier || 1;
        const finalSpeed = baseSpeed * speedMultiplier;
        
        const bird = createCommonBird(
            hawfinchType,
            startX,
            startY,
            fromLeft,
            behavior,
            stayTime,
            finalSpeed,
            groupId
        );
        
        // è®¾ç½®èœ¡å˜´é›€ç‰¹æœ‰å±æ€§
        bird.quarterBeak = true;
        bird.beakLengthMultiplier = 0.25;
        bird.isVulnerableToRaptors = true;
        bird.eatFruits = true;
        bird.eatProbability = 0.15;
        bird.eatDuration = 2000;
        bird.originalSize = hawfinchType.size;
        bird.noStats = !countStats;
        bird.isNight = !isDaytime;
        
        if (behavior === "landOnTreeTop") {
            bird.targetTree = treePositions[Math.floor(Math.random() * treePositions.length)];
            bird.x = bird.targetTree.x + Math.random() * bird.targetTree.width;
            bird.y = bird.targetTree.y + bird.targetTree.height * 0.2;
            bird.state = 'perching';
            bird.stateTime = 0;
            bird.speed = 0;
            bird.direction = bird.targetTree.side === 'left' ? 1 : -1;
        }
        
        birds.push(bird);
        birdGroupInfo[groupId].birds.push(bird);
    }
    
    // æ˜¾ç¤ºæç¤ºä¿¡æ¯
    showSpecialAlert(`ç”Ÿæˆèœ¡å˜´é›€ ${birdCount} åª`);
}

function generateBramblingManual(countStats = false) {
    const bramblingType = BIRD_TYPES.BRAMBLING;
    
    if (countStats) {
        appearedBirds[bramblingType.name] = (appearedBirds[bramblingType.name] || 0) + 1;
        updateTextStats();
    }
    
    const fromLeft = Math.random() > 0.5;
    const birdCount = getRandomGroupSize(bramblingType);
    const groupId = nextGroupId++;
    
    birdGroupInfo[groupId] = {
        direction: fromLeft ? 1 : -1,
        birds: []
    };
    
    for (let i = 0; i < birdCount; i++) {
        const startX = fromLeft ? -50 : GAME_WIDTH + 50;
        const startY = Math.random() * (GAME_HEIGHT * 0.6) + GAME_HEIGHT * 0.2;
        
        // ç‡•é›€çš„è¡Œä¸ºå¯ä»¥æ˜¯é£è¡Œæˆ–åœåœ¨æ ‘ä¸Š
        let behavior = "flyThrough";
        let stayTime = 10;
        
        if (Math.random() < 0.3) {
            behavior = "landOnTreeTop";
            stayTime = 10;
        }
        
        let baseSpeed = 1.6 + Math.random() * 0.8;
        const speedMultiplier = bramblingType.speedMultiplier || 1;
        const finalSpeed = baseSpeed * speedMultiplier;
        
        const bird = createCommonBird(
            bramblingType,
            startX,
            startY,
            fromLeft,
            behavior,
            stayTime,
            finalSpeed,
            groupId
        );
        
        // è®¾ç½®ç‡•é›€ç‰¹æœ‰å±æ€§
        bird.halfBeak = true;
        bird.isVulnerableToRaptors = true;
        bird.eatFruits = true;
        bird.eatProbability = 0.1;
        bird.eatDuration = 1800;
        bird.originalSize = bramblingType.size;
        bird.noStats = !countStats;
        bird.isNight = !isDaytime;
        
        if (behavior === "landOnTreeTop") {
            bird.targetTree = treePositions[Math.floor(Math.random() * treePositions.length)];
            bird.x = bird.targetTree.x + Math.random() * bird.targetTree.width;
            bird.y = bird.targetTree.y + bird.targetTree.height * 0.2;
            bird.state = 'perching';
            bird.stateTime = 0;
            bird.speed = 0;
            bird.direction = bird.targetTree.side === 'left' ? 1 : -1;
        }
        
        birds.push(bird);
        birdGroupInfo[groupId].birds.push(bird);
    }
    
    // æ˜¾ç¤ºæç¤ºä¿¡æ¯
    showSpecialAlert(`ç”Ÿæˆç‡•é›€ ${birdCount} åª`);
}

function generateKestrel(countStats = false) {
    const kestrelType = BIRD_TYPES.KESTREL;
    if (countStats) {
        appearedBirds[kestrelType.name]++;
        updateTextStats();
    }
    
    generateGroundMouseForPredator("çº¢éš¼");
    scareMode = true;
    scareModeEndTime = gameTime + 3000;
    
    const startX = GAME_WIDTH * 0.5 + (Math.random() - 0.5) * 200;
    const startY = -50;
    
    const bird = {
        type: kestrelType,
        name: kestrelType.name,
        x: startX,
        y: startY,
        size: kestrelType.size,
        speed: 1.5,
        direction: Math.random() > 0.5 ? 1 : -1,
        state: 'circling',
        stateTime: 0,
        circlingTime: 0,
        hoveringTime: 0,
        circlingRadius: 100 + Math.random() * 50,
        circlingAngle: Math.random() * Math.PI * 2,
        circlingCenterX: GAME_WIDTH * 0.5,
        circlingCenterY: GAME_HEIGHT * 0.3,
        hasDecided: false,
        decision: null,
        caughtPrey: null,
        isPredator: true,
        diveSpeed: 3.0,
        noStats: !countStats,
        isFleeingFromChasers: false,
        originalState: '',
        originalSpeed: 1.2,
        fleeFromChasersStartTime: 0,
        chasedStartTime: 0,
        maxChasedTime: 15000,
        whiteEyeRing: kestrelType.whiteEyeRing || false,
        yellowEyeRing: kestrelType.yellowEyeRing || false,
        hasBeenNearCenter: false,
        centerArrivalTime: 0,
        requiredCirclingWhenChasedCount: 1 + Math.floor(Math.random() * 3),
        circlingWhenChasedCount: 0,
        circlingWhenChasedStartTime: 0,
        circlingWhenChasedCenterX: 0,
        circlingWhenChasedCenterY: 0,
        circlingWhenChasedAngle: 0,
        circlingWhenChasedRadius: 300,
        isCirclingWhenChased: false,
        forcedToLeave: false,
        fleeDirection: 0,
        fleeSpeed: 0,
        isNight: !isDaytime,
        caughtMouse: null,
        mouseTarget: null,
        hasGeneratedMouse: true,
        hasFoundMouse: false,
        catchMouseChance: kestrelType.catchMouseChance || 0.5,
        catchDoveChance: kestrelType.catchDoveChance || 0.3,
        leaveChance: kestrelType.leaveChance || 0.2
    };
    
    birds.push(bird);
}

function generatePeregrine(countStats = true) {
    const peregrineType = BIRD_TYPES.PEREGRINE;
    if (countStats) {
        appearedBirds[peregrineType.name]++;
        updateTextStats();
    }
    
    const startX = GAME_WIDTH * 0.5 + (Math.random() - 0.5) * 200;
    const startY = -50;
    
    const bird = {
        type: peregrineType,
        name: peregrineType.name,
        x: startX,
        y: startY,
        size: peregrineType.size,
        speed: 1.5,
        direction: Math.random() > 0.5 ? 1 : -1,
        state: 'circling',
        stateTime: 0,
        circlingTime: 0,
        circlingRadius: 100 + Math.random() * 50,
        circlingAngle: Math.random() * Math.PI * 2,
        circlingCenterX: GAME_WIDTH * 0.5,
        circlingCenterY: GAME_HEIGHT * 0.3,
        huntingBird: true,
        hasLanded: false,
        groundTime: 0,
        isBeingChased: false,
        escapeDirection: 0,
        escapeSpeed: 0,
        isEscaping: false,
        escapeStartTime: 0,
        originalState: '',
        originalSpeed: 1.5,
        noStats: !countStats,
        isFleeingFromChasers: false,
        fleeFromChasersStartTime: 0,
        chasedStartTime: 0,
        maxChasedTime: 10000,
        whiteEyeRing: peregrineType.whiteEyeRing || false,
        yellowEyeRing: peregrineType.yellowEyeRing || false,
        hasBeenNearCenter: false,
        centerArrivalTime: 0,
        requiredCirclingWhenChasedCount: 1 + Math.floor(Math.random() * 3),
        circlingWhenChasedCount: 0,
        circlingWhenChasedStartTime: 0,
        circlingWhenChasedCenterX: 0,
        circlingWhenChasedCenterY: 0,
        circlingWhenChasedAngle: 0,
        circlingWhenChasedRadius: 300,
        isCirclingWhenChased: false,
        forcedToLeave: false,
        fleeDirection: 0,
        fleeSpeed: 0,
        isNight: !isDaytime,
        originalState: 'circling',
        hasTriggeredRaptorLeave: false
    };
    
    birds.push(bird);
}

function generateBlackWingedKite(countStats = true) {
    const kiteType = BIRD_TYPES.BLACKWINGEDKITE;
    if (countStats) {
        appearedBirds[kiteType.name]++;
        updateTextStats();
    }
    
    generateGroundMouseForPredator("é»‘ç¿…é¸¢");
    
    const startX = GAME_WIDTH * 0.5 + (Math.random() - 0.5) * 200;
    const startY = -50;
    
    const bird = {
        type: kiteType,
        name: kiteType.name,
        x: startX,
        y: startY,
        size: kiteType.size,
        speed: 1.5,
        direction: Math.random() > 0.5 ? 1 : -1,
        state: 'circling',
        stateTime: 0,
        circlingTime: 0,
        hoveringTime: 0,
        circlingRadius: 100 + Math.random() * 50,
        circlingAngle: Math.random() * Math.PI * 2,
        circlingCenterX: GAME_WIDTH * 0.5,
        circlingCenterY: GAME_HEIGHT * 0.3,
        huntingMouse: true,
        caughtMouse: null,
        mouseRelativeX: 15,
        mouseRelativeY: 10,
        mouseSwingAngle: 0,
        mouseSwingSpeed: 0.05 + Math.random() * 0.05,
        hasLanded: false,
        groundTime: 0,
        isBeingChased: false,
        escapeDirection: 0,
        escapeSpeed: 0,
        isEscaping: false,
        escapeStartTime: 0,
        originalState: '',
        originalSpeed: 1.2,
        mouseTarget: null,
        hasGeneratedMouse: false,
        noStats: !countStats,
        isFleeingFromChasers: false,
        fleeFromChasersStartTime: 0,
        chasedStartTime: 0,
        maxChasedTime: 20000,
        whiteEyeRing: kiteType.whiteEyeRing || false,
        hasBeenNearCenter: false,
        centerArrivalTime: 0,
        requiredCirclingWhenChasedCount: 1 + Math.floor(Math.random() * 3),
        circlingWhenChasedCount: 0,
        circlingWhenChasedStartTime: 0,
        circlingWhenChasedCenterX: 0,
        circlingWhenChasedCenterY: 0,
        circlingWhenChasedAngle: 0,
        circlingWhenChasedRadius: 300,
        isCirclingWhenChased: false,
        forcedToLeave: false,
        fleeDirection: 0,
        fleeSpeed: 0,
        isNight: !isDaytime,
        originalState: 'circling',
        hasTriggeredRaptorLeave: false,
        // é»‘ç¿…é¸¢ç‰¹æœ‰å±æ€§
        catchMouseChance: 0.5,
        leaveChance: 0.2
    };
    
    birds.push(bird);
}

function generateKentishPlover(countStats = false) {
    const kentishPloverType = BIRD_TYPES.KENTISH_PLOVER;
    
    if (countStats) {
        appearedBirds[kentishPloverType.name]++;
        updateTextStats();
    }
    
    const fromLeft = Math.random() > 0.5;
    const birdCount = getRandomGroupSize(kentishPloverType);
    const groupId = nextGroupId++;
    
    // âœ… æ–°å¢ï¼šå°ç»„ç»Ÿä¸€å†³å®šè¡Œä¸º
    let groupBehavior = "flyThrough"; // é»˜è®¤é£è¿‡
    let groupStayTime = kentishPloverType.stayTime || 10;
    
    // æ•´ä¸ªå°ç»„ç»Ÿä¸€å†³å®šæ˜¯å¦é™è½åœ¨èŠ¦è‹‡ä¸Š
    if (Math.random() < kentishPloverType.landOnReedsChance) {
        groupBehavior = "landOnReeds";
        groupStayTime = kentishPloverType.landOnReedsTime;
    }
    
    // âœ… æ–°å¢ï¼šä¸ºæ•´ä¸ªå°ç»„é€‰æ‹©ä¸€ä¸ªç»Ÿä¸€çš„èŠ¦è‹‡é™è½åŒºåŸŸ
    let groupReedTargetX = 0;
    let groupReedTargetY = 0;
    let groupGroundDirection = Math.random() > 0.5 ? 1 : -1;
    
    if (groupBehavior === "landOnReeds" && reedZone) {
        // å°ç»„é™è½åœ¨èŠ¦è‹‡çš„åŒä¸€ä¸ªåŒºåŸŸé™„è¿‘
        const baseX = reedZone.x + Math.random() * reedZone.width * 0.7;
        const baseY = reedZone.y + reedZone.height - 3;
        groupReedTargetX = baseX;
        groupReedTargetY = baseY;
    }
    
    birdGroupInfo[groupId] = {
        direction: fromLeft ? 1 : -1,
        birds: [],
        behavior: groupBehavior, // å­˜å‚¨å°ç»„è¡Œä¸º
        reedTargetX: groupReedTargetX,
        reedTargetY: groupReedTargetY,
        groundDirection: groupGroundDirection
    };
    
    for (let i = 0; i < birdCount; i++) {
        let startX, startY;
        
        // ä½¿ç”¨å°ç»„ç»Ÿä¸€çš„è¡Œä¸º
        startX = fromLeft ? -50 : GAME_WIDTH + 50;
        startY = Math.random() * (GAME_HEIGHT * 0.6) + GAME_HEIGHT * 0.2;
        
        let baseSpeed = (2.6 + Math.random() * 0.8);
        const speedMultiplier = kentishPloverType.speedMultiplier || 1;
        const finalSpeed = baseSpeed * speedMultiplier;
        
        const bird = createCommonBird(
            kentishPloverType, 
            startX, 
            startY, 
            fromLeft, 
            groupBehavior, // ä½¿ç”¨å°ç»„ç»Ÿä¸€è¡Œä¸º
            groupStayTime,  // ä½¿ç”¨å°ç»„ç»Ÿä¸€åœç•™æ—¶é—´
            finalSpeed, 
            groupId
        );
        
        bird.noStats = true;
        bird.yellowEyeRing = true;
        bird.groundPecking = true;
        bird.groundMoveSpeed = 0.3;
        
        if (groupBehavior === "landOnReeds" && reedZone) {
            // æ¯åªé¸Ÿåœ¨å°ç»„ç›®æ ‡ä½ç½®é™„è¿‘å°èŒƒå›´éšæœºåˆ†å¸ƒ
            const spreadX = (Math.random() - 0.5) * 60; // Â±30åƒç´ èŒƒå›´å†…
            const spreadY = (Math.random() - 0.5) * 20; // Â±10åƒç´ èŒƒå›´å†…
            
            bird.reedTargetX = groupReedTargetX + spreadX;
            bird.reedTargetY = groupReedTargetY + spreadY;
            bird.state = 'landingOnReeds';
            bird.groundDirection = groupGroundDirection; // ä½¿ç”¨å°ç»„ç»Ÿä¸€æ–¹å‘
            bird.isLandingOnReeds = true;
        }
        
        birds.push(bird);
        birdGroupInfo[groupId].birds.push(bird);
    }
}


function generateLittleOwl(countStats = true) {
    if (littleOwl) return;
    
    let cooldown;
    if (gameMode === 'day') {
        cooldown = LITTLE_OWL_DAY_COOLDOWN;
    } else if (gameMode === 'night') {
        cooldown = LITTLE_OWL_NIGHT_COOLDOWN;
    } else {
        cooldown = isDaytime ? LITTLE_OWL_DAY_COOLDOWN : LITTLE_OWL_NIGHT_COOLDOWN;
    }
    
    if (gameTime - lastLittleOwlTime < cooldown) {
        return;
    }
    
    const littleOwlType = BIRD_TYPES.LITTLE_OWL;
    if (countStats) {
        appearedBirds[littleOwlType.name]++;
        updateTextStats();
    }
    
    const baseSize = 20;
    const birdSize = baseSize * littleOwlType.size;
    const birdRadius = birdSize / 2;
    const holeBottomY = hole.y + hole.diameter / 2;
    const owlY = holeBottomY - birdRadius;
    
    const owl = {
        type: littleOwlType,
        name: littleOwlType.name,
        x: hole.x,
        y: owlY,
        size: littleOwlType.size,
        state: 'appearing',
        stateTime: 0,
        stayTime: littleOwlType.stayTime || 15,
        isBackground: littleOwlType.isBackground || false,
        whiteEyeRing: littleOwlType.whiteEyeRing || false,
        noStats: !countStats,
        isNight: !isDaytime
    };
    
    littleOwl = owl;
    birds.push(owl);
    lastLittleOwlTime = gameTime;
}

function generateGroundMouseForPredator(predatorName) {
    const mouse = {
        x: GAME_WIDTH * 0.3 + Math.random() * (GAME_WIDTH * 0.4),
        y: GAME_HEIGHT - 10,
        size: 8,
        color: "#D3D3D3",
        type: "mouse",
        createdAt: gameTime,
        lifetime: 10000,
        predatorTarget: predatorName
    };
    
    groundObjects.push(mouse);
    return mouse;
}

function generateHedgehog() {
    const hedgehog = {
        x: GAME_WIDTH * 0.3 + Math.random() * (GAME_WIDTH * 0.4),
        y: GAME_HEIGHT - 15,
        size: 12,
        color: "#A0522D",
        type: "hedgehog",
        createdAt: gameTime,
        lifetime: 15000,
        spikes: []
    };
    
    for (let i = 0; i < 24; i++) {
        const angle = (i / 24) * Math.PI * 2;
        const length = 3 + Math.random() * 1.5;
        hedgehog.spikes.push({ angle: angle, length: length });
    }
    
    groundObjects.push(hedgehog);
    return hedgehog;
}

function createBat(batType) {
    const startX = GAME_WIDTH * 0.5 + (Math.random() - 0.5) * 200;
    const startY = -50;
    
    const baseSpeed = (1.5 + Math.random());
    const speedMultiplier = batType.speedMultiplier || 1;
    const finalSpeed = baseSpeed * speedMultiplier;
    
    const circlingCenterY = GAME_HEIGHT * 0.25 + Math.random() * (GAME_HEIGHT * 0.25);
    
    const bat = {
        type: batType,
        name: batType.name,
        x: startX,
        y: startY,
        size: batType.size,
        speed: finalSpeed,
        direction: Math.random() > 0.5 ? 1 : -1,
        state: 'circling',
        stateTime: 0,
        circlingTime: 0,
        circlingRadius: 80 + Math.random() * 40,
        circlingAngle: Math.random() * Math.PI * 2,
        circlingCenterX: GAME_WIDTH * 0.5,
        circlingCenterY: circlingCenterY,
        isBat: true,
        circleTime: batType.circleTime || 15000,
        faceDirection: -1,
        faceChangeTimer: 0,
        faceChangeInterval: 10000 + Math.random() * 10000,
        wingsOpen: true,
        isNight: true,
        wingFlapTimer: 0,
        wingFlapSpeed: 0.1 + Math.random() * 0.05,
        maxConcurrent: batType.maxConcurrent || 3
    };
    
    return bat;
}

function spawnNightOwls() {
    let shortEaredOwlCount = 0;
    let eagleOwlCount = 0;
    
    for (const bird of birds) {
        if (bird.name === "çŸ­è€³é¸®") {
            shortEaredOwlCount++;
        } else if (bird.name === "é›•é¸®") {
            eagleOwlCount++;
        }
    }
    
    if (eagleOwlCount > 0) {
        if (shortEaredOwlCount >= MAX_SHORT_EARED_OWL_COUNT) {
            return;
        }
        const owlType = BIRD_TYPES.SHORT_EARED_OWL;
        createNightOwl(owlType);
        return;
    }
    
    const owlTypes = ['EAGLE_OWL', 'SHORT_EARED_OWL'];
    let selectedType = owlTypes[Math.floor(Math.random() * owlTypes.length)];
    
    if (selectedType === 'SHORT_EARED_OWL' && shortEaredOwlCount >= MAX_SHORT_EARED_OWL_COUNT) {
        selectedType = 'EAGLE_OWL';
    }
    
    const owlType = BIRD_TYPES[selectedType];
    
    appearedBirds[owlType.name]++;
    updateTextStats();
    
    createNightOwl(owlType);
}

function createNightOwl(owlType) {
    const bird = {
        type: owlType,
        name: owlType.name,
        x: GAME_WIDTH * 0.5 + (Math.random() - 0.5) * 200,
        y: owlType.flyInLowerHalf ? GAME_HEIGHT * 0.7 + Math.random() * 100 : -50,
        size: owlType.size,
        speed: 1.1 * (owlType.speedMultiplier || 1),
        direction: Math.random() > 0.5 ? 1 : -1,
        state: 'circling',
        stateTime: 0,
        circlingTime: 0,
        circlingRadius: 150 + Math.random() * 50,
        circlingAngle: Math.random() * Math.PI * 2,
        circlingCenterX: GAME_WIDTH * 0.5,
        circlingCenterY: owlType.flyInLowerHalf ? GAME_HEIGHT * 0.7 : GAME_HEIGHT * 0.3,
        isOwl: true,
        circleTime: owlType.circleTime || 30000,
        catchPreyChance: owlType.catchPreyChance || 0,
        catchPreyType: owlType.catchPreyType || null,
        caughtPrey: null,
        hasGlided: false,
        glidingStartY: 0,
        faceDirection: -1,
        faceChangeTimer: 0,
        faceChangeInterval: 10000 + Math.random() * 10000,
        wingsOpen: true,
        isFleeing: false,
        fleeStartTime: 0,
        isEagleOwl: owlType.name === "é›•é¸®",
        wingOffset: owlType.wingOffset || 0,
        isNight: true
    };
    
    if (owlType.name === "é›•é¸®") {
        for (const otherBird of birds) {
            if (otherBird.isOwl && otherBird.name === "çŸ­è€³é¸®") {
                otherBird.state = 'fleeing';
                otherBird.speed = otherBird.speed * 2;
                otherBird.direction = Math.random() > 0.5 ? 1 : -1;
                otherBird.fleeStartTime = gameTime;
            }
        }
    }
    
    birds.push(bird);
}

function startEatingFruit(bird) {
    let nearestFruit = null;
    let minDistance = Infinity;
    
    for (const fruit of fruits) {
        if (!fruit.isEaten && fruit.treeIndex === treePositions.indexOf(bird.targetTree)) {
            const dx = fruit.x - bird.x;
            const dy = fruit.y - bird.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < 50 && distance < minDistance) {
                minDistance = distance;
                nearestFruit = fruit;
            }
        }
    }
    
    if (nearestFruit) {
        bird.isEating = true;
        bird.eatingFruit = nearestFruit;
        bird.eatingTime = 0;
        bird.eatAnimationOffset = 0;
        
        nearestFruit.isEaten = true;
        nearestFruit.eatenBy = bird.name;
        nearestFruit.eatStartTime = gameTime;
        
        if (nearestFruit.color === "red") {
            nearestFruit.color = "#8B0000";
        } else if (nearestFruit.color === "yellow") {
            nearestFruit.color = "#DAA520";
        }
    }
}

function finishEatingFruit(bird) {
    bird.isEating = false;
    bird.eatingFruit = null;
    bird.eatingTime = 0;
    bird.eatAnimationOffset = 0;
    bird.size = bird.type.originalSize;
}

function drawNightObject(obj) {
    const baseSize = 20;
    const objSize = baseSize * obj.size;
    
    ctx.save();
    
    switch (obj.type.type) {
        case 'meteor':
            ctx.fillStyle = obj.color;
            ctx.beginPath();
            ctx.arc(obj.x, obj.y, objSize, 0, Math.PI * 2);
            ctx.fill();
            
            const trailLength = obj.trailLength;
            const trailX = obj.x - Math.cos(obj.angle) * trailLength;
            const trailY = obj.y - Math.sin(obj.angle) * trailLength;
            
            const gradient = ctx.createLinearGradient(trailX, trailY, obj.x, obj.y);
            gradient.addColorStop(0, 'rgba(255, 255, 200, 0)');
            gradient.addColorStop(0.5, obj.trailColor);
            gradient.addColorStop(1, 'rgba(255, 255, 200, 0)');
            
            ctx.strokeStyle = gradient;
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(trailX, trailY);
            ctx.lineTo(obj.x, obj.y);
            ctx.stroke();
            break;
            
        case 'comet':
            const coreRadius = objSize * (1/3);
            ctx.fillStyle = obj.color;
            ctx.beginPath();
            ctx.arc(obj.x, obj.y, coreRadius, 0, Math.PI * 2);
            ctx.fill();
            
            const tailLength = obj.tailLength * 8;
            const tailX = obj.x - Math.cos(obj.angle) * tailLength;
            const tailY = obj.y - Math.sin(obj.angle) * tailLength;
            const halfTailWidth = tailLength * Math.tan(5 * Math.PI / 180);
            const tailWidth = 2 * halfTailWidth;
            
            const tailGradient = ctx.createRadialGradient(
                obj.x, obj.y, 0,
                tailX, tailY, tailLength * 0.8
            );
            tailGradient.addColorStop(0, "rgba(173, 216, 230, 0.4)");
            tailGradient.addColorStop(0.3, obj.tailColor);
            tailGradient.addColorStop(0.7, "rgba(135, 206, 235, 0.2)");
            tailGradient.addColorStop(1, 'rgba(135, 206, 235, 0)');
            
            ctx.fillStyle = tailGradient;
            ctx.beginPath();
            ctx.moveTo(obj.x, obj.y);
            ctx.lineTo(tailX - halfTailWidth, tailY - tailLength * 0.05);
            ctx.lineTo(tailX + halfTailWidth, tailY + tailLength * 0.05);
            ctx.closePath();
            ctx.fill();
            break;
            
        case 'ufo':
            ctx.fillStyle = obj.color;
            ctx.beginPath();
            ctx.ellipse(obj.x, obj.y, objSize * 1.5, objSize * 0.8, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#32CD32';
            ctx.beginPath();
            ctx.ellipse(obj.x, obj.y - objSize * 0.5, objSize, objSize * 0.5, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#FFFF00';
            for (let i = 0; i < 5; i++) {
                const lightX = obj.x - objSize + i * (objSize / 2);
                ctx.beginPath();
                ctx.arc(lightX, obj.y + objSize * 0.3, 2, 0, Math.PI * 2);
                ctx.fill();
            }
            
            if (obj.beamActive) {
                const beamPulse = Math.sin(gameTime * 0.005 + obj.beamPhase) * 0.3 + 0.7;
                const beamGradient = ctx.createLinearGradient(
                    obj.x, obj.y + objSize,
                    obj.x, obj.y + obj.beamLength
                );
                beamGradient.addColorStop(0, `rgba(144, 238, 144, ${0.5 * beamPulse})`);
                beamGradient.addColorStop(1, 'rgba(144, 238, 144, 0)');
                
                ctx.fillStyle = beamGradient;
                ctx.beginPath();
                ctx.ellipse(obj.x, obj.y + obj.beamLength * 0.5, objSize * 0.8, obj.beamLength * 0.5, 0, 0, Math.PI * 2);
                ctx.fill();
            }
            break;
    }
    
    ctx.restore();
}

function updateNightObjects(deltaTime) {
    if (gamePaused) return;
    
    for (let i = nightObjects.length - 1; i >= 0; i--) {
        const obj = nightObjects[i];
        
        if (gameTime - obj.createdAt > obj.duration) {
            nightObjects.splice(i, 1);
            continue;
        }
        
        if (obj.type.type === 'meteor' && !obj.hasSummoned) {
            if (gameTime - obj.createdAt > 500) {
                if (Math.random() < obj.summonProbability) {
                    generateMeteor(false, true, obj.intersectionPoint);
                }
                obj.hasSummoned = true;
            }
        }
        
        switch (obj.type.type) {
            case 'meteor':
                obj.x += Math.cos(obj.angle) * obj.speed;
                obj.y += Math.sin(obj.angle) * obj.speed;
                
                const dx = obj.x - (obj.targetPoint?.x || 0);
                const dy = obj.y - (obj.targetPoint?.y || 0);
                const distanceToTarget = Math.sqrt(dx * dx + dy * dy);
                
                const isOutOfBounds = obj.x < -2000 || obj.x > GAME_WIDTH + 2000 || obj.y < -2000 || obj.y > GAME_HEIGHT + 2000;
                const isBelowMountain = obj.y >= GAME_HEIGHT * 0.55;
                const isNearTarget = distanceToTarget < 50;
                
                if (isOutOfBounds || isBelowMountain || isNearTarget) {
                    nightObjects.splice(i, 1);
                }
                break;
                
            case 'comet':
                obj.x += Math.cos(obj.angle) * obj.speed;
                obj.y += Math.sin(obj.angle) * obj.speed;
                
                if (obj.y > GAME_HEIGHT + 100) {
                    nightObjects.splice(i, 1);
                }
                break;
                
            case 'ufo':
                obj.x += obj.speed * obj.direction * (deltaTime / 1000);
                obj.y += Math.sin(gameTime * 0.001) * 0.5;
                
                if ((obj.direction === -1 && obj.x < -100) || (obj.direction === 1 && obj.x > GAME_WIDTH + 100)) {
                    nightObjects.splice(i, 1);
                }
                break;
        }
    }
}

function drawBackground() {
    const isNightMode = gameMode === 'night' || (gameMode === 'normal' && !isDaytime);
    
    if (!isNightMode) {
        const gradient = ctx.createLinearGradient(0, 0, 0, GAME_HEIGHT);
        gradient.addColorStop(0, '#87CEEB');
        gradient.addColorStop(1, '#E0F7FF');
        ctx.fillStyle = gradient;
    } else {
        const gradient = ctx.createLinearGradient(0, 0, 0, GAME_HEIGHT);
        gradient.addColorStop(0, '#191970');
        gradient.addColorStop(0.5, '#000033');
        gradient.addColorStop(1, '#000000');
        ctx.fillStyle = gradient;
    }
    
    ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
}

function drawSunMoon() {
    if (gameMode !== 'normal') {
        return;
    }
    
    const archHeight = 350;
    const t = sunMoonPosition;
    
    const archX = GAME_WIDTH * (1 - t);
    const verticalOffset = GAME_HEIGHT / 3;
    const archY = (GAME_HEIGHT - verticalOffset) - (Math.sin(t * Math.PI) * archHeight);
    
    const minY = 50;
    const finalY = Math.max(minY, archY);
    
    sunMoonX = archX;
    sunMoonY = finalY;
    
    const isNightMode = gameMode === 'normal' && !isDaytime;
    
    if (!isNightMode) {
        const sunGradient = ctx.createRadialGradient(
            archX, finalY, 0,
            archX, finalY, 40
        );
        sunGradient.addColorStop(0, '#FFFF00');
        sunGradient.addColorStop(0.7, '#FFD700');
        sunGradient.addColorStop(1, 'rgba(255, 215, 0, 0.3)');
        
        ctx.fillStyle = sunGradient;
        ctx.beginPath();
        ctx.arc(archX, finalY, 40, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = 'rgba(255, 255, 200, 0.2)';
        ctx.beginPath();
        ctx.arc(archX, finalY, 60, 0, Math.PI * 2);
        ctx.fill();
    } else {
        drawMoon(archX, finalY);
    }
}

function drawMoon(x, y) {
    const moonRadius = 30;
    
    ctx.save();
    
    const phase = (moonPhaseTimer / MOON_PHASE_CYCLE) % 1;
    
    let glowIntensity = 0.15;
    if (phase === 0.5) {
        glowIntensity = 0.25;
    } else if (phase < 0.25 || phase > 0.75) {
        glowIntensity = 0.05;
    }
    
    ctx.fillStyle = `rgba(240, 240, 255, ${glowIntensity})`;
    ctx.beginPath();
    ctx.arc(x, y, 50, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = '#F0F0F0';
    ctx.beginPath();
    ctx.arc(x, y, moonRadius, 0, Math.PI * 2);
    ctx.fill();
    
    if (phase > 0 && phase < 0.5) {
        const illumination = 0.5 - phase;
        const gradient = ctx.createRadialGradient(
            x + illumination * moonRadius * 2, y, 0,
            x, y, moonRadius
        );
        
        if (phase < 0.25) {
            gradient.addColorStop(0, 'rgba(0, 0, 51, 0.9)');
            gradient.addColorStop(0.3, 'rgba(0, 0, 51, 0.6)');
            gradient.addColorStop(0.6, 'rgba(0, 0, 51, 0.3)');
            gradient.addColorStop(1, 'rgba(0, 0, 51, 0)');
        } else {
            gradient.addColorStop(0, 'rgba(0, 0, 51, 0.7)');
            gradient.addColorStop(0.5, 'rgba(0, 0, 51, 0.4)');
            gradient.addColorStop(1, 'rgba(0, 0, 51, 0)');
        }
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(x, y, moonRadius, 0, Math.PI * 2);
        ctx.fill();
        
        const edgeGradient = ctx.createRadialGradient(
            x, y, moonRadius - 2,
            x, y, moonRadius + 5
        );
        edgeGradient.addColorStop(0, 'rgba(240, 240, 255, 0.3)');
        edgeGradient.addColorStop(1, 'rgba(240, 240, 255, 0)');
        
        ctx.fillStyle = edgeGradient;
        ctx.beginPath();
        ctx.arc(x, y, moonRadius + 5, 0, Math.PI * 2);
        ctx.fill();
    } else if (phase > 0.5 && phase < 1) {
        const illumination = phase - 0.5;
        const gradient = ctx.createRadialGradient(
            x - illumination * moonRadius * 2, y, 0,
            x, y, moonRadius
        );
        
        if (phase < 0.75) {
            gradient.addColorStop(0, 'rgba(0, 0, 51, 0.9)');
            gradient.addColorStop(0.3, 'rgba(0, 0, 51, 0.6)');
            gradient.addColorStop(0.6, 'rgba(0, 0, 51, 0.3)');
            gradient.addColorStop(1, 'rgba(0, 0, 51, 0)');
        } else {
            gradient.addColorStop(0, 'rgba(0, 0, 51, 0.7)');
            gradient.addColorStop(0.5, 'rgba(0, 0, 51, 0.4)');
            gradient.addColorStop(1, 'rgba(0, 0, 51, 0)');
        }
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(x, y, moonRadius, 0, Math.PI * 2);
        ctx.fill();
        
        const edgeGradient = ctx.createRadialGradient(
            x, y, moonRadius - 2,
            x, y, moonRadius + 5
        );
        edgeGradient.addColorStop(0, 'rgba(240, 240, 255, 0.3)');
        edgeGradient.addColorStop(1, 'rgba(240, 240, 255, 0)');
        
        ctx.fillStyle = edgeGradient;
        ctx.beginPath();
        ctx.arc(x, y, moonRadius + 5, 0, Math.PI * 2);
        ctx.fill();
    } else if (phase === 0 || phase === 1) {
        ctx.fillStyle = 'rgba(0, 0, 51, 0.95)';
        ctx.beginPath();
        ctx.arc(x, y, moonRadius, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = 'rgba(240, 240, 255, 0.05)';
        ctx.beginPath();
        ctx.arc(x, y, moonRadius + 3, 0, Math.PI * 2);
        ctx.fill();
    }
    
    if (phase !== 0 && phase !== 1) {
        let craterBrightness = 0.8;
        if (phase < 0.5) {
            craterBrightness = 0.7 + (phase * 0.6);
        } else {
            craterBrightness = 0.7 + ((1 - phase) * 0.6);
        }
        
        ctx.fillStyle = `rgba(208, 208, 208, ${craterBrightness})`;
        
        if (phase < 0.5) {
            ctx.beginPath();
            ctx.arc(x + 10, y - 5, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + 15, y + 10, 8, 0, Math.PI * 2);
            ctx.fill();
        } else if (phase > 0.5) {
            ctx.beginPath();
            ctx.arc(x - 10, y - 5, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x - 15, y + 10, 8, 0, Math.PI * 2);
            ctx.fill();
        }
        
        if (phase > 0.2 && phase < 0.8) {
            ctx.beginPath();
            ctx.arc(x - 20, y + 15, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + 5, y - 15, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + 8, y + 18, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x - 12, y - 10, 3, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    
    ctx.restore();
}

function drawWallAndHole() {
    if (!wall || !hole) return;
    
    ctx.fillStyle = wall.color;
    ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
    
    ctx.strokeStyle = '#A9A9A9';
    ctx.lineWidth = 2;
    
    for (let i = 0; i < 5; i++) {
        const x = wall.x + (i + 1) * wall.width / 6;
        ctx.beginPath();
        ctx.moveTo(x, wall.y);
        ctx.lineTo(x, wall.y + wall.height);
        ctx.stroke();
    }
    
    for (let i = 0; i < 3; i++) {
        const y = wall.y + (i + 1) * wall.height / 4;
        ctx.beginPath();
        ctx.moveTo(wall.x, y);
        ctx.lineTo(wall.x + wall.width, y);
        ctx.stroke();
    }
    
    ctx.save();
    ctx.beginPath();
    ctx.rect(wall.x, wall.y, wall.width, wall.height);
    ctx.arc(hole.x, hole.y, hole.diameter / 2, 0, Math.PI * 2);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
    
    ctx.strokeStyle = '#5D4037';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(hole.x, hole.y, hole.diameter / 2, 0, Math.PI * 2);
    ctx.stroke();
    
    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
    ctx.beginPath();
    ctx.arc(hole.x, hole.y, hole.diameter / 2 - 2, 0, Math.PI * 2);
    ctx.fill();
}

function drawTrees() {
    treePositions.forEach(tree => {
        ctx.fillStyle = '#2F4F4F';
        ctx.fillRect(tree.x + tree.width * 0.4, tree.y + tree.height * 0.7, tree.width * 0.2, tree.height * 0.3);
        
        ctx.fillStyle = '#2E8B57';
        ctx.beginPath();
        ctx.ellipse(tree.x + tree.width/2, tree.y + tree.height * 0.4, tree.width/2, tree.height * 0.5, 0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#228B22';
        
        fixedLeaves.forEach(leaf => {
            if (leaf.treeIndex === treePositions.indexOf(tree)) {
                ctx.save();
                ctx.translate(leaf.x + leaf.offsetX, leaf.y + leaf.offsetY);
                ctx.rotate(leaf.rotation);
                
                ctx.fillStyle = leaf.color;
                if (leaf.type === 0) {
                    ctx.beginPath();
                    ctx.arc(0, 0, leaf.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.strokeStyle = '#1A6B1A';
                    ctx.lineWidth = 0.5;
                    ctx.beginPath();
                    ctx.moveTo(0, -leaf.size/2);
                    ctx.lineTo(0, leaf.size/2);
                    ctx.stroke();
                } else if (leaf.type === 1) {
                    ctx.beginPath();
                    ctx.ellipse(0, 0, leaf.size, leaf.size/1.5, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.strokeStyle = '#1A6B1A';
                    ctx.lineWidth = 0.5;
                    ctx.beginPath();
                    ctx.moveTo(-leaf.size/2, 0);
                    ctx.lineTo(leaf.size/2, 0);
                    ctx.stroke();
                } else {
                    ctx.beginPath();
                    ctx.moveTo(0, -leaf.size);
                    ctx.lineTo(leaf.size/1.5, 0);
                    ctx.lineTo(0, leaf.size);
                    ctx.lineTo(-leaf.size/1.5, 0);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.strokeStyle = '#1A6B1A';
                    ctx.lineWidth = 0.5;
                    ctx.beginPath();
                    ctx.moveTo(0, -leaf.size);
                    ctx.lineTo(0, leaf.size);
                    ctx.stroke();
                }
                
                ctx.restore();
            }
        });
    });
    
    drawFruits();
}

function drawFruits() {
    fruits.forEach(fruit => {
        if (fruit.isEaten) {
            ctx.globalAlpha = 0.6;
        } else {
            ctx.globalAlpha = 1;
        }
        
        if (fruit.color === "red" || fruit.color === "#8B0000") {
            ctx.fillStyle = fruit.isEaten ? "#8B0000" : "#FF4500";
        } else {
            ctx.fillStyle = fruit.isEaten ? "#DAA520" : "#FFD700";
        }
        
        ctx.beginPath();
        ctx.arc(fruit.x, fruit.y, fruit.size, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.strokeStyle = '#8B4513';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(fruit.x, fruit.y - fruit.size);
        ctx.lineTo(fruit.x, fruit.y - fruit.size - 4);
        ctx.stroke();
        
        ctx.globalAlpha = 1;
        
        if (fruit.isEaten && fruit.eatenBy) {
            const timeSinceEaten = gameTime - fruit.eatStartTime;
            if (timeSinceEaten < 1000) {
                ctx.fillStyle = 'rgba(255, 255, 200, 0.3)';
                ctx.beginPath();
                ctx.arc(fruit.x, fruit.y, fruit.size * 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    });
}

function drawReeds() {
  if (!reedZone) return;
  
  const reedCount = reedBends.length;
  for (let i = 0; i < reedCount; i++) {
    const reedX = reedZone.x + (i / reedCount) * reedZone.width;
    const reedBend = reedBends[i] || { 
      bendAmount: 0, 
      bendPointRatio: 0.5, 
      topBendAmount: 0, 
      reedType: 0, 
      reedColor: '#8B4513', 
      topColor: '#DAA520', 
      reedWidth: 1.0 
    };
    
    const reedType = reedBend.reedType;
    let reedHeight, reedY;
    
    // æ ¹æ®èŠ¦è‹‡ç±»å‹å†³å®šé«˜åº¦
    switch(reedType) {
      case 0: reedHeight = reedZone.height * (0.5 + ((i % 10) / 25)); break;
      case 1: reedHeight = reedZone.height * (0.6 + ((i % 8) / 20)); break;
      case 2: reedHeight = reedZone.height * (0.7 + ((i % 12) / 30)); break;
      case 3: reedHeight = reedZone.height * (0.4 + ((i % 15) / 35)); break;
      case 4: reedHeight = reedZone.height * (0.3 + ((i % 6) / 15)); break;
      case 5: reedHeight = reedZone.height * (0.5 + ((i % 10) / 22)); break;
      default: reedHeight = reedZone.height * (0.5 + ((i % 10) / 20)); break;
    }
    
    // èŠ¦è‹‡ä»åœ°é¢å¼€å§‹ç”Ÿé•¿ï¼ˆyåæ ‡æ˜¯èŠ¦è‹‡åº•éƒ¨ï¼‰
    reedY = GAME_HEIGHT - reedHeight;
    
    const bendAmount = reedBend.bendAmount;
    const bendPoint = reedHeight * reedBend.bendPointRatio;
    const topBendAmount = reedBend.topBendAmount;
    
    // ç»˜åˆ¶èŠ¦è‹‡èŒ
    ctx.strokeStyle = reedBend.reedColor;
    ctx.lineWidth = reedBend.reedWidth;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(reedX, reedY + reedHeight); // ä»åœ°é¢å¼€å§‹
    ctx.bezierCurveTo(
      reedX + bendAmount * (reedType === 3 ? 1.5 : 1),
      reedY + reedHeight - bendPoint,
      reedX + topBendAmount * (reedType === 5 ? 1.8 : 1),
      reedY + reedHeight * 0.2,
      reedX,
      reedY
    );
    ctx.stroke();
    
    // ç»˜åˆ¶èŠ¦è‹‡é¡¶éƒ¨
    let topSize;
    switch(reedType) {
      case 1: topSize = 4 + ((i % 5) / 1.5); break;
      case 4: topSize = 2 + ((i % 5) / 3); break;
      default: topSize = 3 + ((i % 5) / 2); break;
    }
    
    ctx.fillStyle = reedBend.topColor;
    switch(reedType) {
      case 0:
        ctx.beginPath();
        ctx.ellipse(reedX, reedY, topSize/2, topSize, 0, 0, Math.PI * 2);
        ctx.fill();
        break;
      case 1:
        ctx.beginPath();
        ctx.ellipse(reedX, reedY, topSize/1.5, topSize*1.2, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#B8860B';
        for (let j = 0; j < 3; j++) {
          const angle = (j / 3) * Math.PI * 2;
          const offsetX = Math.cos(angle) * (topSize/3);
          const offsetY = Math.sin(angle) * (topSize/1.5);
          ctx.beginPath();
          ctx.arc(reedX + offsetX, reedY + offsetY, 1, 0, Math.PI * 2);
          ctx.fill();
        }
        break;
      case 2:
        ctx.beginPath();
        ctx.ellipse(reedX, reedY, topSize/3, topSize*1.3, 0, 0, Math.PI * 2);
        ctx.fill();
        break;
      case 3:
        ctx.beginPath();
        ctx.ellipse(reedX, reedY, topSize/2, topSize*0.8, 0, 0, Math.PI * 2);
        ctx.fill();
        break;
      case 4:
        ctx.beginPath();
        ctx.arc(reedX, reedY, topSize, 0, Math.PI * 2);
        ctx.fill();
        break;
      case 5:
        ctx.beginPath();
        ctx.ellipse(reedX, reedY, topSize/2, topSize*0.9, topBendAmount * 0.1, 0, Math.PI * 2);
        ctx.fill();
        break;
      default:
        ctx.beginPath();
        ctx.arc(reedX, reedY, topSize, 0, Math.PI * 2);
        ctx.fill();
    }
    
    // ç»˜åˆ¶èŠ¦è‹‡èŠ‚
    if (reedType !== 4) {
      const jointCount = 2 + (i % 3);
      for (let j = 1; j <= jointCount; j++) {
        const jointY = reedY + reedHeight * (j / (jointCount + 1));
        const jointSize = reedBend.reedWidth * 0.7;
        ctx.fillStyle = '#654321';
        ctx.beginPath();
        ctx.arc(reedX, jointY, jointSize, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  }
}

function drawMountains() {
    const isNightMode = gameMode === 'night' || (gameMode === 'normal' && !isDaytime);
    
    ctx.fillStyle = !isNightMode ? '#4682B4' : '#2F4F4F';
    ctx.strokeStyle = !isNightMode ? '#FFFFFF' : '#1E1E1E';
    ctx.lineWidth = 4;
    
    ctx.beginPath();
    ctx.moveTo(-50, GAME_HEIGHT * 0.7);
    ctx.lineTo(200, GAME_HEIGHT * 0.5);
    ctx.lineTo(450, GAME_HEIGHT * 0.7);
    ctx.lineTo(-50, GAME_HEIGHT * 0.7);
    ctx.fill();
    ctx.stroke();
    
    ctx.beginPath();
    ctx.moveTo(300, GAME_HEIGHT * 0.75);
    ctx.lineTo(600, GAME_HEIGHT * 0.55);
    ctx.lineTo(900, GAME_HEIGHT * 0.75);
    ctx.lineTo(300, GAME_HEIGHT * 0.75);
    ctx.fill();
    ctx.stroke();
    
    ctx.beginPath();
    ctx.moveTo(700, GAME_HEIGHT * 0.8);
    ctx.lineTo(1000, GAME_HEIGHT * 0.6);
    ctx.lineTo(1300, GAME_HEIGHT * 0.8);
    ctx.lineTo(700, GAME_HEIGHT * 0.8);
    ctx.fill();
    ctx.stroke();
    
    ctx.strokeStyle = !isNightMode ? '#2F4F4F' : '#1E1E1E';
    ctx.lineWidth = 1;
    
    for (let i = 0; i < 5; i++) {
        const x = 50 + i * 80;
        ctx.beginPath();
        ctx.moveTo(x, GAME_HEIGHT * 0.7);
        ctx.lineTo(200, GAME_HEIGHT * 0.5 + i * 10);
        ctx.stroke();
    }
    
    for (let i = 0; i < 5; i++) {
        const x = 400 + i * 80;
        ctx.beginPath();
        ctx.moveTo(x, GAME_HEIGHT * 0.75);
        ctx.lineTo(600, GAME_HEIGHT * 0.55 + i * 10);
        ctx.stroke();
    }
}

function drawClouds() {
    const isNightMode = gameMode === 'night' || (gameMode === 'normal' && !isDaytime);
    if (isNightMode) return;
    
    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
    ctx.beginPath();
    ctx.arc(200, 100, 30, 0, Math.PI * 2);
    ctx.arc(240, 90, 40, 0, Math.PI * 2);
    ctx.arc(280, 100, 30, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.beginPath();
    ctx.arc(600, 150, 25, 0, Math.PI * 2);
    ctx.arc(640, 140, 35, 0, Math.PI * 2);
    ctx.arc(680, 150, 25, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.beginPath();
    ctx.arc(1000, 80, 30, 0, Math.PI * 2);
    ctx.arc(1040, 70, 40, 0, Math.PI * 2);
    ctx.arc(1080, 80, 30, 0, Math.PI * 2);
    ctx.fill();
}

// åˆå§‹åŒ–å›ºå®šæ˜Ÿæ˜Ÿ
function initStars() {
    stars = [];
    for (let i = 0; i < STARS_COUNT; i++) {
        stars.push({
            x: Math.random() * GAME_WIDTH,
            y: Math.random() * (GAME_HEIGHT * 0.5),
            size: Math.random() * 2 + 0.5,
            alpha: 0.5 + Math.random() * 0.3, // éšæœºé€æ˜åº¦
            twinkleSpeed: 0.5 + Math.random() * 1.5, // é—ªçƒé€Ÿåº¦
            twinkleOffset: Math.random() * Math.PI * 2 // é—ªçƒåç§»
        });
    }
}

// ä¿®æ”¹åçš„drawStarså‡½æ•°
function drawStars() {
    const isNightMode = gameMode === 'night' || (gameMode === 'normal' && !isDaytime);
    if (!isNightMode) return;
    
    stars.forEach(star => {
        // åŸºäºæ—¶é—´çš„é—ªçƒæ•ˆæœ
        const twinkle = 0.6 + 0.4 * Math.sin(gameTime * 0.002 * star.twinkleSpeed + star.twinkleOffset);
        
        // ç»˜åˆ¶æ˜Ÿæ˜Ÿä¸»ä½“
        ctx.fillStyle = `rgba(255, 255, 255, ${star.alpha * twinkle})`;
        ctx.beginPath();
        ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
        ctx.fill();
        
        // æ·»åŠ å¾®å°çš„å…‰æ™•æ•ˆæœï¼ˆå¯é€‰ï¼‰
        if (twinkle > 0.8) {
            ctx.fillStyle = `rgba(255, 255, 255, ${0.2 * (twinkle - 0.8)})`;
            ctx.beginPath();
            ctx.arc(star.x, star.y, star.size * 1.5, 0, Math.PI * 2);
            ctx.fill();
        }
    });
}

function drawLittleOwl(bird) {
    const baseSize = 20;
    const birdSize = baseSize * bird.size;
    
    ctx.save();
    
    ctx.fillStyle = "#D2B48C";
    ctx.beginPath();
    ctx.arc(bird.x, bird.y, birdSize/2, 0, Math.PI * 2);
    ctx.fill();
    
    let eyeRingColor = "#FFFFFF";
    let eyeColor = "#000000";
    
    if (bird.isNight) {
        eyeRingColor = "#FFFF99";
        eyeColor = "#FFFF99";
    }
    
    ctx.fillStyle = eyeRingColor;
    ctx.beginPath();
    ctx.arc(bird.x - 8, bird.y - 5, 4.2, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(bird.x + 8, bird.y - 5, 4.2, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = eyeColor;
    ctx.beginPath();
    ctx.arc(bird.x - 8, bird.y - 5, 2.1, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(bird.x + 8, bird.y - 5, 2.1, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = "#8B4513";
    ctx.beginPath();
    ctx.moveTo(bird.x - 3, bird.y + 5);
    ctx.lineTo(bird.x + 3, bird.y + 5);
    ctx.lineTo(bird.x, bird.y + 10);
    ctx.closePath();
    ctx.fill();
    
    ctx.strokeStyle = "#8B4513";
    ctx.lineWidth = 1;
    for (let i = 0; i < 6; i++) {
        const angle = (i * Math.PI * 2) / 6;
        const startX = bird.x + Math.cos(angle) * (birdSize/2 - 5);
        const startY = bird.y + Math.sin(angle) * (birdSize/2 - 5);
        const endX = bird.x + Math.cos(angle) * (birdSize/2 - 2);
        const endY = bird.y + Math.sin(angle) * (birdSize/2 - 2);
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(endX, endY);
        ctx.stroke();
    }
    
    ctx.restore();
}

function drawBat(bird) {
    const baseSize = 20;
    const birdSize = baseSize * bird.size;
    
    ctx.save();
    
    bird.wingFlapTimer += bird.wingFlapSpeed;
    const wingFlapOffset = Math.sin(bird.wingFlapTimer) * 5;
    
    const x = bird.x;
    const y = bird.y;
    
    const bodyWidth = 10;
    const bodyHeight = 6;
    
    ctx.fillStyle = "#333333";
    ctx.beginPath();
    ctx.ellipse(x, y, bodyWidth/2, bodyHeight/2, 0, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = "#333333";
    const headSize = 4;
    ctx.beginPath();
    ctx.moveTo(x + bodyWidth/2, y);
    ctx.lineTo(x + bodyWidth/2 + headSize, y - headSize/2);
    ctx.lineTo(x + bodyWidth/2 + headSize, y + headSize/2);
    ctx.closePath();
    ctx.fill();
    
    ctx.fillStyle = "#000000";
    ctx.beginPath();
    ctx.arc(x + bodyWidth/2 + headSize/2, y - headSize/4, 1, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(x + bodyWidth/2 + headSize/2, y + headSize/4, 1, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = "#666666";
    const wingLength = 15;
    const wingHeight = 8 + wingFlapOffset;
    
    const leftWingX = x - bodyWidth/2 - wingLength;
    const leftWingY = y - wingHeight/2;
    ctx.fillRect(leftWingX, leftWingY, wingLength, wingHeight);
    
    const rightWingX = x + bodyWidth/2;
    const rightWingY = y - wingHeight/2;
    ctx.fillRect(rightWingX, rightWingY, wingLength, wingHeight);
    
    ctx.restore();
}

function drawOwlBird(bird) {
    const baseSize = 20;
    const birdSize = baseSize * bird.size;
    
    ctx.save();
    drawOwlFrontNew(bird);
    
    if (bird.caughtPrey) {
        drawOwlPrey(bird);
    }
    
    ctx.restore();
}

function drawOwlFrontNew(bird) {
  const baseSize = 20;
  const birdSize = baseSize * bird.size;
  let bodyDiameter, headRadius, bodyRadius;
  
  if (bird.name === "é›•é¸®") {
    headRadius = birdSize * 0.4 * 1.2;
    bodyDiameter = headRadius * 1.1 * 2;
    bodyRadius = bodyDiameter / 2;
  } else if (bird.name === "çŸ­è€³é¸®") {
    // ä¿®æ”¹ï¼šå°†çŸ­è€³é¸®çš„å¤´éƒ¨å¢å¤§è‡³ä¸èº«ä½“ä¸€æ ·
    // å…ˆè®¡ç®—èº«ä½“åŠå¾„
    bodyRadius = birdSize * 0.4 * 1.3;
    bodyDiameter = bodyRadius * 2;
    // å¤´éƒ¨åŠå¾„ä¸èº«ä½“åŠå¾„ç›¸åŒ
    headRadius = bodyRadius;
  } else {
    bodyDiameter = birdSize * 0.8 * 1.2;
    headRadius = bodyDiameter / 2 * 0.8 * 1.2;
    bodyRadius = bodyDiameter / 2;
  }
  
  // è®¡ç®—åŸºç¡€ç¿…è†€é«˜åº¦
  let wingHeight = bodyDiameter * 0.25 * 2;
  const wingLength = bodyDiameter * 3 * 0.5;
  
  // ä¿®æ”¹ï¼šçŸ­è€³é¸®çš„ç¿…è†€é«˜åº¦å‡å°‘1/5
  if (bird.name === "çŸ­è€³é¸®") {
    wingHeight = wingHeight * 0.8; // å‡å°‘1/5ï¼Œå³åŸæ¥çš„80%
  }
  
  ctx.save();
  const x = bird.x;
  const y = bird.y;
  
  let bodyCenterX = x;
  let bodyCenterY = y;
  let headCenterX = x;
  let headCenterY;
  
  if (bird.name === "é›•é¸®") {
    headCenterY = y;
  } else if (bird.name === "çŸ­è€³é¸®") {
    headCenterY = y;
    bodyCenterY = y;
  } else {
    headCenterY = y - bodyRadius * 0.3;
    bodyCenterY = y;
  }
  
  // ç»˜åˆ¶èº«ä½“
  if (bird.name === "é›•é¸®") {
    ctx.fillStyle = "#666666";
  } else if (bird.name === "çŸ­è€³é¸®") {
    ctx.fillStyle = "#FFFFFF";
  } else {
    ctx.fillStyle = bird.type.bodyColor;
  }
  
  ctx.beginPath();
  ctx.arc(bodyCenterX, bodyCenterY, bodyRadius, 0, Math.PI * 2);
  ctx.fill();
  
  // ç»˜åˆ¶ç¿…è†€
  ctx.fillStyle = bird.type.wingColor;
  const leftWingX = bodyCenterX - bodyRadius - wingLength;
  const leftWingY = bodyCenterY - bodyRadius + (bird.wingOffset || 0) * bodyDiameter;
  ctx.fillRect(leftWingX, leftWingY, wingLength, wingHeight);
  
  const rightWingX = bodyCenterX + bodyRadius;
  const rightWingY = bodyCenterY - bodyRadius + (bird.wingOffset || 0) * bodyDiameter;
  ctx.fillRect(rightWingX, rightWingY, wingLength, wingHeight);
  
  // ç»˜åˆ¶å¤´éƒ¨
  ctx.fillStyle = bird.type.headColor;
  ctx.beginPath();
  ctx.arc(headCenterX, headCenterY, headRadius, 0, Math.PI * 2);
  ctx.fill();
  
  // ä¿®æ”¹ï¼šé‡æ–°è®¡ç®—çœ¼ç›åŠå¾„ï¼ˆåŸºäºç¼©å°1/4åçš„å¤´éƒ¨åŠå¾„ï¼‰
  const originalEyeRadius = headRadius * 0.2 * 1.2;
  const smallEyeRadius = originalEyeRadius * 0.75; // ç¼©å°1/4
  
  const eyeSpacing = headRadius * 0.4;
  const eyeY = headCenterY - headRadius * 0.1;
  
// === çŸ­è€³é¸®çš„çœ¼ç›å’Œçœ¼å‘¨çŸ©å½¢æ•ˆæœï¼ˆåœ¨ç™½è‰²è¦†ç›–å±‚ä¹‹å‰ï¼‰===
if (bird.name === "çŸ­è€³é¸®" && bird.type.blackEyeRing) {
  // ä¿®æ”¹ï¼šä½¿ç”¨æ–°çš„å¤´éƒ¨åŠå¾„è®¡ç®—é»‘è‰²çœ¼ç¯
  const outerRadius = headRadius * 1.15 * 1.2;
  const innerRadius = headRadius * 0.8;
  const headGradient = ctx.createRadialGradient(
    headCenterX, headCenterY, innerRadius * 0.5,
    headCenterX, headCenterY, outerRadius
  );
  // ä¿®æ”¹ï¼šé™ä½ç™½è‰²æ¸å˜çš„é€æ˜åº¦
  headGradient.addColorStop(0, 'rgba(255, 255, 255, 0.60)'); // é™ä½åˆ°60%é€æ˜åº¦
  headGradient.addColorStop(0.4, 'rgba(240, 240, 240, 0.50)'); // é™ä½åˆ°50%é€æ˜åº¦
  headGradient.addColorStop(0.8, 'rgba(220, 220, 220, 0.40)'); // é™ä½åˆ°40%é€æ˜åº¦
  headGradient.addColorStop(1, 'rgba(200, 200, 200, 0.30)'); // é™ä½åˆ°30%é€æ˜åº¦
  ctx.fillStyle = headGradient;
  ctx.beginPath();
  ctx.arc(headCenterX, headCenterY, outerRadius, 0, Math.PI * 2);
  ctx.fill();
  
  // ç»˜åˆ¶é»„è‰²çœ¼ç›
  ctx.fillStyle = bird.type.eyeColor; // #FFFF99 é»„è‰²
  ctx.beginPath();
  ctx.arc(headCenterX - eyeSpacing, eyeY, smallEyeRadius, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(headCenterX + eyeSpacing, eyeY, smallEyeRadius, 0, Math.PI * 2);
  ctx.fill();
}
  
  // === é›•é¸®çš„çœ¼ç›ï¼ˆåœ¨ç™½è‰²è¦†ç›–å±‚ä¹‹å‰ï¼‰===
  if (bird.name === "é›•é¸®") {
    // ä¿®æ”¹ï¼šä½¿ç”¨ç¼©å°åçš„çœ¼ç›åŠå¾„
    ctx.fillStyle = bird.type.eyeColor;
    ctx.beginPath();
    ctx.arc(headCenterX - eyeSpacing, eyeY, smallEyeRadius, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(headCenterX + eyeSpacing, eyeY, smallEyeRadius, 0, Math.PI * 2);
    ctx.fill();
  }
  
  // === å–™éƒ¨ï¼ˆåœ¨ç™½è‰²è¦†ç›–å±‚ä¹‹å‰ï¼‰===
  ctx.fillStyle = "#8B4513";
  const beakWidth = originalEyeRadius * 1.5; // ä½¿ç”¨åŸå§‹çœ¼ç›åŠå¾„è®¡ç®—å–™éƒ¨å¤§å°
  const beakHeight = originalEyeRadius * 1.2; // ä½¿ç”¨åŸå§‹çœ¼ç›åŠå¾„è®¡ç®—å–™éƒ¨å¤§å°
  const beakY = headCenterY + originalEyeRadius * 0.5; // ä½¿ç”¨åŸå§‹çœ¼ç›åŠå¾„è®¡ç®—å–™éƒ¨ä½ç½®
  ctx.beginPath();
  ctx.moveTo(headCenterX - beakWidth/2, beakY);
  ctx.lineTo(headCenterX + beakWidth/2, beakY);
  ctx.lineTo(headCenterX, beakY + beakHeight);
  ctx.closePath();
  ctx.fill();
  
  // é›•é¸®çš„è€³ç°‡ç¾½
  if (bird.name === "é›•é¸®") {
    const earLength = headRadius * 0.8;
    const earWidth = headRadius * 0.3;
    
    ctx.save();
    ctx.translate(headCenterX, headCenterY - headRadius * 0.5);
    ctx.rotate(-Math.PI/4);
    ctx.fillStyle = bird.type.headColor;
    ctx.beginPath();
    ctx.ellipse(0, -earLength/2, earWidth/2, earLength/2, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
    
    ctx.save();
    ctx.translate(headCenterX, headCenterY - headRadius * 0.5);
    ctx.rotate(Math.PI/4);
    ctx.fillStyle = bird.type.headColor;
    ctx.beginPath();
    ctx.ellipse(0, -earLength/2, earWidth/2, earLength/2, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
  
  // === çŸ­è€³é¸®çš„çœ¼ç›ï¼ˆåœ¨ç™½è‰²è¦†ç›–å±‚ä¹‹å‰ï¼‰===
  if (bird.name === "çŸ­è€³é¸®") {
    // ä¿®æ”¹ï¼šä½¿ç”¨ç¼©å°åçš„çœ¼ç›åŠå¾„
    ctx.fillStyle = bird.type.eyeColor;
    ctx.beginPath();
    ctx.arc(headCenterX - eyeSpacing, eyeY, smallEyeRadius, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(headCenterX + eyeSpacing, eyeY, smallEyeRadius, 0, Math.PI * 2);
    ctx.fill();
  }
  
  // === ä¸ºé›•é¸®å’ŒçŸ­è€³é¸®çš„æ­£é¢è„¸éƒ¨æ·»åŠ 30%é€æ˜åº¦çš„#FCFCFCè¦†ç›–å±‚ï¼ˆè¦†ç›–å¤´éƒ¨å’Œç¿…è†€ï¼‰===
  if (bird.name === "é›•é¸®" || bird.name === "çŸ­è€³é¸®") {
    // ä¿å­˜å½“å‰ç»˜å›¾çŠ¶æ€
    ctx.save();
    
    // 1. é¦–å…ˆç»˜åˆ¶ç¿…è†€çš„è¦†ç›–å±‚
    ctx.fillStyle = 'rgba(252, 252, 252, 0.3)';
    
    // å·¦ä¾§ç¿…è†€è¦†ç›–
    ctx.fillRect(leftWingX, leftWingY, wingLength, wingHeight);
    
    // å³ä¾§ç¿…è†€è¦†ç›–
    ctx.fillRect(rightWingX, rightWingY, wingLength, wingHeight);
    
    // 2. ç„¶åç»˜åˆ¶å¤´éƒ¨çš„è¦†ç›–å±‚
    const overlayGradient = ctx.createRadialGradient(
      headCenterX, headCenterY, headRadius * 0.5,
      headCenterX, headCenterY, headRadius
    );
    
    if (bird.name === "é›•é¸®") {
      overlayGradient.addColorStop(0, 'rgba(252, 252, 252, 0.25)');
      overlayGradient.addColorStop(0.7, 'rgba(252, 252, 252, 0.30)');
      overlayGradient.addColorStop(1, 'rgba(252, 252, 252, 0.35)');
    } else {
      overlayGradient.addColorStop(0, 'rgba(252, 252, 252, 0.20)');
      overlayGradient.addColorStop(0.7, 'rgba(252, 252, 252, 0.25)');
      overlayGradient.addColorStop(1, 'rgba(252, 252, 252, 0.30)');
    }
    
    ctx.fillStyle = overlayGradient;
    ctx.beginPath();
    ctx.arc(headCenterX, headCenterY, headRadius, 0, Math.PI * 2);
    ctx.fill();
    
    // æ¢å¤ç»˜å›¾çŠ¶æ€
    ctx.restore();
  }
  
  ctx.restore();
}

function drawOwlPrey(bird) {
    if (!bird.caughtPrey) return;
    
    ctx.save();
    const prey = bird.caughtPrey;
    const preyX = bird.x + (bird.direction === 1 ? 30 : -30);
    const preyY = bird.y + 20;
    
    if (prey.type === "mouse") {
        ctx.fillStyle = "#D3D3D3";
        const bodyWidth = 10;
        const bodyHeight = 6;
        ctx.beginPath();
        ctx.ellipse(preyX, preyY, bodyWidth/2, bodyHeight/2, 0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = "#D3D3D3";
        const headSize = 4;
        ctx.beginPath();
        ctx.moveTo(preyX + bodyWidth/2, preyY);
        ctx.lineTo(preyX + bodyWidth/2 + headSize, preyY - headSize/2);
        ctx.lineTo(preyX + bodyWidth/2 + headSize, preyY + headSize/2);
        ctx.closePath();
        ctx.fill();
        
        ctx.fillStyle = "#000000";
        ctx.beginPath();
        ctx.arc(preyX + bodyWidth/2 + headSize/2, preyY - headSize/4, 1, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(preyX + bodyWidth/2 + headSize/2, preyY + headSize/4, 1, 0, Math.PI * 2);
        ctx.fill();
    } else if (prey.type === "hedgehog") {
        ctx.fillStyle = "#A0522D";
        const bodySize = 8;
        ctx.beginPath();
        ctx.arc(preyX, preyY, bodySize, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = "#A0522D";
        ctx.beginPath();
        ctx.moveTo(preyX + bodySize, preyY);
        ctx.lineTo(preyX + bodySize * 1.5, preyY - bodySize * 0.5);
        ctx.lineTo(preyX + bodySize * 1.5, preyY + bodySize * 0.5);
        ctx.closePath();
        ctx.fill();
        
        ctx.strokeStyle = "#8B4513";
        ctx.lineWidth = 2;
        ctx.lineCap = "round";
        for (let i = 0; i < 24; i++) {
            const angle = (i / 24) * Math.PI * 2;
            const length = 3 + Math.random() * 1.5;
            const startX = preyX + Math.cos(angle) * bodySize;
            const startY = preyY + Math.sin(angle) * bodySize;
            const endX = preyX + Math.cos(angle) * (bodySize + length);
            const endY = preyY + Math.sin(angle) * (bodySize + length);
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.stroke();
        }
        
        ctx.fillStyle = "#000000";
        ctx.beginPath();
        ctx.arc(preyX + bodySize * 1.2, preyY - bodySize * 0.2, 1, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = "#000000";
        ctx.beginPath();
        ctx.arc(preyX + bodySize * 1.5, preyY, 0.8, 0, Math.PI * 2);
        ctx.fill();
    }
    
    ctx.restore();
}

function drawOwl(bird) {
  const baseSize = 20;
  const birdSize = baseSize * bird.size;
  ctx.save();
  
  // æ ¹æ®æ˜¯å¦æ˜¯å¤œé—´é€‰æ‹©çœ¼ç›é¢œè‰²
  let eyeColor = bird.isNight ? "#FFFF99" : "#FFA500"; // å¤œé—´äº®é»„è‰²ï¼Œæ—¥é—´æ©™é»„è‰²
  
  ctx.fillStyle = "#8B4513";
  ctx.beginPath();
  ctx.arc(bird.x, bird.y, birdSize/2, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.fillStyle = eyeColor;
  ctx.beginPath();
  ctx.arc(bird.x - 8, bird.y - 5, 4, 0, Math.PI * 2);
  ctx.arc(bird.x + 8, bird.y - 5, 4, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.fillStyle = "#FFFF00";
  ctx.beginPath();
  ctx.moveTo(bird.x - 3, bird.y + 5);
  ctx.lineTo(bird.x + 3, bird.y + 5);
  ctx.lineTo(bird.x, bird.y + 10);
  ctx.closePath();
  ctx.fill();
  
  ctx.fillStyle = "#8B4513";
  ctx.beginPath();
  ctx.moveTo(bird.x - 8, bird.y - birdSize/2 - 16);
  ctx.lineTo(bird.x - 12, bird.y - birdSize/2 + 20 - 16);
  ctx.lineTo(bird.x - 4, bird.y - birdSize/2 + 15 - 16);
  ctx.closePath();
  ctx.fill();
  
  ctx.beginPath();
  ctx.moveTo(bird.x + 8, bird.y - birdSize/2 - 16);
  ctx.lineTo(bird.x + 12, bird.y - birdSize/2 + 20 - 16);
  ctx.lineTo(bird.x + 4, bird.y - birdSize/2 + 15 - 16);
  ctx.closePath();
  ctx.fill();
  
  ctx.restore();
}

function drawBird(bird) {
    ctx.save();
    
    // âœ… ç»Ÿä¸€å¤„ç†å‘å·¦é£è¡Œçš„é•œåƒ
    if (bird.direction === -1 && bird.state !== 'perching') {
        ctx.translate(bird.x * 2, 0);
        ctx.scale(-1, 1);
    }
  // æ£€æŸ¥æ˜¯å¦ä¸ºç¿ é¸Ÿ
  if (bird.isKingfisher) {
    drawKingfisher(bird);
        ctx.restore();
    return;
  }
    if (bird.name === "å°é¸®") {
        drawLittleOwl(bird);
        ctx.restore();
        return;
    }
    
    if (bird.isBat) {
        drawBat(bird);
        ctx.restore();
        return;
    }
    
    if (bird.isOwl) {
        drawOwlBird(bird);
        ctx.restore();
        return;
    }
    
    if ((bird.name === "å•„æœ¨é¸Ÿ" || bird.name === "å¤œé¹­") && bird.state === 'perching') {
        drawPerchingWoodpeckerOrHeron(bird);
        ctx.restore();
        return;
    }
    
    if (bird.name === "æˆ´èŠ" && bird.state === 'perching' && bird.riceBallAppearance) {
        drawRiceBallBird(bird);
        ctx.restore();
        return;
    }
    
// æ–°å¢ï¼šé•¿å°¾é›€ã€èœ¡å˜´é›€ã€ç‡•é›€ã€ç½—å®¾çš„ç‰¹æ®Šç»˜åˆ¶
  if (bird.name === "é•¿å°¾é›€") {
    drawLongtailedFinch(bird);
    ctx.restore();
    return;
  } else if (bird.name === "èœ¡å˜´é›€") {
    drawHawfinch(bird);
    ctx.restore();
    return;
  } else if (bird.name === "ç‡•é›€") {
    drawBrambling(bird);
    ctx.restore();
    return;
  } else if (bird.name === "ç½—å®¾") {
    drawRobin(bird);
    ctx.restore();
    return;
  }

    if ((bird.name === "çº¢éš¼" || bird.name === "é»‘ç¿…é¸¢") && bird.caughtMouse) {
        drawMouseInClaws(bird);
    }
    
    if (bird.name === "é•¿è€³é¸®" && bird.faceScreen) {
        drawOwl(bird);
        ctx.restore();
        return;
    }
    
    const baseSize = 20;
    let birdSize = baseSize * bird.size;
    const headSize = birdSize * 0.5;
    const bodySize = birdSize;
    
    ctx.save();
    
    let headOffsetY = 0;
    if (bird.isEating && bird.eatAnimationOffset) {
        headOffsetY = bird.eatAnimationOffset;
    }
    
    // Internal flip removed (handled globally)
    
    let bodyColor = bird.type.bodyColor;
    let headColor = bird.type.headColor;
    let wingColor = bird.type.wingColor;
    let tailColor = bird.type.tailColor;
    
    if (bird.name === "å¤œé¹­" && bird.isNight) {
        bodyColor = bird.nightBodyColor || "#808080";
        headColor = bird.nightBodyColor || "#808080";
        wingColor = bird.nightWingColor || "#4682B4";
        tailColor = bird.nightBodyColor || "#808080";
    } else if (bird.name !== "ç»¿å¤´é¸­") {
        if (bodyColor === "#00AA00") bodyColor = "#90EE90";
        if (headColor === "#00AA00") headColor = "#90EE90";
        if (wingColor === "#00AA00") wingColor = "#90EE90";
        if (tailColor === "#00AA00") tailColor = "#90EE90";
    }
    
    if (bird.type.variant && bird.variant !== undefined) {
        if (bird.name === "ç»¿å¤´é¸­") {
            if (bird.variant) {
                bodyColor = "#8B4513";
                headColor = "#8B4513";
                wingColor = "#8B4513";
            } else {
                bodyColor = "#FFFFFF";
                headColor = "#00AA00";
                wingColor = "#FF0000";
            }
        } else if (bird.name === "å±±æ¤’é¸Ÿ") {
            bodyColor = bird.variant ? "#FFFF00" : "#FF0000";
        }
    }
    
    ctx.fillStyle = bodyColor;
    ctx.beginPath();
    ctx.arc(bird.x, bird.y, bodySize/2, 0, Math.PI * 2);
    ctx.fill();
    
    if (bird.name === "ç™½é¹¡é¸°" && bird.hasHeart) {
        const heartX = bird.x;
        const heartY = bird.y - birdSize/6;
        const heartSize = 5;
        
        ctx.fillStyle = "#000000";
        ctx.save();
        ctx.translate(heartX, heartY);
        ctx.scale(1, 0.8);
        ctx.beginPath();
        ctx.moveTo(0, -heartSize/2);
        ctx.bezierCurveTo(
            heartSize/2, -heartSize/2,
            heartSize/2, heartSize/2,
            0, heartSize/2
        );
        ctx.bezierCurveTo(
            -heartSize/2, heartSize/2,
            -heartSize/2, -heartSize/2,
            0, -heartSize/2
        );
        ctx.fill();
        ctx.restore();
    }
    
    ctx.fillStyle = headColor || '#000000';
    ctx.beginPath();
    ctx.arc(
        bird.x + bodySize/2 - headSize/2,
        bird.y - bodySize/2 + headSize/2 + headOffsetY,
        headSize/2, 0, Math.PI * 2
    );
    ctx.fill();
    
    ctx.fillStyle = bird.type.color || '#000000';
    ctx.beginPath();
    
    const beakStartX = bird.x + bodySize/2 - headSize/2 + headSize/2;
    const beakStartY = bird.y - bodySize/2 + headSize/2 + headOffsetY;
    
    let beakLength = 8;
    let beakHeight = 5;
    
    if (bird.isEating) {
        beakHeight = 6;
        beakLength = 9;
    }
    
    if (bird.name === "å°åŒ—" && bird.fifthBeak) {
        beakLength = 1.6;
        beakHeight = 1;
        ctx.moveTo(beakStartX, beakStartY);
        ctx.lineTo(beakStartX + beakLength, beakStartY);
        ctx.lineTo(beakStartX, beakStartY + beakHeight);
    } else if (bird.name === "ç»¿å¤´é¸­" && bird.doubleBeak) {
        if (bird.beakOnePointFive) {
            beakLength = 8 * 1.5;
        } else {
            beakLength = 16;
        }
        beakHeight = 4;
        ctx.fillRect(beakStartX, beakStartY - beakHeight/2, beakLength, beakHeight);
    } else if (bird.name === "èµ¤éº»é¸­" && bird.beakOnePointThree) {
        beakLength = 8 * 1.3;
        beakHeight = 4;
        ctx.fillRect(beakStartX, beakStartY - beakHeight/2, beakLength, beakHeight);
    } else if (bird.name === "éº»é›€") {
        beakLength = 4;
        beakHeight = 3;
        ctx.moveTo(beakStartX, beakStartY);
        ctx.lineTo(beakStartX + beakLength, beakStartY);
        ctx.lineTo(beakStartX, beakStartY + beakHeight);
    } else if (bird.name === "å¤œé¹­") {
        beakLength = 24;
        beakHeight = 6;
        ctx.moveTo(beakStartX, beakStartY);
        ctx.lineTo(beakStartX + beakLength, beakStartY);
        ctx.lineTo(beakStartX, beakStartY + beakHeight);
    } else if (bird.name === "å•„æœ¨é¸Ÿ" && bird.doubleBeak) {
        beakLength = 8;
        beakHeight = 5;
        ctx.moveTo(beakStartX, beakStartY);
        ctx.lineTo(beakStartX + beakLength, beakStartY);
        ctx.lineTo(beakStartX, beakStartY + beakHeight);
    } else if (bird.name === "æˆ´èƒœ" && bird.beakOnePointFive) {
        beakLength = 8 * 1.5;
        beakHeight = 5;
        ctx.moveTo(beakStartX, beakStartY);
        ctx.lineTo(beakStartX + beakLength, beakStartY);
        ctx.lineTo(beakStartX, beakStartY + beakHeight);
    } else if (bird.name === "æˆ´èŠ" && bird.state !== 'perching' && bird.halfBeakFlying) {
        beakLength = 4 * 0.5;
        beakHeight = 3;
        ctx.moveTo(beakStartX, beakStartY);
        ctx.lineTo(beakStartX + beakLength, beakStartY);
        ctx.lineTo(beakStartX, beakStartY + beakHeight);
    } else if (bird.name === "å±±é›€" && bird.halfBeak) {
        beakLength = 4;
        beakHeight = 3;
        ctx.moveTo(beakStartX, beakStartY);
        ctx.lineTo(beakStartX + beakLength, beakStartY);
        ctx.lineTo(beakStartX, beakStartY + beakHeight);
    } else if (bird.name === "æ£•å¤´é¸¦é›€" && bird.quarterBeak) {
        beakLength = 2;
        beakHeight = 2;
        ctx.moveTo(beakStartX, beakStartY);
        ctx.lineTo(beakStartX + beakLength, beakStartY);
        ctx.lineTo(beakStartX, beakStartY + beakHeight);
    } else if (bird.name === "æŸç§æŸ³èº" && bird.halfBeak) {
        beakLength = 4;
        beakHeight = 3;
        ctx.moveTo(beakStartX, beakStartY);
        ctx.lineTo(beakStartX + beakLength, beakStartY);
        ctx.lineTo(beakStartX, beakStartY + beakHeight);
    } else if ((bird.name === "é‡‘çœ¶é¸»" || bird.name === "12000é¸»") && bird.beakOnePointFive) {
        beakLength = 6 * 1.5;
        beakHeight = 3;
        ctx.moveTo(beakStartX, beakStartY);
        ctx.lineTo(beakStartX + beakLength, beakStartY);
        ctx.lineTo(beakStartX, beakStartY + beakHeight);
    } else if (bird.name === "é‡‘ç¿…é›€" && bird.halfBeak) {
        beakLength = 4;
        beakHeight = 3;
        ctx.moveTo(beakStartX, beakStartY);
        ctx.lineTo(beakStartX + beakLength, beakStartY);
        ctx.lineTo(beakStartX, beakStartY + beakHeight);
    } else {
        ctx.moveTo(beakStartX, beakStartY);
        ctx.lineTo(beakStartX + beakLength, beakStartY);
        ctx.lineTo(beakStartX, beakStartY + beakHeight);
    }
    
    if (!((bird.name === "ç»¿å¤´é¸­" && bird.doubleBeak) || (bird.name === "èµ¤éº»é¸­" && bird.beakOnePointThree))) {
        ctx.closePath();
        ctx.fill();
    }
    
    const eyeColor = bird.type.eyeColor || '#000000';
    const eyeX = bird.x + bodySize/2 - headSize/2 + headSize/4;
    const eyeY = bird.y - bodySize/2 + headSize/3 + headOffsetY;
    
    if (bird.yellowEyeRing) {
        ctx.fillStyle = '#FFFF00';
        ctx.beginPath();
        ctx.arc(eyeX, eyeY, 4, 0, Math.PI * 2);
        ctx.fill();
    } else if (bird.whiteEyeRing) {
        ctx.fillStyle = '#FFFFFF';
        ctx.beginPath();
        ctx.arc(eyeX, eyeY, 3, 0, Math.PI * 2);
        ctx.fill();
    }
    
    if (bird.name === "æ–‘é¸ " && bird.brownEyeRing) {
        ctx.fillStyle = '#8B4513';
        ctx.beginPath();
        ctx.arc(eyeX, eyeY, 4, 0, Math.PI * 2);
        ctx.fill();
    }
    
    if (bird.name === "å°åŒ—") {
        ctx.fillStyle = eyeColor;
        ctx.beginPath();
        ctx.arc(eyeX, eyeY, 1, 0, Math.PI * 2);
        ctx.fill();
    } else {
        ctx.fillStyle = eyeColor;
        ctx.beginPath();
        ctx.arc(eyeX, eyeY, 2, 0, Math.PI * 2);
        ctx.fill();
    }
    
    ctx.fillStyle = wingColor || '#000000';
    ctx.fillRect(
        bird.x - bodySize/4 - headSize/2,
        bird.y - bodySize/2,
        bodySize/2,
        bodySize/3
    );
    
    if (bird.name === "å–œé¹Š" && bird.longBlackTail) {
        ctx.fillStyle = "#000000";
        const tailWidth = 8;
        const tailLength = bodySize;
        const tailStartX = bird.x - bodySize/2;
        const tailStartY = bird.y;
        ctx.fillRect(tailStartX, tailStartY - tailWidth/2, -tailLength, tailWidth);
    } else if (bird.name === "ç™½é¹¡é¸°" && bird.longBlackTail) {
        ctx.fillStyle = "#000000";
        const tailWidth = 3;
        const tailLength = 20;
        const tailStartX = bird.x - bodySize/2;
        const tailStartY = bird.y - bodySize/8;
        ctx.fillRect(tailStartX, tailStartY - tailWidth/2, -tailLength, tailWidth);
        
        ctx.fillStyle = "#000000";
        const blackLineY = tailStartY + tailWidth/2 + 1;
        ctx.fillRect(tailStartX, blackLineY, -tailLength, 1);
    } else if (bird.name === "æ£•å¤´é¸¦é›€" && bird.longBrownTail) {
        ctx.fillStyle = tailColor || "#8B4513";
        const tailWidth = 2;
        const tailLength = bodySize;
        const tailStartX = bird.x - bodySize/2;
        const tailStartY = bird.y;
        ctx.fillRect(tailStartX, tailStartY - tailWidth/2, -tailLength, tailWidth);
    } else if (bird.name === "é»‘ç¿…é¸¢") {
        ctx.fillStyle = "#FFFFFF";
        const tailStartX = bird.x - bodySize/2;
        const tailStartY = bird.y - bodySize/8;
        const tailHeight = bodySize/4;
        ctx.beginPath();
        ctx.moveTo(tailStartX, tailStartY);
        ctx.lineTo(tailStartX - 8, tailStartY - tailHeight/2);
        ctx.lineTo(tailStartX - 8, tailStartY + tailHeight/2);
        ctx.lineTo(tailStartX, tailStartY);
        ctx.closePath();
        ctx.fill();
    } else if (bird.name === "é‡‘ç¿…é›€") {
        ctx.fillStyle = tailColor || "#FFD700";
        const tailStartX = bird.x - bodySize/2;
        const tailStartY = bird.y - bodySize/8;
        const tailHeight = bodySize/4;
        ctx.beginPath();
        ctx.moveTo(tailStartX, tailStartY);
        ctx.lineTo(tailStartX - 8, tailStartY - tailHeight/2);
        ctx.lineTo(tailStartX - 8, tailStartY + tailHeight/2);
        ctx.lineTo(tailStartX, tailStartY);
        ctx.closePath();
        ctx.fill();
    } else if (bird.name === "é‡‘çœ¶é¸»" || bird.name === "12000é¸»") {
        ctx.fillStyle = tailColor || "#D2B48C";
        const tailStartX = bird.x - bodySize/2;
        const tailStartY = bird.y - bodySize/8;
        const tailHeight = bodySize/4;
        ctx.beginPath();
        ctx.moveTo(tailStartX, tailStartY);
        ctx.lineTo(tailStartX - 8, tailStartY - tailHeight/2);
        ctx.lineTo(tailStartX - 8, tailStartY + tailHeight/2);
        ctx.lineTo(tailStartX, tailStartY);
        ctx.closePath();
        ctx.fill();
    } else {
        ctx.fillStyle = tailColor || "#000000";
        const tailStartX = bird.x - bodySize/2;
        const tailStartY = bird.y - bodySize/8;
        const tailHeight = bodySize/4;
        ctx.beginPath();
        ctx.moveTo(tailStartX, tailStartY);
        ctx.lineTo(tailStartX - 8, tailStartY - tailHeight/2);
        ctx.lineTo(tailStartX - 8, tailStartY + tailHeight/2);
        ctx.lineTo(tailStartX, tailStartY);
        ctx.closePath();
        ctx.fill();
    }
    
    if (bird.hasCrest && bird.crestColor) {
        ctx.fillStyle = bird.crestColor || '#D2B48C';
        ctx.beginPath();
        const centerX = bird.x;
        const centerY = bird.y - bodySize/2;
        const radius = 10;
        const startAngle = -Math.PI/2 - Math.PI/9 - Math.PI/18;
        const endAngle = -Math.PI/2 + Math.PI/3.6 - Math.PI/18;
        
        ctx.moveTo(centerX, centerY);
        for (let i = 0; i <= 6; i++) {
            const angle = startAngle + (endAngle - startAngle) * (i / 6);
            const x = centerX + Math.cos(angle) * radius;
            const y = centerY + Math.sin(angle) * radius;
            ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.fill();
        
        for (let i = 0; i < 5; i++) {
            const pointAngle = startAngle + (endAngle - startAngle) * ((i+1)/6);
            const pointRadius = radius * 0.6;
            const pointX = centerX + Math.cos(pointAngle) * pointRadius;
            const pointY = centerY + Math.sin(pointAngle) * pointRadius;
            const pointSize = 2;
            
            if (i % 2 === 0) {
                ctx.fillStyle = "#000000";
            } else {
                ctx.fillStyle = "#FFFFFF";
            }
            
            ctx.beginPath();
            ctx.arc(pointX, pointY, pointSize, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    
    ctx.restore();
    
    if ((bird.name === "é»‘ç¿…é¸¢" || bird.name === "çº¢éš¼") && bird.caughtMouse) {
        drawMouseInClaws(bird);
    }
    
    if (bird.name === "æ¸¸éš¼" && bird.caughtBird) {
        ctx.save();
        ctx.fillStyle = "#A0522D";
        const preySize = 10;
        const preyX = bird.x + (bird.direction === 1 ? 20 : -20);
        const preyY = bird.y + 15;
        ctx.beginPath();
        ctx.arc(preyX, preyY, preySize, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }
    
    if (bird.name === "çº¢éš¼" && bird.caughtDove) {
        ctx.save();
        ctx.fillStyle = "#808080";
        const doveSize = 12;
        const doveX = bird.x + (bird.direction === 1 ? 20 : -20);
        const doveY = bird.y + 15;
        ctx.beginPath();
        ctx.arc(doveX, doveY, doveSize, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = "#A0522D";
        const wingWidth = doveSize * 0.8;
        const wingHeight = doveSize * 0.4;
        ctx.fillRect(doveX - wingWidth/2, doveY - wingHeight/2, wingWidth, wingHeight);
        ctx.restore();
    }
    
    if (bird.isEating && bird.eatingFruit) {
        const timeSinceStart = bird.eatingTime;
        const pulse = Math.sin(timeSinceStart * 0.01) * 0.5 + 0.5;
        
        ctx.save();
        ctx.fillStyle = `rgba(255, 200, 0, ${0.3 * pulse})`;
        ctx.beginPath();
        ctx.arc(
            bird.x + (bird.direction === 1 ? 30 : -30),
            bird.y - 10,
            3 + pulse * 2,
            0, Math.PI * 2
        );
        ctx.fill();
        ctx.restore();
    }
    
    ctx.restore();
}

function drawPerchingWoodpeckerOrHeron(bird) {
    const baseSize = 20;
    const birdSize = baseSize * bird.size;
    const bodySize = birdSize;
    
    ctx.save();
    
    let beakDirection = 1;
    if (bird.targetTree && bird.targetTree.side === 'right') {
        beakDirection = -1;
    }
    
    let bodyColor = bird.type.bodyColor;
    let headColor = bird.type.headColor || '#000000';
    let wingColor = bird.type.wingColor || '#000000';
    let tailColor = bird.type.tailColor || "#000000";
    
    if (bird.name === "å¤œé¹­" && bird.isNight) {
        bodyColor = bird.nightBodyColor || "#808080";
        headColor = bird.nightBodyColor || "#808080";
        wingColor = bird.nightWingColor || "#4682B4";
        tailColor = bird.nightBodyColor || "#808080";
    }
    
    ctx.fillStyle = bodyColor;
    ctx.beginPath();
    ctx.ellipse(bird.x, bird.y, bodySize/3, bodySize/2, 0, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = headColor;
    const headSize = bodySize * 0.4;
    const headY = bird.y - bodySize/2 - headSize/2;
    const headX = bird.x + (bird.headOffsetX || 0);
    
    ctx.beginPath();
    ctx.arc(headX, headY, headSize/2, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = bird.type.color || '#000000';
    ctx.beginPath();
    
    let beakLength = 8;
    let beakHeight = 5;
    
    if (bird.name === "å¤œé¹­") {
        beakLength = 24;
        beakHeight = 6;
    } else if (bird.name === "å•„æœ¨é¸Ÿ" && bird.doubleBeak) {
        beakLength = 8;
        beakHeight = 5;
    }
    
    const beakStartX = headX + (headSize/2 * beakDirection);
    const beakStartY = headY;
    const beakEndX = beakStartX + beakLength * beakDirection + (bird.headOffsetX || 0);
    
    ctx.moveTo(beakStartX, beakStartY);
    ctx.lineTo(beakEndX, beakStartY);
    ctx.lineTo(beakStartX, beakStartY + beakHeight);
    ctx.closePath();
    ctx.fill();
    
    const eyeColor = bird.type.eyeColor || '#000000';
    const eyeX = headX + headSize/4 * beakDirection;
    const eyeY = headY - headSize/8;
    
    if (bird.whiteEyeRing) {
        ctx.fillStyle = '#FFFFFF';
        ctx.beginPath();
        ctx.arc(eyeX, eyeY, 3, 0, Math.PI * 2);
        ctx.fill();
    }
    
    ctx.fillStyle = eyeColor;
    ctx.beginPath();
    ctx.arc(eyeX, eyeY, 2, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = wingColor;
    const wingWidth = bodySize/8;
    const wingHeight = bodySize/3;
    const wingY = bird.y - wingHeight/2;
    
    if (bird.name === "å¤œé¹­") {
        if (beakDirection === 1) {
            ctx.fillRect(
                bird.x - bodySize/3 - wingWidth/2,
                wingY,
                wingWidth,
                wingHeight
            );
        } else {
            ctx.fillRect(
                bird.x + bodySize/3 - wingWidth/2,
                wingY,
                wingWidth,
                wingHeight
            );
        }
    } else {
        if (bird.targetTree.side === 'left') {
            ctx.fillRect(
                bird.x + bodySize/2 - wingWidth/2,
                wingY,
                wingWidth,
                wingHeight
            );
        } else {
            ctx.fillRect(
                bird.x - bodySize/2 - wingWidth/2,
                wingY,
                wingWidth,
                wingHeight
            );
        }
    }
    
    ctx.fillStyle = tailColor;
    const tailStartX = bird.x;
    const tailStartY = bird.y + bodySize/2;
    const tailHeight = bodySize/4;
    const tailWidth = bodySize/3;
    
    ctx.beginPath();
    ctx.moveTo(tailStartX - tailWidth/2, tailStartY);
    ctx.lineTo(tailStartX + tailWidth/2, tailStartY);
    ctx.lineTo(tailStartX, tailStartY + tailHeight);
    ctx.closePath();
    ctx.fill();
    
    ctx.restore();
}

function drawRiceBallBird(bird) {
    const baseSize = 20;
    const birdSize = baseSize * bird.size;
    const bodySize = birdSize;
    
    ctx.save();
    
    let riceBallColor;
    let dotColor = "#000000";
    let eyeRingColor = "#FFFFFF";
    let topSquareColor = "#FF8C00";
    
    if (bird.name === "æˆ´èŠ") {
        riceBallColor = "#90EE90";
    }
    
    ctx.fillStyle = riceBallColor;
    ctx.beginPath();
    ctx.arc(bird.x, bird.y, bodySize/2, 0, Math.PI * 2);
    ctx.fill();
    
    const highlightGradient = ctx.createRadialGradient(
        bird.x - bodySize/4, bird.y - bodySize/4, 0,
        bird.x, bird.y, bodySize
    );
    highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
    highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
    
    ctx.fillStyle = highlightGradient;
    ctx.beginPath();
    ctx.arc(bird.x, bird.y, bodySize/2, 0, Math.PI * 2);
    ctx.fill();
    
    const eyeSpacing = bodySize * 0.4;
    const leftEyeX = bird.x - eyeSpacing/2;
    const rightEyeX = bird.x + eyeSpacing/2;
    const eyeY = bird.y - bodySize/6;
    const mouthX = bird.x;
    const mouthY = bird.y + bodySize/6;
    
    const eyeRadius = 0.25;
    const mouthRadius = 0.25;
    
    if (bird.name === "æˆ´èŠ") {
        ctx.fillStyle = eyeRingColor;
        ctx.beginPath();
        ctx.arc(leftEyeX, eyeY, eyeRadius + 0.125, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(rightEyeX, eyeY, eyeRadius + 0.125, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = dotColor;
        ctx.beginPath();
        ctx.arc(leftEyeX, eyeY, eyeRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(rightEyeX, eyeY, eyeRadius, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.beginPath();
        ctx.arc(mouthX, mouthY, mouthRadius, 0, Math.PI * 2);
        ctx.fill();
        
        const squareSize = bodySize * 0.3;
        ctx.fillStyle = topSquareColor;
        
        const roundRect = (x, y, width, height, radius) => {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            ctx.fill();
        };
        
        roundRect(bird.x - squareSize/2, bird.y - bodySize/2 - squareSize/2, squareSize, squareSize, 2);
    }
    
    ctx.fillStyle = riceBallColor;
    const tailWidth = bodySize * 0.15;
    const tailHeight = bodySize * 0.2;
    const tailX = bird.x + bodySize/2 - tailWidth/2;
    const tailY = bird.y + bodySize/2 - tailHeight/2;
    
    ctx.beginPath();
    ctx.moveTo(tailX, tailY);
    ctx.lineTo(tailX + tailWidth, tailY);
    ctx.lineTo(tailX + tailWidth/2, tailY + tailHeight);
    ctx.closePath();
    ctx.fill();
    
    ctx.restore();
}

function drawLongtailedFinch(bird) {
  const baseSize = 20;
  let birdSize = baseSize * bird.size;
  const headSize = birdSize * 0.5;
  const bodySize = birdSize;
  
  ctx.save();
  let headOffsetY = 0;
  
  ctx.fillStyle = bird.type.bodyColor;
  ctx.beginPath();
  ctx.arc(bird.x, bird.y, bodySize/2, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.fillStyle = bird.type.headColor;
  ctx.beginPath();
  ctx.arc(
    bird.x + bodySize/2 - headSize/2,
    bird.y - bodySize/2 + headSize/2,
    headSize/2, 0, Math.PI * 2
  );
  ctx.fill();
  
  ctx.fillStyle = bird.type.color;
  const beakLength = 8 * 0.5;
  const beakHeight = 4;
  const beakStartX = bird.x + bodySize/2 - headSize/2 + headSize/2;
  const beakStartY = bird.y - bodySize/2 + headSize/2;
  
  ctx.beginPath();
  ctx.moveTo(beakStartX, beakStartY);
  ctx.lineTo(beakStartX + beakLength, beakStartY);
  ctx.lineTo(beakStartX, beakStartY + beakHeight);
  ctx.closePath();
  ctx.fill();
  
  ctx.fillStyle = bird.type.eyeColor;
  const eyeX = bird.x + bodySize/2 - headSize/2 + headSize/4;
  const eyeY = bird.y - bodySize/2 + headSize/3;
  
  ctx.beginPath();
  ctx.arc(eyeX, eyeY, 2, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.fillStyle = bird.type.wingColor;
  ctx.fillRect(
    bird.x - bodySize/4 - headSize/2,
    bird.y - bodySize/2,
    bodySize/2, bodySize/3
  );
  
  // ä¿®æ”¹å°¾å·´æ ·å¼ä¸ºç™½é¹¡é¸°æ ·å¼
  ctx.fillStyle = "#000000"; // ä½¿ç”¨é»‘è‰²ï¼Œä¸ç™½é¹¡é¸°ä¸€è‡´
  const tailWidth = 3;
  const tailLength = 20; // ä¿æŒä¸ç™½é¹¡é¸°ç›¸åŒçš„é•¿åº¦
  const tailStartX = bird.x - bodySize/2;
  const tailStartY = bird.y - bodySize/8; // è°ƒæ•´ä½ç½®
  
  // ç»˜åˆ¶å°¾å·´ä¸»ä½“
  ctx.fillRect(tailStartX, tailStartY - tailWidth/2, -tailLength, tailWidth);
  
  // ç»˜åˆ¶å°¾å·´ä¸‹é¢çš„æ¨ªçº¿ï¼ˆç™½é¹¡é¸°æ ·å¼ï¼‰
  ctx.fillStyle = "#000000";
  const blackLineY = tailStartY + tailWidth/2 + 1;
  ctx.fillRect(tailStartX, blackLineY, -tailLength, 1);
  
  ctx.restore();
}

function drawHawfinch(bird) {
    const baseSize = 20;
    let birdSize = baseSize * bird.size;
    const headSize = birdSize * 0.5;
    const bodySize = birdSize;
    
    // âœ… ç§»é™¤åŸæœ‰çš„æ–¹å‘å¤„ç†
    ctx.fillStyle = bird.type.bodyColor;
    ctx.beginPath();
    ctx.arc(bird.x, bird.y, bodySize/2, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = bird.type.headColor;
    ctx.beginPath();
    ctx.arc(
        bird.x + bodySize/2 - headSize/2,
        bird.y - bodySize/2 + headSize/2,
        headSize/2,
        0,
        Math.PI * 2
    );
    ctx.fill();

    // å–™
    ctx.fillStyle = bird.type.beakColor || bird.type.color || "#000000";
    const beakStartX = bird.x + bodySize/2 - headSize/2 + headSize/2;
    const beakStartY = bird.y - bodySize/2 + headSize/2;
    const beakLength = 4;
    const beakHeight = 6;
    ctx.beginPath();
    ctx.moveTo(beakStartX, beakStartY);
    ctx.lineTo(beakStartX + beakLength, beakStartY);
    ctx.lineTo(beakStartX, beakStartY + beakHeight);
    ctx.closePath();
    ctx.fill();

    // çœ¼ç›
    ctx.fillStyle = bird.type.eyeColor;
    const eyeX = bird.x + bodySize/2 - headSize/2 + headSize/4;
    const eyeY = bird.y - bodySize/2 + headSize/3;
    ctx.beginPath();
    ctx.arc(eyeX, eyeY, 2, 0, Math.PI * 2);
    ctx.fill();

    // ç¿…è†€
    ctx.fillStyle = bird.type.wingColor;
    ctx.fillRect(
        bird.x - bodySize/4 - headSize/2,
        bird.y - bodySize/2,
        bodySize/2,
        bodySize/3
    );

    // å°¾å·´
    ctx.fillStyle = bird.type.tailColor;
    const tailStartX = bird.x - bodySize/2;
    const tailStartY = bird.y - bodySize/8;
    const tailHeight = bodySize/4;
    ctx.beginPath();
    ctx.moveTo(tailStartX, tailStartY);
    ctx.lineTo(tailStartX - 8, tailStartY - tailHeight/2);
    ctx.lineTo(tailStartX - 8, tailStartY + tailHeight/2);
    ctx.lineTo(tailStartX, tailStartY);
    ctx.closePath();
    ctx.fill();
}

function drawBrambling(bird) {
    const baseSize = 20;
    let birdSize = baseSize * bird.size;
    const headSize = birdSize * 0.5;
    const bodySize = birdSize;
    
    // âœ… ç§»é™¤åŸæœ‰çš„æ–¹å‘å¤„ç†ï¼Œä½¿ç”¨ç»Ÿä¸€çš„é•œåƒé€»è¾‘
    ctx.fillStyle = bird.type.bodyColor;
    ctx.beginPath();
    ctx.arc(bird.x, bird.y, bodySize/2, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = bird.type.headColor;
    ctx.beginPath();
    ctx.arc(
        bird.x + bodySize/2 - headSize/2,
        bird.y - bodySize/2 + headSize/2,
        headSize/2,
        0,
        Math.PI * 2
    );
    ctx.fill();

    // å–™
    ctx.fillStyle = bird.type.beakColor || bird.type.color || "#000000";
    const beakStartX = bird.x + bodySize/2 - headSize/2 + headSize/2;
    const beakStartY = bird.y - bodySize/2 + headSize/2;
    const beakLength = 4;
    const beakHeight = 3;
    ctx.beginPath();
    ctx.moveTo(beakStartX, beakStartY);
    ctx.lineTo(beakStartX + beakLength, beakStartY);
    ctx.lineTo(beakStartX, beakStartY + beakHeight);
    ctx.closePath();
    ctx.fill();

    // çœ¼ç›
    ctx.fillStyle = bird.type.eyeColor;
    const eyeX = bird.x + bodySize/2 - headSize/2 + headSize/4;
    const eyeY = bird.y - bodySize/2 + headSize/3;
    ctx.beginPath();
    ctx.arc(eyeX, eyeY, 2, 0, Math.PI * 2);
    ctx.fill();

    // ç¿…è†€
    ctx.fillStyle = bird.type.wingColor;
    ctx.fillRect(
        bird.x - bodySize/4 - headSize/2,
        bird.y - bodySize/2,
        bodySize/2,
        bodySize/3
    );

    // å°¾å·´
    ctx.fillStyle = bird.type.tailColor;
    const tailStartX = bird.x - bodySize/2;
    const tailStartY = bird.y - bodySize/8;
    const tailHeight = bodySize/4;
    ctx.beginPath();
    ctx.moveTo(tailStartX, tailStartY);
    ctx.lineTo(tailStartX - 8, tailStartY - tailHeight/2);
    ctx.lineTo(tailStartX - 8, tailStartY + tailHeight/2);
    ctx.lineTo(tailStartX, tailStartY);
    ctx.closePath();
    ctx.fill();
}

// æ–°å¢ï¼šç½—å®¾ç»˜åˆ¶å‡½æ•°
function drawRobin(bird) {
  const baseSize = 20;
  let birdSize = baseSize * bird.size;
  const headSize = birdSize * 0.5;
  const bodySize = birdSize;
  ctx.save();
  
  // èº«ä½“ - æµ…ç°è‰²
  ctx.fillStyle = bird.type.bodyColor;
  ctx.beginPath();
  ctx.arc(bird.x, bird.y, bodySize/2, 0, Math.PI * 2);
  ctx.fill();
  
  // å¤´éƒ¨ - æ©™è‰²
  ctx.fillStyle = bird.type.headColor;
  ctx.beginPath();
  ctx.arc(
    bird.x + bodySize/2 - headSize/2,
    bird.y - bodySize/2 + headSize/2,
    headSize/2, 0, Math.PI * 2
  );
  ctx.fill();
  
  // å˜´ - æ£•è‰²ï¼Œ0.8å€é•¿
  ctx.fillStyle = bird.type.color;
  const beakLength = 8 * 0.8;
  const beakHeight = 4;
  const beakStartX = bird.x + bodySize/2 - headSize/2 + headSize/2;
  const beakStartY = bird.y - bodySize/2 + headSize/2;
  ctx.beginPath();
  ctx.moveTo(beakStartX, beakStartY);
  ctx.lineTo(beakStartX + beakLength, beakStartY);
  ctx.lineTo(beakStartX, beakStartY + beakHeight);
  ctx.closePath();
  ctx.fill();
  
  // çœ¼ç› - é»‘è‰²
  ctx.fillStyle = bird.type.eyeColor;
  const eyeX = bird.x + bodySize/2 - headSize/2 + headSize/4;
  const eyeY = bird.y - bodySize/2 + headSize/3;
  ctx.beginPath();
  ctx.arc(eyeX, eyeY, 2, 0, Math.PI * 2);
  ctx.fill();
  
  // ç¿…è†€ - æ£•è‰²
  ctx.fillStyle = bird.type.wingColor;
  ctx.fillRect(
    bird.x - bodySize/4 - headSize/2,
    bird.y - bodySize/2,
    bodySize/2,
    bodySize/3
  );
  
  // å°¾å·´ - æ£•è‰²
  ctx.fillStyle = bird.type.tailColor;
  const tailStartX = bird.x - bodySize/2;
  const tailStartY = bird.y - bodySize/8;
  const tailHeight = bodySize/4;
  ctx.beginPath();
  ctx.moveTo(tailStartX, tailStartY);
  ctx.lineTo(tailStartX - 8, tailStartY - tailHeight/2);
  ctx.lineTo(tailStartX - 8, tailStartY + tailHeight/2);
  ctx.lineTo(tailStartX, tailStartY);
  ctx.closePath();
  ctx.fill();
  
  ctx.restore();
}

function drawMouseInClaws(bird) {
    ctx.save();
    
    const clawOffsetX = 20;
    const clawOffsetY = 15;
    
    let mouseX = bird.x + clawOffsetX;
    let mouseY = bird.y + clawOffsetY;
    
    if (bird.mouseSwingAngle !== undefined) {
        bird.mouseSwingAngle += bird.mouseSwingSpeed || 0.05;
    }
    
    const swingOffset = Math.sin(bird.mouseSwingAngle || 0) * 3;
    mouseX += swingOffset;
    mouseY += Math.abs(swingOffset) * 0.5;
    
    ctx.fillStyle = "#D3D3D3";
    const bodyWidth = 12;
    const bodyHeight = 8;
    ctx.beginPath();
    ctx.ellipse(mouseX, mouseY, bodyWidth/2, bodyHeight/2, 0, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = "#D3D3D3";
    const headSize = 6;
    let headX, headY;
    
    headX = mouseX + bodyWidth/2;
    headY = mouseY;
    
    ctx.save();
    ctx.translate(headX, headY);
    ctx.rotate(swingOffset * 0.1);
    
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(headSize, -headSize/2);
    ctx.lineTo(headSize, headSize/2);
    ctx.closePath();
    ctx.fill();
    
    ctx.fillStyle = "#000000";
    const eyeX = headSize/2;
    ctx.beginPath();
    ctx.arc(eyeX, -headSize/4, 1.5, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(eyeX, headSize/4, 1.5, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.restore();
    
    ctx.save();
    ctx.translate(mouseX, mouseY);
    
    let tailStartX, tailStartY;
    tailStartX = -bodyWidth/2;
    tailStartY = 0;
    
    const tailLength = 15;
    const tailAngle = swingOffset * 0.2;
    
    let tailEndX, tailEndY;
    tailEndX = tailStartX - Math.cos(tailAngle) * tailLength;
    tailEndY = tailStartY + Math.sin(tailAngle) * tailLength;
    
    ctx.strokeStyle = "#D3D3D3";
    ctx.lineWidth = 2;
    ctx.lineCap = "round";
    ctx.beginPath();
    ctx.moveTo(tailStartX, tailStartY);
    ctx.lineTo(tailEndX, tailEndY);
    ctx.stroke();
    
    ctx.restore();
    ctx.restore();
}

function updateDayNight(deltaTime) {
    if (gamePaused) return;
    
    gameTime += deltaTime;
    
    // åº”ç”¨æ—¶é—´åŠ é€Ÿ
    let effectiveDeltaTime = deltaTime;
    
    if (isNightAccelerated && gameMode === 'normal' && !isDaytime) {
        effectiveDeltaTime = deltaTime * nightAccelerationMultiplier;
    }
    
    // æ™®é€šæ¨¡å¼ï¼šæ—¥å¤œå¾ªç¯
    if (gameMode === 'normal') {
        dayNightTimer += effectiveDeltaTime;
        
        // æ£€æŸ¥æ—¥å¤œåˆ‡æ¢
        if (dayNightTimer >= DAY_NIGHT_CYCLE_DURATION) {
            isDaytime = !isDaytime;
            dayNightTimer = 0;
            
            // å¤œæ™šåˆ‡æ¢ä¸ºç™½å¤©æ—¶ï¼Œé‡ç½®åŠ é€ŸçŠ¶æ€
            if (isDaytime) {
                isNightAccelerated = false;
                // æ³¨æ„ï¼šè¿™é‡Œä¸è¦é‡ç½®isCampfireExtinguishedï¼Œè®©å®ƒä¿æŒçŠ¶æ€
                showSpecialAlert("é»æ˜åˆ°æ¥");
            } else {
                // ç™½å¤©åˆ‡æ¢ä¸ºå¤œæ™šæ—¶ï¼Œå¿…é¡»é‡ç½®ç¯ç«çŠ¶æ€ï¼
                isCampfireExtinguished = false; // é‡è¦ï¼šé‡ç½®ç¯ç«çŠ¶æ€
                isNightAccelerated = false; // é‡ç½®åŠ é€ŸçŠ¶æ€
                moonPhaseTimer = Math.random() * MOON_PHASE_CYCLE;
                showSpecialAlert("å¤œå¹•é™ä¸´ï¼Œç¯ç«é‡æ–°ç‚¹ç‡ƒ");
                
                // æ›´æ–°è¥åœ°æ˜¾ç¤ºï¼Œç¡®ä¿ç¯ç«æ˜¯ç‚¹ç‡ƒçŠ¶æ€
                updateCampsiteVisibility();
            }
            
            updateModeToggleButtons();
            // æ›´æ–°è¥åœ°å¯è§æ€§
            updateCampsiteVisibility();
            
            // åˆ‡æ¢æ—¶æ¸…ç†ä¸ç¬¦åˆå½“å‰æ—¶é—´çš„ç”Ÿç‰©
            if (!isDaytime) {
                for (let i = birds.length - 1; i >= 0; i--) {
                    if (!birds[i].isOwl && !birds[i].isBat && birds[i].name !== "å°é¸®" && birds[i].name !== "å¤œé¹­") {
                        birds.splice(i, 1);
                    }
                }
                nightObjects = [];
            } else {
                for (let i = birds.length - 1; i >= 0; i--) {
                    if (birds[i].isOwl || birds[i].isBat) {
                        birds.splice(i, 1);
                    }
                }
                
                if (littleOwl) {
                    birds.splice(birds.indexOf(littleOwl), 1);
                    littleOwl = null;
                }
                nightObjects = [];
            }
        }
        
        moonPhaseTimer += deltaTime;
        if (moonPhaseTimer >= MOON_PHASE_CYCLE) {
            moonPhaseTimer = 0;
        }
        
        updateGoldenFilter();
        
        // æ›´æ–°å¤ªé˜³/æœˆäº®ä½ç½®
        sunMoonPosition = dayNightTimer / DAY_NIGHT_CYCLE_DURATION;
    } 
    // æ°¸ä¹…æ—¥é—´æ¨¡å¼
    else if (gameMode === 'day') {
        dayModeTimeState += deltaTime;
        dayNightTimer = dayModeTimeState;
        
        // ç¡®ä¿è¥åœ°çŠ¶æ€è¢«é‡ç½®
        isCampfireExtinguished = false;
        isNightAccelerated = false;
        
        const goldenFilter = document.getElementById('goldenFilter');
        goldenFilter.style.backgroundColor = 'rgba(255, 215, 0, 0.1)';
        
        // æ›´æ–°è¥åœ°å¯è§æ€§
        updateCampsiteVisibility();
    } 
    // æ°¸ä¹…å¤œé—´æ¨¡å¼
    else if (gameMode === 'night') {
        nightModeTimeState += deltaTime;
        nightModeMoonPhaseTimer += deltaTime;
        dayNightTimer = nightModeTimeState;
        moonPhaseTimer = nightModeMoonPhaseTimer;
        
        if (moonPhaseTimer >= MOON_PHASE_CYCLE) {
            moonPhaseTimer = 0;
            nightModeMoonPhaseTimer = 0;
        }
        
        // ç¡®ä¿è¥åœ°çŠ¶æ€è¢«é‡ç½®
        isCampfireExtinguished = false;
        isNightAccelerated = false;
        
        const goldenFilter = document.getElementById('goldenFilter');
        goldenFilter.style.backgroundColor = 'rgba(255, 215, 0, 0)';
        
        // æ›´æ–°è¥åœ°å¯è§æ€§
        updateCampsiteVisibility();
    }
    
    updateTimeIndicator();
    
    // ç¨€æœ‰é¸Ÿç±»ç”Ÿæˆï¼ˆä½¿ç”¨å®é™…æ—¶é—´ï¼Œä¸å—åŠ é€Ÿå½±å“ï¼‰
    let rareBirdDelta = deltaTime;
    lastRareBirdTime += rareBirdDelta;
    
    if (gameTime - lastRareBirdTime >= RARE_BIRD_INTERVAL && !birdingModeActive) {
        generateRareBird();
        lastRareBirdTime = gameTime;
    }
    
    // å°é¸®ç”Ÿæˆé€»è¾‘ï¼ˆä½¿ç”¨å®é™…æ—¶é—´ï¼‰
    if (!littleOwl) {
        let cooldown;
        if (gameMode === 'day') {
            cooldown = LITTLE_OWL_DAY_COOLDOWN;
        } else if (gameMode === 'night') {
            cooldown = LITTLE_OWL_NIGHT_COOLDOWN;
        } else {
            cooldown = isDaytime ? LITTLE_OWL_DAY_COOLDOWN : LITTLE_OWL_NIGHT_COOLDOWN;
        }
        
        // ä½¿ç”¨å®é™…æ—¶é—´è®¡ç®—
        let actualTimePassed = deltaTime;
        lastLittleOwlTime += actualTimePassed;
        
        if (gameTime - lastLittleOwlTime > cooldown) {
            generateLittleOwl(true);
            lastLittleOwlTime = gameTime;
        }
    }
    
    // å¤œé—´çŒ«å¤´é¹°ç”Ÿæˆï¼ˆä½¿ç”¨å®é™…æ—¶é—´ï¼‰
    if ((gameMode === 'night' || (gameMode === 'normal' && !isDaytime))) {
        let actualTimePassed = deltaTime;
        lastOwlSpawnTime += actualTimePassed;
        
        if (gameTime - lastOwlSpawnTime > NIGHT_OWL_SPAWN_INTERVAL) {
            spawnNightOwls();
            lastOwlSpawnTime = gameTime;
        }
    }
}

function generateRareBird() {
  const isNightMode = gameMode === 'night' || (gameMode === 'normal' && !isDaytime);
  let availableRareBirds = RARE_BIRDS.filter(birdKey => {
    const birdType = BIRD_TYPES[birdKey];
    if (!birdType) return false; // æ·»åŠ ä¿æŠ¤æ€§æ£€æŸ¥
    if (birdType.isNocturnal || birdType.canAppearAtNight) {
      return isNightMode;
    }
    return !isNightMode;
  });
  
  if (availableRareBirds.length === 0) {
    if (isNightMode) {
      availableRareBirds = ['OWL'];
    } else {
      // ç¡®ä¿ç™½å¤©å¯ç”¨çš„ç¨€æœ‰é¸Ÿç±»åŒ…å«æ‰€æœ‰ç™½å¤©é¸Ÿç±»
      availableRareBirds = ['KENTISH_PLOVER', 'MINIVET', 'GOLDCREST', 'LITTLEGREBE', 'LONGTAILED_FINCH', 'ROBIN'];
    }
  }
  
  const capturedRareBirds = availableRareBirds.filter(birdKey => {
    const birdName = BIRD_TYPES[birdKey]?.name;
    return birdName && capturedBirds[birdName] && capturedBirds[birdName] > 0;
  });
  
  const uncapturedRareBirds = availableRareBirds.filter(birdKey => {
    const birdName = BIRD_TYPES[birdKey]?.name;
    return birdName && (!capturedBirds[birdName] || capturedBirds[birdName] === 0);
  });
  
  let randomBirdKey;
  if (uncapturedRareBirds.length > 0) {
    randomBirdKey = uncapturedRareBirds[Math.floor(Math.random() * uncapturedRareBirds.length)];
  } else {
    randomBirdKey = availableRareBirds[Math.floor(Math.random() * availableRareBirds.length)];
  }
  
  // ç¡®ä¿ randomBirdKey æœ‰å¯¹åº”çš„å¤„ç†
  switch (randomBirdKey) {
    case 'KENTISH_PLOVER':
      generateKentishPlover(false);
      showSpecialAlert("ç¨€æœ‰é¸Ÿç±»å‡ºç°ï¼šé‡‘çœ¶é¸»ï¼");
      break;
    case 'MINIVET':
      generateMinivetRare(false);
      showSpecialAlert("ç¨€æœ‰é¸Ÿç±»å‡ºç°ï¼šå±±æ¤’é¸Ÿï¼");
      break;
    case 'GOLDCREST':
      generateGoldcrest(false);
      showSpecialAlert("ç¨€æœ‰é¸Ÿç±»å‡ºç°ï¼šæˆ´èŠï¼");
      break;
    case 'OWL':
      generateOwlRare(false);
      showSpecialAlert("ç¨€æœ‰é¸Ÿç±»å‡ºç°ï¼šé•¿è€³é¸®ï¼");
      break;
    case 'LITTLEGREBE':
      generateLittleGrebe(false);
      showSpecialAlert("ç¨€æœ‰é¸Ÿç±»å‡ºç°ï¼šå°åŒ—ï¼");
      break;
    case 'LONGTAILED_FINCH':
      generateLongtailedFinchRare(false);
      showSpecialAlert("ç¨€æœ‰é¸Ÿç±»å‡ºç°ï¼šé•¿å°¾é›€ï¼");
      break;
    case 'ROBIN':
      generateRobinRare(false);
      showSpecialAlert("ç¨€æœ‰é¸Ÿç±»å‡ºç°ï¼šç½—å®¾ï¼");
      break;
default:
      console.log("æœªå¤„ç†çš„ç¨€æœ‰é¸Ÿç±»é”®:", randomBirdKey);
      // é»˜è®¤ç”Ÿæˆä¸€ä¸ªå·²çŸ¥çš„ç¨€æœ‰é¸Ÿç±»
      generateKentishPlover(false);
      showSpecialAlert("ç¨€æœ‰é¸Ÿç±»å‡ºç°ï¼šé‡‘çœ¶é¸»ï¼");
      break;
  }
}
// æ–°å¢ï¼šé•¿å°¾é›€ç¨€æœ‰ç”Ÿæˆå‡½æ•°
function generateLongtailedFinchRare(countStats = true) {
  const longtailedFinchType = BIRD_TYPES.LONGTAILED_FINCH;
  if (countStats) {
    appearedBirds[longtailedFinchType.name]++;
    updateTextStats();
  }
  
  const fromLeft = Math.random() > 0.5;
  const birdCount = getRandomGroupSize(longtailedFinchType);
  const groupId = nextGroupId++;
  birdGroupInfo[groupId] = { direction: fromLeft ? 1 : -1, birds: [] };
  
  for (let i = 0; i < birdCount; i++) {
    const startX = fromLeft ? -50 : GAME_WIDTH + 50;
    const startY = Math.random() * (GAME_HEIGHT * 0.6) + GAME_HEIGHT * 0.2;
    const bird = createCommonBird(
      longtailedFinchType,
      startX,
      startY,
      fromLeft,
      "landOnTreeTop",
      longtailedFinchType.stayTime,
      2 + Math.random(),
      groupId
    );
    bird.halfBeak = true;
    bird.isVulnerableToRaptors = true;
    bird.noStats = !countStats;
    bird.isNight = !isDaytime;
    birds.push(bird);
    birdGroupInfo[groupId].birds.push(bird);
  }
}

// æ–°å¢ï¼šç½—å®¾ç¨€æœ‰ç”Ÿæˆå‡½æ•°
function generateRobinRare(countStats = true) {
  const robinType = BIRD_TYPES.ROBIN;
  if (countStats) {
    appearedBirds[robinType.name]++;
    updateTextStats();
  }
  
  const fromLeft = Math.random() > 0.5;
  const birdCount = getRandomGroupSize(robinType);
  const groupId = nextGroupId++;
  birdGroupInfo[groupId] = { direction: fromLeft ? 1 : -1, birds: [] };
  
  for (let i = 0; i < birdCount; i++) {
    const startX = fromLeft ? -50 : GAME_WIDTH + 50;
    const startY = Math.random() * (GAME_HEIGHT * 0.6) + GAME_HEIGHT * 0.2;
    const bird = createCommonBird(
      robinType,
      startX,
      startY,
      fromLeft,
      "landOnTreeBottom",
      robinType.stayTime,
      2 + Math.random(),
      groupId
    );
    bird.beakLengthMultiplier = 0.8;
    bird.isVulnerableToRaptors = true;
    bird.noStats = !countStats;
    bird.isNight = !isDaytime;
    birds.push(bird);
    birdGroupInfo[groupId].birds.push(bird);
  }
}

function generateMinivetRare(countStats = true) {
    const minivetType = BIRD_TYPES.MINIVET;
    if (countStats) {
        appearedBirds[minivetType.name]++;
        updateTextStats();
    }
    
    const fromLeft = Math.random() > 0.5;
    const birdCount = getRandomGroupSize(minivetType);
    const groupId = nextGroupId++;
    birdGroupInfo[groupId] = { direction: fromLeft ? 1 : -1, birds: [] };
    
    for (let i = 0; i < birdCount; i++) {
        let startX, startY;
        const behavior = minivetType.behavior;
        const stayTime = minivetType.stayTime || 10;
        
        startX = fromLeft ? -50 : GAME_WIDTH + 50;
        startY = Math.random() * (GAME_HEIGHT * 0.6) + GAME_HEIGHT * 0.2;
        
        let baseSpeed = (1.6 + Math.random() * 0.8);
        const speedMultiplier = minivetType.speedMultiplier || 1;
        const finalSpeed = baseSpeed * speedMultiplier;
        
        const bird = createCommonBird(minivetType, startX, startY, fromLeft, behavior, stayTime, finalSpeed, groupId);
        bird.variant = Math.random() > 0.5;
        bird.iconColor = bird.variant ? "#FFFF00" : "#FF0000";
        bird.noStats = !countStats;
        bird.isNight = !isDaytime;
        
        birds.push(bird);
        birdGroupInfo[groupId].birds.push(bird);
    }
}

function generateOwlRare(countStats = true) {
    const owlType = BIRD_TYPES.OWL;
    if (countStats) {
        appearedBirds[owlType.name]++;
        updateTextStats();
    }
    
    const targetTree = treePositions[Math.floor(Math.random() * treePositions.length)];
    const x = targetTree.x + targetTree.width * 0.4 + Math.random() * targetTree.width * 0.2;
    const y = targetTree.y + targetTree.height * 0.2 + Math.random() * targetTree.height * 0.3;
    
    const isNightMode = gameMode === 'night' || (gameMode === 'normal' && !isDaytime);
    
    const bird = {
        type: owlType,
        name: owlType.name,
        x: x,
        y: y,
        size: owlType.size,
        speed: 0,
        direction: targetTree.side === 'left' ? 1 : -1,
        state: 'perching',
        stateTime: 0,
        stayTime: owlType.stayTime || 15,
        faceScreen: true,
        iconColor: owlType.iconColor,
        eyeColor: isNightMode ? "#FFFF99" : "#FFA500", // å¤œæ™šé»„è‰²ï¼Œç™½å¤©æ©™è‰²
        whiteEyeRing: true,
        noStats: !countStats,
        isNight: isNightMode,
        // âœ… æ–°å¢ï¼šæ ‡è®°ä¸ºç›´æ¥æ¶ˆå¤±çš„é¸Ÿç±»
        shouldVanishInsteadOfFlying: true,
        behavior: "appearOnTree" // æ˜ç¡®è¡Œä¸ºç±»å‹
    };
    
    birds.push(bird);
    showSpecialAlert("ç¨€æœ‰é¸Ÿç±»å‡ºç°ï¼šé•¿è€³é¸®ï¼");
    return bird;
}

function updateGoldenFilter() {
    const goldenFilter = document.getElementById('goldenFilter');
    
    if (gameMode === 'normal' && isDaytime) {
        const oneMinute = 1 * 60 * 1000;
        const dayDuration = DAY_NIGHT_CYCLE_DURATION;
        const currentDayTime = dayNightTimer;
        
        let intensity = 0;
        if (currentDayTime < oneMinute) {
            intensity = 0.3 * (1 - currentDayTime / oneMinute);
        } else if (currentDayTime > dayDuration - oneMinute) {
            const timeLeft = dayDuration - currentDayTime;
            intensity = 0.3 * (1 - timeLeft / oneMinute);
        } else {
            intensity = 0;
        }
        
        goldenFilter.style.backgroundColor = `rgba(255, 215, 0, ${intensity})`;
        isGoldenFilterActive = intensity > 0.01;
    } else {
        goldenFilter.style.backgroundColor = 'rgba(255, 215, 0, 0)';
        isGoldenFilterActive = false;
    }
}

function updateBirds(deltaTime) {
    if (gamePaused) return;
    
    raptorsPresent = birds.filter(bird => bird.name === "æ¸¸éš¼" || bird.name === "çº¢éš¼" || bird.name === "é»‘ç¿…é¸¢");
    
    raptorsPresent.forEach(raptor => {
        if (!raptor.hasBeenNearCenter) {
            const centerX = GAME_WIDTH / 2;
            const centerY = GAME_HEIGHT / 2;
            const distanceX = Math.abs(raptor.x - centerX);
            const distanceY = Math.abs(raptor.y - centerY);
            if (distanceX < 400 && distanceY < 300) {
                raptor.hasBeenNearCenter = true;
                raptor.centerArrivalTime = gameTime;
            }
        }
    });
    
    const isNightMode = gameMode === 'night' || (gameMode === 'normal' && !isDaytime);
    const qualifiedRaptors = raptorsPresent.filter(raptor => raptor.hasBeenNearCenter && gameTime - raptor.centerArrivalTime >= 1000);
    
    if (qualifiedRaptors.length > 0) {
        birds.forEach(bird => {
            const exemptBirds = [
                "å–œé¹Š", "ä¹Œé¸¦", "å¤œé¹­", "ç»¿å¤´é¸­", "èµ¤éº»é¸­", "å°åŒ—", "æˆ´èŠ", "å±±é›€", 
                "æ£•å¤´é¸¦é›€", "é‡‘çœ¶é¸»", "12000é¸»", "æ¸¸éš¼", "çº¢éš¼", "é»‘ç¿…é¸¢", 
                "é•¿è€³é¸®", "é›•é¸®", "çŸ­è€³é¸®", "å°é¸®", "è™è "
            ];
            
            if (exemptBirds.includes(bird.name)) {
                return;
            }
            
            if (!bird.isFleeingFromRaptor) {
                bird.isFleeingFromRaptor = true;
                bird.originalState = bird.state;
                bird.originalSpeed = bird.speed;
                bird.fleeFromRaptorStartTime = gameTime;
                bird.speed = bird.originalSpeed * 1.5;
                
                let nearestRaptor = null;
                let minDistance = Infinity;
                qualifiedRaptors.forEach(raptor => {
                    const dx = raptor.x - bird.x;
                    const dy = raptor.y - bird.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < minDistance) {
                        minDistance = distance;
                        nearestRaptor = raptor;
                    }
                });
                
                if (nearestRaptor) {
                    bird.direction = nearestRaptor.x > bird.x ? -1 : 1;
                }
                bird.state = 'flying';
            }
        });
        
        birds.forEach(bird => {
            if (bird.name === "é‡‘çœ¶é¸»" || bird.name === "12000é¸»") {
                if (bird.state === 'flying' || bird.state === 'landingOnReeds' || bird.state === 'takingOff') {
                    if (!bird.isFleeingFromRaptor) {
                        bird.isFleeingFromRaptor = true;
                        bird.originalState = bird.state;
                        bird.originalSpeed = bird.speed;
                        bird.speed = bird.originalSpeed * 3;
                        bird.state = 'flying';
                        bird.direction = Math.random() > 0.5 ? 1 : -1;
                    }
                } else if (bird.state === 'onReedsGround') {
                    if (!bird.isHidingFromRaptor) {
                        bird.isHidingFromRaptor = true;
                        bird.originalY = bird.y;
                        bird.originalSpeed = bird.speed;
                        bird.speed = 0;
                        bird.y = bird.originalY + (20 * bird.size * 0.5);
                    }
                }
            }
        });
        
        // åªåœ¨çŒ›ç¦½æ²¡æœ‰è¢«è¿½é€å·¡é€»æ—¶è§¦å‘æ–°çš„è¿½é€
        if (Math.random() > 1/3) {
            if (raptorsPresent.length > 0) {
                const availableMagpiesCrows = birds.filter(bird => 
                    (bird.name === "å–œé¹Š" || bird.name === "ä¹Œé¸¦") && 
                    !bird.isChasingRaptor && 
                    !bird.isFleeingFromRaptor && 
                    !bird.isFleeingFromChasers
                );
                
                raptorsPresent.forEach(raptor => {
                    // å¦‚æœçŒ›ç¦½å·²ç»åœ¨è¢«è¿½é€å·¡é€»ä¸­ï¼Œæˆ–è€…æ­£åœ¨é€ƒç¦»è¿½é€ï¼Œæˆ–è€…å·²ç»è¢«è¿½é€è¿‡ï¼ˆå…ç–«çŠ¶æ€ï¼‰ï¼Œä¸é‡æ–°è§¦å‘
                    if (raptor.isChasedPatrolling || raptor.isFleeingFromChasers || raptor.hasBeenChased) {
                        return;
                    }
                    
                    const currentChasers = chasingMagpiesCrows.filter(chaser => chaser.chasingTarget === raptor);
                    const neededChasers = raptor.name === "æ¸¸éš¼" ? 2 : 1;
                    
                    if (currentChasers.length < neededChasers) {
                        const potentialChasers = availableMagpiesCrows.filter(bird => !bird.chasingTarget);
                        const newChasers = potentialChasers.slice(0, neededChasers - currentChasers.length);
                        
                        if (newChasers.length > 0 && !raptor.hasPatrolStarted) {
                            // æ ‡è®°ä¸ºå·²å¼€å§‹å·¡é€»ï¼Œé˜²æ­¢é‡å¤è§¦å‘
                            raptor.hasPatrolStarted = true;
                            
                            newChasers.forEach(chaser => {
                                if (chaser.state === 'perching' || chaser.state === 'landing') {
                                    chaser.state = 'takingOff';
                                    chaser.speed = 2.0;
                                    setTimeout(() => {
                                        if (birds.includes(chaser) && birds.includes(raptor)) {
                                            chaser.chasingTarget = raptor;
                                            chaser.isChasingRaptor = true;
                                            chaser.originalState = chaser.state;
                                            chaser.originalSpeed = chaser.speed;
                                            chaser.chaseStartTime = gameTime;
                                            chaser.willFollowCircles = true;
                                            chaser.circleFollowingCount = 0;
                                            chaser.state = 'chasingRaptor';
                                            chasingMagpiesCrows.push(chaser);
                                        }
                                    }, 500);
                                } else {
                                    chaser.chasingTarget = raptor;
                                    chaser.isChasingRaptor = true;
                                    chaser.originalState = chaser.state;
                                    chaser.originalSpeed = chaser.speed;
                                    chaser.chaseStartTime = gameTime;
                                    chaser.willFollowCircles = true;
                                    chaser.circleFollowingCount = 0;
                                    chaser.state = 'chasingRaptor';
                                    chasingMagpiesCrows.push(chaser);
                                }
                            });
                            
                            // å¯åŠ¨è¿½é€å·¡é€»
                            raptor.isChasedPatrolling = true;
                            raptor.originalState = raptor.state;
                            raptor.originalSpeed = raptor.speed;
                            raptor.chasedPatrolStartTime = gameTime;
                            raptor.chasedPatrolStage = 0; // 0: ä»ä¸­å¤®é£å‡ºå³ä¾§
                            raptor.chasedPatrolLoops = 0;
                            raptor.maxPatrolLoops = 2 + Math.floor(Math.random() * 3); // 2-4æ¬¡å¾ªç¯
                            raptor.state = 'chasedPatrolling';
                            raptor.forcedToLeave = false;
                            
                            // a) ä»ä¸­å¤®é£å‡ºå³ä¾§
                            raptor.x = GAME_WIDTH / 2;
                            raptor.y = GAME_HEIGHT * 0.3 + Math.random() * (GAME_HEIGHT * 0.2);
                            raptor.direction = 1; // å‘å³
                            raptor.speed = 2.0;
                            console.log("çŒ›ç¦½å¼€å§‹è¿½é€å·¡é€»ï¼Œé˜¶æ®µ0: ä»ä¸­å¤®é£å‡ºå³ä¾§ï¼Œæœ€å¤§å¾ªç¯æ¬¡æ•°: " + raptor.maxPatrolLoops);
                        }
                    }
                });
            }
        }
    } else {
        for (let i = chasingMagpiesCrows.length - 1; i >= 0; i--) {
            const chaser = chasingMagpiesCrows[i];
            chaser.isChasingRaptor = false;
            chaser.chasingTarget = null;
            if (chaser.originalState) {
                chaser.state = chaser.originalState;
            }
            if (chaser.originalSpeed) {
                chaser.speed = chaser.originalSpeed;
            }
        }
        chasingMagpiesCrows = [];
    }
    
    for (let i = chasingMagpiesCrows.length - 1; i >= 0; i--) {
        const chaser = chasingMagpiesCrows[i];
        if (chaser.chasingTarget && birds.includes(chaser.chasingTarget)) {
            const raptor = chaser.chasingTarget;
            const dx = raptor.x - chaser.x;
            const dy = raptor.y - chaser.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const baseSize = 20;
            const birdSize = baseSize * chaser.size;
            const minDistance = birdSize * 0.5;
            const maxDistance = birdSize * 0.8;
            const targetDistance = minDistance + Math.random() * (maxDistance - minDistance);
            
            if (chaser.isChasingRaptor && chaser.state === 'chasingRaptor') {
                const chaseDuration = gameTime - chaser.chaseStartTime;
                
                // æ£€æŸ¥å–œé¹Š/ä¹Œé¸¦æ˜¯å¦æ”¾å¼ƒè¿½é€ - ä¿®æ”¹ï¼šåªåœ¨çŒ›ç¦½åœ¨å±å¹•å†…æ—¶æ‰å¯èƒ½æ”¾å¼ƒ
                if (chaseDuration > 3000) {
                    const timeSinceLastCheck = chaseDuration % 2000;
                    if (timeSinceLastCheck < 50) {
                        // æ£€æŸ¥çŒ›ç¦½æ˜¯å¦åœ¨å±å¹•å†…
                        const isRaptorOnScreen = raptor.x >= -250 && raptor.x <= GAME_WIDTH + 250 && 
                                                raptor.y >= -250 && raptor.y <= GAME_HEIGHT + 250;
                        
                        // åªåœ¨çŒ›ç¦½åœ¨å±å¹•å†…æ—¶æ‰å¯èƒ½æ”¾å¼ƒè¿½é€
                        if (isRaptorOnScreen) {
                            let abandonChance = 0;
                            if (chaser.name === "å–œé¹Š") {
                                abandonChance = 0.03;
                            } else if (chaser.name === "ä¹Œé¸¦") {
                                abandonChance = 0.01;
                            }
                            
                            if (Math.random() < abandonChance) {
                                chaser.isChasingRaptor = false;
                                chaser.chasingTarget = null;
                                if (chaser.originalState) {
                                    chaser.state = chaser.originalState;
                                }
                                if (chaser.originalSpeed) {
                                    chaser.speed = chaser.originalSpeed;
                                }
                                const index = chasingMagpiesCrows.indexOf(chaser);
                                if (index !== -1) {
                                    chasingMagpiesCrows.splice(index, 1);
                                }
                                
                                // å¦‚æœæ‰€æœ‰è¿½é€è€…éƒ½æ”¾å¼ƒäº†ï¼ŒçŒ›ç¦½æ¢å¤æ­£å¸¸å¹¶æ ‡è®°ä¸ºå·²è¢«è¿½é€è¿‡
                                if (raptor && raptor.isChasedPatrolling) {
                                    const remainingChasers = chasingMagpiesCrows.filter(c => c.chasingTarget === raptor);
                                    if (remainingChasers.length === 0) {
                                        raptor.isChasedPatrolling = false;
                                        raptor.isFleeingFromChasers = false;
                                        raptor.forcedToLeave = false;
                                        raptor.hasPatrolStarted = false;
                                        raptor.hasBeenChased = true; // æ ‡è®°ä¸ºå·²è¢«è¿½é€è¿‡
                                        if (raptor.originalState) {
                                            raptor.state = raptor.originalState;
                                        }
                                        if (raptor.originalSpeed) {
                                            raptor.speed = raptor.originalSpeed;
                                        }
                                        console.log("æ‰€æœ‰è¿½é€è€…æ”¾å¼ƒï¼ŒçŒ›ç¦½æ¢å¤æ­£å¸¸ï¼Œæ ‡è®°ä¸ºå·²è¢«è¿½é€è¿‡");
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            // æ›´æ–°è¿½é€è€…ä½ç½®
            let dynamicTargetDistance = targetDistance;
            if (distance > birdSize * 1.5) {
                dynamicTargetDistance = birdSize * 0.4;
            } else if (distance < birdSize * 0.3) {
                dynamicTargetDistance = birdSize * 1.0;
            }
            
            const angle = Math.atan2(dy, dx);
            const targetX = raptor.x - Math.cos(angle) * dynamicTargetDistance;
            const targetY = raptor.y - Math.sin(angle) * dynamicTargetDistance;
            const targetDx = targetX - chaser.x;
            const targetDy = targetY - chaser.y;
            const targetDist = Math.sqrt(targetDx * targetDx + targetDy * targetDy);
            
            if (targetDist > 5) {
                const moveSpeed = chaser.speed;
                chaser.x += (targetDx / targetDist) * moveSpeed;
                chaser.y += (targetDy / targetDist) * moveSpeed;
                chaser.direction = targetDx > 0 ? 1 : -1;
            } else {
                chaser.x = targetX;
                chaser.y = targetY;
                chaser.direction = raptor.direction;
            }
            
            // å¦‚æœçŒ›ç¦½å·²ç»é£ç¦»ï¼Œè¿½é€è€…æ”¾å¼ƒ
            if (!birds.includes(raptor)) {
                chaser.isChasingRaptor = false;
                chaser.chasingTarget = null;
                chaser.state = 'fleeing';
                chaser.speed = 2.0;
                chaser.direction = -1;
                const index = chasingMagpiesCrows.indexOf(chaser);
                if (index !== -1) {
                    chasingMagpiesCrows.splice(index, 1);
                }
            }
        } else {
            chaser.isChasingRaptor = false;
            chaser.chasingTarget = null;
            if (chaser.originalState) {
                chaser.state = chaser.originalState;
            }
            if (chaser.originalSpeed) {
                chaser.speed = chaser.originalSpeed;
            }
            chasingMagpiesCrows.splice(i, 1);
        }
    }
    
    // æ›´æ–°çŒ›ç¦½çš„è¿½é€å·¡é€»è¡Œä¸º
    raptorsPresent.forEach(raptor => {
        if (raptor.state === 'chasedPatrolling' && raptor.isChasedPatrolling) {
            const patrolDuration = gameTime - raptor.chasedPatrolStartTime;
            
            switch (raptor.chasedPatrolStage) {
                case 0: // a) ä»ä¸­å¤®é£å‡ºå³ä¾§
                    raptor.x += raptor.speed * raptor.direction;
                    raptor.y += Math.sin(gameTime * 0.005) * 1; // è½»å¾®ä¸Šä¸‹æ³¢åŠ¨
                    
                    // é£å‡ºå³ä¾§åè¿›å…¥ä¸‹ä¸€é˜¶æ®µ
                    if (raptor.x > GAME_WIDTH + 100) {
                        raptor.chasedPatrolStage = 1;
                        raptor.chasedPatrolStartTime = gameTime;
                        // b) 1-2ç§’åå†ä»å³ä¾§é£å…¥
                        raptor.chasedPatrolDelay = 1000 + Math.random() * 1000;
                        raptor.direction = -1; // å‘å·¦é£
                        raptor.x = GAME_WIDTH + 100; // é‡ç½®åˆ°å³ä¾§å¤–
                        raptor.y = GAME_HEIGHT * 0.3 + Math.random() * (GAME_HEIGHT * 0.2);
                        console.log("çŒ›ç¦½è¿›å…¥é˜¶æ®µ1: ç­‰å¾…åä»å³ä¾§é£å…¥");
                    }
                    break;
                    
                case 1: // b) ä»å³ä¾§é£å…¥è‡³å·¦ä¾§é£å‡º
                    if (patrolDuration < raptor.chasedPatrolDelay) {
                        // ç­‰å¾…å»¶è¿Ÿ
                        // ä½ç½®å·²ç»åœ¨ä¸Šä¸€ä¸ªé˜¶æ®µè®¾ç½®å¥½äº†
                    } else {
                        // ä»å³ä¾§é£å…¥
                        raptor.x += raptor.speed * raptor.direction;
                        raptor.y += Math.sin(gameTime * 0.005) * 1;
                        
                        // é£å‡ºå·¦ä¾§åè¿›å…¥ä¸‹ä¸€é˜¶æ®µ
                        if (raptor.x < -100) {
                            raptor.chasedPatrolStage = 2;
                            raptor.chasedPatrolStartTime = gameTime;
                            // c) 0.5-1ç§’å†ä»å·¦ä¾§é£å…¥
                            raptor.chasedPatrolDelay = 500 + Math.random() * 500;
                            raptor.direction = 1; // å‘å³é£
                            raptor.x = -100; // é‡ç½®åˆ°å·¦ä¾§å¤–
                            raptor.y = GAME_HEIGHT * 0.3 + Math.random() * (GAME_HEIGHT * 0.2);
                            
                            // è¿™é‡Œä¸å¢åŠ å¾ªç¯æ¬¡æ•°ï¼Œå› ä¸ºè¿™æ˜¯ä¸€ä¸ªå®Œæ•´çš„æ¥å›
                            console.log("çŒ›ç¦½è¿›å…¥é˜¶æ®µ2: ç­‰å¾…åä»å·¦ä¾§é£å…¥");
                        }
                    }
                    break;
                    
                case 2: // c) ä»å·¦ä¾§é£å…¥è‡³å³ä¾§é£å‡º
                    if (patrolDuration < raptor.chasedPatrolDelay) {
                        // ç­‰å¾…å»¶è¿Ÿ
                        // ä½ç½®å·²ç»åœ¨ä¸Šä¸€ä¸ªé˜¶æ®µè®¾ç½®å¥½äº†
                    } else {
                        // ä»å·¦ä¾§é£å…¥
                        raptor.x += raptor.speed * raptor.direction;
                        raptor.y += Math.sin(gameTime * 0.005) * 1;
                        
                        // é£å‡ºå³ä¾§åå›åˆ°é˜¶æ®µ1ï¼Œå¢åŠ å¾ªç¯æ¬¡æ•°
                        if (raptor.x > GAME_WIDTH + 100) {
                            raptor.chasedPatrolStage = 1;
                            raptor.chasedPatrolStartTime = gameTime;
                            raptor.chasedPatrolDelay = 1000 + Math.random() * 1000;
                            raptor.chasedPatrolLoops++;
                            raptor.direction = -1; // å‘å·¦é£
                            raptor.x = GAME_WIDTH + 100; // é‡ç½®åˆ°å³ä¾§å¤–
                            raptor.y = GAME_HEIGHT * 0.3 + Math.random() * (GAME_HEIGHT * 0.2);
                            console.log("çŒ›ç¦½å›åˆ°é˜¶æ®µ1: ç­‰å¾…åä»å³ä¾§é£å…¥ï¼Œå¾ªç¯æ¬¡æ•°: " + raptor.chasedPatrolLoops + "/" + raptor.maxPatrolLoops);
                            
                            // æ£€æŸ¥å¾ªç¯æ¬¡æ•°
                            if (raptor.chasedPatrolLoops >= raptor.maxPatrolLoops) {
                                // å¦‚æœå–œé¹Šæˆ–ä¹Œé¸¦è¿˜æ²¡æœ‰æ”¾å¼ƒè¿½é€ï¼ŒçŒ›ç¦½é£ç¦»
                                const remainingChasers = chasingMagpiesCrows.filter(c => c.chasingTarget === raptor);
                                if (remainingChasers.length > 0) {
                                    raptor.isChasedPatrolling = false;
                                    raptor.isFleeingFromChasers = true;
                                    raptor.fleeFromChasersStartTime = gameTime;
                                    raptor.fleeDirection = -1;
                                    raptor.fleeSpeed = raptor.originalSpeed * 1.2;
                                    raptor.state = 'fleeingFromChasers';
                                    raptor.hasPatrolStarted = false;
                                    raptor.hasBeenChased = true; // æ ‡è®°ä¸ºå·²è¢«è¿½é€è¿‡
                                    
                                    // æ¸…é™¤è¿½é€è€…
                                    for (let j = chasingMagpiesCrows.length - 1; j >= 0; j--) {
                                        const chaser = chasingMagpiesCrows[j];
                                        if (chaser.chasingTarget === raptor) {
                                            chaser.isChasingRaptor = false;
                                            chaser.chasingTarget = null;
                                            if (chaser.originalState) {
                                                chaser.state = chaser.originalState;
                                            }
                                            if (chaser.originalSpeed) {
                                                chaser.speed = chaser.originalSpeed;
                                            }
                                            chasingMagpiesCrows.splice(j, 1);
                                        }
                                    }
                                    console.log("çŒ›ç¦½é£ç¦»ï¼Œå¾ªç¯å®Œæˆï¼Œæ ‡è®°ä¸ºå·²è¢«è¿½é€è¿‡");
                                } else {
                                    // æ²¡æœ‰è¿½é€è€…äº†ï¼Œæ¢å¤æ­£å¸¸å¹¶æ ‡è®°ä¸ºå·²è¢«è¿½é€è¿‡
                                    raptor.isChasedPatrolling = false;
                                    raptor.hasPatrolStarted = false;
                                    raptor.hasBeenChased = true; // æ ‡è®°ä¸ºå·²è¢«è¿½é€è¿‡
                                    if (raptor.originalState) {
                                        raptor.state = raptor.originalState;
                                    }
                                    if (raptor.originalSpeed) {
                                        raptor.speed = raptor.originalSpeed;
                                    }
                                    console.log("çŒ›ç¦½æ¢å¤æ­£å¸¸ï¼Œæ— è¿½é€è€…ï¼Œæ ‡è®°ä¸ºå·²è¢«è¿½é€è¿‡");
                                }
                            }
                        }
                    }
                    break;
            }
        }
        
        if (raptor.isFleeingFromChasers && raptor.state === 'fleeingFromChasers') {
            const fleeAngle = (15 + Math.random() * 10) * Math.PI / 180;
            raptor.x += raptor.fleeSpeed * raptor.fleeDirection * Math.cos(fleeAngle);
            raptor.y -= raptor.fleeSpeed * Math.sin(fleeAngle);
            
            // é£å‡ºå±å¹•åç§»é™¤
            if (raptor.x < -500 || raptor.x > GAME_WIDTH + 500 || raptor.y < -500) {
                const index = birds.indexOf(raptor);
                if (index !== -1) {
                    birds.splice(index, 1);
                    console.log("çŒ›ç¦½é£å‡ºå±å¹•è¢«ç§»é™¤");
                }
            }
        }
    });
    
    // æ›´æ–°è¿½é€è€…ä½ç½®ï¼ˆé’ˆå¯¹æ­£åœ¨è¿½é€çš„çŒ›ç¦½ï¼‰
    chasingMagpiesCrows.forEach(chaser => {
        if (chaser.chasingTarget && birds.includes(chaser.chasingTarget)) {
            const raptor = chaser.chasingTarget;
            const dx = raptor.x - chaser.x;
            const dy = raptor.y - chaser.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const birdSize = 20 * chaser.size;
            const targetDistance = birdSize * 1.5;
            
            const angle = Math.atan2(dy, dx);
            const targetX = raptor.x - Math.cos(angle) * targetDistance;
            const targetY = raptor.y - Math.sin(angle) * targetDistance;
            const targetDx = targetX - chaser.x;
            const targetDy = targetY - chaser.y;
            const targetDist = Math.sqrt(targetDx * targetDx + targetDy * targetDy);
            
            if (targetDist > 5) {
                chaser.x += (targetDx / targetDist) * chaser.speed;
                chaser.y += (targetDy / targetDist) * chaser.speed;
                chaser.direction = targetDx > 0 ? 1 : -1;
            } else {
                chaser.speed = raptor.speed;
                chaser.x = targetX;
                chaser.y = targetY;
                chaser.direction = raptor.direction;
            }
        }
    });
    
    let hasKestrel = false;
    for (const bird of birds) {
        if (bird.name === "çº¢éš¼") {
            hasKestrel = true;
            break;
        }
    }
    
    if (!isNightMode && gameTime - lastDoveSummonCheck > DOVE_SUMMON_INTERVAL && !hasKestrel) {
        let doveCount = 0;
        for (const bird of birds) {
            if (bird.name === "æ–‘é¸ ") {
                doveCount++;
            }
        }
        if (doveCount >= 2 && Math.random() < 0.18) {
            generateKestrel(true);
        }
        lastDoveSummonCheck = gameTime;
    }
    
    // æ›´æ–°æ™®é€šé¸Ÿç±»çš„è¡Œä¸º
    for (let i = birds.length - 1; i >= 0; i--) {
        const bird = birds[i];
    
    // ç¿ é¸Ÿç‰¹æ®Šè¡Œä¸ºé€»è¾‘
    if (bird.isKingfisher) {
      updateKingfisher(bird, deltaTime);
      continue;
    }
        // é•¿è€³é¸®çš„ç‰¹æ®Šæ¶ˆå¤±é€»è¾‘
    if (bird.name === "é•¿è€³é¸®" && bird.state === 'perching') {
      bird.stateTime += deltaTime;
      
      // åœç•™æ—¶é—´ç»“æŸåç›´æ¥æ¶ˆå¤±ï¼ˆä¸æ˜¯é£ç¦»ï¼‰
      if (bird.stateTime >= (bird.stayTime * 1000)) {
        // ç›´æ¥ç§»é™¤ï¼Œä¸ä»æ ‘ä¸Šé£ç¦»
        birds.splice(i, 1);
        continue;
 // ç¬¬3é¡¹ä¿®æ”¹å¼€å§‹ï¼šå°ç»„åè°ƒé€»è¾‘
    if (bird.groupId && birdGroupInfo[bird.groupId]) {
        const group = birdGroupInfo[bird.groupId];

        // ä¸ºé‡‘çœ¶é¸»å’Œ12000é¸»æ·»åŠ å°ç»„åè°ƒ
        if ((bird.name === "é‡‘çœ¶é¸»" || bird.name === "12000é¸»") && group.behavior) {
            // å¦‚æœå°ç»„å†³å®šé™è½èŠ¦è‹‡ï¼Œç¡®ä¿æ‰€æœ‰æˆå‘˜éƒ½æ‰§è¡Œ
            if (group.behavior === "landOnReeds" && reedZone) {
                // å¦‚æœè¿™åªé¸Ÿä¸åœ¨é™è½çŠ¶æ€ï¼Œä½†å°ç»„åœ¨é™è½ï¼Œåˆ™è®©å®ƒä¹Ÿå¼€å§‹é™è½
                if (!bird.isLandingOnReeds && bird.state !== 'landingOnReeds' && bird.state !== 'onReedsGround') {
                    bird.reedTargetX = group.reedTargetX + (Math.random() - 0.5) * 40;
                    bird.reedTargetY = group.reedTargetY + (Math.random() - 0.5) * 15;
                    bird.state = 'landingOnReeds';
                    bird.groundDirection = group.groundDirection;
                    bird.isLandingOnReeds = true;
                }
            }

            // å¦‚æœå°ç»„å†³å®šé£èµ°ï¼Œç¡®ä¿æ‰€æœ‰æˆå‘˜éƒ½ç¦»å¼€
            if (group.behavior === "flyThrough") {
                // ç¡®ä¿æ‰€æœ‰æˆå‘˜éƒ½åœ¨é£è¡ŒçŠ¶æ€
                if (bird.state === 'landingOnReeds' || bird.state === 'onReedsGround') {
                    bird.state = 'takingOff';
                    bird.stateTime = 0;
                    bird.speed = 2.5 + Math.random();
                    bird.direction = group.direction;
                    bird.isLandingOnReeds = false;
                }
            }
        }
    }
      }
    }
        // è·³è¿‡ç‰¹æ®ŠçŠ¶æ€çš„é¸Ÿ
        if (bird.isChasingRaptor || bird.isFleeingFromChasers || bird.isChasedPatrolling) {
            continue;
        }
        
        // å¤„ç†è¢«çŒ›ç¦½æƒŠå“çš„é¸Ÿ
        if (bird.isFleeingFromRaptor && !(bird.name === "é‡‘çœ¶é¸»" || bird.name === "12000é¸»")) {
            const fleeAngle = (10 + Math.random() * 10) * Math.PI / 180;
            bird.x += bird.speed * bird.direction * Math.cos(fleeAngle);
            bird.y -= bird.speed * Math.sin(fleeAngle);
            
            if (bird.x < -500 || bird.x > GAME_WIDTH + 500 || bird.y < -500 || bird.y > GAME_HEIGHT + 500) {
                birds.splice(i, 1);
            }
            continue;
        }
                     
    
    
    if (bird.isHidingFromRaptor) {
        continue;
    }
    
    if (bird.isChasingRaptor) {
        continue;
    }
    
    if (bird.isFleeingFromChasers) {
        continue;
    }
    
    bird.stateTime += deltaTime;
    
    if (bird.name === "å°é¸®") {
        if (bird.state === 'appearing') {
            bird.state = 'perching';
        }
        
        if (bird.stateTime > (bird.stayTime || 15) * 1000) {
            if (littleOwl === bird) {
                littleOwl = null;
            }
            birds.splice(i, 1);
            continue;
        }
        continue;
    }
    
    if (bird.isBat) {
        updateBat(bird, deltaTime);
        continue;
    }
    
    if (bird.isOwl) {
        updateOwlBird(bird, deltaTime);
        continue;
    }
    
    const behavior = bird.actualBehavior || bird.type.behavior;
    
    if (bird.state === 'perching' && bird.eatFruits && !bird.isEating) {
            if (Math.random() < bird.eatProbability * (deltaTime / 1000)) {
                startEatingFruit(bird);
            }
        }
        
        if (bird.isEating && bird.eatingFruit) {
            bird.eatingTime += deltaTime;
            bird.eatAnimationOffset = Math.sin(bird.eatingTime * 0.01) * 3;
            bird.size = bird.originalSize + Math.sin(bird.eatingTime * 0.005) * 0.1;
            
            if (bird.eatingTime > bird.eatDuration) {
                finishEatingFruit(bird);
            }
        }
        
// ä¿®æ”¹ä¹Œé¸«æ‹‰å±é€»è¾‘
if (bird.name === "ä¹Œé¸«" && bird.state === 'flying') {
    if (!bird.lastPoopTime) {
        bird.lastPoopTime = gameTime;
    }
    
    if (gameTime - bird.lastPoopTime > bird.poopInterval) {
        if (Math.random() < bird.poopProbability) {
            // ç›´æ¥åœ¨æ¸¸æˆåæ ‡ç³»ä¸­è®¡ç®—
            const baseSize = 20;
            const birdSize = baseSize * bird.size;
            const bodyRadius = birdSize / 2;
            
            const poopSize = (2.5 + Math.random());
            const poop = {
                x: bird.x,
                y: bird.y + bodyRadius, // é¸Ÿèº«ä½“ä¸‹æ–¹
                size: poopSize,
                color: bird.poopColor || "#FFFFFF",
                speed: 1 + Math.random() * 0.5,
                createdAt: gameTime,
                lifetime: 10000,
                direction: bird.direction
            };
            
            poops.push(poop);
            bird.lastPoopTime = gameTime;
        }
    }
}
        
        if (bird.name === "å•„æœ¨é¸Ÿ" && bird.state === 'perching') {
            if (bird.stateTime % 1000 < 200) {
                bird.headOffsetX = 5 * (bird.targetTree.side === 'left' ? 1 : -1);
            } else {
                bird.headOffsetX = 0;
            }
        }
  
// ä¿®å¤ï¼šç¡®ä¿è§‚é¸Ÿæ¨¡å¼ä¸‹æ ‘æ –é¸Ÿçš„ç¦»å¼€è¡Œä¸ºæ­£å¸¸å·¥ä½œ
if (bird.state === 'perching' && bird.targetTree) {
  // ç¡®ä¿è§‚é¸Ÿæ¨¡å¼ä¸å½±å“ç¦»å¼€æ—¶é—´
  if (bird.stateTime > (bird.stayTime || 10) * 1000) {
// å¦‚æœæ˜¯é•¿è€³é¸®ï¼Œåˆ™è·³è¿‡é€šç”¨å¤„ç†
        if (bird.name === "é•¿è€³é¸®") {
            continue;
        }
    // å¦‚æœé¸Ÿæœ‰ç¦»å¼€æ¡ä»¶ï¼ˆæ¯”å¦‚åƒå®Œæœå®ï¼‰ï¼Œå°±ç¦»å¼€
    if (!bird.isEating || bird.eatingTime > (bird.eatDuration || 2000)) {
      bird.state = 'takingOff';
      bird.speed = 2.0;
      bird.direction = bird.targetTree.side === 'left' ? 1 : -1;
      bird.stateTime = 0;
      // ä¿®å¤ï¼šç¡®ä¿é¸Ÿä¸ä¼šåœ¨è§‚é¸Ÿæ¨¡å¼ä¸‹å¡ä½
      bird.isChasingRaptor = false;
      bird.isFleeingFromRaptor = false;
      bird.isFleeingFromChasers = false;
    }
  }
}      
        // åœ¨ updateBirds å‡½æ•°ä¸­ï¼Œæ‰¾åˆ°æ£•å¤´é¸¦é›€çš„å¤„ç†éƒ¨åˆ†ï¼Œä¿®æ”¹å¦‚ä¸‹ï¼š

if (bird.name === "æ£•å¤´é¸¦é›€" && behavior === "flyInReedsAndStay") {
    // ç¡®ä¿æ¯åªé¸Ÿéƒ½æœ‰é€Ÿåº¦å·®å¼‚å‚æ•°ï¼ˆåœ¨è¿›å…¥èŠ¦è‹‡åŒºæ—¶åˆå§‹åŒ–ï¼‰
    if (!bird.reedSpeedFactor) {
        // ä¸ºæ¯åªé¸Ÿç”Ÿæˆéšæœºé€Ÿåº¦å·®å¼‚å‚æ•°ï¼ˆÂ±25%ï¼Œæœ€å¤§50%å·®å¼‚ï¼‰
        bird.reedSpeedFactor = 0.75 + Math.random() * 0.5; // 0.75 ~ 1.25
    }
    
    if (bird.state === 'flying') {
        if (bird.y < reedZone.y) {
            bird.y = reedZone.y + Math.random() * 10;
        } else if (bird.y > reedZone.y + reedZone.height) {
            bird.y = reedZone.y + reedZone.height - Math.random() * 10;
        }
        
        if (bird.x > reedZone.x && bird.x < reedZone.x + reedZone.width) {
            bird.state = 'stayingInReeds';
            bird.stateTime = 0;
            // åº”ç”¨ä¸ªä½“é€Ÿåº¦å·®å¼‚
            bird.speed = 0.5 * bird.reedSpeedFactor; // åŸºå‡†é€Ÿåº¦0.5ï¼Œä¹˜ä»¥é€Ÿåº¦å› å­
        }
    } else if (bird.state === 'stayingInReeds') {
        // åº”ç”¨ä¸ªä½“é€Ÿåº¦å·®å¼‚çš„æ¨ªå‘ç§»åŠ¨
        bird.x += bird.speed * bird.direction;
        bird.y += Math.sin(bird.stateTime * 0.005) * 0.3;
        
        if (bird.x < reedZone.x || bird.x > reedZone.x + reedZone.width) {
            bird.state = 'takingOff';
            // èµ·é£é€Ÿåº¦ä¹Ÿåº”ç”¨ä¸ªä½“å·®å¼‚
            bird.speed = 1.0 * bird.reedSpeedFactor;
            if (bird.groupId && birdGroupInfo[bird.groupId]) {
                bird.direction = birdGroupInfo[bird.groupId].direction;
            }
        }
    }
}
        
// åœ¨ updateBirds å‡½æ•°ä¸­ï¼Œä¿®æ”¹éº»é›€å’Œå°åŒ—çš„å¤„ç†é€»è¾‘ï¼š

if ((bird.name === "éº»é›€" || bird.name === "å°åŒ—") && 
    (bird.actualBehavior === "flyToReedsAndStay" || 
     bird.type.behavior === "flyToReedsAndStay")) {
    
    let reedStayTime = bird.reedStayTime;
    if (!reedStayTime) {
        reedStayTime = bird.name === "éº»é›€" ? 15000 : 20000;
    }
    
    let reedMoveSpeed = bird.reedMoveSpeed;
    if (!reedMoveSpeed) {
        reedMoveSpeed = bird.name === "éº»é›€" ? 0.5 * 0.2 : 0.6 * 0.2; // é™ä¸ºåŸæ¥çš„1/5
    }
    
    switch (bird.state) {
        case 'flying':
            // åªåœ¨è¿›å…¥èŠ¦è‹‡åŒºå‰è®¾ç½®ä¸€æ¬¡ç›®æ ‡ç‚¹ï¼Œé¿å…é‡å¤è®¾ç½®å¯¼è‡´è·³å˜
            if (!bird.reedTargetX && reedZone) {
                // è®¾ç½®ç›®æ ‡ç‚¹åœ¨èŠ¦è‹‡åŒºä¸­å¿ƒä¸‰åˆ†ä¹‹ä¸€åŒºåŸŸå†…
                const centerThirdWidth = reedZone.width / 3;
                const centerThirdLeft = reedZone.x + reedZone.width / 3;
                
                bird.reedTargetX = centerThirdLeft + Math.random() * centerThirdWidth;
                bird.reedTargetY = reedZone.y + reedZone.height * 0.5 + Math.random() * reedZone.height * 0.3;
                
                // è®°å½•å¼€å§‹é™è½çš„æ—¶é—´ï¼Œç”¨äºå¹³æ»‘è¿‡æ¸¡
                bird.landingStartTime = gameTime;
                bird.landingDuration = (1000 + Math.random() * 500) * 5; // å»¶é•¿5å€ï¼Œé™ä½é€Ÿåº¦
                bird.landingStartX = bird.x;
                bird.landingStartY = bird.y;
                
                // é™ä½é£è¡Œé€Ÿåº¦åˆ°åŸæ¥çš„1/5
                bird.speed *= 0.2;
            }
            
            if (bird.reedTargetX && bird.reedTargetY) {
                const elapsedTime = gameTime - bird.landingStartTime;
                const progress = Math.min(elapsedTime / bird.landingDuration, 1);
                
                // ä½¿ç”¨ç¼“åŠ¨å‡½æ•°å®ç°å¹³æ»‘é™è½
                const easeProgress = easeInOutQuad(progress);
                
                // è®¡ç®—å¹³æ»‘çš„é™è½ä½ç½®
                bird.x = bird.landingStartX + (bird.reedTargetX - bird.landingStartX) * easeProgress;
                bird.y = bird.landingStartY + (bird.reedTargetY - bird.landingStartY) * easeProgress;
                
                // åœ¨é™è½è¿‡ç¨‹ä¸­ä¿æŒåˆç†çš„é€Ÿåº¦æ„Ÿ
                const speedFactor = 1 - (progress * 0.7); // è¶Šæ¥è¿‘ç›®æ ‡é€Ÿåº¦è¶Šæ…¢
                bird.direction = (bird.reedTargetX - bird.landingStartX) > 0 ? 1 : -1;
                
                // å½“éå¸¸æ¥è¿‘ç›®æ ‡ç‚¹æ—¶ï¼Œåˆ‡æ¢åˆ°åœç•™çŠ¶æ€
                if (progress >= 0.95 || elapsedTime > bird.landingDuration) {
                    // ç¡®ä¿æœ€ç»ˆä½ç½®åœ¨èŠ¦è‹‡åŒºå†…
                    const centerThirdWidth = reedZone.width / 3;
                    const centerThirdLeft = reedZone.x + reedZone.width / 3;
                    const centerThirdRight = centerThirdLeft + centerThirdWidth;
                    
                    bird.x = Math.max(centerThirdLeft, Math.min(centerThirdRight, bird.reedTargetX));
                    bird.y = Math.max(reedZone.y, Math.min(reedZone.y + reedZone.height, bird.reedTargetY));
                    
                    // å¹³æ»‘åˆ‡æ¢åˆ°åœç•™çŠ¶æ€
                    bird.state = 'stayingInReeds';
                    bird.stateTime = 0;
                    bird.speed = reedMoveSpeed;
                    bird.reedStayTime = reedStayTime;
                    
                    // è®¾ç½®ä¸€ä¸ªå°çš„éšæœºç§»åŠ¨èŒƒå›´ï¼Œé¿å…å®Œå…¨é™æ­¢
                    bird.reedsMoveRangeX = 15;
                    bird.reedsMoveRangeY = 8;
                    bird.reedsMoveTimer = 0;
                    bird.reedsMoveSpeed = (0.2 + Math.random() * 0.3) * 1; 
                    
                    // æ¸…é™¤é™è½æ•°æ®
                    bird.reedTargetX = null;
                    bird.reedTargetY = null;
                    bird.landingStartTime = null;
                }
            }
            break;
            
        case 'stayingInReeds':
    bird.stateTime += deltaTime;
    
    // åˆå§‹åŒ–è·³è·ƒç›¸å…³å±æ€§
    if (bird.jumpInterval === undefined) {
        bird.jumpInterval = 2000 + Math.random() * 3000; // 2-5ç§’éšæœºé—´éš”
        bird.lastJumpTime = gameTime;
        bird.jumpDirection = bird.direction; // å¤´éƒ¨æœå‘å†³å®šè·³è·ƒæ–¹å‘
    }
    
    // æ£€æŸ¥æ˜¯å¦åˆ°è¾¾èŠ¦è‹‡é¡¶éƒ¨
    const reedTopThreshold = reedZone.y + 20; // èŠ¦è‹‡é¡¶éƒ¨é˜ˆå€¼
    if (bird.y <= reedTopThreshold && !bird.reachedTop) {
        bird.reachedTop = true;
        bird.topStayStartTime = gameTime;
        bird.speed = 0; // åˆ°è¾¾é¡¶éƒ¨ååœæ­¢ç§»åŠ¨
    }
    
    // å¦‚æœåˆ°è¾¾é¡¶éƒ¨ï¼Œåœç•™5ç§’åç¦»å¼€
    if (bird.reachedTop) {
        if (gameTime - bird.topStayStartTime > 5000) {
            bird.state = 'takingOffFromReeds';
            bird.stateTime = 0;
            bird.speed = (bird.name === "éº»é›€" ? 1.5 : 1.3);
            bird.direction = Math.random() > 0.5 ? 1 : -1;
            bird.takeoffStartX = bird.x;
            bird.takeoffStartY = bird.y;
            bird.takeoffStartTime = gameTime;
            bird.takeoffDuration = (1000 + Math.random() * 500) * 3;
            bird.takeoffTargetX = bird.x + (bird.direction === 1 ? 300 : -300);
            bird.takeoffTargetY = -50;
        }
        continue;
    }
    
    // æ¯éš”1-5ç§’è·³è·ƒä¸€æ¬¡
    if (gameTime - bird.lastJumpTime > bird.jumpInterval) {
        bird.lastJumpTime = gameTime;
        bird.jumpInterval = 1000 + Math.random() * 4000; // é‡æ–°è®¾ç½®è·³è·ƒé—´éš”
        
        // æ ¹æ®å¤´éƒ¨æœå‘å†³å®šè·³è·ƒæ–¹å‘
        const jumpAngle = bird.jumpDirection === 1 ? 
            -Math.PI/4 :  // å‘å³ä¸Šè·³ï¼ˆ45åº¦è§’ï¼‰
            -3*Math.PI/4; // å‘å·¦ä¸Šè·³ï¼ˆ135åº¦è§’ï¼‰
        
        // è·³è·ƒè·ç¦»ï¼ˆä¸€ä¸ªèº«ä½ï¼‰
        const jumpDistance = 40 * bird.size;
        
        // è®¡ç®—æ–°ä½ç½®
        const newX = bird.x + Math.cos(jumpAngle) * jumpDistance;
        const newY = bird.y + Math.sin(jumpAngle) * jumpDistance;
        
        // æ£€æŸ¥æ˜¯å¦åœ¨èŠ¦è‹‡åŒºåŸŸå†…
        const centerThirdWidth = reedZone.width / 3;
        const centerThirdLeft = reedZone.x + reedZone.width / 3;
        const centerThirdRight = centerThirdLeft + centerThirdWidth;
        
        // é™åˆ¶åœ¨èŠ¦è‹‡åŒºåŸŸå†…
        bird.x = Math.max(centerThirdLeft, Math.min(centerThirdRight, newX));
        bird.y = Math.max(reedZone.y, Math.min(reedZone.y + reedZone.height, newY));
        
        // è·³è·ƒåŠ¨ç”»æ•ˆæœ
        bird.isJumping = true;
        bird.jumpStartTime = gameTime;
        bird.jumpDuration = 300; // è·³è·ƒåŠ¨ç”»æŒç»­æ—¶é—´
        bird.originalY = bird.y;
    }
    
    // è·³è·ƒåŠ¨ç”»
    if (bird.isJumping) {
        const jumpElapsed = gameTime - bird.jumpStartTime;
        const jumpProgress = Math.min(jumpElapsed / bird.jumpDuration, 1);
        
        // ä½¿ç”¨ç¼“åŠ¨å‡½æ•°ä½¿è·³è·ƒæ›´è‡ªç„¶
        const easeProgress = easeInOutQuad(jumpProgress);
        
        // è®¡ç®—è·³è·ƒé«˜åº¦ï¼ˆæŠ›ç‰©çº¿è½¨è¿¹ï¼‰
        const maxJumpHeight = 10; // æœ€å¤§è·³è·ƒé«˜åº¦
        const jumpHeight = 4 * maxJumpHeight * easeProgress * (1 - easeProgress);
        
        bird.y = bird.originalY - jumpHeight;
        
        // è·³è·ƒç»“æŸ
        if (jumpProgress >= 1) {
            bird.isJumping = false;
            bird.y = bird.originalY; // å›åˆ°åŸå§‹é«˜åº¦
        }
    }
    
   
    // æ£€æŸ¥æ€»åœç•™æ—¶é—´æ˜¯å¦ç»“æŸ
    if (bird.stateTime > bird.reedStayTime && !bird.reachedTop) {
        bird.state = 'takingOffFromReeds';
        bird.stateTime = 0;
        bird.speed = (bird.name === "éº»é›€" ? 1.5 : 1.3);
        bird.direction = Math.random() > 0.5 ? 1 : -1;
        bird.takeoffStartX = bird.x;
        bird.takeoffStartY = bird.y;
        bird.takeoffStartTime = gameTime;
        bird.takeoffDuration = (1000 + Math.random() * 500) * 3;
        bird.takeoffTargetX = bird.x + (bird.direction === 1 ? 300 : -300);
        bird.takeoffTargetY = -50;
    }
    break;
            
// åœ¨ updateBirds å‡½æ•°ä¸­ï¼Œä¿®æ”¹éº»é›€å’Œå°åŒ—çš„èµ·é£é˜¶æ®µï¼š

case 'takingOffFromReeds':
    bird.stateTime += deltaTime;
    if (!bird.takeoffInitialized) {
        bird.takeoffInitialized = true;
        bird.takeoffSpeed = bird.speed;
        // ä¿®æ”¹è¿™é‡Œï¼šèµ·é£è§’åº¦ä¸è¶…è¿‡20åº¦
        bird.takeoffAngle = (10 + Math.random() * 10) * Math.PI / 180; // 10-20åº¦
        bird.takeoffVx = Math.cos(bird.takeoffAngle) * bird.takeoffSpeed * bird.direction;
        bird.takeoffVy = -Math.sin(bird.takeoffAngle) * bird.takeoffSpeed;
        bird.startTakeoffY = bird.y;
        bird.maxClimbHeight = Math.max(GAME_HEIGHT * 0.3, reedZone.y - 50);
    }
    bird.x += bird.takeoffVx;
    bird.y += bird.takeoffVy;
    if (bird.y < bird.maxClimbHeight) {
        bird.y = bird.maxClimbHeight;
        bird.takeoffVy = 0;
        if (bird.y < bird.startTakeoffY - 50) {
            bird.takeoffVy = -bird.takeoffSpeed * 0.1;
        }
    }
    const margin = 100;
    if (bird.x < -margin || bird.x > GAME_WIDTH + margin || bird.y < -margin || bird.y > GAME_HEIGHT + margin) {
        birds.splice(i, 1);
    }
    if (bird.stateTime > 15000) {
        birds.splice(i, 1);
    }
    break;
    }
    
    if (bird.state === 'stayingInReeds' || bird.state === 'takingOffFromReeds') {
        continue;
    }
}

// ä¿®æ”¹å…¶ä»–é¸Ÿç±»åœ¨èŠ¦è‹‡åŒºçš„è¡Œä¸ºï¼Œä½¿å…¶é€‚åº”æ–°çš„èŠ¦è‹‡åŒºå®½åº¦
if ((bird.name === "é‡‘çœ¶é¸»" || bird.name === "12000é¸»") && bird.isLandingOnReeds) {
    switch (bird.state) {
        case 'landingOnReeds':
            // åœ¨é‡‘çœ¶é¸»å’Œ12000é¸»çš„ä»£ç ä¸­ï¼Œä¿®æ”¹ç›®æ ‡ç‚¹é€‰æ‹©ï¼š
if (!bird.reedTargetX && reedZone) {
    // åœ¨æ•´ä¸ªèŠ¦è‹‡åŒºå®½åº¦å†…é€‰æ‹©ç›®æ ‡ç‚¹ï¼ˆæ³¨æ„èŠ¦è‹‡åŒºå·¦ä¾§æœ‰200åƒç´ ç¼©è¿›ï¼‰
    bird.reedTargetX = reedZone.x + Math.random() * reedZone.width;
    bird.reedTargetY = reedZone.y + reedZone.height - 3;
}
            
            if (bird.reedTargetX && bird.reedTargetY) {
                const dx = bird.reedTargetX - bird.x;
                const dy = bird.reedTargetY - bird.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 2) {
                    bird.state = 'onReedsGround';
                    bird.groundTime = 0;
                    bird.groundDirection = Math.random() > 0.5 ? 1 : -1;
                    bird.speed = bird.groundMoveSpeed || 0.3;
                } else {
                    bird.x += (dx / distance) * 2;
                    bird.y += (dy / distance) * 2;
                }
            }
            break;
            
case 'onReedsGround':
    bird.groundTime += deltaTime;
    
    // âœ… æ–°å¢ï¼šå°ç»„åè°ƒåœ°é¢ç§»åŠ¨
    // å¦‚æœæœ‰å°ç»„ä¿¡æ¯ï¼Œä½¿ç”¨å°ç»„ç»Ÿä¸€çš„åœ°é¢ç§»åŠ¨æ–¹å‘
    if (bird.groupId && birdGroupInfo[bird.groupId] && 
        (bird.name === "é‡‘çœ¶é¸»" || bird.name === "12000é¸»")) {
        
        const group = birdGroupInfo[bird.groupId];
        
        // ä½¿ç”¨å°ç»„ç»Ÿä¸€çš„åœ°é¢ç§»åŠ¨æ–¹å‘
        if (group.groundDirection) {
            bird.groundDirection = group.groundDirection;
        }
        
        // å¦‚æœå°ç»„æœ‰ç»Ÿä¸€çš„ç›®æ ‡ä½ç½®ï¼Œç¡®ä¿é¸Ÿä¸è¦ç¦»å¾—å¤ªè¿œ
        if (group.reedTargetX) {
            const distanceFromGroupCenter = Math.abs(bird.x - group.reedTargetX);
            
            // å¦‚æœç¦»å°ç»„ä¸­å¿ƒå¤ªè¿œï¼ˆè¶…è¿‡30åƒç´ ï¼‰ï¼Œè°ƒæ•´æ–¹å‘å‘ä¸­å¿ƒç§»åŠ¨
            if (distanceFromGroupCenter > 30) {
                bird.groundDirection = bird.x > group.reedTargetX ? -1 : 1;
                // æ›´æ–°å°ç»„æ–¹å‘ï¼Œç¡®ä¿å…¶ä»–æˆå‘˜ä¹Ÿè·Ÿéš
                group.groundDirection = bird.groundDirection;
            }
        }
        
        // âœ… å°ç»„ç»Ÿä¸€æ”¹å˜æ–¹å‘çš„é€»è¾‘
        // ä¸å†æ¯åªé¸Ÿç‹¬ç«‹æ”¹å˜æ–¹å‘ï¼Œè€Œæ˜¯ç”±å°ç»„ç»Ÿä¸€å†³å®š
        // å½“å°ç»„ç»Ÿä¸€æ”¹å˜æ–¹å‘æ—¶ï¼Œæ‰€æœ‰æˆå‘˜ä¸€èµ·æ”¹å˜
        if (group.lastDirectionChange && (bird.groundTime - group.lastDirectionChange) > 3000) {
            // æ¯3ç§’å°ç»„å¯èƒ½æ”¹å˜æ–¹å‘
            if (Math.random() < 0.3) { // 30%æ¦‚ç‡æ”¹å˜æ–¹å‘
                group.groundDirection *= -1;
                group.lastDirectionChange = bird.groundTime;
            }
        } else if (!group.lastDirectionChange) {
            group.lastDirectionChange = bird.groundTime;
        }
    } else {
        // åŸæœ‰çš„ç‹¬ç«‹è¡Œä¸ºï¼šæ¯3ç§’å¯èƒ½ç‹¬ç«‹æ”¹å˜æ–¹å‘
        if (bird.groundTime % 3000 < deltaTime) {
            bird.groundDirection = Math.random() > 0.5 ? 1 : -1;
        }
    }
    
    // ç¼“æ…¢ç§»åŠ¨ï¼ˆä½¿ç”¨å°ç»„åè°ƒåçš„æ–¹å‘ï¼‰
    bird.x += (bird.groundMoveSpeed || 0.3) * bird.groundDirection;
    
    // ä¿æŒåœ¨èŠ¦è‹‡åŒºå†…ï¼ˆè€ƒè™‘å°ç»„åè°ƒï¼‰
    if (bird.x < reedZone.x) {
        bird.x = reedZone.x;
        bird.groundDirection = 1;
        // å¦‚æœæ˜¯å°ç»„ï¼Œæ›´æ–°å°ç»„æ–¹å‘
        if (bird.groupId && birdGroupInfo[bird.groupId]) {
            birdGroupInfo[bird.groupId].groundDirection = 1;
        }
    } else if (bird.x > reedZone.x + reedZone.width) {
        bird.x = reedZone.x + reedZone.width;
        bird.groundDirection = -1;
        // å¦‚æœæ˜¯å°ç»„ï¼Œæ›´æ–°å°ç»„æ–¹å‘
        if (bird.groupId && birdGroupInfo[bird.groupId]) {
            birdGroupInfo[bird.groupId].groundDirection = -1;
        }
    }
    
    // å•„é£ŸåŠ¨ç”»
    if (bird.groundTime % 1500 < deltaTime) {
        bird.peckingState = 1; // å¼€å§‹å•„é£Ÿ
        bird.peckingTimer = 0;
    }
    
    if (bird.peckingState > 0) {
        bird.peckingTimer += deltaTime;
        if (bird.peckingTimer > 200) {
            bird.peckingState = 0; // å•„é£Ÿç»“æŸ
        }
    }
    
    // âœ… æ–°å¢ï¼šå°ç»„ç»Ÿä¸€åœç•™æ—¶é—´ï¼Œé¿å…æœ‰çš„é¸Ÿé£èµ°æœ‰çš„ç•™ä¸‹
    // è®¡ç®—åœç•™æ—¶é—´æ—¶è€ƒè™‘å°ç»„ç»Ÿä¸€æ€§
    let adjustedStayTime = (bird.stayTime || 30) * 1000;
    
    // å¦‚æœæœ‰å°ç»„ï¼Œä½¿ç”¨å°ç»„ç»Ÿä¸€çš„åœç•™æ—¶é—´
    if (bird.groupId && birdGroupInfo[bird.groupId]) {
        const group = birdGroupInfo[bird.groupId];
        
        // è®°å½•å°ç»„å¼€å§‹åœç•™çš„æ—¶é—´ï¼ˆå¦‚æœæ²¡æœ‰è®°å½•çš„è¯ï¼‰
        if (!group.groundStartTime) {
            group.groundStartTime = bird.groundTime;
        }
        
        // è®¡ç®—å°ç»„å·²ç»åœç•™çš„æ—¶é—´
        const groupStayTime = bird.groundTime - group.groundStartTime;
        
        // å¦‚æœå°ç»„åœç•™æ—¶é—´åˆ°äº†ï¼Œæ‰€æœ‰æˆå‘˜ä¸€èµ·èµ·é£
        if (groupStayTime > adjustedStayTime) {
            bird.state = 'takingOff';
            bird.speed = 1.5 + Math.random() * 0.5;
            bird.direction = Math.random() > 0.5 ? 1 : -1;
            
            // å¦‚æœæ˜¯å°ç»„ï¼Œç¡®ä¿æ‰€æœ‰æˆå‘˜æœ‰ç›¸åŒçš„èµ·é£æ–¹å‘
            if (group.groundDirection) {
                bird.direction = group.groundDirection > 0 ? 1 : -1;
            }
            
            continue;
        }
    } else {
        // åŸæœ‰çš„ç‹¬ç«‹èµ·é£é€»è¾‘
        if (bird.groundTime > adjustedStayTime) {
            bird.state = 'takingOff';
            bird.speed = 1.5;
            bird.direction = Math.random() > 0.5 ? 1 : -1;
        }
    }
    break;
    }
    
    if (bird.state === 'landingOnReeds' || bird.state === 'onReedsGround') {
        continue;
    }
}
        
        if (bird.name === "é»‘ç¿…é¸¢" && bird.state === 'circling' && !bird.hasGeneratedMouse) {
            bird.mouseTarget = generateGroundMouseForPredator(bird.name);
            bird.hasGeneratedMouse = true;
            bird.circlingTime = 0;
        }
        
        switch (bird.state) {
            case 'circling':
                bird.circlingTime += deltaTime;
                
                
                bird.circlingAngle += 0.01;
                bird.x = bird.circlingCenterX + Math.cos(bird.circlingAngle) * bird.circlingRadius;
                bird.y = bird.circlingCenterY + Math.sin(bird.circlingAngle) * bird.circlingRadius;
                
                const tangentAngle = bird.circlingAngle + Math.PI / 2;
                bird.direction = Math.cos(tangentAngle) > 0 ? 1 : -1;
                
                if (bird.name === "çº¢éš¼" && !bird.mouseTarget) {
                    for (let j = groundObjects.length - 1; j >= 0; j--) {
                        const mouse = groundObjects[j];
                        if (mouse.type === "mouse" && mouse.predatorTarget === "çº¢éš¼") {
                            bird.mouseTarget = mouse;
                            bird.hasFoundMouse = true;
                            break;
                        }
                    }
                }
                
                if (bird.name === "é»‘ç¿…é¸¢" && !bird.hasGeneratedMouse) {
                    bird.mouseTarget = generateGroundMouseForPredator(bird.name);
                    bird.hasGeneratedMouse = true;
                    bird.circlingTime = 0;
                }
                
                if (bird.name === "é»‘ç¿…é¸¢" && bird.huntingMouse) {
                    if (bird.circlingTime > 2000 + Math.random() * 2000) {
                        bird.state = 'hovering';
                        bird.speed = 0;
                        bird.hoveringTime = 0;
                    }
                } else if (bird.name === "çº¢éš¼" && bird.isPredator) {
                    if (bird.circlingTime > 2000 + Math.random() * 2000) {
                        if (bird.mouseTarget) {
                            bird.state = 'hovering';
                            bird.speed = 0;
                            bird.hoveringTime = 0;
                        } else {
                            bird.state = 'hunting';
                            bird.speed = (3 + Math.random() * 2);
                            bird.direction = Math.random() > 0.5 ? 1 : -1;
                        }
                    }
                } else if (bird.name === "æ¸¸éš¼" && bird.huntingBird) {
                    if (bird.circlingTime > 2000 + Math.random() * 2000) {
                        bird.state = 'huntingBird';
                        bird.speed = (3 + Math.random() * 2) * 3;
                        bird.direction = Math.random() > 0.5 ? 1 : -1;
                    }
                }
                break;
                
            case 'divingToMouse':
                if (bird.mouseTarget && bird.mouseTarget.type === "mouse") {
                    const dx = bird.mouseTarget.x - bird.x;
                    const dy = bird.mouseTarget.y - bird.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < 25) {
                        if (Math.random() < bird.catchMouseChance) {
                            bird.caughtMouse = { x: 0, y: 0, size: 8, type: "mouse" };
                            bird.state = 'flyingWithMouse';
                            bird.speed = 1.5;
                            bird.direction = 1;
                            
                            const index = groundObjects.indexOf(bird.mouseTarget);
                            if (index !== -1) {
                                groundObjects.splice(index, 1);
                            }
                            bird.mouseTarget = null;
                            
                            scareMode = true;
                            scareModeEndTime = gameTime + 5000;
                        } else {
                            const index = groundObjects.indexOf(bird.mouseTarget);
                            if (index !== -1) {
                                groundObjects.splice(index, 1);
                            }
                            bird.mouseTarget = null;
                            bird.state = 'takingOffToCircle';
                            bird.speed = 1.5;
                            bird.direction = 1;
                            bird.takeoffStartTime = gameTime;
                            bird.takeoffDuration = 3000;
                            bird.startX = bird.x;
                            bird.startY = bird.y;
                            bird.targetX = bird.circlingCenterX;
                            bird.targetY = bird.circlingCenterY;
                            bird.hasGeneratedMouse = false;
                        }
                    } else {
                        bird.x += (dx / distance) * bird.speed;
                        bird.y += (dy / distance) * bird.speed;
                        bird.direction = dx > 0 ? 1 : -1;
                    }
                } else {
                    bird.state = 'takingOffToCircle';
                    bird.speed = 1.5;
                    bird.direction = 1;
                    bird.takeoffStartTime = gameTime;
                    bird.takeoffDuration = 3000;
                    bird.startX = bird.x;
                    bird.startY = bird.y;
                    bird.targetX = bird.circlingCenterX;
                    bird.targetY = bird.circlingCenterY;
                    bird.mouseTarget = null;
                    bird.hasGeneratedMouse = false;
                }
                break;
                
            case 'takingOffToCircle':
                const elapsedTime = gameTime - bird.takeoffStartTime;
                const progress = Math.min(elapsedTime / bird.takeoffDuration, 1);
                const easeProgress = easeInOutQuad(progress);
                
                bird.x = bird.startX + (bird.targetX - bird.startX) * easeProgress;
                bird.y = bird.startY + (bird.targetY - bird.startY) * easeProgress;
                
                if (progress < 0.3) {
                    bird.y -= 1;
                } else if (progress < 0.7) {
                    bird.y -= 0.5;
                } else {
                    bird.y += 0.2;
                }
                
                bird.direction = (bird.targetX - bird.startX) > 0 ? 1 : -1;
                
                if (progress >= 1) {
                    bird.state = 'circling';
                    bird.circlingTime = 0;
                    bird.circlingAngle = Math.random() * Math.PI * 2;
                    bird.x = bird.targetX;
                    bird.y = bird.targetY;
                }
                break;
                
            case 'followingMousePath':
                if (bird.mouseFlightIndex < bird.mouseFlightPath.length) {
                    const targetPoint = bird.mouseFlightPath[bird.mouseFlightIndex];
                    const dx = targetPoint.x - bird.x;
                    const dy = targetPoint.y - bird.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < 5) {
                        bird.mouseFlightIndex++;
                    } else {
                        bird.x += (dx / distance) * bird.speed;
                        bird.y += (dy / distance) * bird.speed;
                        bird.direction = dx > 0 ? 1 : -1;
                    }
                    
                    if (bird.mouseFlightIndex >= bird.mouseFlightPath.length) {
                        if (bird.name === "é»‘ç¿…é¸¢") {
                            bird.state = 'huntingMouse';
                            bird.hasLanded = false;
                            bird.groundTime = 0;
                        } else if (bird.name === "æ¸¸éš¼") {
                            bird.state = 'huntingBird';
                        }
                    }
                }
                break;
                
            case 'hovering':
                bird.hoveringTime += deltaTime;
                bird.y += Math.sin(bird.hoveringTime * 0.005) * 0.5;
                
                if (bird.name === "çº¢éš¼") {
                    if (bird.hoveringTime > 3000) {
                        if (bird.mouseTarget && bird.mouseTarget.type === "mouse") {
                            bird.state = 'divingToMouse';
                            bird.speed = 3.0;
                        } else {
                            bird.state = 'hunting';
                            bird.speed = 3 + Math.random() * 2;
                            bird.direction = Math.random() > 0.5 ? 1 : -1;
                        }
                    }
                } else if (bird.hoveringTime > 5000) {
                    bird.state = 'huntingMouse';
                    bird.speed = 3 + Math.random() * 2;
                    bird.direction = Math.random() > 0.5 ? 1 : -1;
                }
                break;
                
            case 'huntingMouse':
                if (!bird.hasLanded) {
                    bird.x += bird.speed * bird.direction * 0.3;
                    bird.y += bird.speed * 1.5;
                    
                    if (bird.y >= GAME_HEIGHT - 50) {
                        bird.hasLanded = true;
                        bird.groundTime = 0;
                        bird.y = GAME_HEIGHT - 30;
                    }
                } else {
                    bird.groundTime += deltaTime;
                    if (bird.groundTime > 500 && !bird.caughtMouse) {
                        if (Math.random() < 0.5) {
                            bird.caughtMouse = { x: 0, y: 0, size: 8 };
                            bird.state = 'flyingWithMouse';
                            bird.speed = 1.5;
                            bird.direction = 1;
                            scareMode = true;
                            scareModeEndTime = gameTime + 5000;
                        } else {
                            bird.state = 'takingOff';
                            bird.speed = 1.5;
                            bird.direction = 1;
                        }
                    }
                }
                
                if (bird.y > GAME_HEIGHT + 100) {
                    birds.splice(i, 1);
                }
                break;
                
            case 'hunting':
                bird.x += bird.speed * bird.direction * 0.3;
                if (bird.y < GAME_HEIGHT - 50) {
                    bird.y += bird.speed * 1.5;
                }
                
                if (bird.y >= GAME_HEIGHT - 50 && !bird.caughtDove && !bird.caughtMouse) {
                    bird.y = GAME_HEIGHT - 50;
                    
                    if (Math.random() < bird.catchDoveChance) {
                        bird.caughtDove = { x: 0, y: 0, size: 12 };
                        bird.state = 'flyingWithDove';
                        bird.speed = 1.5;
                        bird.direction = 1;
                        scareMode = true;
                        scareModeEndTime = gameTime + 5000;
                    } else if (Math.random() < bird.catchMouseChance) {
                        bird.caughtMouse = { x: 0, y: 0, size: 8 };
                        bird.state = 'flyingWithMouse';
                        bird.speed = 1.5;
                        bird.direction = 1;
                        scareMode = true;
                        scareModeEndTime = gameTime + 5000;
                    } else if (Math.random() < bird.leaveChance) {
                        bird.state = 'flyingAway';
                        bird.speed = 1.5;
                        bird.direction = 1;
                    } else {
                        bird.state = 'flyingAway';
                        bird.speed = 1.5;
                        bird.direction = 1;
                    }
                }
                
                if (bird.y > GAME_HEIGHT + 100) {
                    birds.splice(i, 1);
                }
                break;
                
            case 'huntingBird':
                bird.x += bird.speed * bird.direction * 0.3;
                bird.y += bird.speed * 1.5;
                
                if (bird.y > GAME_HEIGHT - 100 && !bird.caughtBird && Math.random() < 0.8) {
                    bird.caughtBird = { x: 0, y: 0, size: 10 };
                    bird.state = 'flyingWithBird';
                    bird.speed = 1.5;
                    bird.direction = 1;
                    bird.y -= 50;
                    scareMode = true;
                    scareModeEndTime = gameTime + 5000;
                }
                
                if (bird.y > GAME_HEIGHT + 100) {
                    birds.splice(i, 1);
                }
                break;
                
            case 'flyingWithMouse':
case 'flyingWithBird':
case 'flyingWithDove':
    // æ°´å¹³æ–œä¸Šé£ï¼Œè§’åº¦ä¸è¶…è¿‡20åº¦
    const flyingAwayAngle = (8 + Math.random() * 12) * Math.PI / 180; // 8-20åº¦
    bird.x += bird.speed * Math.cos(flyingAwayAngle);
    bird.y -= bird.speed * Math.sin(flyingAwayAngle);
    if (bird.x > GAME_WIDTH + 100 || bird.y < -100) {
        birds.splice(i, 1);
    }
    break;
                
            case 'flying':
                let speedFactor = 1;
                if (bird.direction === -1 && !bird.isChasing && !bird.isBeingChased) {
                    speedFactor = 0.3;
                }
                
                if (bird.name === "éº»é›€") {
                    // éº»é›€çš„åŸæœ‰è¡Œä¸ºï¼šç›´æ¥é£è¿‡å±å¹•
                    bird.x += bird.speed * bird.direction * speedFactor;
                    if ((bird.direction === 1 && bird.x > GAME_WIDTH + 200) || (bird.direction === -1 && bird.x < -200)) {
                        birds.splice(i, 1);
                        continue;
                    }
                } else if (bird.hunting) {
                    bird.x += bird.speed * bird.direction * speedFactor;
                    bird.y += bird.speed * 0.7 * speedFactor;
                } else {
                    bird.x += bird.speed * bird.direction * speedFactor;
                    if (behavior === 'waveFlight') {
                        bird.y += Math.sin(bird.stateTime * 0.01) * 2 * speedFactor;
                    }
                }
                
                if ((behavior === 'landOnTree' || behavior === 'appearOnTree') && bird.targetTree) {
                    const treeCenterX = bird.targetTree.x + bird.targetTree.width / 2;
                    const distanceToTree = Math.abs(bird.x - treeCenterX);
                    
                    if (distanceToTree < 50) {
                        bird.state = 'landing';
                        const tree = bird.targetTree;
                        const crownTopArea = {
                            x: tree.x + tree.width * 0.2,
                            y: tree.y + tree.height * 0.1,
                            width: tree.width * 0.6,
                            height: tree.height * 0.25
                        };
                        
                        if (bird.name === "å–œé¹Š" || bird.name === "ä¹Œé¸¦") {
                            const targetX = crownTopArea.x + Math.random() * crownTopArea.width;
                            const targetY = crownTopArea.y + Math.random() * crownTopArea.height;
                            bird.targetX = targetX;
                            bird.targetY = targetY;
                        } else {
                            const treeCenterY = tree.y + tree.height * 0.35;
                            const angle = Math.atan2(treeCenterY - bird.y, treeCenterX - bird.x);
                            const distance = 30 + Math.random() * 20;
                            bird.targetX = bird.x + Math.cos(angle) * distance;
                            bird.targetY = bird.y + Math.sin(angle) * distance;
                            
                            bird.targetX = Math.max(tree.x, Math.min(tree.x + tree.width, bird.targetX));
                            bird.targetY = Math.max(tree.y, Math.min(tree.y + tree.height * 0.7, bird.targetY));
                        }
                    }
                }
                
                if ((bird.direction === 1 && bird.x > GAME_WIDTH + 200) || (bird.direction === -1 && bird.x < -200) || bird.y > GAME_HEIGHT + 200) {
                    birds.splice(i, 1);
                    continue;
                }
                break;
                
            case 'landing':
                const dx = bird.targetX - bird.x;
                const dy = bird.targetY - bird.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 2) {
                    bird.state = 'perching';
                    bird.x = bird.targetX;
                    bird.y = bird.targetY;
                    bird.speed = 0;
                } else {
                    let landingSpeedFactor = 1;
                    if (bird.direction === -1 && !bird.isChasing && !bird.isBeingChased) {
                        landingSpeedFactor = 0.3;
                    }
                    
                    bird.x += (dx / distance) * 2 * landingSpeedFactor;
                    bird.y += (dy / distance) * 2 * landingSpeedFactor;
                }
                break;
                
            case 'perching':
                if (bird.name === "é•¿è€³é¸®") {
                    if (bird.stateTime > (bird.stayTime || 15) * 1000) {
                        birds.splice(i, 1);
                        continue;
                    }
                }
                
                if (behavior === 'landOnTreeThenMove') {
                    if (bird.stateTime > (bird.stayTimePerTree || 2000)) {
                        if (!bird.hasMovedToSecondTree) {
                            bird.state = 'movingToSecondTree';
                            bird.hasMovedToSecondTree = true;
                            bird.stateTime = 0;
                            
                            const currentTreeSide = bird.targetTree.side;
                            const oppositeTree = treePositions.find(tree => tree.side !== currentTreeSide);
                            
                            if (oppositeTree) {
                                bird.targetTree = oppositeTree;
                                const treeCenterX = oppositeTree.x + oppositeTree.width / 2;
                                const treeCenterY = oppositeTree.y + oppositeTree.height * 0.35;
                                const angle = Math.atan2(treeCenterY - bird.y, treeCenterX - bird.x);
                                const distance = 30 + Math.random() * 20;
                                
                                bird.targetX = bird.x + Math.cos(angle) * distance;
                                bird.targetY = bird.y + Math.sin(angle) * distance;
                                
                                bird.targetX = Math.max(oppositeTree.x, Math.min(oppositeTree.x + oppositeTree.width, bird.targetX));
                                bird.targetY = Math.max(oppositeTree.y, Math.min(oppositeTree.y + oppositeTree.height * 0.7, bird.targetY));
                                
                                bird.speed = 1.5;
                                bird.direction = bird.targetX > bird.x ? 1 : -1;
                            } else {
                                bird.state = 'takingOff';
                                bird.speed = 1;
                                if (bird.groupId && birdGroupInfo[bird.groupId]) {
                                    bird.direction = birdGroupInfo[bird.groupId].direction;
                                } else {
                                    bird.direction = Math.random() > 0.5 ? 1 : -1;
                                }
                            }
                        } else {
                            bird.state = 'takingOff';
                            bird.speed = 1;
                            if (bird.groupId && birdGroupInfo[bird.groupId]) {
                                bird.direction = birdGroupInfo[bird.groupId].direction;
                            } else {
                                bird.direction = Math.random() > 0.5 ? 1 : -1;
                            }
                        }
                    }
                } else {
                    if (bird.stateTime > (bird.stayTime || 10) * 1000) {
                        bird.state = 'takingOff';
                        bird.speed = 1;
                        if (bird.groupId && birdGroupInfo[bird.groupId]) {
                            bird.direction = birdGroupInfo[bird.groupId].direction;
                        } else {
                            bird.direction = Math.random() > 0.5 ? 1 : -1;
                        }
                    }
                }
                break;
                
            case 'takingOff':
    let takeoffSpeedFactor = 1;
    if (bird.direction === -1 && !bird.isChasing && !bird.isBeingChased) {
        takeoffSpeedFactor = 0.3;
    }
    // æ°´å¹³æ–œä¸Šé£ï¼Œè§’åº¦ä¸è¶…è¿‡20åº¦
    const takeoffAngle = (5 + Math.random() * 15) * Math.PI / 180; // 5-20åº¦
    bird.x += bird.speed * bird.direction * takeoffSpeedFactor * Math.cos(takeoffAngle);
    bird.y -= bird.speed * takeoffSpeedFactor * Math.sin(takeoffAngle);
    if (bird.x < -100 || bird.x > GAME_WIDTH + 100 || bird.y < -100) {
        birds.splice(i, 1);
    }
    break;
                
            case 'movingToSecondTree':
                if (bird.targetTree) {
                    const moveDx = bird.targetX - bird.x;
                    const moveDy = bird.targetY - bird.y;
                    const moveDistance = Math.sqrt(moveDx * moveDx + moveDy * moveDy);
                    
                    let moveSpeedFactor = 1;
                    if (bird.direction === -1 && !bird.isChasing && !bird.isBeingChased) {
                        moveSpeedFactor = 0.3;
                    }
                    
                    if (moveDistance < 2) {
                        bird.state = 'perching';
                        bird.x = bird.targetX;
                        bird.y = bird.targetY;
                        bird.speed = 0;
                        bird.stateTime = 0;
                        bird.direction = bird.targetTree.side === 'left' ? 1 : -1;
                    } else {
                        bird.x += (moveDx / moveDistance) * bird.speed * moveSpeedFactor;
                        bird.y += (moveDy / moveDistance) * bird.speed * moveSpeedFactor;
                        bird.direction = moveDx > 0 ? 1 : -1;
                    }
                } else {
                    bird.state = 'takingOff';
                    bird.speed = 1;
                    if (bird.groupId && birdGroupInfo[bird.groupId]) {
                        bird.direction = birdGroupInfo[bird.groupId].direction;
                    } else {
                        bird.direction = Math.random() > 0.5 ? 1 : -1;
                    }
                }
                break;
                
            case 'stayingInReeds':
                if (bird.name === "æ£•å¤´é¸¦é›€") {
                    bird.y += Math.sin(bird.stateTime * 0.005) * 0.3;
                }
                break;
                
            case 'flyingAway':
    // æ°´å¹³æ–œä¸Šé£ï¼Œè§’åº¦ä¸è¶…è¿‡20åº¦
    const flyingAwayAngle2 = (5 + Math.random() * 15) * Math.PI / 180; // 5-20åº¦
    bird.x += bird.speed * bird.direction * Math.cos(flyingAwayAngle2);
    bird.y -= bird.speed * Math.sin(flyingAwayAngle2);
    if ((bird.direction === 1 && bird.x > GAME_WIDTH + 200) || (bird.direction === -1 && bird.x < -200) || bird.y < -200) {
        birds.splice(i, 1);
    }
    break;
                
            case 'fleeing':
    // æ°´å¹³æ–œä¸Šé£ï¼Œè§’åº¦ä¸è¶…è¿‡20åº¦
    const fleeVerticalAngle = (10 + Math.random() * 10) * Math.PI / 180; // 10-20åº¦
    bird.x += bird.speed * bird.direction * Math.cos(fleeVerticalAngle);
    bird.y -= bird.speed * Math.sin(fleeVerticalAngle);
    if (bird.y < -100) {
        birds.splice(i, 1);
    }
    break;
        }
    }
    
    if (scareMode && gameTime >= scareModeEndTime) {
        scareMode = false;
        birds.forEach(bird => {
            if (bird.isScared) {
                bird.speed = bird.speed / 1.5;
                bird.isScared = false;
            }
            if (bird.isChasing && !bird.chasingTarget) {
                bird.isChasing = false;
            }
        });
    }
}

// ä¿®æ”¹ç¿ é¸Ÿç”Ÿæˆå‡½æ•°ï¼Œä»è¾ƒä½é«˜åº¦æ°´å¹³é£å…¥
function generateKingfisher(countStats = false) {
  const kingfisherType = BIRD_TYPES.KINGFISHER;
  
  if (countStats) {
    appearedBirds[kingfisherType.name] = (appearedBirds[kingfisherType.name] || 0) + 1;
    updateTextStats();
  }
  
  // ä»ç”»é¢å¤–é£å…¥ï¼Œç›´æ¥é£å‘èŠ¦è‹‡ä¸›
  const fromLeft = Math.random() > 0.5;
  const startX = fromLeft ? -50 : GAME_WIDTH + 50;
  
  // é£å‘èŠ¦è‹‡ä¸›åŒºåŸŸ
  const targetReedX = reedZone.x + Math.random() * reedZone.width;
  const targetReedY = reedZone.y + reedZone.height * 0.5; // åœåœ¨èŠ¦è‹‡ä¸Š
  
  // è®¾ç½®è¾ƒä½çš„é£è¡Œé«˜åº¦ - ä»èŠ¦è‹‡åŒºåŸŸä¸Šæ–¹ä¸€ç‚¹é£å…¥
  const startY = reedZone.y + reedZone.height * 0.5 + Math.random() * (GAME_HEIGHT * 0.1);
  
  const bird = {
    type: kingfisherType,
    name: kingfisherType.name,
    x: startX,
    y: startY, // è¾ƒä½çš„åˆå§‹é«˜åº¦
    size: kingfisherType.size,
    speed: 2.0,
    direction: fromLeft ? 1 : -1, // 1=å‘å³ï¼Œ-1=å‘å·¦
    state: 'flyingToReed',
    stateTime: 0,
    targetX: targetReedX,
    targetY: targetReedY,
    
    // é£å…¥æ—¶æ°´å¹³ï¼ŒheadAngle = 0
    headAngle: 0, // æ°´å¹³
    
    // åˆå§‹æœå‘ï¼ˆçœ‹å‘çš„æ–¹å‘ï¼‰
    facingDirection: fromLeft ? 1 : -1, // 1=å‘å³ï¼Œ-1=å‘å·¦
    
    // æ¢å‘ç›¸å…³
    nextTurnTime: 0,
    turnInterval: kingfisherType.turnInterval[0] + 
                  Math.random() * (kingfisherType.turnInterval[1] - kingfisherType.turnInterval[0]),
    
    stayTime: kingfisherType.stayTime[0] + 
              Math.random() * (kingfisherType.stayTime[1] - kingfisherType.stayTime[0]),
    
    diveTargetX: 0,
    diveTargetY: 0,
    hasDived: false,
    hasCaughtFish: false,
    caughtFish: null,
    fishOffsetX: 0,
    fishOffsetY: 0,
    fishAngle: 0,
    beakLengthMultiplier: kingfisherType.beakLengthMultiplier,
    isVulnerableToRaptors: true,
    noStats: !countStats,
    isKingfisher: true,
    
    // èº«ä½“æ˜¯å¦ç¿»è½¬çš„æ ‡å¿—ï¼ˆç”¨äºç»˜åˆ¶ï¼‰
    bodyFlipped: false
  };
  
  // è®¾ç½®è½¬å‘æ—¶é—´
  bird.nextTurnTime = gameTime + bird.turnInterval;
  
  birds.push(bird);
  
}

// ä¿®æ”¹é£è¡Œé€»è¾‘ï¼Œç¡®ä¿æ°´å¹³é£å…¥
function updateKingfisher(bird, deltaTime) {
  bird.stateTime += deltaTime;
  
  // æ£€æŸ¥æ˜¯å¦æœ‰çŒ›ç¦½é è¿‘ï¼ˆæƒŠå“æ¡ä»¶ï¼‰
  let raptorNearby = false;
  for (let otherBird of birds) {
    // æ£€æŸ¥æ˜¯å¦æ˜¯çŒ›ç¦½ç±»å‹
    if ((otherBird.name === "æ¸¸éš¼" || otherBird.name === "çº¢éš¼" || otherBird.name === "é»‘ç¿…é¸¢") && 
        otherBird.state !== 'fleeing') {
      const dx = otherBird.x - bird.x;
      const dy = otherBird.y - bird.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      // å¦‚æœçŒ›ç¦½åœ¨1000åƒç´ èŒƒå›´å†…
      if (distance < 1000) {
        raptorNearby = true;
        break;
      }
    }
  }
  
  // å¦‚æœçŒ›ç¦½é è¿‘ä¸”ç¿ é¸Ÿä¸åœ¨é€ƒè·‘çŠ¶æ€ï¼Œç«‹å³å¼€å§‹é€ƒè·‘
  if (raptorNearby && bird.state !== 'fleeingFromRaptor' && bird.state !== 'flyingAway') {
    bird.state = 'fleeingFromRaptor';
    bird.stateTime = 0;
    bird.speed = 3.5; // æƒŠå“é€ƒè·‘é€Ÿåº¦æ›´å¿«
    bird.direction = Math.random() > 0.5 ? 1 : -1; // éšæœºæ–¹å‘é€ƒè·‘
    bird.facingDirection = bird.direction;
    bird.headAngle = 0; // æ°´å¹³é£è¡Œ
    bird.bodyFlipped = (bird.facingDirection === -1);
    return; // ç«‹å³è¿”å›ï¼Œä¸æ‰§è¡Œåç»­çŠ¶æ€é€»è¾‘
  }
  
  switch (bird.state) {
    case 'flyingToReed':
      // é£å‘èŠ¦è‹‡ä¸› - ä¿æŒæ°´å¹³é£è¡Œï¼Œä¸æ”¹å˜yåæ ‡
      const dx = bird.targetX - bird.x;
      const horizontalDistance = Math.abs(dx);
      
      if (horizontalDistance < 5) {
        // åˆ°è¾¾ç›®æ ‡xåæ ‡ï¼Œæ£€æŸ¥æ˜¯å¦éœ€è¦ä¸‹é™
        if (Math.abs(bird.y - bird.targetY) < 5) {
          // å·²ç»åˆ°è¾¾ç›®æ ‡ä½ç½®ï¼Œåˆ‡æ¢åˆ°åœç•™çŠ¶æ€
          bird.state = 'perchingOnReed';
          bird.stateTime = 0;
          bird.speed = 0;
          bird.x = bird.targetX;
          bird.y = bird.targetY;
          
          // åˆ°è¾¾èŠ¦è‹‡åï¼Œå¤´å’Œå˜´æ–œå‘ä¸‹45åº¦
          bird.headAngle = Math.PI/4;
        } else {
          // éœ€è¦å‚ç›´ä¸‹é™
          const dy = bird.targetY - bird.y;
          const verticalDistance = Math.abs(dy);
          
          if (verticalDistance < 2) {
            bird.y = bird.targetY;
          } else {
            // å‚ç›´ä¸‹é™
            bird.y += (dy / verticalDistance) * bird.speed * 0.5;
          }
        }
      } else {
        // æ°´å¹³é£å‘ç›®æ ‡xåæ ‡
        bird.x += (dx / horizontalDistance) * bird.speed;
        // ä¿æŒæ°´å¹³é£è¡Œï¼Œä¸æ”¹å˜yåæ ‡
        bird.headAngle = 0; // é£è¡Œæ—¶ä¿æŒæ°´å¹³
      }
      break;
      
    case 'perchingOnReed':
      // åœ¨èŠ¦è‹‡ä¸Šåœç•™
      if (bird.stateTime > bird.stayTime) {
        // åœç•™æ—¶é—´ç»“æŸï¼Œå¼€å§‹ä¿¯å†²æ‰é±¼
        bird.state = 'divingForFish';
        bird.stateTime = 0;
        
        // è®¾ç½®ä¿¯å†²ç›®æ ‡ï¼ˆæ°´é¢ä½ç½®ï¼‰
        // æ ¹æ®å½“å‰æœå‘å†³å®šä¿¯å†²æ–¹å‘
        bird.diveTargetX = bird.x + (bird.facingDirection > 0 ? 100 : -100);
        bird.diveTargetY = reedZone.y + reedZone.height - 10;
        bird.speed = bird.type.diveSpeed || 3.0;
      } else {
        // æ¯éš”ä¸€æ®µæ—¶é—´æ¢æ–¹å‘
        if (gameTime > bird.nextTurnTime) {
          // æ°´å¹³æ¢å‘ï¼šæ”¹å˜facingDirectionï¼ˆä»å‘å³å˜æˆå‘å·¦ï¼Œæˆ–åä¹‹ï¼‰
          bird.facingDirection *= -1;
          bird.direction = bird.facingDirection; // åŒæ­¥æ›´æ–° direction ä»¥è§¦å‘å…¨å±€ç¿»è½¬
          bird.bodyFlipped = (bird.facingDirection === -1);
          
          // ä¸éœ€è¦æ”¹å˜headAngleï¼Œå› ä¸ºç»˜åˆ¶æ—¶ä¼šæ ¹æ®facingDirectionç¿»è½¬
          bird.nextTurnTime = gameTime + bird.turnInterval;
        }
      }
      break;
      
    case 'divingForFish':
      // ä¿¯å†²æ‰é±¼
      const diveDx = bird.diveTargetX - bird.x;
      const diveDy = bird.diveTargetY - bird.y;
      const diveDistance = Math.sqrt(diveDx * diveDx + diveDy * diveDy);
      
      // æ›´æ–°æœå‘ï¼šæ ¹æ®ä¿¯å†²æ–¹å‘è®¾ç½®
      bird.direction = diveDx > 0 ? 1 : -1;
      
      if (diveDistance < 10 || bird.stateTime > 2000) {
        // åˆ°è¾¾æ°´é¢ï¼Œæ‰åˆ°é±¼
        bird.state = 'caughtFish';
        bird.stateTime = 0;
        bird.hasCaughtFish = true;
        
        // åˆ›å»ºé±¼å¯¹è±¡
        bird.caughtFish = {
          x: 0,
          y: 0,
          size: bird.type.fishSize,
          color: bird.type.fishColor,
          angle: Math.PI/2 // é±¼æ¨ªå‘å‚ç›´äºå˜´
        };
        
        // å‘ä¸Šé£èµ·
        bird.speed = 2.0;
        bird.direction = -1; // å‘ä¸Šï¼Ÿè¿™é‡Œdirectionåº”è¯¥æ˜¯å·¦å³æ–¹å‘ã€‚
        // å¦‚æœæ˜¯å‚ç›´å‘ä¸Šï¼Œdirectionä¿æŒåŸæ ·æˆ–è€…éšæœºï¼Ÿ
        // åŸä»£ç å†™çš„æ˜¯ direction = -1ï¼Œè¿™ä¼šè®©å®ƒå‘å·¦é£ã€‚
        // åº”è¯¥æ˜¯ä¿æŒå½“å‰æœå‘ï¼Œæˆ–è€…éšæœºé€‰ä¸€ä¸ªã€‚
        // è¿™é‡Œæš‚æ—¶ä¿æŒåŸæ ·ï¼Œæˆ–è€…ä¿®å¤å®ƒã€‚
        // å‡è®¾å‘ä¸Šé£æ—¶ä¿æŒä¹‹å‰çš„æœå‘
        // bird.direction = bird.direction; 
        
        bird.headAngle = 0; // å‘ä¸Šé£æ—¶æ°´å¹³
        bird.bodyFlipped = false; // å–æ¶ˆç¿»è½¬
      } else {
        // ç»§ç»­ä¿¯å†²
        // è®¡ç®—ç›¸å¯¹äºè¡Œè¿›æ–¹å‘çš„è§’åº¦
        // ä½¿ç”¨ abs(diveDx) ç¡®ä¿è§’åº¦å§‹ç»ˆæŒ‡å‘â€œå‰æ–¹â€
        const diveAngle = Math.atan2(diveDy, Math.abs(diveDx));
        
        // ç§»åŠ¨é€»è¾‘ä¿æŒä½¿ç”¨çœŸå®çš„ diveDx, diveDy
        // æˆ–è€…ä½¿ç”¨ angle * direction ? 
        // æœ€ç®€å•çš„æ˜¯ï¼š
        const moveAngle = Math.atan2(diveDy, diveDx);
        bird.x += Math.cos(moveAngle) * bird.speed;
        bird.y += Math.sin(moveAngle) * bird.speed;
        
        // å¤´éƒ¨æœå‘ä¿¯å†²æ–¹å‘ï¼ˆç›¸å¯¹äºèº«ä½“ï¼‰
        bird.headAngle = diveAngle;
      }
      break;
      
    case 'caughtFish':
      // æ‰åˆ°é±¼åå‘ä¸Šé£
      if (bird.stateTime < 600) {
        // å‘ä¸Šé£åŠä¸ªèŠ¦è‹‡é«˜
        bird.y -= bird.speed;
        
        // è®¡ç®—é±¼çš„æ­£ç¡®ä½ç½®ï¼ˆåœ¨å˜´å°–ï¼‰
        const beakLength = 8 * bird.beakLengthMultiplier; // å˜´çš„å®é™…é•¿åº¦
        const fishDistance = beakLength + bird.caughtFish.size/2; // é±¼åº”è¯¥åœ¨å˜´å°–å¤–ä¸€ç‚¹
        
        // è®¡ç®—é±¼ç›¸å¯¹äºç¿ é¸Ÿèº«ä½“ä¸­å¿ƒçš„ä½ç½®
        // æ³¨æ„ï¼šé±¼çš„æ¨ªå‘å‚ç›´äºå˜´ï¼Œæ‰€ä»¥éœ€è¦æ—‹è½¬90åº¦
        const angleForFish = bird.headAngle + Math.PI/2;
        
        // é±¼çš„åç§»é‡ï¼ˆä»ç¿ é¸Ÿèº«ä½“ä¸­å¿ƒåˆ°é±¼çš„ä¸­å¿ƒï¼‰
        bird.fishOffsetX = Math.cos(bird.headAngle) * fishDistance;
        bird.fishOffsetY = Math.sin(bird.headAngle) * fishDistance;
        
        // é±¼è‡ªèº«çš„è§’åº¦ï¼ˆæ¨ªå‘å‚ç›´äºå˜´ï¼‰
        bird.fishAngle = angleForFish;
      } else {
        // å‘ä¸Šé£åé£èµ°
        bird.state = 'flyingAway';
        bird.speed = 2.5;
        bird.direction = Math.random() > 0.5 ? 1 : -1;
        bird.facingDirection = bird.direction; // é¢å‘é£è¡Œæ–¹å‘
        bird.headAngle = 0; // æ°´å¹³é£è¡Œ
        bird.bodyFlipped = (bird.facingDirection === -1);
      }
      break;
      
    case 'flyingAway':
      // æ­£å¸¸é£ç¦»ç”»é¢
      bird.x += bird.direction * bird.speed;
      bird.headAngle = 0; // æ°´å¹³é£è¡Œ
      
      if (bird.x < -100 || bird.x > GAME_WIDTH + 100) {
        // é£å‡ºç”»é¢ï¼Œç§»é™¤
        birds.splice(birds.indexOf(bird), 1);
      }
      break;
      
case 'fleeingFromRaptor':
  // å—æƒŠå“é£èµ°ï¼Œä½†ä¿æŒåŸæœ‰çš„é±¼ä½ç½®
  bird.x += bird.direction * bird.speed;
  bird.headAngle = 0; // æ°´å¹³é£è¡Œ
  bird.bodyFlipped = (bird.direction === -1);
  
  // æ›´æ–°é±¼çš„ä½ç½®ï¼ˆä¿æŒåŸæœ‰é€»è¾‘ï¼‰
  if (bird.caughtFish) {
    // è®¡ç®—å˜´å°–çš„å…¨å±€ä½ç½®
    const beakLength = 10 * bird.beakLengthMultiplier;
    const localBeakTipX = bird.direction === 1 ? beakLength : -beakLength;
    const globalBeakTipX = bird.x + localBeakTipX;
    const globalBeakTipY = bird.y;
    
    // é±¼çš„ä½ç½®åº”è¯¥åœ¨å˜´é‡Œé¢ä¸€ç‚¹
    const fishDistance = -bird.caughtFish.size/3; // è´Ÿå€¼è¡¨ç¤ºå‘é‡Œï¼ˆå‘ç¿ é¸Ÿå¤´éƒ¨æ–¹å‘ï¼‰
    const fishX = globalBeakTipX + Math.cos(bird.headAngle) * fishDistance;
    const fishY = globalBeakTipY + Math.sin(bird.headAngle) * fishDistance;
    
    bird.fishOffsetX = fishX - bird.x;
    bird.fishOffsetY = fishY - bird.y;
    bird.fishAngle = bird.headAngle + Math.PI/2;
  }
  
  if (bird.x < -100 || bird.x > GAME_WIDTH + 100) {
    // é£å‡ºç”»é¢ï¼Œç§»é™¤
    birds.splice(birds.indexOf(bird), 1);
  }
  break;
  }
  
  // æ›´æ–°èº«ä½“ç¿»è½¬çŠ¶æ€
  // å½“é¢å‘å·¦è¾¹æ—¶ï¼Œèº«ä½“éœ€è¦ç¿»è½¬
  if (bird.state !== 'fleeingFromRaptor' && bird.state !== 'flyingAway') {
    bird.bodyFlipped = (bird.facingDirection === -1);
  }
}

// ä¿®æ”¹ç¿ é¸Ÿç»˜åˆ¶å‡½æ•°ï¼Œå®ç°æ•´ä½“å·¦å³ç¿»è½¬
function drawKingfisher(bird) {
  const baseSize = 20;
  const birdSize = baseSize * bird.size;
  
  ctx.save();
  
  // ç¿ é¸Ÿçš„ç‰¹æ®Šå¤„ç†ï¼šå†…éƒ¨ç¿»è½¬é€»è¾‘ç§»é™¤ï¼Œä¾èµ–å…¨å±€ç¿»è½¬
  // if (bird.bodyFlipped) { ... } REMOVED
  
  // ç»˜åˆ¶èº«ä½“
  ctx.fillStyle = bird.type.bodyColor; // æ©™è‰²èº«ä½“
  ctx.beginPath();
  ctx.arc(bird.x, bird.y, birdSize/2, 0, Math.PI * 2);
  ctx.fill();
  
  // ä¿å­˜ç”»å¸ƒçŠ¶æ€ï¼Œå‡†å¤‡ç»˜åˆ¶å¤´éƒ¨
  ctx.save();
  
  // å¹³ç§»ç”»å¸ƒåˆ°å¤´éƒ¨ä½ç½®
  const headX = bird.x + birdSize/2 - (birdSize * 0.5)/2;
  const headY = bird.y - birdSize/2 + (birdSize * 0.5)/2;
  ctx.translate(headX, headY);
  
  // æ ¹æ®å¤´éƒ¨è§’åº¦æ—‹è½¬ç”»å¸ƒï¼ˆå¤´å’Œå˜´ä¸€èµ·æ—‹è½¬ï¼‰
  ctx.rotate(bird.headAngle);
  
  // ç»˜åˆ¶å¤´éƒ¨ï¼ˆåœ¨æ—‹è½¬åçš„åæ ‡ç³»ä¸­ç»˜åˆ¶ï¼‰
  ctx.fillStyle = bird.type.headColor; // é’è‰²å¤´éƒ¨
  ctx.beginPath();
  ctx.arc(0, 0, (birdSize * 0.5)/2, 0, Math.PI * 2);
  ctx.fill();
  
  // ç»˜åˆ¶é•¿å˜´
  const beakLength = 8 * bird.beakLengthMultiplier;
  const beakHeight = 3;
  
  ctx.fillStyle = bird.type.beakColor; // é»‘è‰²å˜´
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(beakLength, 0);
  ctx.lineTo(0, beakHeight);
  ctx.closePath();
  ctx.fill();
  
  // ç»˜åˆ¶çœ¼ç›å’Œæ©™è‰²çœ¼åœˆ
  const eyeX = (birdSize * 0.5)/4;
  const eyeY = 0;
  
  // æ©™è‰²çœ¼åœˆ
  ctx.fillStyle = bird.type.eyeRingColor;
  ctx.beginPath();
  ctx.arc(eyeX, eyeY, 4, 0, Math.PI * 2);
  ctx.fill();
  
  // é»‘è‰²çœ¼ç›
  ctx.fillStyle = bird.type.eyeColor;
  ctx.beginPath();
  ctx.arc(eyeX, eyeY, 2, 0, Math.PI * 2);
  ctx.fill();
  
  // æ¢å¤ç”»å¸ƒçŠ¶æ€
  ctx.restore();
  
  // ç»˜åˆ¶ç¿…è†€
  ctx.fillStyle = bird.type.wingColor; // è“è‰²ç¿…è†€
  ctx.fillRect(
    bird.x - birdSize/4 - (birdSize * 0.5)/2,
    bird.y - birdSize/2,
    birdSize/2,
    birdSize/3
  );
  
  // ç»˜åˆ¶å°¾éƒ¨
  ctx.fillStyle = bird.type.tailColor; // é’è‰²å°¾éƒ¨
  const tailStartX = bird.x - birdSize/2;
  const tailStartY = bird.y - birdSize/8;
  const tailHeight = birdSize/4;
  
  ctx.beginPath();
  ctx.moveTo(tailStartX, tailStartY);
  ctx.lineTo(tailStartX - 8, tailStartY - tailHeight/2);
  ctx.lineTo(tailStartX - 8, tailStartY + tailHeight/2);
  ctx.lineTo(tailStartX, tailStartY);
  ctx.closePath();
  ctx.fill();
  
  // å¦‚æœæ‰åˆ°é±¼ï¼Œç»˜åˆ¶é±¼
  if (bird.hasCaughtFish && bird.caughtFish) {
    ctx.save();
    
    // è®¡ç®—é±¼çš„æ­£ç¡®ä½ç½®
    // é¦–å…ˆè®¡ç®—å˜´å°–çš„ä½ç½®ï¼ˆå¤´éƒ¨ä½ç½® + å˜´é•¿ï¼‰
    const headX = bird.x + birdSize/2 - (birdSize * 0.5)/2;
    const headY = bird.y - birdSize/2 + (birdSize * 0.5)/2;
    
    // å˜´å°–åœ¨æ—‹è½¬åæ ‡ç³»ä¸­çš„ä½ç½®
    const beakTipX = Math.cos(bird.headAngle) * beakLength;
    const beakTipY = Math.sin(bird.headAngle) * beakLength;
    
    // é±¼çš„ä½ç½®åº”è¯¥åœ¨å˜´é‡Œé¢ä¸€ç‚¹ï¼Œä¸æ˜¯å˜´å°–
    const fishDistance = -bird.caughtFish.size/4; // è´Ÿå€¼è¡¨ç¤ºå‘é‡Œï¼ˆå‘ç¿ é¸Ÿå¤´éƒ¨æ–¹å‘ï¼‰
    
    // ç›´æ¥ä½¿ç”¨å…¨å±€åæ ‡ï¼ˆå‡è®¾é¢æœå³ï¼‰ï¼Œå…¨å±€ç¿»è½¬ä¼šè‡ªåŠ¨å¤„ç†é¢æœå·¦çš„æƒ…å†µ
    // å˜´å°–åœ¨æ—‹è½¬åæ ‡ç³»ä¸­çš„ä½ç½®ï¼ˆç›¸å¯¹äºå¤´éƒ¨ä¸­å¿ƒï¼‰
    // æ³¨æ„ï¼šæˆ‘ä»¬éœ€è¦å…ˆæ—‹è½¬å†å¹³ç§»ï¼Œæˆ–è€…ç›´æ¥è®¡ç®—æ—‹è½¬åçš„åæ ‡
    // è¿™é‡Œæˆ‘ä»¬ç›´æ¥åœ¨å¤´éƒ¨ä¸­å¿ƒçš„åŸºç¡€ä¸Šï¼ŒåŠ ä¸Šæ—‹è½¬åçš„å‘é‡
    
    // å¤´éƒ¨ä¸­å¿ƒåæ ‡
    const headCenterX = bird.x + birdSize/2 - (birdSize * 0.5)/2;
    const headCenterY = bird.y - birdSize/2 + (birdSize * 0.5)/2;
    
    // é±¼åœ¨å˜´ä¸Šçš„ä½ç½®ï¼ˆç›¸å¯¹äºå¤´éƒ¨ä¸­å¿ƒï¼‰
    // å˜´é•¿æ˜¯ beakLength
    // é±¼åœ¨å˜´ä¸Šçš„è·ç¦»æ˜¯ beakLength + fishDistance (ä»å¤´ä¸­å¿ƒç®—èµ·å—ï¼Ÿ)
    // ä¹‹å‰çš„ beakTipX æ˜¯å˜´å°–ã€‚
    // è®©æˆ‘ä»¬é‡æ–°è®¡ç®—ï¼š
    // å˜´æ˜¯ä» (0,0) ç”»åˆ° (beakLength, 0) ï¼ˆåœ¨å¤´éƒ¨å±€éƒ¨åæ ‡ç³»ä¸­ï¼‰
    // é±¼åº”è¯¥åœ¨ (beakLength + fishDistance, 0) ï¼ˆåœ¨å¤´éƒ¨å±€éƒ¨åæ ‡ç³»ä¸­ï¼‰
    
    const fishLocalX = beakLength + fishDistance;
    const fishLocalY = 0;
    
    // å°†å±€éƒ¨åæ ‡è½¬æ¢ä¸ºå…¨å±€åæ ‡ï¼ˆè€ƒè™‘ headAngleï¼‰
    const fishGlobalX = headCenterX + Math.cos(bird.headAngle) * fishLocalX - Math.sin(bird.headAngle) * fishLocalY;
    const fishGlobalY = headCenterY + Math.sin(bird.headAngle) * fishLocalX + Math.cos(bird.headAngle) * fishLocalY;
    
    let fishAngle = bird.headAngle + Math.PI/2;
    
    ctx.translate(fishGlobalX, fishGlobalY);
    ctx.rotate(fishAngle);
    
    // ç»˜åˆ¶é±¼èº«
    ctx.fillStyle = bird.caughtFish.color;
    ctx.beginPath();
    ctx.ellipse(0, 0, bird.caughtFish.size/2, bird.caughtFish.size/4, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // ç»˜åˆ¶é±¼å°¾
    ctx.beginPath();
    ctx.moveTo(-bird.caughtFish.size/3, 0);
    ctx.lineTo(-bird.caughtFish.size/2, -bird.caughtFish.size/4);
    ctx.lineTo(-bird.caughtFish.size/2, bird.caughtFish.size/4);
    ctx.closePath();
    ctx.fill();
    
    // ç»˜åˆ¶é±¼çœ¼
    ctx.fillStyle = "#000000";
    ctx.beginPath();
    ctx.arc(bird.caughtFish.size/4, 0, 1, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.restore();
  }
  
  ctx.restore();
}

function updateBat(bird, deltaTime) {
    if (gamePaused) return;
    bird.stateTime += deltaTime;
    bird.circlingTime += deltaTime;
    bird.wingFlapTimer += bird.wingFlapSpeed;
    if (gameMode === 'normal' && isDaytime) {
        bird.state = 'fleeing';
        bird.speed = bird.speed * 1.5;
        bird.direction = 1;
        bird.fleeStartTime = gameTime;
    }
    if (bird.circlingTime > bird.circleTime) {
        bird.state = 'leaving';
        bird.speed = 1.5;
        bird.direction = 1;
    }
    if (!bird.irregularParams) {
        bird.irregularParams = {
            radiusVariation: 0.3 + Math.random() * 0.4,
            angleVariation: 0.02 + Math.random() * 0.03,
            radiusChangeSpeed: 0.001 + Math.random() * 0.002,
            centerDriftSpeed: 0.05 + Math.random() * 0.1,
            verticalDriftSpeed: 0.02 + Math.random() * 0.03,
            currentRadius: bird.circlingRadius,
            targetRadius: bird.circlingRadius * (0.7 + Math.random() * 0.6),
            radiusDirection: Math.random() > 0.5 ? 1 : -1,
            centerDriftX: (Math.random() - 0.5) * 2,
            centerDriftY: (Math.random() - 0.5) * 2,
            verticalDrift: 0,
            verticalDirection: Math.random() > 0.5 ? 1 : -1
        };
    }
    const params = bird.irregularParams;
    switch (bird.state) {
        case 'circling':
            bird.circlingAngle += params.angleVariation * (bird.type.speedMultiplier || 1);
            params.currentRadius += params.radiusChangeSpeed * params.radiusDirection;
            if (Math.abs(params.currentRadius - params.targetRadius) < 5) {
                params.targetRadius = bird.circlingRadius * (0.7 + Math.random() * 0.6);
                params.radiusDirection *= -1;
            }
            params.currentRadius = Math.max(
                bird.circlingRadius * 0.5,
                Math.min(bird.circlingRadius * 1.5, params.currentRadius)
            );
            bird.circlingCenterX += params.centerDriftX * params.centerDriftSpeed;
            bird.circlingCenterY += params.centerDriftY * params.centerDriftSpeed;
            bird.circlingCenterX = Math.max(
                GAME_WIDTH * 0.3,
                Math.min(GAME_WIDTH * 0.7, bird.circlingCenterX)
            );
            bird.circlingCenterY = Math.max(
                GAME_HEIGHT * 0.2,
                Math.min(GAME_HEIGHT * 0.4, bird.circlingCenterY)
            );
            params.verticalDrift += params.verticalDriftSpeed * params.verticalDirection;
            if (Math.abs(params.verticalDrift) > 20) {
                params.verticalDirection *= -1;
            }
            const effectiveRadiusX = params.currentRadius * (1 + Math.sin(bird.circlingAngle * 0.5) * 0.2);
            const effectiveRadiusY = params.currentRadius * (1 + Math.cos(bird.circlingAngle * 0.3) * 0.2);
            bird.x = bird.circlingCenterX + Math.cos(bird.circlingAngle) * effectiveRadiusX;
            bird.y = bird.circlingCenterY + Math.sin(bird.circlingAngle) * effectiveRadiusY + params.verticalDrift;
            if (bird.y > GAME_HEIGHT * 0.5) {
                bird.y = GAME_HEIGHT * 0.5 - 10;
                bird.circlingAngle += Math.PI * 0.2;
                params.verticalDrift = -10;
                params.verticalDirection = -1;
            }
            if (bird.y < GAME_HEIGHT * 0.15) {
                bird.y = GAME_HEIGHT * 0.15 + 10;
                bird.circlingAngle += Math.PI * 0.2;
                params.verticalDrift = 10;
                params.verticalDirection = 1;
            }
            if (Math.random() < 0.01) {
                params.centerDriftX = (Math.random() - 0.5) * 2;
                params.centerDriftY = (Math.random() - 0.5) * 2;
            }
            if (Math.random() < 0.02) {
                params.verticalDirection *= -1;
            }
            const tangentAngle = bird.circlingAngle + Math.PI / 2;
            bird.direction = Math.cos(tangentAngle) > 0 ? 1 : -1;
            if (Math.random() < 0.005) {
                bird.direction *= -1;
                bird.circlingAngle += Math.PI * 0.5;
            }
            break;
        case 'leaving':
        case 'fleeing':
            // æ°´å¹³æ–œä¸Šé£ï¼Œè§’åº¦ä¸è¶…è¿‡20åº¦
            const batLeavingAngle = (8 + Math.random() * 12) * Math.PI / 180; // 8-20åº¦
            bird.x += bird.speed * Math.cos(batLeavingAngle);
            bird.y -= bird.speed * Math.sin(batLeavingAngle);
            // ä¿æŒåŸæœ‰çš„æ‘†åŠ¨æ•ˆæœï¼Œä½†å‡å°å¹…åº¦
            bird.y += Math.sin(gameTime * 0.001) * 0.1; // å‡å°å‚ç›´æ‘†åŠ¨å¹…åº¦
            bird.x += Math.sin(gameTime * 0.002) * 0.2; // å‡å°æ°´å¹³æ‘†åŠ¨å¹…åº¦
            if (bird.x > GAME_WIDTH + 100 || bird.y < -100) {
                birds.splice(birds.indexOf(bird), 1);
            }
            break;
    }
}

function updateOwlBird(bird, deltaTime) {
    bird.stateTime += deltaTime;
    bird.faceChangeTimer += deltaTime;
    if (bird.faceChangeTimer > bird.faceChangeInterval) {
        bird.faceChangeTimer = 0;
        bird.faceChangeInterval = 10000 + Math.random() * 10000;
    }
    if (bird.name !== "é›•é¸®" && bird.state !== 'fleeing') {
        for (const otherBird of birds) {
            if (otherBird.name === "é›•é¸®" && otherBird.state !== 'fleeing') {
                bird.state = 'fleeing';
                bird.speed = bird.speed * 2;
                bird.direction = Math.random() > 0.5 ? 1 : -1;
                bird.fleeStartTime = gameTime;
                break;
            }
        }
    }
    if (gameMode === 'normal' && isDaytime && bird.state !== 'fleeing') {
        bird.state = 'fleeing';
        bird.speed = bird.speed * 1.5;
        bird.direction = 1;
        bird.fleeStartTime = gameTime;
    }
    switch (bird.state) {
        case 'circling':
            bird.circlingTime += deltaTime;
            bird.circlingAngle += 0.01 * (bird.type.speedMultiplier || 1);
            bird.x = bird.circlingCenterX + Math.cos(bird.circlingAngle) * bird.circlingRadius;
            bird.y = bird.circlingCenterY + Math.sin(bird.circlingAngle) * bird.circlingRadius;
            const tangentAngle = bird.circlingAngle + Math.PI / 2;
            bird.direction = Math.cos(tangentAngle) > 0 ? 1 : -1;
            if (bird.circlingTime > bird.circleTime) {
                bird.state = 'glidingToGround';
                bird.speed = 0.8 * (bird.type.speedMultiplier || 1);
                bird.direction = Math.random() > 0.5 ? 1 : -1;
                bird.glidingStartY = bird.y;
            }
            break;
        case 'glidingToGround':
            bird.x += bird.speed * bird.direction * 0.3;
            bird.y += bird.speed * 1.5;
            if (bird.y >= GAME_HEIGHT - 60) {
                if (Math.random() < bird.catchPreyChance) {
                    if (bird.catchPreyType === "hedgehog") {
                        bird.caughtPrey = generateHedgehog();
                    } else if (bird.catchPreyType === "mouse") {
                        bird.caughtPrey = generateGroundMouseForPredator(bird.name);
                    }
                    if (bird.caughtPrey) {
                        const index = groundObjects.indexOf(bird.caughtPrey);
                        if (index !== -1) {
                            groundObjects.splice(index, 1);
                        }
                    }
                    bird.state = 'flyingWithPrey';
                    bird.speed = 1.5;
                    bird.direction = 1;
                    bird.y -= 50;
                } else {
                    bird.state = 'leaving';
                    bird.speed = 1.5;
                    bird.direction = 1;
                }
            }
            break;
        case 'flyingWithPrey':
        case 'leaving':
            // æ°´å¹³æ–œä¸Šé£ï¼Œè§’åº¦ä¸è¶…è¿‡20åº¦
            const owlLeavingAngle = (10 + Math.random() * 10) * Math.PI / 180; // 10-20åº¦
            bird.x += bird.speed * Math.cos(owlLeavingAngle);
            bird.y -= bird.speed * Math.sin(owlLeavingAngle);
            if (bird.x > GAME_WIDTH + 100 || bird.y < -100) {
                birds.splice(birds.indexOf(bird), 1);
            }
            break;
        case 'fleeing':
            // æ°´å¹³æ–œä¸Šé£ï¼Œè§’åº¦ä¸è¶…è¿‡20åº¦
            const owlFleeAngle = (12 + Math.random() * 8) * Math.PI / 180; // 12-20åº¦
            bird.x += bird.speed * bird.direction * Math.cos(owlFleeAngle);
            bird.y -= bird.speed * Math.sin(owlFleeAngle);
            if (bird.x < -100 || bird.x > GAME_WIDTH + 100 || bird.y < -100) {
                birds.splice(birds.indexOf(bird), 1);
            }
            break;
    }
}

// ä¿®æ”¹ç²ªä¾¿æ›´æ–°å‡½æ•°ï¼Œå¢åŠ è¾¹ç•Œæ£€æŸ¥
function updatePoops(deltaTime) {
    if (gamePaused) return;
    
    // æ›´æ–°æ‰€æœ‰ç²ªä¾¿çš„ä½ç½®ï¼ˆä¸‹è½ï¼‰
    for (let i = poops.length - 1; i >= 0; i--) {
        const poop = poops[i];
        
        // ä¸‹è½æ•ˆæœ - ç¡®ä¿æ˜¯å‘ä¸‹çš„
        poop.y += Math.abs(poop.speed) * (deltaTime / 16);
        
        // è½»å¾®å·¦å³æ‘†åŠ¨
        poop.x += Math.sin(gameTime * 0.001 + i) * 0.05;
        
        // ä¸¥æ ¼çš„è¾¹ç•Œæ£€æŸ¥
        const isOutOfBounds = poop.y > GAME_HEIGHT + 50;
        const isExpired = gameTime - poop.createdAt > poop.lifetime;
        
        if (isOutOfBounds || isExpired) {
            poops.splice(i, 1);
        }
    }
}

function drawPoops() {
    // æ¸…é™¤ç”»å¸ƒ
    poopCtx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
    
    poops.forEach(poop => {
        // ç›´æ¥ä½¿ç”¨æ¸¸æˆé€»è¾‘åæ ‡ç»˜åˆ¶
        poopCtx.fillStyle = poop.color;
        poopCtx.beginPath();
        poopCtx.arc(poop.x, poop.y, poop.size, 0, Math.PI * 2);
        poopCtx.fill();
    });
}

function updateGroundObjects(deltaTime) {
    for (let i = groundObjects.length - 1; i >= 0; i--) {
        const obj = groundObjects[i];
        
        if (gameTime - obj.createdAt > obj.lifetime) {
            groundObjects.splice(i, 1);
        }
    }
}

function drawGroundObjects() {
    groundObjects.forEach(obj => {
        if (obj.type === "mouse") {
            ctx.fillStyle = obj.color;
            ctx.beginPath();
            ctx.ellipse(obj.x, obj.y, obj.size, obj.size/1.5, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = obj.color;
            ctx.beginPath();
            ctx.arc(obj.x + obj.size, obj.y, obj.size/2, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = "#000000";
            ctx.beginPath();
            ctx.arc(obj.x + obj.size + 2, obj.y - 1, 1, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = obj.color;
            ctx.lineWidth = 2;
            ctx.lineCap = "round";
            ctx.beginPath();
            ctx.moveTo(obj.x - obj.size, obj.y);
            ctx.lineTo(obj.x - obj.size - 10, obj.y + 3);
            ctx.stroke();
            
            obj.x += Math.sin(gameTime * 0.001) * 0.1;
        } else if (obj.type === "hedgehog") {
            ctx.fillStyle = obj.color;
            ctx.beginPath();
            ctx.arc(obj.x, obj.y, obj.size, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = obj.color;
            ctx.beginPath();
            ctx.moveTo(obj.x + obj.size, obj.y);
            ctx.lineTo(obj.x + obj.size * 1.5, obj.y - obj.size * 0.5);
            ctx.lineTo(obj.x + obj.size * 1.5, obj.y + obj.size * 0.5);
            ctx.closePath();
            ctx.fill();
            
            ctx.strokeStyle = "#8B4513";
            ctx.lineWidth = 2;
            ctx.lineCap = "round";
            for (let i = 0; i < 24; i++) {
                const angle = (i / 24) * Math.PI * 2;
                const length = 3 + Math.random() * 1.5;
                const startX = obj.x + Math.cos(angle) * obj.size;
                const startY = obj.y + Math.sin(angle) * obj.size;
                const endX = obj.x + Math.cos(angle) * (obj.size + length);
                const endY = obj.y + Math.sin(angle) * (obj.size + length);
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.stroke();
            }
            
            ctx.fillStyle = "#000000";
            ctx.beginPath();
            ctx.arc(obj.x + obj.size * 1.2, obj.y - obj.size * 0.2, 1, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = "#000000";
            ctx.beginPath();
            ctx.arc(obj.x + obj.size * 1.5, obj.y, 0.8, 0, Math.PI * 2);
            ctx.fill();
            
            obj.x += Math.sin(gameTime * 0.001) * 0.05;
        }
    });
}

function updateFruits(deltaTime) {
    fruits.forEach(fruit => {
        if (fruit.isEaten && gameTime - fruit.eatStartTime > 10000) {
            fruit.isEaten = false;
            fruit.color = fruit.originalColor;
            fruit.eatenBy = null;
        }
    });
}

function drawViewfinder() {
    const viewfinderSize = getViewfinderSize();
    const actualViewfinderWidth = viewfinderSize.width;
    const actualViewfinderHeight = viewfinderSize.height;
    
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
    ctx.lineWidth = 2;
    ctx.setLineDash([5, 5]);
    ctx.strokeRect(
        mouseX - actualViewfinderWidth / 2,
        mouseY - actualViewfinderHeight / 2,
        actualViewfinderWidth,
        actualViewfinderHeight
    );
    ctx.setLineDash([]);
}

// ä¿®æ”¹gameLoopå‡½æ•°ï¼Œåœ¨é™€èºä»ªæ¨¡å¼ä¸‹æ›´æ–°å–æ™¯æ¡†
function gameLoop(timestamp) {
  if (gamePaused) {
    requestAnimationFrame(gameLoop);
    return;
  }
    const deltaTime = timestamp - lastFrameTime;
    lastFrameTime = timestamp;
    
    updateDayNight(deltaTime);
    
    ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
    poopCtx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
// æ›´æ–°è§‚é¸Ÿæ¨¡å¼çŠ¶æ€æŒ‡ç¤ºå™¨
if (birdingModeActive) {
    const birdingStatusIndicator = document.getElementById('birdingStatusIndicator');
    const birdingDuration = gameTime - birdingModeStartTime;
    const birdingMinutes = Math.floor(birdingDuration / 60000);
    const birdingSeconds = Math.floor((birdingDuration % 60000) / 1000);
    
    // åªæ˜¾ç¤ºè§‚é¸Ÿå·²è¿›è¡Œçš„æ—¶é—´ï¼Œä¸æ˜¾ç¤ºå€’è®¡æ—¶
    birdingStatusIndicator.textContent = `è¿›è¡Œä¸­ ${birdingMinutes}:${birdingSeconds.toString().padStart(2, '0')}`;
 }
    if (gameMode === 'normal' && isDaytime) {
        updateGoldenFilter();
    }
    
    drawBackground();
    drawSunMoon();
    drawStars();
    drawClouds();
    
    updateNightObjects(deltaTime);
    
    drawMountains();
    nightObjects.forEach(obj => drawNightObject(obj));
    
    drawTrees();
    drawReeds();
    drawWallAndHole();
    drawGroundObjects();
    generateBird();
    
    updateBirds(deltaTime);
    updatePoops(deltaTime);
    updateGroundObjects(deltaTime);
    updateFruits(deltaTime);
      // åœ¨é™€èºä»ªæ¨¡å¼ä¸‹ï¼Œæˆ‘ä»¬éœ€è¦æŒç»­æ›´æ–°å–æ™¯æ¡†ä½ç½®
  if (gyroModeActive) {
    updateViewfinderFromGyro();
  }
    birds.forEach(bird => drawBird(bird));
    drawPoops();
    
    drawViewfinder();
    
    requestAnimationFrame(gameLoop);
}

// ==================== æ–‡æœ¬æµè§ˆå™¨åŠŸèƒ½ ====================

let textBrowserVisible = false;

function loadTextOverlayContent() {
    const contentDiv = document.getElementById('textBrowserContent');
    if (!contentDiv) return;
    
    // ä¿æŒç©ºç™½ï¼Œä¸æ˜¾ç¤ºä»»ä½•åˆå§‹æ–‡æœ¬
    contentDiv.textContent = '';
    
    // æ£€æŸ¥æ˜¯å¦æœ‰ä¸Šæ¬¡ä¿å­˜çš„å†…å®¹
    const savedContent = localStorage.getItem('textBrowserLastContent');
    if (savedContent) {
        contentDiv.textContent = savedContent;
        updateCharacterCount();
    }
}

function toggleTextBrowser() {
    const overlay = document.getElementById('textBrowserOverlay');
    if (!overlay) return;
    
    if (textBrowserVisible) {
        overlay.style.display = 'none';
        textBrowserVisible = false;
    } else {
        overlay.style.display = 'block';
        textBrowserVisible = true;
        
        // å¦‚æœä¹‹å‰æœ‰åŠ è½½è¿‡æ–‡æœ¬ï¼Œé‡æ–°æ˜¾ç¤º
        const savedContent = localStorage.getItem('textBrowserLastContent');
        if (savedContent) {
            document.getElementById('textBrowserContent').textContent = savedContent;
            updateCharacterCount();
        }
    }
}

// åŠ è½½æ–‡æœ¬æ–‡ä»¶
function setupTextBrowser() {
    const loadBtn = document.getElementById('loadTextFile');
    const fileInput = document.getElementById('textFileInput');
    const closeBtn = document.getElementById('closeTextBrowser');
    const textContent = document.getElementById('textBrowserContent');
    
    if (!loadBtn || !fileInput || !closeBtn || !textContent) return;
    
    // åŠ è½½æ–‡ä»¶æŒ‰é’®ç‚¹å‡»äº‹ä»¶
    loadBtn.addEventListener('click', function() {
        fileInput.click();
    });
    
    // æ–‡ä»¶é€‰æ‹©äº‹ä»¶
    fileInput.addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (!file) return;
        
        // æ£€æŸ¥æ–‡ä»¶ç±»å‹
        const validTypes = ['.txt', '.md', '.html', '.js', '.css', '.json'];
        const fileName = file.name.toLowerCase();
        const isValid = validTypes.some(type => fileName.endsWith(type));
        
        if (!isValid) {
            alert('ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹ã€‚è¯·é€‰æ‹©æ–‡æœ¬æ–‡ä»¶(.txt, .md, .html, .js, .css, .json)');
            return;
        }
        
        // è¯»å–æ–‡ä»¶
        const reader = new FileReader();
        reader.onload = function(event) {
            const content = event.target.result;
            
            // æ˜¾ç¤ºæ–‡ä»¶å†…å®¹
            textContent.textContent = content;
            
            // æ›´æ–°æ–‡ä»¶ä¿¡æ¯
            document.getElementById('fileInfo').textContent = 
                `å·²åŠ è½½: ${file.name} (${(file.size / 1024).toFixed(2)} KB)`;
            
            // æ›´æ–°å­—ç¬¦æ•°
            updateCharacterCount();
            
            // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨ï¼Œæ–¹ä¾¿é‡æ–°æ‰“å¼€æ—¶æ˜¾ç¤º
            localStorage.setItem('textBrowserLastContent', content);
            localStorage.setItem('textBrowserLastFileName', file.name);
            
            // æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
            showTextBrowserMessage(`æˆåŠŸåŠ è½½æ–‡ä»¶: ${file.name}`);
        };
        
        reader.onerror = function() {
            showTextBrowserMessage('è¯»å–æ–‡ä»¶å¤±è´¥ï¼Œè¯·é‡è¯•');
        };
        
        reader.readAsText(file);
    });
    
    // å…³é—­æŒ‰é’®äº‹ä»¶
    closeBtn.addEventListener('click', function() {
        document.getElementById('textBrowserOverlay').style.display = 'none';
        textBrowserVisible = false;
    });
    
    // ESCé”®å…³é—­
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape' && textBrowserVisible) {
            document.getElementById('textBrowserOverlay').style.display = 'none';
            textBrowserVisible = false;
        }
    });
    
    // æ£€æŸ¥æ˜¯å¦æœ‰ä¸Šæ¬¡ä¿å­˜çš„å†…å®¹
    const savedContent = localStorage.getItem('textBrowserLastContent');
    const savedFileName = localStorage.getItem('textBrowserLastFileName');
    
    if (savedContent && savedFileName) {
        document.getElementById('fileInfo').textContent = `ä¸Šæ¬¡åŠ è½½: ${savedFileName}`;
    }
}

// æ›´æ–°å­—ç¬¦æ•°
function updateCharacterCount() {
    const content = document.getElementById('textBrowserContent').textContent;
    const charCount = content.length;
    const lineCount = content.split('\n').length;
    document.getElementById('characterCount').textContent = 
        `å­—ç¬¦æ•°: ${charCount.toLocaleString()} | è¡Œæ•°: ${lineCount}`;
}

// åœ¨æ–‡æœ¬æµè§ˆå™¨ä¸­æ˜¾ç¤ºæ¶ˆæ¯
function showTextBrowserMessage(message) {
    const textContent = document.getElementById('textBrowserContent');
    const originalContent = textContent.textContent;
    
    // åˆ›å»ºæ¶ˆæ¯å…ƒç´ 
    const messageDiv = document.createElement('div');
    messageDiv.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background-color: #4CAF50;
        color: white;
        padding: 10px 20px;
        border-radius: 5px;
        z-index: 10001;
        box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        animation: fadeInOut 3s ease-in-out;
    `;
    
    // æ·»åŠ CSSåŠ¨ç”»
    const style = document.createElement('style');
    style.textContent = `
        @keyframes fadeInOut {
            0% { opacity: 0; transform: translateY(-20px); }
            15% { opacity: 1; transform: translateY(0); }
            85% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-20px); }
        }
    `;
    document.head.appendChild(style);
    
    messageDiv.textContent = message;
    document.getElementById('textBrowserOverlay').appendChild(messageDiv);
    
    // 3ç§’åç§»é™¤æ¶ˆæ¯
    setTimeout(() => {
        if (messageDiv.parentNode) {
            messageDiv.parentNode.removeChild(messageDiv);
        }
    }, 3000);
}

// æ–‡æœ¬æ‹–æ”¾åŠŸèƒ½
function setupTextDragAndDrop() {
    const overlay = document.getElementById('textBrowserOverlay');
    const textContainer = document.getElementById('textContentContainer');
    
    if (!overlay || !textContainer) return;
    
    // é˜²æ­¢é»˜è®¤æ‹–æ”¾è¡Œä¸º
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        overlay.addEventListener(eventName, preventDefaults, false);
        textContainer.addEventListener(eventName, preventDefaults, false);
    });
    
    function preventDefaults(e) {
        e.preventDefault();
        e.stopPropagation();
    }
    
    // é«˜äº®æ‹–æ”¾åŒºåŸŸ
    ['dragenter', 'dragover'].forEach(eventName => {
        overlay.addEventListener(eventName, highlight, false);
        textContainer.addEventListener(eventName, highlight, false);
    });
    
    ['dragleave', 'drop'].forEach(eventName => {
        overlay.addEventListener(eventName, unhighlight, false);
        textContainer.addEventListener(eventName, unhighlight, false);
    });
    
    function highlight() {
        textContainer.style.backgroundColor = '#f0f8ff';
        textContainer.style.border = '3px dashed #4CAF50';
    }
    
    function unhighlight() {
        textContainer.style.backgroundColor = 'white';
        textContainer.style.border = 'none';
    }
    
    // å¤„ç†æ–‡ä»¶æ‹–æ”¾
    textContainer.addEventListener('drop', handleDrop, false);
    
    function handleDrop(e) {
        const dt = e.dataTransfer;
        const files = dt.files;
        
        if (files.length > 0) {
            const file = files[0];
            const validTypes = ['.txt', '.md', '.html', '.js', '.css', '.json'];
            const fileName = file.name.toLowerCase();
            const isValid = validTypes.some(type => fileName.endsWith(type));
            
            if (!isValid) {
                showTextBrowserMessage('ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹');
                return;
            }
            
            // åˆ›å»ºFileListå¯¹è±¡å¹¶è§¦å‘æ–‡ä»¶è¾“å…¥
            const dataTransfer = new DataTransfer();
            dataTransfer.items.add(file);
            document.getElementById('textFileInput').files = dataTransfer.files;
            
            // è§¦å‘changeäº‹ä»¶
            document.getElementById('textFileInput').dispatchEvent(new Event('change'));
        }
    }
}

// åˆå§‹åŒ–æ–‡æœ¬æµè§ˆå™¨
function initTextBrowser() {
    setupTextBrowser();
    setupTextDragAndDrop();
    
    // æ·»åŠ æ–‡æœ¬æµè§ˆå™¨æ ·å¼
    const style = document.createElement('style');
    style.textContent = `
        #textContentContainer {
            scrollbar-width: thin;
            scrollbar-color: #ccc #f5f5f5;
        }
        
        #textContentContainer::-webkit-scrollbar {
            width: 10px;
        }
        
        #textContentContainer::-webkit-scrollbar-track {
            background: #f5f5f5;
        }
        
        #textContentContainer::-webkit-scrollbar-thumb {
            background-color: #ccc;
            border-radius: 5px;
        }
        
        #textContentContainer::-webkit-scrollbar-thumb:hover {
            background-color: #aaa;
        }
        
        #textBrowserContent {
            font-family: 'Courier New', monospace;
            tab-size: 4;
        }
        
        #loadTextFile:hover {
            background-color: #45a049 !important;
            transform: scale(1.05);
            transition: all 0.2s;
        }
        
        #closeTextBrowser:hover {
            background-color: #d32f2f !important;
            transform: scale(1.05);
            transition: all 0.2s;
        }
    `;
    document.head.appendChild(style);
}

// åœ¨é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–æ–‡æœ¬æµè§ˆå™¨
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initTextBrowser);
} else {
    initTextBrowser();
}

window.onload = init; </script></body></html>
