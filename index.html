<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>观鸟模拟器 - 一万两千鸻使用AI制作</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }
        body {
            background-color: #000;
            overflow: hidden;
            font-family: 'SimSun', sans-serif;
            color: #333;
        }
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }
        #gameCanvas {
            display: block;
            background: linear-gradient(to bottom, #87CEEB 0%, #E0F7FF 100%);
            cursor: crosshair;
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        #poopCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }
        #viewfinder {
            position: absolute;
            border: 2px dashed rgba(255, 255, 255, 0.8);
            background-color: rgba(255, 255, 255, 0.1);
            pointer-events: none;
            display: none;
            z-index: 100;
        }
        #photoPreview {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 120px;
            height: 80px;
            border: 2px solid white;
            border-radius: 5px;
            background-color: rgba(0, 0, 0, 0.3);
            overflow: hidden;
            z-index: 60;
            cursor: pointer;
        }
        #photoPreview img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        #photoPreview .noPhoto {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: white;
            font-size: 12px;
            text-align: center;
        }
        #birdingToggleContainer {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 70;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 5px;
        }
        #helpButton {
            background-color: rgba(0, 0, 0, 0.7);
            color: #FFD700;
            border: 2px solid #FFD700;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 5px;
        }
        #helpButton:hover {
            background-color: rgba(255, 215, 0, 0.3);
            transform: scale(1.1);
        }
        #helpButton:active {
            transform: scale(0.95);
        }
        #birdingModeToggle {
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border: 2px solid #90EE90;
            border-radius: 20px;
            padding: 8px 16px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s;
            min-width: 120px;
            text-align: center;
        }
        #birdingModeToggle:hover {
            background-color: rgba(144, 238, 144, 0.3);
        }
        #birdingModeToggle.active {
            background-color: rgba(144, 238, 144, 0.5);
            border-color: #FFFFFF;
        }
        #birdingStatusIndicator {
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 4px 10px;
            border-radius: 10px;
            font-size: 12px;
            border: 1px solid #90EE90;
            text-align: center;
            min-width: 120px;
        }
        #birdingRecordIcon {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #FFD700;
            border-radius: 8px;
            width: 120px;
            height: 20px;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
            margin-top: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-size: 10px;
            color: #FFD700;
            font-weight: bold;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }
        #birdingRecordIcon:hover {
            background: rgba(255, 215, 0, 0.15);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(255, 215, 0, 0.2);
        }
        #birdingRecordIcon:active {
            transform: translateY(0);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }
        #birdingRecordIcon::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: linear-gradient(90deg, #FFD700, #FFA500);
        }
        #birdingRecordIcon .iconNumber {
            font-size: 11px;
            font-weight: bold;
            color: #FFD700;
            margin-right: 4px;
        }
        #birdingRecordIcon .iconTime {
            font-size: 9px;
            color: #87CEEB;
            margin-right: 4px;
        }
        #birdingRecordIcon .iconBirdCount {
            font-size: 9px;
            color: #90EE90;
        }
        #birdingRecordNav {
            position: fixed;
            top: 50%;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 410;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
        #birdingRecordNav.show {
            opacity: 1;
        }
        .birdingRecordNavButton {
            pointer-events: auto;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border: 2px solid #FFD700;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }
        .birdingRecordNavButton:hover {
            background-color: rgba(255, 215, 0, 0.3);
            transform: scale(1.1);
        }
        .birdingRecordNavButton:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        .birdingRecordNavButton:disabled:hover {
            background-color: rgba(0, 0, 0, 0.7);
            transform: none;
        }
        #birdingRecordCounter {
            position: fixed;
            bottom: 20px;
            left: 0;
            right: 0;
            text-align: center;
            color: white;
            font-size: 16px;
            z-index: 410;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 10px;
            margin: 0 auto;
            width: fit-content;
            opacity: 0;
            transition: opacity 0.3s;
        }
        #birdingRecordCounter.show {
            opacity: 1;
        }
        .swipe-hint {
            position: fixed;
            bottom: 80px;
            left: 0;
            right: 0;
            text-align: center;
            color: #FFD700;
            font-size: 14px;
            z-index: 410;
            opacity: 0.7;
            animation: pulse 2s infinite;
        }
        #textStats {
            position: absolute;
            top: 95px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 6px 12px;
            border-radius: 6px;
            z-index: 50;
            font-size: 12px;
            max-width: 90%;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        #textStats span {
            margin: 0 8px;
            color: #FFD700;
            font-weight: bold;
        }
        #albumModal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            z-index: 200;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        #albumTitle {
            color: white;
            margin-bottom: 10px;
            font-size: 24px;
        }
        #albumPromotion {
            color: #FFD700;
            margin-bottom: 20px;
            font-size: 16px;
            text-align: center;
        }
        #albumPhotos {
            display: flex;
            flex-wrap: wrap;
            justify-content: flex-start;
            align-content: flex-start;
            max-width: 90%;
            max-height: 70%;
            overflow-x: auto;
            overflow-y: auto;
            padding: 20px;
            width: 100%;
        }
        .albumPhoto {
            width: 160px;
            height: 140px;
            margin: 10px;
            border: 2px solid white;
            border-radius: 5px;
            overflow: hidden;
            position: relative;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }
        .albumPhoto img {
            width: 100%;
            height: 100px;
            object-fit: cover;
        }
        .photoInfo {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px;
            font-size: 12px;
            text-align: center;
            flex-grow: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #albumStats {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 90%;
            max-height: 20%;
            overflow-y: auto;
            padding: 10px;
            margin-top: 10px;
        }
        .albumStatItem {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 8px;
            margin: 2px;
            border-radius: 4px;
            background-color: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 12px;
            min-width: 120px;
        }
        #closeAlbum {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 20px;
            cursor: pointer;
        }
        #gameTitle {
            position: absolute;
            top: 100px;
            left: 0;
            width: 100%;
            text-align: center;
            color: white;
            font-size: 24px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
            z-index: 10;
            display: none;
        }
        #creator {
            position: absolute;
            top: 5px;
            left: 0;
            width: 100%;
            text-align: center;
            color: white;
            font-size: 16px;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.7);
            z-index: 10;
        }
        #specialAlert {
            position: absolute;
            top: 140px;
            left: 0;
            width: 100%;
            text-align: center;
            color: #FFD700;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
            z-index: 10;
            opacity: 0;
            transition: opacity 0.5s;
        }
        #captureAlert {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #FFD700;
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            z-index: 150;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.9);
            background-color: transparent;
            padding: 0;
        }
        #gameNote {
            position: absolute;
            bottom: 5px;
            left: 0;
            width: 100%;
            text-align: center;
            color: white;
            font-size: 12px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
            z-index: 10;
            opacity: 0.7;
            padding: 0 10px;
        }
        #modeToggleContainer {
            position: absolute;
            bottom: 10px;
            right: 10px;
            display: flex;
            gap: 10px;
            z-index: 70;
        }
        .modeToggleButton {
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border: 2px solid #FFD700;
            border-radius: 20px;
            padding: 8px 16px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .modeToggleButton:hover {
            background-color: rgba(255, 215, 0, 0.3);
        }
        .modeToggleButton.active {
            background-color: rgba(255, 215, 0, 0.5);
            border-color: #FFFFFF;
        }
        #timeIndicator {
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 14px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
            z-index: 10;
            opacity: 0.8;
        }
        #nightObjectAlert {
            position: absolute;
            top: 180px;
            left: 0;
            width: 100%;
            text-align: center;
            color: #87CEEB;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
            z-index: 10;
            opacity: 0;
            transition: opacity 0.5s;
        }
        .meteor-trail {
            position: absolute;
            background: linear-gradient(to right, rgba(255,255,255,0) 0%, rgba(255,255,255,0.8) 50%, rgba(255,255,255,0) 100%);
            border-radius: 2px;
            z-index: 2;
            pointer-events: none;
        }
        .comet-trail {
            position: absolute;
            background: radial-gradient(circle, rgba(173,216,230,0.8) 0%, rgba(173,216,230,0) 70%);
            border-radius: 50%;
            z-index: 2;
            pointer-events: none;
        }
        .ufo-beam {
            position: absolute;
            background: linear-gradient(to bottom, rgba(144,238,144,0.7) 0%, rgba(144,238,144,0) 100%);
            border-radius: 50%;
            z-index: 2;
            pointer-events: none;
        }
        #allBirdsAlert {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.9);
            color: #FFD700;
            padding: 30px 40px;
            border-radius: 15px;
            border: 3px solid #FFD700;
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            z-index: 300;
            max-width: 80%;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.05); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }
        #lensToggleContainer {
            position: absolute;
            bottom: 10px;
            left: 10px;
            display: flex;
            gap: 10px;
            z-index: 70;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 8px;
            border-radius: 20px;
            border: 2px solid #FFD700;
        }
        .lensToggleButton {
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border: 1px solid #FFD700;
            border-radius: 15px;
            padding: 6px 12px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .lensToggleButton:hover {
            background-color: rgba(255, 215, 0, 0.3);
        }
        .lensToggleButton.active {
            background-color: rgba(255, 215, 0, 0.5);
            border-color: #FFFFFF;
        }
        #goldenFilter {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 215, 0, 0);
            pointer-events: none;
            z-index: 5;
            transition: background-color 1s ease;
        }
        .birdingRecordIcon {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #FFD700;
            border-radius: 10px;
            width: 60px;
            height: 60px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }
        .birdingRecordIcon:hover {
            background: rgba(255, 215, 0, 0.2);
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
        }
        .birdingRecordIcon::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 5px;
            background: linear-gradient(90deg, #FFD700, #FFA500);
        }
        .birdingRecordIcon .iconNumber {
            font-size: 18px;
            font-weight: bold;
            color: #FFD700;
            margin-bottom: 2px;
        }
        .birdingRecordIcon .iconTime {
            font-size: 11px;
            color: #87CEEB;
        }
        .birdingRecordIcon .iconBirdCount {
            font-size: 10px;
            color: #90EE90;
            margin-top: 2px;
        }
        .birdRecordText {
            background: rgba(0, 0, 0, 0.7);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            border-left: 4px solid #87CEEB;
        }
        .birdRecordText.highlight {
            border-left-color: #FFD700;
            background: rgba(255, 215, 0, 0.1);
        }
        .birdRecordText .birdName {
            color: white;
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 5px;
        }
        .birdRecordText .birdStats {
            font-size: 14px;
            color: #87CEEB;
        }
        .birdRecordText .birdStats span {
            margin-right: 15px;
        }
        .birdRecordText.highlight .birdName {
            color: #FFD700;
        }
        .recordSummaryText {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
            border-top: 2px solid #90EE90;
        }
        .recordSummaryText .summaryItem {
            display: inline-block;
            margin-right: 20px;
            font-size: 14px;
        }
        .recordSummaryText .summaryLabel {
            color: #87CEEB;
        }
        .recordSummaryText .summaryValue {
            color: white;
            font-weight: bold;
        }
        .rareBirdText {
            background: rgba(255, 215, 0, 0.15);
            border: 1px solid #FFD700;
            border-radius: 6px;
            padding: 8px 12px;
            margin: 5px 0;
            color: #FFD700;
            font-size: 14px;
        }
        .rareBirdText::before {
            content: '★ ';
        }
        #gyroToggleContainer {
            position: absolute;
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 70;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 5px;
        }
        #gyroSensitivityContainer {
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 3px 8px;
            border-radius: 8px;
            border: 1px solid #FFA500;
            z-index: 70;
            width: 80px;
            margin-bottom: 5px;
            height: 35px;
            display: none;
        }
        #gyroSensitivityContainer.active {
            display: block;
        }
        #gyroSensitivityLabel {
            font-size: 10px;
            margin-bottom: 2px;
            text-align: center;
        }
        #gyroSensitivitySlider {
            width: 100%;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            background: #555;
            border-radius: 2px;
            outline: none;
        }
        #gyroSensitivitySlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            background: #FFA500;
            border-radius: 50%;
            cursor: pointer;
        }
        #gyroSensitivityValue {
            font-size: 10px;
            margin-top: 1px;
            text-align: center;
        }
        #gyroModeToggle {
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border: 2px solid #FFA500;
            border-radius: 20px;
            padding: 6px 12px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s;
            min-width: 60px;
            max-width: 80px;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        #gyroModeToggle:hover {
            background-color: rgba(255, 165, 0, 0.3);
        }
        #gyroModeToggle.active {
            background-color: rgba(255, 165, 0, 0.5);
            border-color: #FFFFFF;
        }
        #gyroStatusIndicator {
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 4px 8px;
            border-radius: 10px;
            font-size: 10px;
            border: 1px solid #FFA500;
            text-align: center;
            min-width: 60px;
            max-width: 80px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 5px;
        }
        #gyroCalibrateButton {
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border: 2px solid #4CAF50;
            border-radius: 20px;
            padding: 4px 8px;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.3s;
            min-width: 60px;
            max-width: 80px;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        #gyroCalibrateButton:hover {
            background-color: rgba(76, 175, 80, 0.3);
        }
        #cameraButton {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            width: 70px;
            height: 70px;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            border: 4px solid #FFD700;
            cursor: pointer;
            z-index: 80;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        #cameraButton:hover {
            background-color: rgba(255, 255, 255, 1);
            transform: translateY(-50%) scale(1.05);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
        }
        #cameraButton:active {
            background-color: rgba(230, 230, 230, 1);
            transform: translateY(-50%) scale(0.95);
        }
        #cameraButton::after {
            content: '';
            width: 40px;
            height: 40px;
            background-color: #FFD700;
            border-radius: 50%;
            border: 3px solid #333;
        }
        #screenshotCanvas {
            position: fixed;
            top: -10000px;
            left: -10000px;
            width: 300px;
            height: 450px;
            z-index: 1000;
        }
        #screenshotButton {
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border: 2px solid #87CEEB;
            border-radius: 20px;
            padding: 8px 16px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s;
            position: absolute;
            top: 20px;
            right: 70px;
            z-index: 401;
            display: none;
        }
        #screenshotButton:hover {
            background-color: rgba(135, 206, 235, 0.3);
        }
        #screenshotButton:active {
            background-color: rgba(135, 206, 235, 0.5);
        }
        #screenshotPreviewModal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 500;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding-top: 20px;
            overflow-y: auto;
        }
        #screenshotPreviewImage {
            max-height: 90vh;
            max-width: 90%;
            object-fit: contain;
            border: 3px solid #FFD700;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
            margin-bottom: 20px;
        }
        #screenshotPreviewControls {
            margin-top: 20px;
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
        }
        .screenshotPreviewButton {
            background-color: rgba(255, 215, 0, 0.8);
            color: black;
            border: none;
            border-radius: 25px;
            padding: 10px 25px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            min-width: 120px;
        }
        .screenshotPreviewButton:hover {
            background-color: rgba(255, 215, 0, 1);
            transform: scale(1.05);
        }
        .screenshotPreviewButton:active {
            transform: scale(0.95);
        }
        #screenshotPreviewClose {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 20px;
            cursor: pointer;
        }
        #lensToggleContainer.hidden-by-gyro,
        #modeToggleContainer.hidden-by-gyro {
            opacity: 0.3;
            background-color: rgba(0, 0, 0, 0.3);
            border-color: rgba(255, 215, 0, 0.3);
            cursor: pointer;
            transition: opacity 0.3s, background-color 0.3s;
        }
        #lensToggleContainer.hidden-by-gyro:hover,
        #modeToggleContainer.hidden-by-gyro:hover {
            opacity: 0.7;
            background-color: rgba(0, 0, 0, 0.5);
        }
        #lensToggleContainer.hidden-by-gyro::after,
        #modeToggleContainer.hidden-by-gyro::after {
            content: '点击显示';
            position: absolute;
            font-size: 10px;
            color: #FFD700;
            background: rgba(0, 0, 0, 0.7);
            padding: 2px 5px;
            border-radius: 3px;
            white-space: nowrap;
            z-index: 71;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
        #lensToggleContainer.hidden-by-gyro:hover::after,
        #modeToggleContainer.hidden-by-gyro:hover::after {
            opacity: 1;
        }
        #lensToggleContainer.hidden-by-gyro::after {
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
        }
        #modeToggleContainer.hidden-by-gyro::after {
            bottom: -20px;
            right: 10px;
        }
        #lensToggleContainer.temporarily-show,
        #modeToggleContainer.temporarily-show {
            opacity: 1 !important;
            background-color: rgba(0, 0, 0, 0.7) !important;
            border-color: #FFD700 !important;
            display: flex !important;
        }
        
        /* 营地样式 */
        #campsite {
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
            height: 200px;
            display: none;
            z-index: 25;
            cursor: pointer;
        }
        
        @keyframes flame-flicker {
            0% { transform: translateX(-50%) scale(1.0); opacity: 0.9; }
            100% { transform: translateX(-50%) scale(1.1); opacity: 1.0; }
        }
        
/* 改为只在篝火点燃时有悬停效果 */
#campsite:not(.extinguished):hover {
    filter: brightness(1.2);
}

#campsite:not(.extinguished):hover #campfire-flame {
    animation: flame-flicker 0.3s infinite alternate;
    background: radial-gradient(circle, #FF6347 0%, #FFA500 30%, #FFFF00 70%);
}
        
    /* 确保篝火元素在各种状态下都正确显示 */
    #campfire-flame {
        transition: opacity 0.3s ease;
    }
    
    /* 熄灭状态 */
    #campfire-flame.extinguished {
        display: none !important;
        opacity: 0 !important;
        visibility: hidden !important;
    }
    
    /* 点燃状态 */
    #campfire-flame:not(.extinguished) {
        display: block !important;
        opacity: 1 !important;
        visibility: visible !important;
    }

        @media (orientation: landscape) {
            .gyro-active #lensToggleContainer,
            .gyro-active #modeToggleContainer {
                display: none;
            }
            .gyro-active #lensToggleContainer.hidden-by-gyro,
            .gyro-active #modeToggleContainer.hidden-by-gyro {
                display: flex;
            }
            .gyro-active #lensToggleContainer.hidden-by-gyro .lensToggleButton,
            .gyro-active #modeToggleContainer.hidden-by-gyro .modeToggleButton {
                pointer-events: none;
                opacity: 0.5;
            }
        }
        @media (orientation: portrait) {
            #photoPreview {
                top: 10px;
                left: 10px;
                width: 90px;
                height: 70px;
            }
            #photoPreview .noPhoto {
                font-size: 10px;
                padding: 3px;
            }
            #birdingToggleContainer {
                top: 10px;
                right: 10px;
            }
            #helpButton {
                width: 25px;
                height: 25px;
                font-size: 14px;
            }
            #birdingModeToggle {
                padding: 5px 10px;
                font-size: 12px;
                min-width: 100px;
            }
            #birdingStatusIndicator {
                font-size: 10px;
                padding: 3px 8px;
                min-width: 100px;
            }
            #birdingRecordIcon {
                width: 100px;
                height: 18px;
                font-size: 9px;
                border-width: 1px;
                border-radius: 6px;
                margin-top: 3px;
            }
            #birdingRecordIcon::before {
                height: 2px;
            }
            #birdingRecordIcon .iconNumber {
                font-size: 10px;
                margin-right: 3px;
            }
            #birdingRecordIcon .iconTime,
            #birdingRecordIcon .iconBirdCount {
                font-size: 8px;
                margin-right: 3px;
            }
            #textStats {
                top: 85px;
                left: 10px;
                padding: 5px 10px;
                font-size: 11px;
                max-width: 60%;
                white-space: normal;
                max-height: 70px;
                overflow-y: auto;
            }
            #textStats span {
                margin: 0 5px;
            }
            #lensToggleContainer {
                bottom: 170px;
                left: 10px;
                padding: 3px;
                gap: 3px;
                border-radius: 15px;
                border-width: 1px;
                min-width: auto;
                max-width: 120px;
            }
            .lensToggleButton {
                padding: 2px 6px;
                font-size: 9px;
                border-radius: 8px;
                border-width: 0.5px;
                min-height: 24px;
                min-width: 40px;
            }
            #modeToggleContainer {
                bottom: 170px;
                right: 10px;
                flex-wrap: wrap;
                justify-content: flex-end;
                gap: 3px;
                max-width: 45%;
            }
            .modeToggleButton {
                padding: 2px 6px;
                font-size: 9px;
                border-radius: 8px;
                border-width: 1px;
                min-height: 24px;
                flex-shrink: 1;
                min-width: 50px;
                text-align: center;
                line-height: 1.2;
            }
            #birdingModeToggle {
                padding: 2px 6px;
                font-size: 9px;
                min-width: 50px;
                border-width: 1px;
                border-radius: 8px;
            }
            #birdingStatusIndicator {
                font-size: 8px;
                padding: 1px 4px;
                min-width: 50px;
                border-radius: 5px;
                border-width: 0.5px;
            }
            #birdingRecordIconsContainer {
                top: 85px;
                left: 10px;
                max-height: 150px;
            }
            .birdingRecordIcon {
                width: 50px;
                height: 50px;
            }
            .birdingRecordIcon .iconNumber {
                font-size: 16px;
            }
            .birdingRecordIcon .iconTime {
                font-size: 10px;
            }
            .birdingRecordIcon .iconBirdCount {
                font-size: 9px;
            }
            #timeIndicator {
                top: 30px;
                font-size: 12px;
            }
            #creator {
                top: 5px;
                font-size: 14px;
            }
            #gameTitle {
                top: 90px;
                font-size: 20px;
            }
            #specialAlert {
                top: 130px;
                font-size: 16px;
            }
            #gameNote {
                bottom: 20px;
                font-size: 10px;
                padding: 0 5px;
            }
            #albumModal {
                padding: 10px;
            }
            #albumTitle {
                font-size: 20px;
                margin-bottom: 5px;
            }
            #albumPromotion {
                font-size: 14px;
                margin-bottom: 10px;
            }
            .albumPhoto {
                width: 120px;
                height: 105px;
                margin: 5px;
            }
            .albumPhoto img {
                height: 75px;
            }
            .photoInfo {
                font-size: 10px;
                padding: 3px;
            }
            .albumStatItem {
                font-size: 10px;
                min-width: 100px;
                padding: 3px 6px;
            }
            #birdingRecordModal {
                padding: 10px;
            }
            #birdingRecordModal > div {
                width: 95%;
                padding: 15px;
                margin-top: 20px;
            }
            #birdingRecordTitle {
                font-size: 22px;
                margin-bottom: 15px;
            }
            .birdRecordText {
                padding: 10px;
                margin-bottom: 8px;
            }
            .birdRecordText .birdName {
                font-size: 14px;
            }
            .birdRecordText .birdStats {
                font-size: 12px;
            }
            .recordSummaryText {
                padding: 8px;
                margin-bottom: 10px;
            }
            .recordSummaryText .summaryItem {
                margin-right: 10px;
                font-size: 12px;
            }
            .rareBirdText {
                padding: 6px 10px;
                font-size: 12px;
            }
            #allBirdsAlert {
                padding: 20px 25px;
                font-size: 18px;
                max-width: 90%;
            }
            #allBirdsAlert button {
                padding: 8px 20px;
                font-size: 14px;
            }
            #gyroToggleContainer {
                left: auto !important;
                right: 10px !important;
                top: 100px !important;
                transform: none !important;
                flex-direction: column !important;
                align-items: flex-end !important;
                z-index: 71 !important;
            }
            #gyroSensitivityContainer {
                width: 100px !important;
                height: 35px !important;
                margin-bottom: 5px !important;
            }
            #gyroSensitivityLabel {
                font-size: 8px;
                margin-bottom: 1px;
            }
            #gyroSensitivitySlider {
                height: 3px;
            }
            #gyroSensitivitySlider::-webkit-slider-thumb {
                width: 8px;
                height: 8px;
            }
            #gyroSensitivityValue {
                font-size: 8px;
                margin-top: 0;
            }
            #gyroModeToggle {
                padding: 2px 4px;
                font-size: 9px;
                min-width: 100px !important;
                max-width: 100px !important;
                border-width: 1px;
                border-radius: 10px;
            }
            #gyroStatusIndicator {
                font-size: 8px;
                padding: 1px 3px;
                min-width: 100px !important;
                max-width: 100px !important;
                border-width: 0.5px;
                border-radius: 5px;
            }
            #gyroCalibrateButton {
                padding: 1px 3px;
                font-size: 8px;
                min-width: 100px !important;
                max-width: 100px !important;
                border-width: 1px;
                border-radius: 10px;
            }
            #cameraButton {
                right: auto;
                top: auto;
                bottom: 70px;
                left: 50%;
                transform: translateX(-50%);
                width: 80px;
                height: 80px;
                background-color: rgba(255, 255, 255, 0.9);
                border-radius: 50%;
                border: 4px solid #FFD700;
                cursor: pointer;
                z-index: 80;
                display: flex;
                align-items: center;
                justify-content: center;
                transition: all 0.2s;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            }
            #cameraButton:hover {
                background-color: rgba(255, 255, 255, 1);
                transform: translateX(-50%) scale(1.05);
                box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
            }
            #cameraButton:active {
                background-color: rgba(230, 230, 230, 1);
                transform: translateX(-50%) scale(0.95);
            }
            #cameraButton::after {
                content: '';
                width: 45px;
                height: 45px;
                background-color: #FFD700;
                border-radius: 50%;
                border: 3px solid #333;
            }
            #screenshotButton {
                top: 10px;
                right: 70px;
                padding: 5px 10px;
                font-size: 12px;
                border-width: 1px;
                border-radius: 15px;
            }
            .screenshotPreviewButton {
                padding: 8px 20px;
                font-size: 14px;
                min-width: 100px;
            }
            #birdingRecordModal > div[style*="position: fixed; top: 0"] {
                padding: 8px 15px !important;
            }
            #birdingRecordModal > div[style*="position: fixed; top: 0"] div:first-child {
                font-size: 16px !important;
            }
            #birdingRecordModal > div[style*="position: fixed; top: 0"] #birdingRecordCounter {
                font-size: 12px !important;
                padding: 3px 8px !important;
            }
            #birdingRecordModal > div[style*="position: fixed; top: 0"] #screenshotButton {
                padding: 6px 12px !important;
                font-size: 12px !important;
            }
            #birdingRecordModal > div[style*="position: fixed; top: 0"] #closeBirdingRecord {
                width: 30px !important;
                height: 30px !important;
                font-size: 16px !important;
            }
            #birdingRecordContent {
                margin-top: 65px !important;
                padding: 0 15px 20px 15px !important;
                font-size: 15px !important;
            }
            #birdingRecordNav {
                padding: 0 10px !important;
            }
            .birdingRecordNavButton {
                width: 40px !important;
                height: 40px !important;
                font-size: 20px !important;
            }
#campsite {
            width: 250px !important;
            height: 120px !important;
            bottom: 5px !important;
        }
        
        #campsite > div > div:first-child {
            /* 帐篷 */
            width: 70px !important;
            height: 50px !important;
            right: 40px !important;
        }
        
        #campsite > div > div:nth-child(2) {
            /* 篝火 */
            width: 50px !important;
            height: 35px !important;
            left: 50px !important;
        }
        
        #campfire-flame {
            width: 25px !important;
            height: 25px !important;
        }
        
        #campsite > div > div:last-child {
            /* 提示文字 */
            font-size: 9px !important;
            padding: 1px 4px !important;
            bottom: 20px !important;
        }
        #campfire-flame:not(.extinguished) {
            display: block !important;
            width: 25px !important;
            height: 25px !important;
        }
    }
        @media (orientation: portrait) and (max-width: 400px) {
            #photoPreview {
                width: 70px;
                height: 50px;
            }
            #textStats {
                font-size: 10px;
                padding: 4px 8px;
                top: 65px;
            }
            #birdingModeToggle,
            .lensToggleButton,
            .modeToggleButton {
                padding: 4px 8px;
                font-size: 11px;
                min-width: 80px;
            }
            #helpButton {
                width: 22px;
                height: 22px;
                font-size: 12px;
            }
            #birdingStatusIndicator {
                font-size: 9px;
                padding: 2px 6px;
                min-width: 80px;
            }
            #birdingRecordIcon {
                width: 80px;
                height: 16px;
                font-size: 8px;
                border-radius: 4px;
                margin-top: 2px;
            }
            #birdingRecordIcon .iconNumber {
                font-size: 9px;
                margin-right: 2px;
            }
            #birdingRecordIcon .iconTime,
            #birdingRecordIcon .iconBirdCount {
                font-size: 7px;
                margin-right: 2px;
            }
            #lensToggleContainer {
                bottom: 60px;
                gap: 2px;
                padding: 2px;
                border-radius: 12px;
                max-width: 90px;
            }
            .lensToggleButton {
                padding: 1px 4px;
                font-size: 8px;
                border-radius: 6px;
                min-height: 20px;
                min-width: 30px;
            }
            #modeToggleContainer {
                bottom: 60px;
                gap: 2px;
            }
            .modeToggleButton {
                padding: 1px 4px;
                font-size: 8px;
                border-radius: 6px;
                min-width: 40px;
                min-height: 20px;
            }
            #birdingModeToggle {
                padding: 1px 4px;
                font-size: 8px;
                min-width: 40px;
                border-radius: 6px;
            }
            #birdingStatusIndicator {
                font-size: 7px;
                padding: 1px 2px;
                min-width: 40px;
                border-radius: 4px;
            }
            .birdingRecordIcon {
                width: 40px;
                height: 40px;
            }
            .birdingRecordIcon .iconNumber {
                font-size: 14px;
            }
            .birdingRecordIcon .iconTime,
            .birdingRecordIcon .iconBirdCount {
                font-size: 9px;
            }
            #gyroToggleContainer {
                top: 70px !important;
                right: 5px !important;
            }
            #gyroSensitivityContainer {
                width: 80px !important;
                height: 30px !important;
            }
            #gyroModeToggle,
            #gyroCalibrateButton {
                min-width: 80px !important;
                max-width: 80px !important;
                font-size: 10px !important;
                padding: 3px 6px !important;
            }
            #gyroStatusIndicator {
                min-width: 80px !important;
                max-width: 80px !important;
                font-size: 10px !important;
                padding: 2px 4px !important;
            }
            #cameraButton {
                right: auto;
                top: auto;
                bottom: 60px;
                left: 50%;
                transform: translateX(-50%);
                width: 70px;
                height: 70px;
            }
            #cameraButton::after {
                width: 40px;
                height: 40px;
            }
            #screenshotButton {
                right: 70px;
                padding: 4px 8px;
                font-size: 10px;
            }
            #birdingRecordModal > div[style*="position: fixed; top: 0"] {
                padding: 6px 10px !important;
            }
            #birdingRecordModal > div[style*="position: fixed; top: 0"] div:first-child {
                font-size: 14px !important;
            }
            #birdingRecordModal > div[style*="position: fixed; top: 0"] #birdingRecordCounter {
                font-size: 11px !important;
                padding: 2px 6px !important;
            }
            #birdingRecordModal > div[style*="position: fixed; top: 0"] #screenshotButton {
                padding: 4px 8px !important;
                font-size: 11px !important;
            }
            #birdingRecordModal > div[style*="position: fixed; top: 0"] #closeBirdingRecord {
                width: 28px !important;
                height: 28px !important;
                font-size: 14px !important;
            }
            #birdingRecordContent {
                margin-top: 55px !important;
                padding: 0 10px 15px 10px !important;
                font-size: 14px !important;
                line-height: 1.5 !important;
            }
            .birdingRecordNavButton {
                width: 35px !important;
                height: 35px !important;
                font-size: 18px !important;
            }
            #swipeHint {
                font-size: 12px !important;
                bottom: 10px !important;
            }
        #campsite {
            width: 200px !important;
            height: 100px !important;
        }
        
        #campsite > div > div:first-child {
            /* 帐篷 */
            width: 60px !important;
            height: 40px !important;
            right: 30px !important;
        }
        
        #campsite > div > div:nth-child(2) {
            /* 篝火 */
            width: 40px !important;
            height: 30px !important;
            left: 40px !important;
        }
        
        #campfire-flame {
            width: 20px !important;
            height: 20px !important;
        }
        
        #campsite > div > div:last-child {
            /* 提示文字 */
            font-size: 8px !important;
            bottom: 15px !important;
        }
    }
        @media (orientation: landscape) and (max-height: 500px) {
            #photoPreview {
                top: 5px;
                left: 5px;
                width: 80px;
                height: 60px;
            }
            #birdingToggleContainer {
                top: 5px;
                right: 5px;
            }
            #helpButton {
                width: 25px;
                height: 25px;
                font-size: 14px;
            }
            #birdingModeToggle {
                padding: 4px 8px;
                font-size: 12px;
                min-width: 100px;
            }
            #birdingStatusIndicator {
                font-size: 10px;
                padding: 2px 6px;
                min-width: 100px;
            }
            #birdingRecordIcon {
                width: 100px;
                height: 18px;
                font-size: 9px;
                border-width: 1px;
                border-radius: 6px;
                margin-top: 3px;
            }
            #birdingRecordIcon::before {
                height: 2px;
            }
            #textStats {
                top: 70px;
                left: 5px;
                font-size: 10px;
                padding: 4px 8px;
            }
            #lensToggleContainer {
                bottom: 40px;
                left: 5px;
            }
            #modeToggleContainer {
                bottom: 40px;
                right: 5px;
            }
            #birdingRecordIconsContainer {
                top: 50px;
                max-height: 150px;
            }
            .birdingRecordIcon {
                width: 40px;
                height: 40px;
            }
            .birdingRecordIcon .iconNumber {
                font-size: 14px;
            }
            .birdingRecordIcon .iconTime {
                font-size: 9px;
            }
            .birdingRecordIcon .iconBirdCount {
                font-size: 8px;
            }
            #gyroToggleContainer {
                left: 5px;
                top: 50%;
            }
            #gyroSensitivityContainer {
                width: 70px;
                padding: 3px 6px;
                height: 32px;
            }
            #gyroModeToggle {
                padding: 4px 8px;
                font-size: 11px;
                min-width: 55px;
                max-width: 70px;
            }
            #gyroStatusIndicator {
                font-size: 9px;
                padding: 2px 6px;
                min-width: 55px;
                max-width: 70px;
            }
            #gyroCalibrateButton {
                padding: 3px 6px;
                font-size: 9px;
                min-width: 55px;
                max-width: 70px;
            }
            #cameraButton {
                right: 10px;
                top: 50%;
                transform: translateY(-50%);
                width: 60px;
                height: 60px;
            }
            #cameraButton::after {
                width: 35px;
                height: 35px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <canvas id="poopCanvas"></canvas>
        <div id="goldenFilter"></div>
        <div id="viewfinder"></div>
        <div id="photoPreview" onclick="openAlbum()">
            <div class="noPhoto">点击查看相册<br>暂无照片</div>
        </div>
        <canvas id="screenshotCanvas"></canvas>
        <div id="screenshotPreviewModal">
            <button id="screenshotPreviewClose" onclick="closeScreenshotPreview()">×</button>
            <img id="screenshotPreviewImage" src="" alt="截图预览">
            <div id="screenshotPreviewControls">
                <button class="screenshotPreviewButton" onclick="saveScreenshot()">💾 保存图片</button>
                <button class="screenshotPreviewButton" onclick="closeScreenshotPreview()">✕ 关闭</button>
            </div>
        </div>
        
<!-- 营地元素 -->
<div id="campsite" style="position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); width: 300px; height: 150px; display: none; z-index: 25; cursor: pointer;" onclick="extinguishCampfire()">
    <div style="position: relative; width: 100%; height: 100%;">
        
        <!-- 帐篷（缩小以适应竖屏） -->
        <div style="position: absolute; bottom: 0; right: 50px; width: 90px; height: 60px;">
            <!-- 帐篷主体 -->
            <div style="position: absolute; bottom: 0; width: 100%; height: 30px; background-color: #8B0000; border-radius: 4px;"></div>
            <!-- 帐篷顶部 -->
            <div style="position: absolute; top: 0; left: 50%; transform: translateX(-50%); width: 0; height: 0; border-left: 45px solid transparent; border-right: 45px solid transparent; border-bottom: 30px solid #B22222;"></div>
            <!-- 帐篷门 -->
            <div style="position: absolute; bottom: 0; left: 50%; transform: translateX(-50%); width: 20px; height: 20px; background-color: #A52A2A;"></div>
            <!-- 帐篷支柱 -->
            <div style="position: absolute; bottom: 0; left: 20px; width: 4px; height: 30px; background-color: #8B4513;"></div>
            <div style="position: absolute; bottom: 0; right: 20px; width: 4px; height: 30px; background-color: #8B4513;"></div>
        </div>
        
        <!-- 篝火（缩小以适应竖屏） -->
        <div style="position: absolute; bottom: 0; left: 70px; width: 60px; height: 45px;">
            <!-- 木柴 -->
            <div style="position: absolute; bottom: 0; left: 8px; width: 45px; height: 8px; background-color: #8B4513; transform: rotate(-15deg);"></div>
            <div style="position: absolute; bottom: 4px; left: 12px; width: 38px; height: 8px; background-color: #A0522D; transform: rotate(10deg);"></div>
            <!-- 火焰动画 -->
            <div id="campfire-flame" style="position: absolute; bottom: 12px; left: 50%; transform: translateX(-50%); width: 30px; height: 30px; background: radial-gradient(circle, #FF4500 0%, #FF8C00 30%, #FFD700 70%); border-radius: 50% 50% 20% 20%; filter: blur(2px); animation: flame-flicker 0.5s infinite alternate;"></div>
        </div>
        
        <!-- 营地提示文字（竖屏时调整） -->
        <div style="position: absolute; bottom: 25px; left: 50%; transform: translateX(-50%); color: #FFD700; font-size: 10px; font-weight: bold; text-shadow: 1px 1px 3px rgba(0,0,0,0.8); text-align: center; background-color: rgba(0,0,0,0.5); padding: 2px 6px; border-radius: 6px; opacity: 0.8;">
            点击熄灭篝火
        </div>
    </div>
</div>
        
        <div id="gyroToggleContainer">
            <div id="gyroSensitivityContainer">
                <div id="gyroSensitivityLabel">灵敏度</div>
                <input type="range" id="gyroSensitivitySlider" min="5" max="20" value="10">
                <div id="gyroSensitivityValue">10</div>
            </div>
            <div id="gyroStatusIndicator">关闭</div>
            <button id="gyroModeToggle">陀螺仪</button>
            <button id="gyroCalibrateButton">校准</button>
        </div>
        <div id="cameraButton" onclick="handleCameraButtonClick()"></div>
        <div id="birdingToggleContainer">
            <button id="helpButton" class="help-button" title="查看帮助">?</button>
            <button id="birdingModeToggle">观鸟模式</button>
            <div id="birdingStatusIndicator">未开始</div>
            <div id="birdingRecordIcon" style="display: none;"></div>
        </div>
        <div id="birdingRecordIconsContainer" style="position: absolute; top: 100px; right: 10px; display: flex; flex-direction: column; gap: 5px; z-index: 70; max-height: 200px; overflow-y: auto; display: none;"></div>
        <div id="textStats">
            已出现鸟类: <span id="appearedCount">0</span> | 已拍摄鸟类: <span id="capturedCount">0</span>
        </div>
        <div id="modeToggleContainer">
            <button id="dayModeToggle" class="modeToggleButton">永久日间</button>
            <button id="normalModeToggle" class="modeToggleButton active">普通模式</button>
            <button id="nightModeToggle" class="modeToggleButton">永久夜间</button>
        </div>
        <div id="timeIndicator">白天 30:00 / 30:00 | 00:00</div>
        <div id="lensToggleContainer">
            <button id="lens600Toggle" class="lensToggleButton active">600镜头</button>
            <button id="lens800Toggle" class="lensToggleButton">800镜头</button>
            <button id="lens1200Toggle" class="lensToggleButton">1200镜头</button>
        </div>
        <div id="gameTitle">观鸟模拟器-一万两千鸻AI制作</div>
        <div id="specialAlert"></div>
        <div id="nightObjectAlert"></div>
        <div id="captureAlert"></div>
        <div id="creator">正在加载创作者信息...</div>
        <div id="albumModal">
            <h2 id="albumTitle">我的相册 - 一万两千鸻</h2>
            <div id="albumPhotos"></div>
            <div id="albumStats"></div>
            <button id="closeAlbum" onclick="closeAlbum()">×</button>
        </div>
        <div id="birdingRecordModal" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.95); z-index: 400; display: none; color: white; font-family: 'SimSun', monospace; overflow-y: auto; white-space: pre-wrap;">
            <div style="position: fixed; top: 0; left: 0; right: 0; background: rgba(0, 0, 0, 0.9); border-bottom: 2px solid #FFD700; padding: 12px 20px; z-index: 10; display: flex; justify-content: space-between; align-items: center; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);">
                <div style="font-size: 20px; font-weight: bold; color: #FFD700;">📖 观鸟记录</div>
                <div id="birdingRecordCounter" style="color: white; font-size: 14px; background: rgba(255, 215, 0, 0.2); padding: 4px 12px; border-radius: 12px; border: 1px solid #FFD700;">记录 1 / 1</div>
                <div style="display: flex; gap: 10px;">
                    <button id="screenshotButton" onclick="captureBirdingRecord()" style="background: rgba(255, 215, 0, 0.8); color: black; border: none; border-radius: 15px; padding: 8px 15px; font-size: 14px; font-weight: bold; cursor: pointer; transition: all 0.3s;">📸 截图</button>
                    <button id="closeBirdingRecord" onclick="closeBirdingRecord()" style="background: rgba(255, 255, 255, 0.2); color: white; border: none; border-radius: 50%; width: 36px; height: 36px; font-size: 18px; cursor: pointer; transition: all 0.3s;">×</button>
                </div>
            </div>
            <div id="birdingRecordNav" style="position: fixed; top: 50%; left: 0; right: 0; display: flex; justify-content: space-between; padding: 0 15px; z-index: 5; pointer-events: none; opacity: 0; transition: opacity 0.3s;">
                <button id="prevRecordButton" class="birdingRecordNavButton" onclick="switchBirdingRecord(-1)" style="pointer-events: auto; background-color: rgba(0, 0, 0, 0.7); color: white; border: 2px solid #FFD700; border-radius: 50%; width: 45px; height: 45px; font-size: 22px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.3s;">←</button>
                <button id="nextRecordButton" class="birdingRecordNavButton" onclick="switchBirdingRecord(1)" style="pointer-events: auto; background-color: rgba(0, 0, 0, 0.7); color: white; border: 2px solid #FFD700; border-radius: 50%; width: 45px; height: 45px; font-size: 22px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.3s;">→</button>
            </div>
            <div id="birdingRecordContent" style="margin-top: 80px; font-size: 16px; line-height: 1.6; padding: 0 20px 30px 20px;"></div>
            <div id="swipeHint" class="swipe-hint" style="display: none; position: fixed; bottom: 15px; left: 0; right: 0; text-align: center; color: #FFD700; font-size: 14px; z-index: 410; opacity: 0.7; animation: pulse 2s infinite;">使用滚轮或滑动切换记录</div>
        </div>
        <div id="helpModal" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.85); z-index: 450; display: none; color: white; font-family: 'SimSun', monospace; overflow-y: auto; padding: 20px; box-sizing: border-box;">
            <div style="position: absolute; top: 20px; right: 20px; background-color: rgba(255, 255, 255, 0.2); color: white; border: none; border-radius: 50%; width: 40px; height: 40px; font-size: 20px; cursor: pointer; display: flex; align-items: center; justify-content: center;" onclick="closeHelpModal()">×</div>
            <div id="helpContent" style="margin-top: 40px; font-size: 16px; line-height: 1.6; white-space: pre-wrap; max-width: 800px; margin-left: auto; margin-right: auto;"></div>
        </div>
    </div>
<script>

const GAME_WIDTH = 1600;
const GAME_HEIGHT = 900;
const ASPECT_RATIO = 16/9;

const WHEEL_COOLDOWN = 500; // 滚轮冷却时间（毫秒）

window.addEventListener('orientationchange', () => {
  requestCalibration = true;
});

    // 营地相关变量
    let isCampfireExtinguished = false; // 篝火是否已熄灭
    let isNightAccelerated = false;
    let nightAccelerationMultiplier = 60;
    let actualNightTimePassed = 0;
    let birdingRecordRealDuration = 0;
    let rareBirdRealInterval = 0;
    
    // 然后定义其他变量
    let gyroModeActive = false;
    let isGyroCalibrated = false;
    let lastGyroUpdate = 0;
    let gyroSensitivity = 10;
    let gyroX = GAME_WIDTH / 2;
    let gyroY = GAME_HEIGHT / 2;
    let gyroAlpha = 0;
    let gyroBeta = 0;
    let gyroGamma = 0;
    let gyroCenterBeta = 0;
    let gyroCenterGamma = 0;
    let requestCalibration = true;
    let currentRecordIndex = 0;
    let isNavigatingRecords = false;
    let touchStartY = 0;
    let touchStartX = 0;
    let lastWheelTime = 0;
    
    window.addEventListener('orientationchange', () => {
        requestCalibration = true;
    });
    
    let gamePaused = false;
    let pausedTimeState = {
        gameTime: 0,
        dayNightTimer: 0,
        moonPhaseTimer: 0,
        dayModeTimeState: 0,
        nightModeTimeState: 0,
        nightModeMoonPhaseTimer: 0,
        lastFrameTime: 0,
        lastBirdTime: 0,
        lastRareBirdTime: 0,
        lastLittleOwlTime: 0,
        lastOwlSpawnTime: 0,
        lastDoveSummonCheck: 0,
        pauseStartTime: 0,
        pauseDeltaOffset: 0
    };

const LENS_SETTINGS = {
  '600': { name: '600mm', multiplier: 2.0, viewfinderScale: 1.0 },
  '800': { name: '800mm', multiplier: 1.42, viewfinderScale: 1.0 },
  '1200': { name: '1200mm', multiplier: 1.0, viewfinderScale: 1.0 }
};

let currentLens = '600';
let viewfinderBaseWidth = 180;
let viewfinderBaseHeight = 120;

const BIRD_COMMON_PROPS = {
  base: {
    color: "#000000",
    eyeColor: "#000000",
    whiteEyeRing: false,
    groupSize: 1,
    probability: 0.05,
    size: 1.0,
    behavior: "flyThrough",
    stayTime: 10
  },
  props: {
    BLACKBIRD_POOP: {
      poopInterval: 3000,
      poopProbability: 0.33,
      poopColor: "#FFFFFF"
    },
    EAT_FRUITS: {
      eatFruits: true,
      eatProbability: 0.1,
      eatDuration: 2000
    },
    EYE_RING: {
      white: { whiteEyeRing: true },
      yellow: { yellowEyeRing: true },
      brown: { brownEyeRing: true }
    },
    BEAK: {
      onePointFive: { beakOnePointFive: true },
      onePointThree: { beakOnePointThree: true },
      half: { halfBeak: true },
      quarter: { quarterBeak: true },
      fifth: { fifthBeak: true },
      double: { doubleBeak: true },
      long: { longBeak: true },
      reducedQuarter: { beakReducedQuarter: true }
    },
    TAIL: {
      longBlack: { longBlackTail: true },
      longBrown: { longBrownTail: true },
      longWhite: { longWhiteTail: true }
    },
    NOCTURNAL: {
      canAppearAtNight: true,
      nightProbability: 0.01
    }
  }
};

const NIGHT_OBJECTS = {
  METEOR: {
    name: "流星",
    type: "meteor",
    probability: 0.02,
    duration: 2000,
    size: 0.1,
    speed: 5.0,
    color: "#FFFFFF",
    trailLength: 100,
    trailColor: "rgba(255, 255, 200, 0.7)",
    summonProbability: 0.67
  },
  COMET: {
    name: "彗星",
    type: "comet",
    probability: 0.001,
    duration: 1800000,
    size: 0.5,
    speed: 0.01,
    color: "#4682B4",
    tailLength: 50,
    tailColor: "rgba(135, 206, 235, 0.4)",
    angle: 2 * Math.PI / 3
  },
  UFO: {
    name: "UFO",
    type: "ufo",
    probability: 0.001,
    duration: 8000,
    size: 1.0,
    speed: GAME_WIDTH / 8,
    color: "#00FF00",
    beamLength: 100,
    beamColor: "rgba(144, 238, 144, 0.3)"
  }
};

const BIRD_TYPES = {
  MAGPIE: {
    name: "喜鹊",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#FFFFFF",
    headColor: "#000000",
    wingColor: "#3333FF",
    tailColor: "#3333FF",
    groupSize: [2, 5],
    probability: 0.067,
    size: 1.8,
    behavior: "landOnTree",
    stayTime: 100,
    whiteEyeRing: true,
    longBlackTail: true,
    eatFruits: true,
    eatProbability: 0.1,
    eatDuration: 2000,
    originalSize: 1.8
  },
  CROW: {
    name: "乌鸦",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#000000",
    headColor: "#000000",
    wingColor: "#000000",
    tailColor: "#000000",
    groupSize: [1, 3],
    probability: 0.051,
    size: 1.8,
    behavior: "landOnTree",
    stayTime: 50,
    whiteEyeRing: true,
    speedMultiplier: 1.5
  },
  BULBUL: {
    name: "白头鹎",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#90EE90",
    headColor: "#FFFFFF",
    wingColor: "#000000",
    tailColor: "#000000",
    groupSize: [5, 10],
    probability: 0.06,
    size: 1.2,
    behavior: "flyThrough",
    whiteEyeRing: true,
    eatFruits: true,
    eatProbability: 0.15,
    eatDuration: 1500,
    originalSize: 1.2,
    speedMultiplier: 1.5
  },
  HOOPOE: {
    name: "戴胜",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#D2B48C",
    headColor: "#D2B48C",
    wingColor: "#000000",
    tailColor: "#000000",
    groupSize: 1,
    probability: 0.035,
    size: 1.3,
    behavior: "waveFlight",
    hasCrest: true,
    crestColor: "#D2B48C",
    whiteEyeRing: true,
    beakOnePointFive: true,
    speedMultiplier: 2.0
  },
  DOVE: {
    name: "斑鸠",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#808080",
    headColor: "#808080",
    wingColor: "#A0522D",
    tailColor: "#A0522D",
    groupSize: [1, 3],
    probability: 0.065,
    size: 1.5,
    behavior: "flyThrough",
    whiteEyeRing: false,
    brownEyeRing: true,
    eatFruits: true,
    eatProbability: 0.08,
    eatDuration: 1800,
    originalSize: 1.5
  },
  BLACKBIRD: {
    name: "乌鸫",
    color: "#FFFF00",
    eyeColor: "#000000",
    bodyColor: "#000000",
    headColor: "#000000",
    wingColor: "#000000",
    tailColor: "#000000",
    groupSize: 1,
    probability: 0.064,
    size: 1.3,
    behavior: "flyThrough",
    whiteEyeRing: false,
    yellowEyeRing: true,
    eatFruits: true,
    eatProbability: 0.12,
    eatDuration: 1600,
    originalSize: 1.3,
    poopInterval: 3000,
    poopProbability: 0.33,
    poopColor: "#FFFFFF",
    speedMultiplier: 1.5
  },
  DUCK: {
    name: "绿头鸭",
    color: "#FFFF00",
    eyeColor: "#000000",
    bodyColor: "#FFFFFF",
    headColor: "#00AA00",
    wingColor: "#FF0000",
    tailColor: "#8B4513",
    groupSize: [5, 7],
    probability: 0.032,
    size: 2.0,
    behavior: "flyThrough",
    variant: true,
    whiteEyeRing: true,
    doubleBeak: true,
    beakOnePointFive: true
  },
  WAGTAIL: {
    name: "白鹡鸰",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#FFFFFF",
    headColor: "#FFFFFF",
    wingColor: "#000000",
    tailColor: "#000000",
    groupSize: 2,
    probability: 0.029,
    size: 1.2,
    behavior: "waveFlight",
    whiteEyeRing: true,
    longBlackTail: true,
    hasHeart: true
  },
  WOODPECKER: {
    name: "啄木鸟",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#8B4513",
    headColor: "#FF0000",
    wingColor: "#000000",
    tailColor: "#000000",
    groupSize: 1,
    probability: 0.056,
    size: 1.7,
    behavior: "landOnTree",
    stayTime: 10,
    whiteEyeRing: true,
    doubleBeak: true,
    peckingAction: true,
    speedMultiplier: 1.5
  },
  HERON: {
    name: "夜鹭",
    color: "#000000",
    eyeColor: "#FF0000",
    bodyColor: "#FFFFFF",
    headColor: "#FFFFFF",
    wingColor: "#1E90FF",
    tailColor: "#FFFFFF",
    groupSize: [1, 3],
    probability: 0.04,
    size: 3.0,
    behavior: "landOnTree",
    stayTime: 20,
    whiteEyeRing: false,
    longBeak: true,
    beakReducedQuarter: true,
    canAppearAtNight: true,
    nightBodyColor: "#808080",
    nightWingColor: "#4682B4",
    nightProbability: 0.01
  },
  TIT: {
    name: "山雀",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#EEEEE0",
    headColor: "#000000",
    wingColor: "#000000",
    tailColor: "#000000",
    groupSize: [2, 5],
    probability: 0.05,
    size: 0.8,
    behavior: "landOnTreeThenMove",
    whiteEyeRing: true,
    halfBeak: true,
    stayTimePerTree: 2000,
    speedMultiplier: 1.5
  },
  PARROTBILL: {
    name: "棕头鸦雀",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#8B4513",
    headColor: "#8B4513",
    wingColor: "#8B4513",
    tailColor: "#8B4513",
    groupSize: [5, 10],
    probability: 0.033,
    size: 0.5,
    behavior: "flyInReedsAndStay",
    whiteEyeRing: true,
    quarterBeak: true,
    longBrownTail: true,
    stayTimeInReeds: 10000,
    speedMultiplier: 1.5
  },
  WARBLER: {
    name: "某种柳莺",
    color: "#FFFF00",
    eyeColor: "#000000",
    bodyColor: "#EEEEE0",
    headColor: "#90EE90",
    wingColor: "#339966",
    tailColor: "#339966",
    groupSize: 1,
    probability: 0.023,
    size: 0.5,
    behavior: "appearOnTree",
    stayTime: 2,
    whiteEyeRing: true,
    halfBeak: true,
    speedMultiplier: 2.0
  },
  SPARROW: {
    name: "麻雀",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#D2B48C",
    headColor: "#8B4513",
    wingColor: "#808080",
    tailColor: "#8B4513",
    groupSize: [5, 10],
    probability: 0,
    size: 1.0,
    behavior: "flyThrough",
    whiteEyeRing: true,
    halfBeak: true,
    speedMultiplier: 2.0
  },
  GOLDFINCH: {
    name: "金翅雀",
    color: "#000000",
    eyeColor: "#8B4513",
    bodyColor: "#D2B48C",
    headColor: "#808080",
    wingColor: "#FFD700",
    tailColor: "#FFD700",
    groupSize: [2, 9],
    probability: 0.055,
    size: 1.0,
    behavior: "flyThrough",
    whiteEyeRing: true,
    halfBeak: true,
    eatFruits: true,
    eatProbability: 0.2,
    eatDuration: 1200,
    originalSize: 1.0,
    speedMultiplier: 2.0
  },
  KENTISH_PLOVER: {
    name: "金眶鸻",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#FFFFFF",
    headColor: "#D2B48C",
    wingColor: "#D2B48C",
    tailColor: "#D2B48C",
    groupSize: [2, 3],
    probability: 0.015,
    size: 1.3,
    behavior: "flyThrough",
    whiteEyeRing: false,
    yellowEyeRing: true,
    beakOnePointFive: true,
    landOnReedsChance: 0.8,
    landOnReedsTime: 10,
    groundPecking: true,
    groundMoveSpeed: 0.3
  },
  PEREGRINE: {
    name: "游隼",
    color: "#FFFF00",
    eyeColor: "#000000",
    bodyColor: "#FFFFFF",
    headColor: "#000000",
    wingColor: "#808080",
    tailColor: "#808080",
    groupSize: 1,
    probability: 0.009,
    size: 2.0,
    behavior: "circleThenHuntBird",
    iconColor: "#FFFFFF",
    whiteEyeRing: true,
    yellowEyeRing: true
  },
  KESTREL: {
    name: "红隼",
    color: "#FFFF00",
    eyeColor: "#000000",
    bodyColor: "#D2B48C",
    headColor: "#606060",
    wingColor: "#8B0000",
    tailColor: "#707070",
    groupSize: 1,
    probability: 0.027,
    size: 2.0,
    behavior: "circleThenHunt",
    iconColor: "#8B0000",
    whiteEyeRing: false,
    yellowEyeRing: true,
    isPredator: true,
    diveSpeedMultiplier: 2.0,
    catchDoveChance: 0.3,
    catchMouseChance: 0.5,
    leaveChance: 0.2,
    scareOtherBirds: true
  },
  RUDDYSHELDUCK: {
    name: "赤麻鸭",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#FF8C00",
    headColor: "#FFFFFF",
    wingColor: "#FF8C00",
    tailColor: "#FF8C00",
    groupSize: 2,
    probability: 0.025,
    size: 3.0,
    behavior: "flyThrough",
    iconColor: "#FF8C00",
    whiteEyeRing: true,
    beakOnePointThree: true,
    speedMultiplier: 2.0
  },
  MINIVET: {
    name: "山椒鸟",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#FF0000",
    headColor: "#000000",
    wingColor: "#000000",
    tailColor: "#000000",
    groupSize: [8, 10],
    probability: 0.008,
    size: 1.2,
    behavior: "flyThrough",
    variant: true,
    iconColor: "#FF0000",
    whiteEyeRing: true
  },
  KINGFISHER: {
    name: "翠鸟",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#FF9933", // 身体橙色
    headColor: "#33CCCC", // 头部青色
    wingColor: "#3399FF", // 翅膀蓝色
    tailColor: "#33CCCC", // 尾部青色
    beakColor: "#000000", // 嘴黑色
    eyeRingColor: "#FFA500", // 眼圈橙色
    groupSize: 1,
    probability: 0.023,
    size: 1.2, // 1.2倍麻雀大小
    behavior: "flyToReedAndPerch",
    stayTime: [45000, 60000], // 停留45-60秒
    headAngle: Math.PI/4, // 头斜向下45度
    turnInterval: [15000, 25000], // 每15-25秒换向
    diveSpeed: 3.0,
    beakLengthMultiplier: 3, // 嘴长为3倍
    isVulnerableToRaptors: true,
    canAppearAtNight: false, // 只在白天出现
    isKingfisher: true, // 特殊标记
    fishSize: 15, // 鱼的大小
    fishColor: "#3399FF", // 鱼的颜色
    originalSize: 1.2
  },
  GOLDCREST: {
    name: "戴菊",
    color: "#000000",
    eyeColor: "#FFFFFF",
    bodyColor: "#90EE90",
    headColor: "#FFFF00",
    wingColor: "#00FF00",
    tailColor: "#00FF00",
    groupSize: 1,
    probability: 0.01,
    size: 0.5,
    behavior: "appearOnTree",
    stayTime: 5,
    iconColor: "#FFFF00",
    whiteEyeRing: false,
    riceBallAppearance: true,
    halfBeakFlying: true,
    halfBeak: true
  },
  OWL: {
    name: "长耳鸮",
    color: "#000000",
    bodyColor: "#8B4513",
    groupSize: 1,
    probability: 0.011,
    size: 2.5,
    behavior: "appearOnTree",
    stayTime: 15,
    faceScreen: true,
    iconColor: "#8B4513",
    eyeColor: "#FFA500",
    whiteEyeRing: true
  },
  LITTLEGREBE: {
    name: "小北",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#FFFFFF",
    headColor: "#FFFFFF",
    wingColor: "#000000",
    tailColor: "#000000",
    groupSize: [2, 5],
    probability: 0.013,
    size: 0.5,
    behavior: "flyToReedsAndStay",
    stayTime: 30,
    iconColor: "#FFFFFF",
    whiteEyeRing: false,
    longBlackTail: true,
    fifthBeak: true,
    reedStayTime: 20000,
    reedMoveSpeed: 0.6
  },
  BLACKWINGEDKITE: {
    name: "黑翅鸢",
    color: "#000000",
    eyeColor: "#FF0000",
    bodyColor: "#FFFFFF",
    headColor: "#FFFFFF",
    wingColor: "#808080",
    tailColor: "#FFFFFF",
    groupSize: 1,
    probability: 0.02,
    size: 2.0,
    behavior: "circleThenHoverThenHuntMouse",
    iconColor: "#000000",
    whiteEyeRing: true
  },
  TWELVE_THOUSAND_PLOVER: {
    name: "12000鸻",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#FFFFFF",
    headColor: "#D2B48C",
    wingColor: "#D2B48C",
    tailColor: "#D2B48C",
    groupSize: [10, 20],
    probability: 0.00008333,
    size: 1.3,
    behavior: "flyThrough",
    whiteEyeRing: false,
    yellowEyeRing: true,
    beakOnePointFive: true,
    landOnReedsChance: 0.8,
    landOnReedsTime: 10,
    groundPecking: true,
    groundMoveSpeed: 0.3,
    isSpecial: true
  },
  LITTLE_OWL: {
    name: "小鸮",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#D2B48C",
    headColor: "#D2B48C",
    wingColor: "#D2B48C",
    tailColor: "#D2B48C",
    groupSize: 1,
    probability: 0.014,
    size: 1.28,
    behavior: "appearInWallHole",
    stayTime: 15,
    iconColor: "#D2B48C",
    whiteEyeRing: true,
    isNocturnal: true,
    nightEyeColor: "#FFFF99",
    nightEyeRingColor: "#FFFF99"
  },
  EAGLE_OWL: {
    name: "雕鸮",
    color: "#6B4F37",
    eyeColor: "#FFFF99",
    bodyColor: "#666666",
    headColor: "#6B4F37",
    wingColor: "#5A422E",
    tailColor: "#5A422E",
    groupSize: 1,
    probability: 0.05,
    size: 3.2,
    behavior: "circleThenGlideToGround",
    iconColor: "#6B4F37",
    whiteEyeRing: false,
    isNocturnal: true,
    isOwl: true,
    speedMultiplier: 0.6,
    circleTime: 30000,
    catchPreyChance: 0.3,
    catchPreyType: "hedgehog",
    scareOtherOwls: true,
    wingOffset: -0.33
  },
  SHORT_EARED_OWL: {
    name: "短耳鸮",
    color: "#8B7D6B",
    eyeColor: "#FFFF99",
    bodyColor: "#8B7D6B",
    headColor: "#8B7D6B",
    wingColor: "#7A6D5C",
    tailColor: "#7A6D5C",
    groupSize: 1,
    probability: 0.15,
    size: 1.8,
    behavior: "circleThenGlideToGround",
    iconColor: "#8B7D6B",
    whiteEyeRing: false,
    blackEyeRing: true,
    isNocturnal: true,
    isOwl: true,
    speedMultiplier: 0.5,
    circleTime: 50000,
    catchPreyChance: 0.5,
    catchPreyType: "mouse",
    scaredByEagleOwl: true,
    wingOffset: -0.33,
    flyInLowerHalf: true
  },
  LONGTAILED_FINCH: {
    name: "长尾雀",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#FF3366",
    headColor: "#EED2EE",
    wingColor: "#A0522D",
    tailColor: "#000000",
    groupSize: [1, 2],
    probability: 0.012,
    size: 1.0,
    behavior: "landOnTreeTop",
    stayTime: 10,
    whiteEyeRing: false,
    halfBeak: true,
    isVulnerableToRaptors: true
  },
  ROBIN: {
    name: "罗宾",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#F4F4F4",
    headColor: "#FF6600",
    wingColor: "#A0522D",
    tailColor: "#000000",
    groupSize: [1, 2],
    probability: 0.005,
    size: 1.0,
    behavior: "landOnTreeBottom",
    stayTime: 5,
    whiteEyeRing: false,
    beakLengthMultiplier: 0.8,
    isVulnerableToRaptors: true
  },
  HAWFINCH: {
    name: "蜡嘴雀",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#D9D9D9",
    headColor: "#000000",
    wingColor: "#000000",
    tailColor: "#000000",
    beakColor: "#FF8C00",
    groupSize: [2, 6],
    probability: 0.031,
    size: 1.2,
    behavior: "landOnTreeTop",
    stayTime: 15,
    whiteEyeRing: false,
    quarterBeak: true,
    beakLengthMultiplier: 0.25,
    isVulnerableToRaptors: true,
    eatFruits: true,
    eatProbability: 0.15,
    eatDuration: 2000,
    originalSize: 1.2,
    iconColor: "#8B4513"
  },
  BRAMBLING: {
    name: "燕雀",
    color: "#000000",
    eyeColor: "#000000",
    bodyColor: "#FCFCFC",
    headColor: "#D9D9D9",
    wingColor: "#FFA500",
    tailColor: "#000000",
    beakColor: "#FF4500",
    groupSize: [2, 8],
    probability: 0.045,
    size: 1.0,
    behavior: "flyThrough",
    stayTime: 10,
    whiteEyeRing: false,
    halfBeak: true,
    isVulnerableToRaptors: true,
    eatFruits: true,
    eatProbability: 0.1,
    eatDuration: 1800,
    originalSize: 1.0,
    iconColor: "#FFA500"
  },
  BAT: {
    name: "蝙蝠",
    color: "#333333",
    eyeColor: "#000000",
    bodyColor: "#333333",
    headColor: "#333333",
    wingColor: "#666666",
    tailColor: "#333333",
    groupSize: [1, 2],
    probability: 0.10,
    size: 1.0,
    behavior: "circleThenLeave",
    iconColor: "#333333",
    whiteEyeRing: false,
    isNocturnal: true,
    isBat: true,
    speedMultiplier: 0.7,
    circleTime: 15000,
    maxConcurrent: 3,
    flyInUpperHalf: true
  }
};

let raptorsPresent = [];
let chasingMagpiesCrows = [];

let totalProbability = 0;
Object.values(BIRD_TYPES).forEach(bird => {
  if (bird.name !== "麻雀" && !bird.isSpecial && !bird.isOwl && !bird.isBat) {
    totalProbability += bird.probability;
  }
});
BIRD_TYPES.SPARROW.probability = Math.max(0, 1 - totalProbability);

let canvas, ctx, poopCanvas, poopCtx;
let trees = [];
let birds = [];
let nightObjects = [];
let photos = [];
let capturedBirds = {};
let appearedBirds = {};
let mouseX = GAME_WIDTH / 2, mouseY = GAME_HEIGHT / 2;
let viewfinderVisible = false;
let viewfinderWidth = 90, viewfinderHeight = 60;
let lastBirdTime = 0;
let birdInterval = 10000;
let birdIntervalVariation = 500;
let gameTime = 0;
let treePositions = [];
let reedZone = null;
let isHunting = false;
let birdSpeedMultiplier = 1;
let specialBirdAlertTimeout = null;
let nightObjectAlertTimeout = null;
let captureAlertTimeout = null;
let isTakingPhoto = false;
let lastFrameTime = 0;
let fixedLeaves = [];
let scareMode = false;
let scareModeEndTime = 0;
let chasingBirds = [];
let reedBends = [];
let birdGroupInfo = {};
let nextGroupId = 1;
let poops = [];
let groundObjects = [];
let fruits = [];
let lastDoveSummonCheck = 0;
const DOVE_SUMMON_INTERVAL = 5000;
let stars = [];
const STARS_COUNT = 50;
let hasShownAllBirdsAlert = false;
const ALL_BIRDS = Object.values(BIRD_TYPES).filter(bird => !bird.isSpecial && !bird.isBat).map(bird => bird.name);

let isDaytime = true;
let dayNightTimer = 0;
const DAY_NIGHT_CYCLE_DURATION = 15 * 60 * 1000;
const RARE_BIRDS = ['KENTISH_PLOVER', 'MINIVET', 'GOLDCREST', 'OWL', 'LITTLEGREBE', 'LONGTAILED_FINCH', 'ROBIN'];
let lastRareBirdTime = 0;
const RARE_BIRD_INTERVAL = 60 * 60 * 1000;
let sunMoonPosition = 0;
let sunMoonX = 0;
let sunMoonY = 0;
let moonPhase = 0;
const MOON_PHASE_CYCLE = 354 * 60 * 1000;
let moonPhaseTimer = 0;
let wall = null;
let hole = null;
let littleOwl = null;
let lastLittleOwlTime = 0;
const LITTLE_OWL_DAY_COOLDOWN = 300000;
const LITTLE_OWL_NIGHT_COOLDOWN = 180000;
const NIGHT_OWL_SPAWN_INTERVAL = 30000;
let lastOwlSpawnTime = 0;
const MAX_SHORT_EARED_OWL_COUNT = 3;
const MAX_BAT_COUNT = 3;

let gameMode = 'normal';
let normalModeTimeState = { isDaytime: true, dayNightTimer: 0, moonPhaseTimer: 0 };
let dayModeTimeState = 0;
let nightModeTimeState = 0;
let nightModeMoonPhaseTimer = 0;

let isGoldenFilterActive = false;

let birdingRecords = [];
let lastBirdingRecordTime = 0;
let currentBirdingRecord = null;
let birdingModeActive = false;
let birdingModeStartTime = 0;
let birdingModeDuration = 0;
let birdingModeEndTime = 0;
let isDaytimeAtStart = true;
let birdingModeStartSnapshot = {};
let birdingModeBirdTracker = {};
let birdingObservedSpecies = new Set();
let birdingModeRecordedBirds = new Set();
let birdingModeUpdateInterval = null;
let birdingModeCapturedSpecies = null; // 用于记录本次观鸟期间拍摄的鸟种

// 截图相关变量
let screenshotCanvas, screenshotCtx;
let currentScreenshotDataURL = null;

// 打开帮助模态框
function openHelpModal() {
    if (gamePaused) return;
    pauseGame();
    
    const helpModal = document.getElementById('helpModal');
    const helpContent = document.getElementById('helpContent');
    
    // 显示加载中
    helpContent.innerHTML = '<div style="text-align: center; color: #FFD700; font-size: 18px;">加载帮助内容中...</div>';
    
    // 显示模态框
    helpModal.style.display = 'block';
    
    // 尝试加载readme.txt
    fetch('readme.txt')
        .then(response => {
            if (!response.ok) {
                throw new Error('无法加载帮助文件');
            }
            return response.text();
        })
        .then(text => {
            // 成功加载，显示内容
            displayHelpContent(text);
        })
        .catch(error => {
            console.error('加载帮助文件失败:', error);
            // 如果读取失败，显示默认帮助内容
            displayDefaultHelp();
        });
}

// 显示帮助内容
function displayHelpContent(text) {
    const helpContent = document.getElementById('helpContent');
    
    // 解析文本内容，可以添加基本的Markdown样式支持
    let htmlContent = '<div class="help-title">观鸟模拟器 使用帮助</div>';
    
    // 简单的文本解析，将文本转换为带格式的HTML
    const lines = text.split('\n');
    let inSection = false;
    let currentSection = '';
    
    lines.forEach(line => {
        const trimmedLine = line.trim();
        
        if (trimmedLine === '') {
            return; // 跳过空行
        }
        
        // 检测标题
        if (trimmedLine.startsWith('# ')) {
            htmlContent += `<h2 style="color: #FFD700; margin: 20px 0 10px 0;">${trimmedLine.substring(2)}</h2>`;
        } else if (trimmedLine.startsWith('## ')) {
            htmlContent += `<h3 style="color: #87CEEB; margin: 15px 0 8px 0; border-left: 3px solid #87CEEB; padding-left: 10px;">${trimmedLine.substring(3)}</h3>`;
        } else if (trimmedLine.startsWith('### ')) {
            htmlContent += `<h4 style="color: #90EE90; margin: 10px 0 5px 0;">${trimmedLine.substring(4)}</h4>`;
        } else if (trimmedLine.startsWith('- ') || trimmedLine.startsWith('* ')) {
            // 列表项
            if (!inSection) {
                htmlContent += '<ul style="margin: 8px 0 8px 20px;">';
                inSection = true;
            }
            htmlContent += `<li style="margin-bottom: 5px;">${trimmedLine.substring(2)}</li>`;
        } else if (trimmedLine.startsWith('  ')) {
            // 代码或键盘快捷键
            const keyMatch = trimmedLine.match(/`([^`]+)`/g);
            if (keyMatch) {
                let formattedLine = trimmedLine;
                keyMatch.forEach(match => {
                    const key = match.replace(/`/g, '');
                    formattedLine = formattedLine.replace(match, `<span class="help-key">${key}</span>`);
                });
                htmlContent += `<p style="font-family: monospace; background-color: rgba(0,0,0,0.3); padding: 5px 10px; border-radius: 4px; margin: 5px 0;">${formattedLine}</p>`;
            } else {
                htmlContent += `<p>${trimmedLine}</p>`;
            }
        } else {
            if (inSection) {
                htmlContent += '</ul>';
                inSection = false;
            }
            htmlContent += `<p>${trimmedLine}</p>`;
        }
    });
    
    if (inSection) {
        htmlContent += '</ul>';
    }
    
    // 添加游戏控制说明部分
    htmlContent += `
        <div class="help-section">
            <h3>游戏控制快捷键</h3>
            <p><span class="help-key">鼠标点击</span> 或 <span class="help-key">相机按钮</span>: 拍照</p>
            <p><span class="help-key">M</span>: 切换观鸟模式</p>
            <p><span class="help-key">V</span>: 查看观鸟记录</p>
            <p><span class="help-key">P</span>: 截图当前记录</p>
            <p><span class="help-key">ESC</span>: 关闭当前窗口</p>            
        </div>
        
        <div class="help-section">
            <h3>观鸟模式说明</h3>
            <p>1. 点击"观鸟模式"按钮开始记录</p>
            <p>2. 观鸟模式下会记录您观察到的所有鸟种</p>
            <p>3. 再次点击按钮结束记录</p>
            <p>4. 结束后会生成观鸟记录，可截图保存</p>
        </div>
        
        <div style="text-align: center; margin-top: 30px; color: #87CEEB; font-size: 14px;">
            <p>游戏制作: 小红书号 S_Asuka_Langley</p>
            <p>一万两千鸻使用AI制作</p>
        </div>
    `;
    
    helpContent.innerHTML = htmlContent;
}

// 显示默认帮助内容（当readme.txt不存在时）
function displayDefaultHelp() {
    const helpContent = document.getElementById('helpContent');
    helpContent.innerHTML = `
        <div class="help-title">观鸟模拟器 使用帮助</div>
        
        <div class="help-section">
            <h3>游戏简介</h3>
            <p>《观鸟模拟器》是一款模拟真实观鸟体验的游戏。您可以在游戏中观察、拍摄各种鸟类，记录您的观鸟成果。</p>
        </div>
        
        <div class="help-section">
            <h3>基本操作</h3>
            <p>1. 移动鼠标或倾斜设备（陀螺仪模式）来瞄准</p>
            <p>2. 点击鼠标或相机按钮进行拍摄</p>
            <p>3. 使用不同的镜头（600mm, 800mm, 1200mm）观察鸟类</p>
            <p>4. 切换日间/夜间/普通模式观察不同习性的鸟类</p>
        </div>
        
        <div class="help-section">
            <h3>观鸟模式</h3>
            <p>• 点击"观鸟模式"按钮开始记录您的观鸟活动</p>
            <p>• 观鸟模式下会记录您观察到的所有鸟种</p>
            <p>• 结束观鸟模式后，系统会生成观鸟记录</p>
            <p>• 您可以在观鸟记录中截图保存您的成果</p>
        </div>
        
        <div class="help-section">
            <h3>键盘快捷键</h3>
            <p><span class="help-key">鼠标点击</span> / <span class="help-key">相机按钮</span>: 拍摄照片</p>
            <p><span class="help-key">M</span>: 切换观鸟模式</p>
            <p><span class="help-key">V</span>: 查看观鸟记录</p>
            <p><span class="help-key">P</span>: 截图当前记录</p>
            <p><span class="help-key">ESC</span>: 关闭当前窗口</p>
        </div>
        
        <div class="help-section">
            <h3>陀螺仪模式</h3>
            <p>• 点击"陀螺仪"按钮启用设备陀螺仪控制</p>
            <p>• 使用陀螺仪可以更自然地移动视角</p>
            <p>• 调整灵敏度滑块以适应您的操作习惯</p>
            <p>• 点击"校准"按钮重新校准陀螺仪</p>
        </div>
        
        <div class="help-section">
            <h3>鸟类图鉴</h3>
            <p>游戏中共有超过30种不同的鸟类，包括:</p>
            <ul>
                <li>常见鸟类: 喜鹊、乌鸦、麻雀、白头鹎等</li>
                <li>稀有鸟类: 金眶鸻、戴菊、长耳鸮等</li>
                <li>猛禽: 游隼、红隼、黑翅鸢等</li>
                <li>夜间鸟类: 雕鸮、短耳鸮等</li>
            </ul>
            <p>尝试集齐所有鸟类完成图鉴！</p>
        </div>
        
        <div class="help-section">
            <h3>相册功能</h3>
            <p>• 点击左上角的照片预览打开相册</p>
            <p>• 相册中会显示您拍摄的所有照片</p>
            <p>• 相册底部会显示已拍摄的鸟类统计</p>
        </div>
        
        <div style="text-align: center; margin-top: 30px; color: #FFD700; font-size: 16px;">
            <p>祝您观鸟愉快！</p>
            <p style="font-size: 14px; color: #87CEEB;">游戏制作: 小红书号 S_Asuka_Langley<br>一万两千鸻使用AI制作</p>
        </div>
    `;
}

// 关闭帮助模态框
function closeHelpModal() {
    const helpModal = document.getElementById('helpModal');
    helpModal.style.display = 'none';
    resumeGame();
}

// 更新营地可见性
function updateCampsiteVisibility() {
    const campsite = document.getElementById('campsite');
    if (!campsite) return;
    
    // 检查屏幕方向
    const isPortrait = window.matchMedia("(orientation: portrait)").matches;
    
    // 只在普通模式且是夜晚时显示营地，并且篝火未熄灭
    // 同时确保营地不会遮挡重要UI元素
    if (gameMode === 'normal' && !isDaytime && !isCampfireExtinguished) {
        // 在竖屏模式下也显示营地
        campsite.style.display = 'block';
        
        // 如果是竖屏，调整位置避免遮挡
        if (isPortrait) {
            // 确保营地不会被其他UI元素遮挡
            campsite.style.zIndex = '25';
        }
    } else {
        campsite.style.display = 'none';
    }
}

// 加速夜晚时间
function extinguishCampfire() {
    if (gameMode !== 'normal' || isDaytime || isCampfireExtinguished) return;
    
    isCampfireExtinguished = true;
    
    // 使用更可靠的方式隐藏篝火
    const flame = document.getElementById('campfire-flame');
    if (flame) {
        // 添加熄灭类名，便于CSS控制
        flame.classList.add('extinguished');
        flame.style.display = 'none';
        flame.style.opacity = '0';
        flame.style.visibility = 'hidden';
    }
    
    // 修改提示文字
    const hint = document.querySelector('#campsite > div > div:last-child');
    if (hint) {
        hint.textContent = "篝火已熄灭";
        hint.style.color = "#87CEEB";
        // 添加数据属性记录状态
        hint.setAttribute('data-state', 'extinguished');
    }
    
    // 开始夜晚加速
    isNightAccelerated = true;
    showSpecialAlert("篝火熄灭，夜晚加速流逝...");
    
    // 设置加速结束监听
    checkNightAcceleration();
}

function checkNightAcceleration() {
    if (!isNightAccelerated) return;
    
    // 如果已经变为白天，恢复正常速度并重置营地
    if (isDaytime) {
        resetCampsite();
        return;
    }
    
    // 继续检查
    setTimeout(checkNightAcceleration, 1000);
}

function resetCampsite() {
    isNightAccelerated = false;
    isCampfireExtinguished = false;
    
    // 重新点燃篝火
    const flame = document.getElementById('campfire-flame');
    if (flame) {
        flame.classList.remove('extinguished');
        flame.style.display = 'block';
        flame.style.opacity = '1';
        flame.style.visibility = 'visible';
    }
    
    // 恢复提示文字
    const hint = document.querySelector('#campsite > div > div:last-child');
    if (hint) {
        hint.textContent = "点击熄灭篝火";
        hint.style.color = "#FFD700";
        hint.setAttribute('data-state', 'lit');
    }
    
    showSpecialAlert("黎明到来，恢复正常时间流速");
    updateCampsiteVisibility();
}
    
function updateDayNight(deltaTime) {
        if (gamePaused) return;
        
        gameTime += deltaTime;
        
        // 应用时间加速
        let effectiveDeltaTime = deltaTime;
        
        if (isNightAccelerated && gameMode === 'normal' && !isDaytime) {
            effectiveDeltaTime = deltaTime * nightAccelerationMultiplier;
        }
        
        // 普通模式：日夜循环
        if (gameMode === 'normal') {
            // 只在这里累加日夜时间
            dayNightTimer += effectiveDeltaTime;
            
            moonPhaseTimer += deltaTime;
            if (moonPhaseTimer >= MOON_PHASE_CYCLE) {
                moonPhaseTimer = 0;
            }
            
            updateGoldenFilter();
            
            // 检查日夜切换
            if (dayNightTimer >= DAY_NIGHT_CYCLE_DURATION) {
                isDaytime = !isDaytime;
                dayNightTimer = 0;
                
                // 夜晚切换为白天时，重置营地
                if (isDaytime) {
                    resetCampsite();
                } else {
                    moonPhaseTimer = Math.random() * MOON_PHASE_CYCLE;
                }
                
                updateModeToggleButtons();
                // 更新营地可见性
                updateCampsiteVisibility();
                showSpecialAlert(isDaytime ? "天亮了！" : "天黑了！");
                
                // 切换时清理不符合当前时间的生物
                if (!isDaytime) {
                    for (let i = birds.length - 1; i >= 0; i--) {
                        if (!birds[i].isOwl && !birds[i].isBat && birds[i].name !== "小鸮" && birds[i].name !== "夜鹭") {
                            birds.splice(i, 1);
                        }
                    }
                    nightObjects = [];
                } else {
                    for (let i = birds.length - 1; i >= 0; i--) {
                        if (birds[i].isOwl || birds[i].isBat) {
                            birds.splice(i, 1);
                        }
                    }
                    
                    if (littleOwl) {
                        birds.splice(birds.indexOf(littleOwl), 1);
                        littleOwl = null;
                    }
                    nightObjects = [];
                }
            }
            
            // 更新太阳/月亮位置
            sunMoonPosition = dayNightTimer / DAY_NIGHT_CYCLE_DURATION;
        } 
        // 永久日间模式
        else if (gameMode === 'day') {
            dayModeTimeState += deltaTime;
            dayNightTimer = dayModeTimeState;
            
            // 确保营地状态被重置
            resetCampsite();
            
            const goldenFilter = document.getElementById('goldenFilter');
            goldenFilter.style.backgroundColor = 'rgba(255, 215, 0, 0.1)';
            
            // 更新营地可见性
            updateCampsiteVisibility();
        } 
        // 永久夜间模式
        else if (gameMode === 'night') {
            nightModeTimeState += deltaTime;
            nightModeMoonPhaseTimer += deltaTime;
            dayNightTimer = nightModeTimeState;
            moonPhaseTimer = nightModeMoonPhaseTimer;
            
            if (moonPhaseTimer >= MOON_PHASE_CYCLE) {
                moonPhaseTimer = 0;
                nightModeMoonPhaseTimer = 0;
            }
            
            // 确保营地状态被重置
            resetCampsite();
            
            const goldenFilter = document.getElementById('goldenFilter');
            goldenFilter.style.backgroundColor = 'rgba(255, 215, 0, 0)';
            
            // 更新营地可见性
            updateCampsiteVisibility();
        }
        
        updateTimeIndicator();
        
        // 稀有鸟类生成（使用实际时间，不受加速影响）
        let rareBirdDelta = deltaTime;
        lastRareBirdTime += rareBirdDelta;
        
        if (gameTime - lastRareBirdTime >= RARE_BIRD_INTERVAL && !birdingModeActive) {
            generateRareBird();
            lastRareBirdTime = gameTime;
        }
        
        // 小鸮生成逻辑（使用实际时间）
        if (!littleOwl) {
            let cooldown;
            if (gameMode === 'day') {
                cooldown = LITTLE_OWL_DAY_COOLDOWN;
            } else if (gameMode === 'night') {
                cooldown = LITTLE_OWL_NIGHT_COOLDOWN;
            } else {
                cooldown = isDaytime ? LITTLE_OWL_DAY_COOLDOWN : LITTLE_OWL_NIGHT_COOLDOWN;
            }
            
            // 使用实际时间计算
            let actualTimePassed = deltaTime;
            lastLittleOwlTime += actualTimePassed;
            
            if (gameTime - lastLittleOwlTime > cooldown) {
                generateLittleOwl(true);
                lastLittleOwlTime = gameTime;
            }
        }
        
        // 夜间猫头鹰生成（使用实际时间）
        if ((gameMode === 'night' || (gameMode === 'normal' && !isDaytime))) {
            let actualTimePassed = deltaTime;
            lastOwlSpawnTime += actualTimePassed;
            
            if (gameTime - lastOwlSpawnTime > NIGHT_OWL_SPAWN_INTERVAL) {
                spawnNightOwls();
                lastOwlSpawnTime = gameTime;
            }
        }
    }

function initGyro() {
    const gyroModeButton = document.getElementById('gyroModeToggle');
    const gyroStatusIndicator = document.getElementById('gyroStatusIndicator');
    const sensitivitySlider = document.getElementById('gyroSensitivitySlider');
    const sensitivityValue = document.getElementById('gyroSensitivityValue');
    const sensitivityContainer = document.getElementById('gyroSensitivityContainer');
    const calibrateButton = document.getElementById('gyroCalibrateButton');
    const cameraButton = document.getElementById('cameraButton'); // 获取快门按钮
    
    // 设置默认状态：只显示陀螺仪按钮，其他元素隐藏
    gyroStatusIndicator.style.display = 'none';
    sensitivityContainer.style.display = 'none';
    calibrateButton.style.display = 'none';
    cameraButton.style.display = 'none'; // 隐藏快门按钮
    
    // 设置陀螺仪按钮为半透明
    gyroModeButton.style.opacity = '0.5';
    
    gyroModeButton.addEventListener('click', toggleGyroMode);
    calibrateButton.addEventListener('click', handleGyroCalibrate);
    sensitivitySlider.addEventListener('input', function() {
        gyroSensitivity = parseInt(this.value);
        sensitivityValue.textContent = gyroSensitivity;
    });
    
    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
        // iOS设备需要权限
    } else if ('ondeviceorientation' in window) {
        // 设备支持陀螺仪
    } else {
        // 设备不支持陀螺仪
        gyroModeButton.disabled = true;
        gyroModeButton.style.opacity = '0.3';
        gyroModeButton.title = "设备不支持陀螺仪";
    }
}

function handleGyroCalibrate() {
  if (!gyroModeActive) {
    showSpecialAlert("请先开启陀螺仪模式");
    return;
  }
  calibrateGyro();
}

function toggleGyroMode() {
  if (gamePaused) return;
  
  if (!gyroModeActive) {
    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
      DeviceOrientationEvent.requestPermission()
        .then(permissionState => {
          if (permissionState === 'granted') {
            startGyroMode();
          } else {
            showSpecialAlert("陀螺仪权限被拒绝");
          }
        })
        .catch(console.error);
    } else {
      startGyroMode();
    }
  } else {
    stopGyroMode();
  }
}

function startGyroMode() {
  gyroModeActive = true;
  isGyroCalibrated = false;
  const gyroModeButton = document.getElementById('gyroModeToggle');
  const gyroStatusIndicator = document.getElementById('gyroStatusIndicator');
  const sensitivityContainer = document.getElementById('gyroSensitivityContainer');
  const calibrateButton = document.getElementById('gyroCalibrateButton');
  const cameraButton = document.getElementById('cameraButton');
  const goldenFilter = document.getElementById('goldenFilter');
  const lensToggleContainer = document.getElementById('lensToggleContainer');
  const modeToggleContainer = document.getElementById('modeToggleContainer');
  
  goldenFilter.style.backgroundColor = 'rgba(255, 215, 0, 0)';
  
  gyroModeButton.classList.add('active');
  gyroModeButton.textContent = "关闭陀螺仪";
  gyroModeButton.style.opacity = '1';
  gyroStatusIndicator.style.display = 'block';
  sensitivityContainer.style.display = 'block';
  calibrateButton.style.display = 'block';
  cameraButton.style.display = 'flex';
  gyroStatusIndicator.textContent = "校准中...";
  
  // 横屏时隐藏镜头切换区和模式切换区
  if (window.matchMedia("(orientation: landscape)").matches) {
    if (lensToggleContainer) {
      lensToggleContainer.style.display = 'none';
      lensToggleContainer.classList.add('hidden-by-gyro');
    }
    if (modeToggleContainer) {
      modeToggleContainer.style.display = 'none';
      modeToggleContainer.classList.add('hidden-by-gyro');
    }
  }
  
  gyroX = GAME_WIDTH / 2;
  gyroY = GAME_HEIGHT / 2;
  mouseX = gyroX;
  mouseY = gyroY;
  
  showSpecialAlert("陀螺仪模式已启动！请保持设备水平以进行校准。");
  
  setTimeout(() => {
    if (gyroModeActive && !isGyroCalibrated) {
      calibrateGyro();
    }
  }, 2000);
  
  window.addEventListener('deviceorientation', handleDeviceOrientation);
}

function stopGyroMode() {
  gyroModeActive = false;
  const gyroModeButton = document.getElementById('gyroModeToggle');
  const gyroStatusIndicator = document.getElementById('gyroStatusIndicator');
  const sensitivityContainer = document.getElementById('gyroSensitivityContainer');
  const calibrateButton = document.getElementById('gyroCalibrateButton');
  const cameraButton = document.getElementById('cameraButton');
  const lensToggleContainer = document.getElementById('lensToggleContainer');
  const modeToggleContainer = document.getElementById('modeToggleContainer');
  
  gyroModeButton.classList.remove('active');
  gyroModeButton.textContent = "陀螺仪";
  gyroModeButton.style.opacity = '0.5';
  gyroStatusIndicator.style.display = 'none';
  sensitivityContainer.style.display = 'none';
  calibrateButton.style.display = 'none';
  cameraButton.style.display = 'none';
  gyroStatusIndicator.textContent = "关闭";
  
  // 恢复显示镜头切换区和模式切换区
  if (lensToggleContainer) {
    lensToggleContainer.style.display = 'flex';
    lensToggleContainer.classList.remove('hidden-by-gyro');
  }
  if (modeToggleContainer) {
    modeToggleContainer.style.display = 'flex';
    modeToggleContainer.classList.remove('hidden-by-gyro');
  }
  
  window.removeEventListener('deviceorientation', handleDeviceOrientation);
  showSpecialAlert("陀螺仪模式已关闭");
}

// 添加点击事件监听器，允许点击被隐藏的区域来显示它们
function addToggleAreaClickListeners() {
  const lensToggleContainer = document.getElementById('lensToggleContainer');
  const modeToggleContainer = document.getElementById('modeToggleContainer');
  
  if (lensToggleContainer) {
    lensToggleContainer.addEventListener('click', function(e) {
      // 如果这个区域被陀螺仪隐藏了，点击时显示它
      if (this.classList.contains('hidden-by-gyro') && gyroModeActive) {
        this.style.display = 'flex';
        this.classList.remove('hidden-by-gyro');
        e.stopPropagation();
        
        // 5秒后自动隐藏
        setTimeout(() => {
          if (gyroModeActive && window.matchMedia("(orientation: landscape)").matches) {
            this.style.display = 'none';
            this.classList.add('hidden-by-gyro');
          }
        }, 5000);
      }
    });
  }
  
  if (modeToggleContainer) {
    modeToggleContainer.addEventListener('click', function(e) {
      // 如果这个区域被陀螺仪隐藏了，点击时显示它
      if (this.classList.contains('hidden-by-gyro') && gyroModeActive) {
        this.style.display = 'flex';
        this.classList.remove('hidden-by-gyro');
        e.stopPropagation();
        
        // 5秒后自动隐藏
        setTimeout(() => {
          if (gyroModeActive && window.matchMedia("(orientation: landscape)").matches) {
            this.style.display = 'none';
            this.classList.add('hidden-by-gyro');
          }
        }, 5000);
      }
    });
  }
}

function calibrateGyro() {
    if (!gyroModeActive) return;
    requestCalibration = true;
    isGyroCalibrated = true;
    const gyroStatusIndicator = document.getElementById('gyroStatusIndicator');
    gyroStatusIndicator.textContent = "已校准";
    showSpecialAlert("陀螺仪校准完成！");
}

function handleDeviceOrientation(event) {
  if (!gyroModeActive || gamePaused) return;
  
  const now = Date.now();
  if (now - lastGyroUpdate < 16) return;
  lastGyroUpdate = now;
  
  const beta = event.beta;
  const gamma = event.gamma;
  
  if (beta === null || gamma === null) return;
  
  if (!isGyroCalibrated) {
    calibrateGyro();
    return;
  }
  
  if (requestCalibration) {
    gyroCenterBeta = beta;
    gyroCenterGamma = gamma;
    requestCalibration = false;
    return;
  }
  
  const sensitivityFactor = gyroSensitivity / 10;
  
  let orientation = window.orientation || 0;
  if (screen.orientation && screen.orientation.angle) {
    orientation = screen.orientation.angle;
  }
  
  let xAngle = 0;
  let yAngle = 0;
  
  if (orientation === 90) {
    xAngle = beta - gyroCenterBeta;
    yAngle = -(gamma - gyroCenterGamma);
  } else if (orientation === -90 || orientation === 270) {
    xAngle = -(beta - gyroCenterBeta);
    yAngle = gamma - gyroCenterGamma;
  } else if (orientation === 180) {
    xAngle = -(gamma - gyroCenterGamma);
    yAngle = -(beta - gyroCenterBeta);
  } else {
    xAngle = gamma - gyroCenterGamma;
    yAngle = beta - gyroCenterBeta;
  }
  
  const maxTiltAngle = 30;
  const xMultiplier = (GAME_WIDTH / 2) / maxTiltAngle;
  const yMultiplier = (GAME_HEIGHT / 2) / maxTiltAngle;
  
  const limitedXAngle = Math.max(-60, Math.min(60, xAngle));
  const limitedYAngle = Math.max(-60, Math.min(60, yAngle));
  
  const targetX = GAME_WIDTH / 2 + (limitedXAngle * xMultiplier * sensitivityFactor);
  const targetY = GAME_HEIGHT / 2 + (limitedYAngle * yMultiplier * sensitivityFactor);
  
  gyroX = gyroX + (targetX - gyroX) * 0.2;
  gyroY = gyroY + (targetY - gyroY) * 0.2;
  
  mouseX = Math.max(0, Math.min(GAME_WIDTH, gyroX));
  mouseY = Math.max(0, Math.min(GAME_HEIGHT, gyroY));
  
  updateViewfinderFromGyro();
}

function updateViewfinderFromGyro() {
  if (!gyroModeActive || gamePaused) return;
  
  const viewfinder = document.getElementById('viewfinder');
  const viewfinderSize = getViewfinderSize();
  const actualViewfinderWidth = viewfinderSize.width;
  const actualViewfinderHeight = viewfinderSize.height;
  
  const rect = canvas.getBoundingClientRect();
  const container = document.getElementById('gameContainer');
  const containerRect = container.getBoundingClientRect();
  
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  
  const screenX = mouseX / scaleX;
  const screenY = mouseY / scaleY;
  
  const canvasLeft = rect.left - containerRect.left;
  const canvasTop = rect.top - containerRect.top;
  
  viewfinder.style.display = 'block';
  viewfinder.style.width = (actualViewfinderWidth * rect.width / canvas.width) + 'px';
  viewfinder.style.height = (actualViewfinderHeight * rect.height / canvas.height) + 'px';
  viewfinder.style.left = (canvasLeft + screenX - actualViewfinderWidth * rect.width / canvas.width / 2) + 'px';
  viewfinder.style.top = (canvasTop + screenY - actualViewfinderHeight * rect.height / canvas.height / 2) + 'px';
}

function handleCameraButtonClick() {
  handleMouseClick();
  
  const cameraButton = document.getElementById('cameraButton');
  cameraButton.style.backgroundColor = 'rgba(200, 200, 200, 0.9)';
  setTimeout(() => {
    cameraButton.style.backgroundColor = 'rgba(255, 255, 255, 0.9)';
  }, 100);
}

function handleMouseMove(e) {
  if (gyroModeActive) return;
  
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  
  mouseX = (e.clientX - rect.left) * scaleX;
  mouseY = (e.clientY - rect.top) * scaleY;
  
  if (!gyroModeActive) {
    const viewfinder = document.getElementById('viewfinder');
    const viewfinderSize = getViewfinderSize();
    const actualViewfinderWidth = viewfinderSize.width;
    const actualViewfinderHeight = viewfinderSize.height;
    
    viewfinder.style.display = 'block';
    viewfinder.style.width = (actualViewfinderWidth * rect.width / canvas.width) + 'px';
    viewfinder.style.height = (actualViewfinderHeight * rect.height / canvas.height) + 'px';
    viewfinder.style.left = (e.clientX - actualViewfinderWidth * rect.width / canvas.width / 2) + 'px';
    viewfinder.style.top = (e.clientY - actualViewfinderHeight * rect.height / canvas.height / 2) + 'px';
  }
}

// 在JavaScript中添加这个函数
function loadCreatorInfo() {
    fetch('creator.txt')
        .then(response => {
            if (!response.ok) {
                throw new Error('无法加载创作者信息');
            }
            return response.text();
        })
        .then(text => {
            const creatorDiv = document.getElementById('creator');
            if (creatorDiv && text.trim()) {
                creatorDiv.textContent = text.trim();
            } else {
                creatorDiv.textContent = "鸟人鸟语";
            }
        })
        .catch(error => {
            console.error('加载创作者信息失败:', error);
            const creatorDiv = document.getElementById('creator');
            if (creatorDiv) {
                creatorDiv.textContent = "鸟人鸟语";
            }
        });
}


function init() {
    canvas = document.getElementById('gameCanvas');
    ctx = canvas.getContext('2d');
    poopCanvas = document.getElementById('poopCanvas');
    poopCtx = poopCanvas.getContext('2d');
    
    loadCreatorInfo();
    
    // 确保截图画布正确初始化
    screenshotCanvas = document.getElementById('screenshotCanvas');
    screenshotCtx = screenshotCanvas.getContext('2d');
    
    // 设置截图画布为隐藏但可用状态
    screenshotCanvas.style.position = 'absolute';
    screenshotCanvas.style.left = '-9999px';
    screenshotCanvas.style.top = '-9999px';
    screenshotCanvas.style.width = '300px';
    screenshotCanvas.style.height = '450px';
        
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    initStars();
    initTrees();
    initReeds();
    initFixedLeaves();
    initTextStats();
    initFruits();
    initWallAndHole();
    initModeToggleButtons();
    initLensToggleButtons();
    initGyro();
    // 监听屏幕方向变化
    window.addEventListener('orientationchange', function() {
        // 方向变化后重新计算营地位置
        setTimeout(updateCampsiteVisibility, 100);
    });
    
    // 监听窗口大小变化
    window.addEventListener('resize', function() {
        updateCampsiteVisibility();
    });
            // 初始化营地
        updateCampsiteVisibility();
    const birdingModeButton = document.getElementById('birdingModeToggle');
    birdingModeButton.addEventListener('click', toggleBirdingMode);
       
 // 添加帮助按钮事件监听
    const helpButton = document.getElementById('helpButton');
    if (helpButton) {
        helpButton.addEventListener('click', openHelpModal);
    }

    lastRareBirdTime = gameTime;
    canvas.addEventListener('mousemove', handleMouseMove);
    canvas.addEventListener('mousedown', handleMouseClick);
    document.addEventListener('keydown', handleKeyDown);
    lastFrameTime = performance.now();
    
    const goldenFilter = document.getElementById('goldenFilter');
    if (!gyroModeActive) {
        goldenFilter.style.backgroundColor = 'rgba(255, 215, 0, 0.1)';
    }
    addToggleAreaClickListeners();
    updateTimeIndicator();

    initBirdingRecords();
    updateBirdingModeButton();
// 初始化观鸟记录图标显示
    updateBirdingRecordIcons();

    requestAnimationFrame(gameLoop);

// 确保截图按钮在页面加载时就绑定事件
    const screenshotButton = document.getElementById('screenshotButton');
    if (screenshotButton) {
        // 移除可能存在的旧监听器，重新绑定
        const newScreenshotButton = screenshotButton.cloneNode(true);
        screenshotButton.parentNode.replaceChild(newScreenshotButton, screenshotButton);
        
        // 重新获取按钮引用
        const updatedScreenshotButton = document.getElementById('screenshotButton');
        updatedScreenshotButton.onclick = function(e) {
            e.stopPropagation();
            captureBirdingRecord();
        };
    }
}

function handleVisibilityChange() {
    if (document.hidden) {
        // 页面不可见时，可以适当降低游戏循环频率或暂停非必要更新
        console.log('页面失去焦点');
    } else {
        // 页面重新可见时，重置 lastFrameTime 避免时间跳跃
        lastFrameTime = performance.now();
        console.log('页面重新获得焦点');
    }
}

function gameLoop(timestamp) {
    if (gamePaused) {
        requestAnimationFrame(gameLoop);
        return;
    }
    
    // 限制最大 deltaTime，避免失去焦点后时间差过大
    let deltaTime = timestamp - lastFrameTime;
    lastFrameTime = timestamp;
    
    // 限制最大 deltaTime 为 30ms
    if (deltaTime > 30) {
        deltaTime = 30;
    }
    
    updateDayNight(deltaTime);
    updateBirds(deltaTime);
    updateNightObjects(deltaTime);
    generateBird();
    
    if (gyroModeActive) {
        updateViewfinderFromGyro();
    }
    
    requestAnimationFrame(gameLoop);
}

function initBirdingRecords() {
  lastBirdingRecordTime = gameTime;
  birdingModeBirdTracker = {};
  birdingObservedSpecies = new Set();
  birdingModeRecordedBirds = new Set();
}

function getBirdsInView() {
  const viewBounds = {
    left: 0,
    right: GAME_WIDTH,
    top: 0,
    bottom: GAME_HEIGHT
  };
  
  const birdsInView = [];
  const countedGroups = new Set();
  
  birds.forEach(bird => {
    if (!bird.name || bird.isBat || bird.type?.isSpecial) return;
    
    const baseSize = 20;
    const birdSize = baseSize * bird.size;
    const birdRadius = birdSize / 2;
    
    const isInView = bird.x + birdRadius >= viewBounds.left &&
                    bird.x - birdRadius <= viewBounds.right &&
                    bird.y + birdRadius >= viewBounds.top &&
                    bird.y - birdRadius <= viewBounds.bottom;
    
    if (isInView) {
      birdsInView.push(bird);
      
      if (bird.groupId && birdGroupInfo[bird.groupId]) {
        if (!countedGroups.has(bird.groupId)) {
          countedGroups.add(bird.groupId);
        }
      }
    }
  });
  
  return birdsInView;
}

function countBirdsInView() {
  const birdsInView = getBirdsInView();
  const birdCounts = {};
  const countedGroups = new Set();
  
  birdsInView.forEach(bird => {
    const birdName = bird.name;
    if (!birdCounts[birdName]) {
      birdCounts[birdName] = 0;
    }
    
    if (bird.groupId && birdGroupInfo[bird.groupId]) {
      if (!countedGroups.has(bird.groupId)) {
        const group = birdGroupInfo[bird.groupId];
        if (group && group.birds) {
          let groupCount = 0;
          group.birds.forEach(groupBird => {
            if (groupBird && birds.includes(groupBird)) {
              const baseSize = 20;
              const groupBirdRadius = baseSize * groupBird.size / 2;
              const isGroupBirdInView = groupBird.x + groupBirdRadius >= 0 &&
                                        groupBird.x - groupBirdRadius <= GAME_WIDTH &&
                                        groupBird.y + groupBirdRadius >= 0 &&
                                        groupBird.y - groupBirdRadius <= GAME_HEIGHT;
              if (isGroupBirdInView) {
                groupCount++;
              }
            }
          });
          birdCounts[birdName] += groupCount;
          countedGroups.add(bird.groupId);
        }
      }
    } else {
      birdCounts[birdName]++;
    }
  });
  
  return birdCounts;
}

// 更新观鸟记录图标显示
function updateBirdingRecordIcons() {
    const iconElement = document.getElementById('birdingRecordIcon');
    if (!iconElement) return;
    
    // 如果有观鸟记录，显示图标
    if (birdingRecords.length > 0) {
        const latestRecord = birdingRecords[birdingRecords.length - 1];
        
        const totalSeconds = Math.floor(latestRecord.birdingModeDuration / 1000);
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        
        // 设置图标内容
        iconElement.innerHTML = `
            <span class="iconNumber">#${latestRecord.id}</span>
            <span class="iconTime">${minutes}:${seconds.toString().padStart(2, '0')}</span>
            <span class="iconBirdCount">${latestRecord.totalObservedSpecies}种</span>
        `;
        
        // 添加点击事件
        iconElement.onclick = function() {
            openBirdingRecord(birdingRecords.length - 1);
        };
        
        // 显示图标
        iconElement.style.display = 'flex';
    } else {
        // 没有记录时隐藏图标
        iconElement.style.display = 'none';
    }
}

    function createBirdingRecord(duration) {
        if (!birdingModeActive && birdingObservedSpecies.size === 0) {
            return null;
        }
        
        const capturedInSession = birdingModeCapturedSpecies ? birdingModeCapturedSpecies.size : 0;
        let rarestBird = null;
        let minProbability = Infinity;
        
        for (const birdName of birdingObservedSpecies) {
            const birdKey = Object.keys(BIRD_TYPES).find(key => BIRD_TYPES[key].name === birdName);
            if (birdKey && BIRD_TYPES[birdKey].probability > 0 && BIRD_TYPES[birdKey].probability < minProbability) {
                minProbability = BIRD_TYPES[birdKey].probability;
                rarestBird = birdName;
            }
        }
        
        const record = {
            id: birdingRecords.length + 1,
            time: gameTime,
            observedSpecies: Array.from(birdingObservedSpecies),
            totalObservedSpecies: birdingObservedSpecies.size,
            capturedInSession: capturedInSession,
            rarestBird: rarestBird,
            birdingModeDuration: duration, // 使用传入的实际时长
            startedAtDaytime: isDaytimeAtStart,
            endedAtDaytime: isDaytime
        };
        
        birdingRecords.push(record);
        if (birdingRecords.length > 20) {
            birdingRecords.shift();
        }
        
        updateBirdingRecordIcons();
        return record;
    }

function openBirdingRecord(recordIndex) {
  if (recordIndex < 0 || recordIndex >= birdingRecords.length) return;
  
  pauseGame();
  
  const modal = document.getElementById('birdingRecordModal');
  const content = document.getElementById('birdingRecordContent');
  const screenshotButton = document.getElementById('screenshotButton');
  const nav = document.getElementById('birdingRecordNav');
  const counter = document.getElementById('birdingRecordCounter');
  const swipeHint = document.getElementById('swipeHint');
  
  // 设置当前记录索引
  currentRecordIndex = recordIndex;
  
  modal.style.display = 'block';
  modal.style.zIndex = '400';
  
  // 显示导航按钮和计数器
  nav.classList.add('show');
  counter.classList.add('show');
  swipeHint.style.display = 'block';
  
  screenshotButton.style.display = 'block';
  screenshotButton.style.pointerEvents = 'auto';
  screenshotButton.style.opacity = '1';
  screenshotButton.style.zIndex = '401';
  screenshotButton.parentNode.appendChild(screenshotButton);
  
  // 更新导航按钮状态
  updateRecordNavButtons();
  
  // 更新记录内容
  updateRecordContent(recordIndex);
  
  // 添加事件监听器
  modal.addEventListener('wheel', handleRecordWheel, { passive: false });
  modal.addEventListener('touchstart', handleRecordTouchStart, { passive: true });
  modal.addEventListener('touchmove', handleRecordTouchMove, { passive: false });
  modal.addEventListener('touchend', handleRecordTouchEnd, { passive: true });
  
  screenshotButton.onclick = function(e) {
    e.stopPropagation();
    captureBirdingRecord();
  };
  
  // 3秒后隐藏滑动提示
  setTimeout(() => {
    swipeHint.style.display = 'none';
  }, 3000);
}
  
  function updateRecordContent(recordIndex) {
  const record = birdingRecords[recordIndex];
  const content = document.getElementById('birdingRecordContent');
  const counter = document.getElementById('birdingRecordCounter');
  
  currentBirdingRecord = record;
  currentRecordIndex = recordIndex;
  
  const totalSeconds = Math.floor(record.birdingModeDuration / 1000);
  const minutes = Math.floor(totalSeconds / 60);
  const seconds = totalSeconds % 60;
  
  let recordText = `第 ${record.id} 次观鸟记录\n`;
  recordText += "=".repeat(50) + "\n\n";
  recordText += `观鸟时长: ${minutes}分${seconds}秒\n`;
  recordText += `时间跨度: ${record.startedAtDaytime ? "白天" : "黑夜"} → ${record.endedAtDaytime ? "白天" : "黑夜"}\n`;
  recordText += `观察鸟种: ${record.totalObservedSpecies} 种\n`;
  recordText += `拍摄鸟种: ${record.capturedInSession} 种\n`;
  
  if (record.rarestBird) {
    recordText += `最稀有鸟种: ${record.rarestBird}\n`;
  }
  
  recordText += "=".repeat(50) + "\n\n";
  recordText += "观察到的鸟种:\n";
  recordText += "-".repeat(50) + "\n\n";
  
  record.observedSpecies.sort().forEach((birdName, index) => {
    const birdKey = Object.keys(BIRD_TYPES).find(key => BIRD_TYPES[key].name === birdName);
    const isRare = birdKey && BIRD_TYPES[birdKey].probability < 0.02;
    
    if (birdName === record.rarestBird) {
      recordText += `${index + 1}. ${birdName} ★\n`;
    } else if (isRare) {
      recordText += `${index + 1}. ${birdName} (稀有)\n`;
    } else {
      recordText += `${index + 1}. ${birdName}\n`;
    }
  });
  
  content.textContent = recordText;
  
  // 更新计数器
  counter.textContent = `记录 ${recordIndex + 1} / ${birdingRecords.length}`;
  
  // 更新导航按钮状态
  updateRecordNavButtons();
}

function updateRecordNavButtons() {
  const prevButton = document.getElementById('prevRecordButton');
  const nextButton = document.getElementById('nextRecordButton');
  
  prevButton.disabled = currentRecordIndex <= 0;
  nextButton.disabled = currentRecordIndex >= birdingRecords.length - 1;
}

// 切换记录
function switchBirdingRecord(direction) {
  if (isNavigatingRecords) return;
  
  const newIndex = currentRecordIndex + direction;
  
  if (newIndex >= 0 && newIndex < birdingRecords.length) {
    isNavigatingRecords = true;
    
    // 添加切换动画效果
    const content = document.getElementById('birdingRecordContent');
    content.style.opacity = '0.5';
    content.style.transition = 'opacity 0.2s';
    
    setTimeout(() => {
      updateRecordContent(newIndex);
      content.style.opacity = '1';
      
      setTimeout(() => {
        isNavigatingRecords = false;
      }, 100);
    }, 100);
  }
}

// 处理滚轮事件
function handleRecordWheel(event) {
  if (isNavigatingRecords) return;
  
  const now = Date.now();
  if (now - lastWheelTime < WHEEL_COOLDOWN) return;
  
  event.preventDefault();
  
  // 判断滚轮方向
  if (event.deltaY > 0) {
    // 向下滚动，切换到下一条记录
    switchBirdingRecord(1);
  } else if (event.deltaY < 0) {
    // 向上滚动，切换到上一条记录
    switchBirdingRecord(-1);
  }
  
  lastWheelTime = now;
}

// 处理触摸开始事件
function handleRecordTouchStart(event) {
  if (event.touches.length === 1) {
    touchStartY = event.touches[0].clientY;
    touchStartX = event.touches[0].clientX;
  }
}

// 处理触摸移动事件
function handleRecordTouchMove(event) {
  if (isNavigatingRecords || event.touches.length !== 1) return;
  
  event.preventDefault();
  
  const touchY = event.touches[0].clientY;
  const touchX = event.touches[0].clientX;
  
  // 计算垂直滑动距离
  const deltaY = touchY - touchStartY;
  const deltaX = touchX - touchStartX;
  
  // 如果是垂直滑动且距离足够大，则切换记录
  if (Math.abs(deltaY) > 50 && Math.abs(deltaY) > Math.abs(deltaX)) {
    if (deltaY > 0) {
      // 向下滑动，切换到上一条记录
      switchBirdingRecord(-1);
    } else {
      // 向上滑动，切换到下一条记录
      switchBirdingRecord(1);
    }
    
    // 重置触摸起点
    touchStartY = touchY;
    touchStartX = touchX;
  }
}

// 处理触摸结束事件
function handleRecordTouchEnd() {
  touchStartY = 0;
  touchStartX = 0;
}

// 修改 closeBirdingRecord 函数
function closeBirdingRecord() {
  const modal = document.getElementById('birdingRecordModal');
  const screenshotButton = document.getElementById('screenshotButton');
  const nav = document.getElementById('birdingRecordNav');
  const counter = document.getElementById('birdingRecordCounter');
  
  // 移除事件监听器
  modal.removeEventListener('wheel', handleRecordWheel);
  modal.removeEventListener('touchstart', handleRecordTouchStart);
  modal.removeEventListener('touchmove', handleRecordTouchMove);
  modal.removeEventListener('touchend', handleRecordTouchEnd);
  
  modal.style.display = 'none';
  nav.classList.remove('show');
  counter.classList.remove('show');
  
  screenshotButton.style.display = 'none';
  currentBirdingRecord = null;
  
  resumeGame();
}

function toggleBirdingMode() {
        if (gamePaused) return;
        
        if (!birdingModeActive) {
            birdingModeActive = true;
            birdingModeStartTime = gameTime;
            isDaytimeAtStart = isDaytime;
            birdingRecordRealDuration = 0; // 重置实际观鸟时长
            
            const dayModeButton = document.getElementById('dayModeToggle');
            const normalModeButton = document.getElementById('normalModeToggle');
            const nightModeButton = document.getElementById('nightModeToggle');
            dayModeButton.disabled = true;
            normalModeButton.disabled = true;
            nightModeButton.disabled = true;
            dayModeButton.style.opacity = '0.5';
            normalModeButton.style.opacity = '0.5';
            nightModeButton.style.opacity = '0.5';
            
            birdingObservedSpecies = new Set();
            birdingModeRecordedBirds = new Set();
            birdingModeCapturedSpecies = new Set();
            
            const initialBirds = getBirdsInView();
            initialBirds.forEach(bird => {
                if (bird.noStats) return;
                const birdId = `${bird.name}_${bird.x}_${bird.y}_${bird.groupId || 'single'}`;
                if (!birdingModeRecordedBirds.has(birdId)) {
                    birdingModeRecordedBirds.add(birdId);
                    birdingObservedSpecies.add(bird.name);
                }
            });
            
            birdingModeStartSnapshot = {
                startTime: gameTime,
                startedAtDaytime: isDaytime,
                birdCounts: countBirdsInView(),
                captured: {...capturedBirds},
                birds: birds.map(bird => ({ 
                    name: bird.name, 
                    type: bird.type, 
                    x: bird.x, 
                    y: bird.y, 
                    groupId: bird.groupId 
                }))
            };
            
            birdingModeBirdTracker = {};
            lastBirdingRecordTime = gameTime;
            showSpecialAlert("观鸟模式已启动！记录已开始。");
            updateBirdingModeButton();
            
            // 开始记录实际观鸟时长
            if (birdingModeUpdateInterval) {
                clearInterval(birdingModeUpdateInterval);
            }
            birdingModeUpdateInterval = setInterval(() => {
                if (birdingModeActive) {
                    // 记录实际时间（不受加速影响）
                    birdingRecordRealDuration += 1000;
                    
                    const currentBirds = getBirdsInView();
                    currentBirds.forEach(bird => {
                        if (bird.noStats) return;
                        const birdId = `${bird.name}_${bird.x}_${bird.y}_${bird.groupId || 'single'}`;
                        if (!birdingModeRecordedBirds.has(birdId)) {
                            birdingModeRecordedBirds.add(birdId);
                            birdingObservedSpecies.add(bird.name);
                        }
                    });
                }
            }, 1000);
        } else {
            birdingModeActive = false;
            birdingModeEndTime = gameTime;
            
            const dayModeButton = document.getElementById('dayModeToggle');
            const normalModeButton = document.getElementById('normalModeToggle');
            const nightModeButton = document.getElementById('nightModeToggle');
            dayModeButton.disabled = false;
            normalModeButton.disabled = false;
            nightModeButton.disabled = false;
            dayModeButton.style.opacity = '1';
            normalModeButton.style.opacity = '1';
            nightModeButton.style.opacity = '1';
            
            // 使用实际记录的观鸟时长
            const recordDuration = birdingRecordRealDuration || (birdingModeEndTime - birdingModeStartTime);
            const record = createBirdingRecord(recordDuration);
            updateBirdingModeButton();
            
            if (record) {
                const elapsedMinutes = Math.floor(record.birdingModeDuration / 60000);
                const elapsedSeconds = Math.floor((record.birdingModeDuration % 60000) / 1000);
                showSpecialAlert(`观鸟模式结束！持续${elapsedMinutes}分${elapsedSeconds}秒，观察${record.totalObservedSpecies}种，拍摄${record.capturedInSession}种`);
                
                if (record.totalObservedSpecies > 0) {
                    pauseGame();
                    openBirdingRecord(record.id - 1);
                }
            } else {
                showSpecialAlert("观鸟模式结束，未生成记录数据。");
            }
            
            birdingModeStartSnapshot = {};
            birdingObservedSpecies = new Set();
            birdingModeRecordedBirds = new Set();
            birdingModeCapturedSpecies = null;
            birdingRecordRealDuration = 0;
            
            if (birdingModeUpdateInterval) {
                clearInterval(birdingModeUpdateInterval);
                birdingModeUpdateInterval = null;
            }
        }
    }

function updateBirdingModeButton() {
  const birdingModeButton = document.getElementById('birdingModeToggle');
  const birdingStatusIndicator = document.getElementById('birdingStatusIndicator');
  
  if (birdingModeActive) {
    birdingModeButton.classList.add('active');
    birdingModeButton.style.borderColor = '#90EE90';
    birdingModeButton.textContent = "结束观鸟模式";
    
    const birdingDuration = gameTime - birdingModeStartTime;
    const birdingMinutes = Math.floor(birdingDuration / 60000);
    const birdingSeconds = Math.floor((birdingDuration % 60000) / 1000);
    
    birdingStatusIndicator.textContent = `进行中 ${birdingMinutes}:${birdingSeconds.toString().padStart(2, '0')}`;
    birdingStatusIndicator.style.color = '#90EE90';
    
    if (birdingModeUpdateInterval) {
      clearInterval(birdingModeUpdateInterval);
      birdingModeUpdateInterval = null;
    }
    
    birdingModeUpdateInterval = setInterval(() => {
      if (birdingModeActive) {
        const currentBirds = getBirdsInView();
        currentBirds.forEach(bird => {
          if (bird.noStats) return;
          const birdId = `${bird.name}_${bird.x}_${bird.y}_${bird.groupId || 'single'}`;
          if (!birdingModeRecordedBirds.has(birdId)) {
            birdingModeRecordedBirds.add(birdId);
            birdingObservedSpecies.add(bird.name);
          }
        });
      }
    }, 1000);
  } else {
    birdingModeButton.classList.remove('active');
    birdingModeButton.style.borderColor = '#90EE90';
    birdingModeButton.textContent = "观鸟模式";
    birdingStatusIndicator.textContent = "未开始";
    birdingStatusIndicator.style.color = "white";
    
    if (birdingModeUpdateInterval) {
      clearInterval(birdingModeUpdateInterval);
      birdingModeUpdateInterval = null;
    }
  }
}

function initLensToggleButtons() {
  const lens600Button = document.getElementById('lens600Toggle');
  const lens800Button = document.getElementById('lens800Toggle');
  const lens1200Button = document.getElementById('lens1200Toggle');
  
  lens600Button.addEventListener('click', () => setLens('600'));
  lens800Button.addEventListener('click', () => setLens('800'));
  lens1200Button.addEventListener('click', () => setLens('1200'));
  
  updateLensToggleButtons();
}

function setLens(lens) {
  if (currentLens === lens) return;
  
  currentLens = lens;
  showSpecialAlert(`切换到${LENS_SETTINGS[lens].name}镜头`);
  
  updateLensToggleButtons();
}

function updateLensToggleButtons() {
  const lens600Button = document.getElementById('lens600Toggle');
  const lens800Button = document.getElementById('lens800Toggle');
  const lens1200Button = document.getElementById('lens1200Toggle');
  
  lens600Button.classList.toggle('active', currentLens === '600');
  lens800Button.classList.toggle('active', currentLens === '800');
  lens1200Button.classList.toggle('active', currentLens === '1200');
}

function getViewfinderSize() {
  const lensMultiplier = LENS_SETTINGS[currentLens].multiplier;
  return {
    width: viewfinderBaseWidth * lensMultiplier,
    height: viewfinderBaseHeight * lensMultiplier
  };
}

function initFixedLeaves() {
  fixedLeaves = [];
  
  treePositions.forEach(tree => {
    for (let i = 0; i < 30; i++) {
      const leafX = tree.x + Math.random() * tree.width;
      const leafY = tree.y + Math.random() * tree.height * 0.8;
      const leafSize = 3 + Math.random() * 5;
      const leafType = Math.floor(Math.random() * 3);
      const leafColor = leafType === 0 ? '#228B22' : leafType === 1 ? '#2E8B57' : '#32CD32';
      
      fixedLeaves.push({
        treeIndex: treePositions.indexOf(tree),
        x: leafX,
        y: leafY,
        size: leafSize,
        color: leafColor,
        type: leafType,
        rotation: Math.random() * Math.PI * 2,
        offsetX: (Math.random() - 0.5) * 2,
        offsetY: (Math.random() - 0.5) * 2
      });
    }
  });
}

function initWallAndHole() {
  const wallWidth = 80;
  const wallHeight = 200;
  const wallX = GAME_WIDTH - wallWidth - 10;
  const wallY = GAME_HEIGHT - wallHeight;
  
  wall = {
    x: wallX,
    y: wallY,
    width: wallWidth,
    height: wallHeight,
    color: '#505050'
  };
  
  const sparrowSize = 20 * BIRD_TYPES.SPARROW.size;
  const holeDiameter = sparrowSize * 2;
  const holeX = wallX + wallWidth / 2;
  const holeY = wallY + wallHeight * 0.3;
  
  hole = {
    x: holeX,
    y: holeY,
    diameter: holeDiameter
  };
}

function initModeToggleButtons() {
  const dayModeButton = document.getElementById('dayModeToggle');
  const normalModeButton = document.getElementById('normalModeToggle');
  const nightModeButton = document.getElementById('nightModeToggle');
  
  dayModeButton.addEventListener('click', () => setGameMode('day'));
  normalModeButton.addEventListener('click', () => setGameMode('normal'));
  nightModeButton.addEventListener('click', () => setGameMode('night'));
  
  updateModeToggleButtons();
}

function easeInOutQuad(t) {
  return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
}

function setGameMode(mode) {
  if (gameMode === mode) return;
  const oldMode = gameMode;
  gameMode = mode;
        // 重置营地状态
        resetCampsite();
  
  if (mode === 'day') {
    if (oldMode === 'normal') {
      normalModeTimeState = {
        isDaytime: isDaytime,
        dayNightTimer: dayNightTimer,
        moonPhaseTimer: moonPhaseTimer
      };
    }
    
    isDaytime = true;
    dayNightTimer = dayModeTimeState;
    
    showSpecialAlert("切换到永久日间模式");
    
    for (let i = birds.length - 1; i >= 0; i--) {
      if (birds[i].isOwl || birds[i].isBat) {
        birds.splice(i, 1);
      }
    }
    
    if (littleOwl) {
      birds.splice(birds.indexOf(littleOwl), 1);
      littleOwl = null;
    }
    
    nightObjects = [];
  } else if (mode === 'night') {
    if (oldMode === 'normal') {
      normalModeTimeState = {
        isDaytime: isDaytime,
        dayNightTimer: dayNightTimer,
        moonPhaseTimer: moonPhaseTimer
      };
    }
    
    isDaytime = false;
    dayNightTimer = nightModeTimeState;
    moonPhaseTimer = nightModeMoonPhaseTimer || Math.random() * MOON_PHASE_CYCLE;
    
    showSpecialAlert("切换到永久夜间模式");
    
    for (let i = birds.length - 1; i >= 0; i--) {
      if (!birds[i].isOwl && !birds[i].isBat && birds[i].name !== "小鸮" && birds[i].name !== "夜鹭") {
        birds.splice(i, 1);
      }
    }
    
    nightObjects = [];
  } else if (mode === 'normal') {
    if (oldMode === 'day') {
      dayModeTimeState = dayNightTimer;
      isDaytime = normalModeTimeState.isDaytime;
      dayNightTimer = normalModeTimeState.dayNightTimer;
      moonPhaseTimer = normalModeTimeState.moonPhaseTimer;
    } else if (oldMode === 'night') {
      nightModeTimeState = dayNightTimer;
      nightModeMoonPhaseTimer = moonPhaseTimer;
      isDaytime = normalModeTimeState.isDaytime;
      dayNightTimer = normalModeTimeState.dayNightTimer;
      moonPhaseTimer = normalModeTimeState.moonPhaseTimer;
    } else {
      if (normalModeTimeState) {
        isDaytime = normalModeTimeState.isDaytime;
        dayNightTimer = normalModeTimeState.dayNightTimer;
        moonPhaseTimer = normalModeTimeState.moonPhaseTimer;
      } else {
        isDaytime = true;
        dayNightTimer = 0;
        moonPhaseTimer = 0;
      }
    }
    
    showSpecialAlert("切换到普通模式");
    
    if (oldMode === 'night') {
      for (let i = birds.length - 1; i >= 0; i--) {
        if (birds[i].isOwl || birds[i].isBat) {
          birds.splice(i, 1);
        }
      }
      nightObjects = [];
    }
  }
        updateModeToggleButtons();
        updateCampsiteVisibility();
        updateTimeIndicator();
}

function updateModeToggleButtons() {
  const dayModeButton = document.getElementById('dayModeToggle');
  const normalModeButton = document.getElementById('normalModeToggle');
  const nightModeButton = document.getElementById('nightModeToggle');
  
  dayModeButton.classList.toggle('active', gameMode === 'day');
  normalModeButton.classList.toggle('active', gameMode === 'normal');
  nightModeButton.classList.toggle('active', gameMode === 'night');
}

function updateTimeIndicator() {
  const timeIndicator = document.getElementById('timeIndicator');
  const totalSeconds = Math.floor(gameTime / 1000);
  const minutes = Math.floor(totalSeconds / 60);
  const seconds = totalSeconds % 60;
  
  if (gameMode === 'normal') {
    const remainingTime = DAY_NIGHT_CYCLE_DURATION - dayNightTimer;
    const remainingMinutes = Math.floor(remainingTime / 60000);
    const remainingSeconds = Math.floor((remainingTime % 60000) / 1000);
    
let timeText = `${isDaytime ? "白天" : "黑夜"} ${remainingMinutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')} / 15:00`;
            
            // 添加加速状态提示
            if (isNightAccelerated && !isDaytime) {
                timeText += " ⏩ (加速中)";
            }
            
            timeText += ` | ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            timeIndicator.textContent = timeText;
        } else if (gameMode === 'day') {
            const timeText = `永久日间 | ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            timeIndicator.textContent = timeText;
        } else if (gameMode === 'night') {
            const timeText = `永久夜间 | ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            timeIndicator.textContent = timeText;
        }
    }

// 观鸟记录截图函数
function captureBirdingRecord() {
    console.log("开始截图记录...");
    
    if (!currentBirdingRecord) {
        console.warn("没有当前观鸟记录");
        showSpecialAlert("请先打开观鸟记录！");
        return;
    }
    
    const screenshotButton = document.getElementById('screenshotButton');
    screenshotButton.disabled = true;
    screenshotButton.style.opacity = '0.5';
    screenshotButton.textContent = "生成中...";
    
// 临时禁用滑动功能
  const originalNavigating = isNavigatingRecords;
  isNavigatingRecords = true;
  
  try {
    if (!gamePaused) {
      pauseGame();
    }
        
        const SCREENSHOT_WIDTH = 300;
        const lineHeight = 22;
        const record = currentBirdingRecord;
        const speciesCount = record.observedSpecies.length;
        
        // 精确计算所需高度
        const titleHeight = 50;
        const recordInfoHeight = 5 * lineHeight;
        const headerMargin = 35;
        const footerHeight = 30;
        const speciesListHeight = speciesCount * lineHeight;
        
        // 动态计算总高度（支持多列布局）
        const baseHeight = titleHeight + recordInfoHeight + headerMargin + footerHeight + 20;
        const dynamicHeight = baseHeight + Math.min(speciesListHeight, 800); // 限制列表部分高度
        
        // 设置合理的最大最小高度
        const MAX_SCREENSHOT_HEIGHT = 2000;
        const MIN_SCREENSHOT_HEIGHT = 650;
        
        const SCREENSHOT_HEIGHT = Math.max(MIN_SCREENSHOT_HEIGHT, 
                                          Math.min(MAX_SCREENSHOT_HEIGHT, dynamicHeight));
        
        screenshotCanvas.width = SCREENSHOT_WIDTH;
        screenshotCanvas.height = SCREENSHOT_HEIGHT;
        
        screenshotCtx.clearRect(0, 0, SCREENSHOT_WIDTH, SCREENSHOT_HEIGHT);
        
        // 绘制背景
        const gradient = screenshotCtx.createLinearGradient(0, 0, 0, SCREENSHOT_HEIGHT);
        gradient.addColorStop(0, '#16213e');
        gradient.addColorStop(1, '#0f3460');
        screenshotCtx.fillStyle = gradient;
        screenshotCtx.fillRect(0, 0, SCREENSHOT_WIDTH, SCREENSHOT_HEIGHT);
        
        // 绘制标题
        screenshotCtx.fillStyle = '#FFD700';
        screenshotCtx.font = 'bold 24px "AlimamaShuHeiTi-Bold.ttf", Arial, sans-serif';
        screenshotCtx.textAlign = 'center';
        screenshotCtx.fillText('观鸟记录', SCREENSHOT_WIDTH / 2, 40);
        
        screenshotCtx.strokeStyle = '#87CEEB';
        screenshotCtx.lineWidth = 2;
        screenshotCtx.beginPath();
        screenshotCtx.moveTo(50, 55);
        screenshotCtx.lineTo(SCREENSHOT_WIDTH - 50, 55);
        screenshotCtx.stroke();
        
        // 绘制内容
        const startY = 85;
        const availableHeight = SCREENSHOT_HEIGHT - startY - footerHeight - 10;
        drawRecordInfoSingleColumn(record, startY, lineHeight, SCREENSHOT_WIDTH - 40, availableHeight);
        
        // 绘制页脚
        screenshotCtx.fillStyle = '#FFD700';
        screenshotCtx.font = 'bold 14px "AlimamaShuHeiTi-Bold.ttf", Arial, sans-serif';
        screenshotCtx.textAlign = 'center';
        const bottomText = 'https://goseplover.github.io/12000h';
        screenshotCtx.fillText(bottomText, SCREENSHOT_WIDTH / 2, SCREENSHOT_HEIGHT - 15);
        
        currentScreenshotDataURL = screenshotCanvas.toDataURL('image/png');
    console.log("截图生成完成，数据URL长度:", currentScreenshotDataURL.length);
    
    setTimeout(() => {
      showScreenshotPreview();
      screenshotButton.disabled = false;
      screenshotButton.style.opacity = '1';
      screenshotButton.textContent = "📸 截图记录";
      isNavigatingRecords = originalNavigating; // 恢复滑动功能
    }, 100);
    
  } catch (error) {
    console.error("截图绘制过程中出错:", error);
    showSpecialAlert("截图绘制失败");
    screenshotButton.disabled = false;
    screenshotButton.style.opacity = '1';
    screenshotButton.textContent = "📸 截图记录";
    isNavigatingRecords = originalNavigating; // 恢复滑动功能
    resumeGame();
  }
}

function drawRecordInfoSingleColumn(record, startY, lineHeight, columnWidth, maxHeight) {
  let y = startY;
  const x = 20;
  const speciesListStartY = y;
  
  screenshotCtx.fillStyle = '#FFFFFF';
  screenshotCtx.font = '16px "AlimamaShuHeiTi-Bold.ttf", Arial, sans-serif';
  screenshotCtx.textAlign = 'left';
  
  screenshotCtx.fillText(`记录编号: #${record.id}`, x, y);
  y += lineHeight;
  
  const durationText = `观鸟时长: ${Math.floor(record.birdingModeDuration / 60000)}分${Math.floor((record.birdingModeDuration % 60000) / 1000)}秒`;
  screenshotCtx.fillText(durationText, x, y);
  y += lineHeight;
  
  screenshotCtx.fillText(`时间: ${record.startedAtDaytime ? "白天" : "黑夜"} → ${record.endedAtDaytime ? "白天" : "黑夜"}`, x, y);
  y += lineHeight;
  
  screenshotCtx.fillText(`观察鸟种: ${record.totalObservedSpecies} 种`, x, y);
  y += lineHeight;

  screenshotCtx.fillText(`拍摄鸟种: ${record.capturedInSession || 0} 种`, x, y);
  y += lineHeight;
  
  if (record.rarestBird) {
    screenshotCtx.fillStyle = '#FFD700';
    screenshotCtx.fillText(`最稀有: ${record.rarestBird}`, x, y);
    screenshotCtx.fillStyle = '#FFFFFF';
    y += lineHeight;
  }
  
  y += lineHeight;
  
  screenshotCtx.fillStyle = '#87CEEB';
  screenshotCtx.fillText('观察到的鸟种:', x, y);
  y += lineHeight;
  
  screenshotCtx.strokeStyle = '#87CEEB';
  screenshotCtx.lineWidth = 1;
  screenshotCtx.beginPath();
  screenshotCtx.moveTo(x, y - 5);
  screenshotCtx.lineTo(x + 120, y - 5);
  screenshotCtx.stroke();
  
  y += 5;
  
  const sortedSpecies = [...record.observedSpecies].sort();
  
  // 每列显示15个鸟种
  const itemsPerColumn = 15;
  const columnCount = Math.ceil(sortedSpecies.length / itemsPerColumn);
  
  // 计算列宽（假设有3列空间，实际根据列数调整）
  const maxColumns = 3; // 最大3列
  const actualColumnCount = Math.min(columnCount, maxColumns);
  const actualColumnWidth = (screenshotCanvas.width - 40) / actualColumnCount;
  
  // 按列优先排列（先竖排，填满一列后再换下一列）
  for (let col = 0; col < actualColumnCount; col++) {
    const columnX = x + col * actualColumnWidth;
    let columnY = y;
    
    for (let row = 0; row < itemsPerColumn; row++) {
      const index = col * itemsPerColumn + row; // 列优先索引
      
      if (index >= sortedSpecies.length) {
        break;
      }
      
      const birdName = sortedSpecies[index];
      const birdKey = Object.keys(BIRD_TYPES).find(key => BIRD_TYPES[key].name === birdName);
      const isRare = birdKey && BIRD_TYPES[birdKey].probability < 0.02;
      const isRarest = birdName === record.rarestBird;
      
      if (isRarest) {
        screenshotCtx.fillStyle = '#FFD700';
        screenshotCtx.font = 'bold 14px "AlimamaShuHeiTi-Bold.ttf"';
        screenshotCtx.fillText(`${index + 1}. ${birdName} ★`, columnX, columnY);
        screenshotCtx.font = '14px "AlimamaShuHeiTi-Bold.ttf"';
      } else if (isRare) {
        screenshotCtx.fillStyle = '#FFA500';
        screenshotCtx.fillText(`${index + 1}. ${birdName} (稀有)`, columnX, columnY);
      } else {
        screenshotCtx.fillStyle = '#FFFFFF';
        screenshotCtx.fillText(`${index + 1}. ${birdName}`, columnX, columnY);
      }
      
      columnY += lineHeight;
    }
  }
  
  // 如果鸟种太多，超过显示空间，添加提示
  if (sortedSpecies.length > itemsPerColumn * actualColumnCount) {
    const remainingCount = sortedSpecies.length - (itemsPerColumn * actualColumnCount);
    screenshotCtx.fillStyle = '#FFA500';
    screenshotCtx.font = '12px "AlimamaShuHeiTi-Bold.ttf"';
    screenshotCtx.fillText(`... 还有 ${remainingCount} 种未显示`, x, y + itemsPerColumn * lineHeight + 10);
  }
  
  return y;
}

// 显示截图预览
function showScreenshotPreview() {
    console.log("显示截图预览...");
    
    if (!currentScreenshotDataURL) {
        console.error("没有可用的截图数据");
        showSpecialAlert("没有可用的截图数据");
        return;
    }

    const previewModal = document.getElementById('screenshotPreviewModal');
    const previewImage = document.getElementById('screenshotPreviewImage');
    
    if (!previewModal || !previewImage) {
        console.error("预览元素未找到");
        showSpecialAlert("预览元素未找到");
        return;
    }

    // 设置图片源
    previewImage.src = currentScreenshotDataURL;
    
    // 显示模态框
    previewModal.style.display = 'flex';
    previewModal.style.zIndex = '500';
    
    console.log("预览模态框已显示");
    
    // 添加加载完成和加载错误的处理
    previewImage.onload = function() {
        console.log("预览图片加载成功");
    };
    
    previewImage.onerror = function() {
        console.error("预览图片加载失败");
        showSpecialAlert("预览图片加载失败");
        previewModal.style.display = 'none';
    };
}

function closeScreenshotPreview() {
    const previewModal = document.getElementById('screenshotPreviewModal');
    previewModal.style.display = 'none';
    
    // 恢复游戏
    resumeGame();
}

function saveScreenshot() {
    console.log("尝试保存截图...");
    
    if (!currentScreenshotDataURL) {
        console.error("没有可用的截图数据");
        showSpecialAlert("没有可用的截图数据");
        return;
    }
    
    try {
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const fileName = `观鸟记录_${timestamp}.png`;
        
        const downloadLink = document.createElement('a');
        downloadLink.href = currentScreenshotDataURL;
        downloadLink.download = fileName;
        downloadLink.style.display = 'none';
        
        document.body.appendChild(downloadLink);
        downloadLink.click();
        
        setTimeout(() => {
            document.body.removeChild(downloadLink);
        }, 100);
        
        console.log("截图保存成功");
        showSpecialAlert("截图已保存！");
        closeScreenshotPreview();
        
    } catch (error) {
        console.error("保存截图时出错:", error);
        showSpecialAlert("保存失败: " + error.message);
    }
}

// 在屏幕方向变化时保存和恢复篝火状态
window.addEventListener('orientationchange', function() {
    // 保存当前篝火状态
    const wasExtinguished = isCampfireExtinguished;
    const wasAccelerated = isNightAccelerated;
    
    // 短暂延迟后恢复状态
    setTimeout(function() {
        // 重新获取营地元素
        const campsite = document.getElementById('campsite');
        const flame = document.getElementById('campfire-flame');
        const hint = document.querySelector('#campsite > div > div:last-child');
        
        if (campsite && flame && hint) {
            // 根据保存的状态恢复篝火
            if (wasExtinguished) {
                // 如果是熄灭状态
                flame.style.display = 'none';
                flame.style.opacity = '0';
                hint.textContent = "篝火已熄灭";
                hint.style.color = "#87CEEB";
                
                // 确保加速状态也恢复
                if (wasAccelerated) {
                    isNightAccelerated = true;
                }
            } else {
                // 如果是点燃状态
                flame.style.display = 'block';
                flame.style.opacity = '1';
                hint.textContent = "点击熄灭篝火";
                hint.style.color = "#FFD700";
            }
            
            // 更新营地可见性
            updateCampsiteVisibility();
        }
    }, 300); // 300ms延迟确保DOM已经更新
});

// 同样处理窗口大小变化
window.addEventListener('resize', function() {
    // 防抖处理，避免频繁触发
    clearTimeout(window.resizeTimer);
    window.resizeTimer = setTimeout(function() {
        restoreCampfireState();
    }, 250);
});

// 恢复篝火状态的函数
function restoreCampfireState() {
    const flame = document.getElementById('campfire-flame');
    const hint = document.querySelector('#campsite > div > div:last-child');
    
    if (flame && hint) {
        if (isCampfireExtinguished) {
            flame.style.display = 'none';
            flame.style.opacity = '0';
            hint.textContent = "篝火已熄灭";
            hint.style.color = "#87CEEB";
        } else {
            flame.style.display = 'block';
            flame.style.opacity = '1';
            hint.textContent = "点击熄灭篝火";
            hint.style.color = "#FFD700";
        }
    }
    
    // 更新营地可见性
    updateCampsiteVisibility();
}

// 修改 handleKeyDown 函数，添加键盘导航支持
function handleKeyDown(e) {
  if (e.key === 'Escape') {
    closeAlbum();
    closeBirdingRecord();
  } else if (e.key === 'c' || e.key === 'C') {
    generateBlackWingedKite(false);
  } else if (e.key === 'x' || e.key === 'X') {
    generateComet(false);
  } else if (e.key === 'd' || e.key === 'D') {
    generateGoldcrest(false);
  } else if (e.key === '1') {
    generateTwelveThousandPlover(false);
  } else if (e.key === 'l' || e.key === 'L') {
    generateMeteor(false);
  } else if (e.key === 'u' || e.key === 'U') {
    generateUFO(false);
  } else if (e.key === 'q' || e.key === 'Q') {
    generateMagpie(false);
  } else if (e.key === 'k' || e.key === 'K') {
    generateKingfisher(false);
  } else if (e.key === 'r' || e.key === 'R') {
    createBirdingRecord();
  } else if (e.key === 'v' || e.key === 'V') {
    if (birdingRecords.length > 0) {
      openBirdingRecord(birdingRecords.length - 1);
    }
  } else if (e.key === 'm' || e.key === 'M') {
    toggleBirdingMode();
  } else if (e.key === '0') {
    generateRareBird();
  } else if (e.key === 'p' || e.key === 'P') {
    if (currentBirdingRecord) {
      captureBirdingRecord();
    }
  } else if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
    // 在观鸟记录界面时，左箭头或上箭头切换到上一条记录
    const modal = document.getElementById('birdingRecordModal');
    if (modal.style.display === 'block') {
      e.preventDefault();
      switchBirdingRecord(-1);
    }
  } else if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {
    // 在观鸟记录界面时，右箭头或下箭头切换到下一条记录
    const modal = document.getElementById('birdingRecordModal');
    if (modal.style.display === 'block') {
      e.preventDefault();
      switchBirdingRecord(1);
    }
  }
}

function generateBlackbird(countStats = false) {
    const blackbirdType = BIRD_TYPES.BLACKBIRD;
    if (countStats) {
        appearedBirds[blackbirdType.name]++;
        updateTextStats();
    }
    
    const fromLeft = Math.random() > 0.5;
    const startX = fromLeft ? -50 : GAME_WIDTH + 50;
    const startY = Math.random() * (GAME_HEIGHT * 0.6) + GAME_HEIGHT * 0.2;
    
    const bird = {
        type: blackbirdType,
        name: blackbirdType.name,
        x: startX,
        y: startY,
        size: blackbirdType.size,
        speed: (1 + Math.random()) * 1.5,
        direction: fromLeft ? 1 : -1,
        state: 'flying',
        stateTime: 0,
        whiteEyeRing: false,
        yellowEyeRing: true,
        eatFruits: true,
        eatProbability: 0.12,
        eatDuration: 1600,
        originalSize: 1.3,
        poopInterval: 3000,
        poopProbability: 0.33,
        poopColor: "#FFFFFF",
        lastPoopTime: 0,
        noStats: !countStats,
        isNight: !isDaytime
    };
    
    birds.push(bird);
}

function generateTwelveThousandPlover(countStats = false) {
    const ploverType = BIRD_TYPES.TWELVE_THOUSAND_PLOVER;
    if (countStats) {
        // 不统计
    }
    
    const fromLeft = Math.random() > 0.5;
    const birdCount = getRandomGroupSize(ploverType);
    const groupId = nextGroupId++;
    birdGroupInfo[groupId] = { direction: fromLeft ? 1 : -1, birds: [] };
    
    for (let i = 0; i < birdCount; i++) {
        let startX, startY;
        let behavior = ploverType.behavior;
        let stayTime = ploverType.stayTime || 10;
        
        if (Math.random() < ploverType.landOnReedsChance) {
            behavior = "landOnReeds";
            stayTime = ploverType.landOnReedsTime;
        }
        
        startX = fromLeft ? -50 : GAME_WIDTH + 50;
        startY = Math.random() * (GAME_HEIGHT * 0.6) + GAME_HEIGHT * 0.2;
        
        let baseSpeed = (1.6 + Math.random() * 0.8);
        const speedMultiplier = ploverType.speedMultiplier || 1;
        const finalSpeed = baseSpeed * speedMultiplier;
        
        const bird = createCommonBird(ploverType, startX, startY, fromLeft, behavior, stayTime, finalSpeed, groupId);
        bird.noStats = true;
        bird.yellowEyeRing = true;
        
        if (behavior === "landOnReeds" && reedZone) {
            bird.reedTargetX = reedZone.x + Math.random() * reedZone.width;
            bird.reedTargetY = reedZone.y + reedZone.height - 3;
            bird.state = 'landingOnReeds';
            bird.groundDirection = Math.random() > 0.5 ? 1 : -1;
            bird.isLandingOnReeds = true;
        }
        
        birds.push(bird);
        birdGroupInfo[groupId].birds.push(bird);
    }
}

function generateGoldcrest(countStats = true) {
    const goldcrestType = BIRD_TYPES.GOLDCREST;
    if (countStats) {
        appearedBirds[goldcrestType.name]++;
        updateTextStats();
    }
    
    const targetTree = treePositions[Math.floor(Math.random() * treePositions.length)];
    const x = targetTree.x + targetTree.width * 0.4 + Math.random() * targetTree.width * 0.2;
    const y = targetTree.y + targetTree.height * 0.2 + Math.random() * targetTree.height * 0.3;
    
    const bird = {
        type: goldcrestType,
        name: goldcrestType.name,
        x: x,
        y: y,
        size: goldcrestType.size,
        speed: 0,
        direction: targetTree.side === 'left' ? 1 : -1,
        state: 'perching',
        stateTime: 0,
        stayTime: 5,
        riceBallAppearance: true,
        halfBeakFlying: true,
        halfBeak: true,
        noStats: !countStats,
        isNight: !isDaytime
    };
    
    birds.push(bird);
}

function generateLittleGrebe(countStats = false) {
    const littleGrebeType = BIRD_TYPES.LITTLEGREBE;
    if (countStats) {
        appearedBirds[littleGrebeType.name]++;
        updateTextStats();
    }
    
    const fromLeft = Math.random() > 0.5;
    const birdCount = getRandomGroupSize(littleGrebeType);
    const groupId = nextGroupId++;
    birdGroupInfo[groupId] = { direction: fromLeft ? 1 : -1, birds: [] };
    
    for (let i = 0; i < birdCount; i++) {
        const startX = fromLeft ? -50 : GAME_WIDTH + 50;
        const startY = reedZone.y + reedZone.height * 0.5 + Math.random() * reedZone.height * 0.3;
        
        let baseSpeed = (1.6 + Math.random() * 0.8);
        
        const bird = {
            type: littleGrebeType,
            name: littleGrebeType.name,
            x: startX,
            y: startY,
            size: littleGrebeType.size,
            speed: baseSpeed,
            direction: fromLeft ? 1 : -1,
            state: 'flying',
            stateTime: 0,
            circlingTime: 0,
            hoveringTime: 0,
            circlingRadius: 100 + Math.random() * 50,
            circlingAngle: Math.random() * Math.PI * 2,
            circlingCenterX: 0,
            circlingCenterY: 0,
            actualBehavior: "flyToReedsAndStay",
            stayTime: littleGrebeType.stayTime,
            originalBehavior: littleGrebeType.behavior,
            groupId: groupId,
            targetX: fromLeft ? GAME_WIDTH + 100 : -100,
            reedStayTime: littleGrebeType.reedStayTime || 20000,
            reedMoveSpeed: littleGrebeType.reedMoveSpeed || 0.6,
            reedTargetX: 0,
            reedTargetY: 0,
            whiteEyeRing: false,
            longBlackTail: true,
            fifthBeak: true,
            noStats: !countStats,
            isNight: !isDaytime
        };
        
        birds.push(bird);
        birdGroupInfo[groupId].birds.push(bird);
    }
}

function generateMeteor(countStats = false, summoned = false, intersectionPoint = null) {
    const isNightMode = gameMode === 'night' || (gameMode === 'normal' && !isDaytime);
    if (!isNightMode) {
        return;
    }
    
    const meteorType = NIGHT_OBJECTS.METEOR;
    
    let startX, startY, angle;
    
    if (!summoned) {
        const intersectionX = GAME_WIDTH * 0.5 + (Math.random() - 0.5) * GAME_WIDTH * 0.5;
        const intersectionY = -500 - Math.random() * 500;
        
        startX = intersectionX;
        startY = intersectionY;
        
        const targetX = -100 + Math.random() * (GAME_WIDTH + 200);
        const targetY = -100 + Math.random() * (GAME_HEIGHT * 0.55 + 100);
        angle = Math.atan2(targetY - startY, targetX - startX);
        
        const meteor = {
            type: meteorType,
            name: meteorType.name,
            x: startX,
            y: startY,
            size: meteorType.size,
            speed: meteorType.speed,
            angle: angle,
            state: 'flying',
            createdAt: gameTime,
            duration: meteorType.duration,
            color: meteorType.color,
            trailLength: meteorType.trailLength,
            trailColor: meteorType.trailColor,
            summonProbability: meteorType.summonProbability,
            hasSummoned: false,
            summoned: summoned,
            isNightObject: true,
            intersectionPoint: { x: intersectionX, y: intersectionY },
            targetPoint: { x: targetX, y: targetY }
        };
        
        nightObjects.push(meteor);
        return meteor;
    } else {
        if (!intersectionPoint) {
            intersectionPoint = { x: -1800 + Math.random() * (GAME_WIDTH + 3600), y: -1800 + Math.random() * (GAME_HEIGHT * 0.55 + 1800) };
        }
        
        startX = intersectionPoint.x;
        startY = intersectionPoint.y;
        
        const targetX = -100 + Math.random() * (GAME_WIDTH + 200);
        const targetY = -100 + Math.random() * (GAME_HEIGHT * 0.55 + 100);
        angle = Math.atan2(targetY - startY, targetX - startX);
        
        const meteor = {
            type: meteorType,
            name: meteorType.name,
            x: startX,
            y: startY,
            size: meteorType.size,
            speed: meteorType.speed,
            angle: angle,
            state: 'flying',
            createdAt: gameTime,
            duration: meteorType.duration,
            color: meteorType.color,
            trailLength: meteorType.trailLength,
            trailColor: meteorType.trailColor,
            summonProbability: meteorType.summonProbability,
            hasSummoned: false,
            summoned: summoned,
            isNightObject: true,
            intersectionPoint: intersectionPoint,
            targetPoint: { x: targetX, y: targetY }
        };
        
        nightObjects.push(meteor);
        return meteor;
    }
}

function generateComet(countStats = false) {
    const isNightMode = gameMode === 'night' || (gameMode === 'normal' && !isDaytime);
    if (!isNightMode) {
        return;
    }
    
    const cometType = NIGHT_OBJECTS.COMET;
    const startX = GAME_WIDTH / 2;
    const startY = GAME_HEIGHT * 0.55 - 100;
    
    const comet = {
        type: cometType,
        name: cometType.name,
        x: startX,
        y: startY,
        size: cometType.size * (1/3),
        speed: cometType.speed,
        state: 'flying',
        createdAt: gameTime,
        duration: cometType.duration,
        color: cometType.color,
        tailLength: cometType.tailLength,
        tailColor: cometType.tailColor,
        angle: cometType.angle,
        isNightObject: true
    };
    
    nightObjects.push(comet);
}

function generateUFO(countStats = false) {
    const isNightMode = gameMode === 'night' || (gameMode === 'normal' && !isDaytime);
    if (!isNightMode) {
        return;
    }
    
    const ufoType = NIGHT_OBJECTS.UFO;
    const startX = GAME_WIDTH + 50;
    const startY = Math.random() * (GAME_HEIGHT * 0.5) + GAME_HEIGHT * 0.2;
    
    const ufo = {
        type: ufoType,
        name: ufoType.name,
        x: startX,
        y: startY,
        size: ufoType.size,
        speed: ufoType.speed,
        state: 'flying',
        direction: -1,
        createdAt: gameTime,
        duration: ufoType.duration,
        color: ufoType.color,
        beamLength: ufoType.beamLength,
        beamColor: ufoType.beamColor,
        beamActive: Math.random() > 0.5,
        beamPhase: Math.random() * Math.PI * 2,
        isNightObject: true
    };
    
    nightObjects.push(ufo);
}

function showNightObjectAlert(text) {
    // 实现夜拍物体提示
}

function initTrees() {
    treePositions.push({
        x: 0,
        y: GAME_HEIGHT * 0.3,
        width: GAME_WIDTH * 0.25,
        height: GAME_HEIGHT * 0.7,
        side: 'left',
        fruits: []
    });
    
    const wallWidth = 80;
    const wallMargin = 10;
    const rightTreeWidth = GAME_WIDTH * 0.25;
    
    treePositions.push({
        x: GAME_WIDTH - wallWidth - wallMargin - rightTreeWidth - 20,
        y: GAME_HEIGHT * 0.3,
        width: rightTreeWidth,
        height: GAME_HEIGHT * 0.7,
        side: 'right',
        fruits: []
    });
}

function resizeCanvas() {
    const container = document.getElementById('gameContainer');
    const containerWidth = container.clientWidth;
    const containerHeight = container.clientHeight;
    
    let width = containerWidth;
    let height = containerWidth / ASPECT_RATIO;
    
    if (height > containerHeight) {
        height = containerHeight;
        width = containerHeight * ASPECT_RATIO;
    }
    
    canvas.width = GAME_WIDTH;
    canvas.height = GAME_HEIGHT;
    poopCanvas.width = GAME_WIDTH;
    poopCanvas.height = GAME_HEIGHT;
    
    canvas.style.width = width + 'px';
    canvas.style.height = height + 'px';
    canvas.style.position = 'absolute';
    canvas.style.left = '50%';
    canvas.style.top = '50%';
    canvas.style.transform = 'translate(-50%, -50%)';
    
    poopCanvas.style.width = width + 'px';
    poopCanvas.style.height = height + 'px';
    poopCanvas.style.position = 'absolute';
    poopCanvas.style.left = '50%';
    poopCanvas.style.top = '50%';
    poopCanvas.style.transform = 'translate(-50%, -50%)';
    
    viewfinderBaseWidth = GAME_WIDTH / 15;
    viewfinderBaseHeight = viewfinderBaseWidth * 2/3;
}

function initFruits() {
    fruits = [];
    
    treePositions.forEach((tree, treeIndex) => {
        tree.fruits = [];
        
        const redCount = Math.floor((15 + Math.floor(Math.random() * 10)) / 4);
        const yellowCount = Math.floor((10 + Math.floor(Math.random() * 8)) / 4);
        
        for (let i = 0; i < redCount; i++) {
            const fruit = createFruit(tree, treeIndex, "red");
            fruits.push(fruit);
            tree.fruits.push(fruit);
        }
        
        for (let i = 0; i < yellowCount; i++) {
            const fruit = createFruit(tree, treeIndex, "yellow");
            fruits.push(fruit);
            tree.fruits.push(fruit);
        }
    });
}

function createFruit(tree, treeIndex, color) {
    const treeCrownX = tree.x + tree.width * 0.2;
    const treeCrownY = tree.y + tree.height * 0.2;
    const treeCrownWidth = tree.width * 0.6;
    const treeCrownHeight = tree.height * 0.25;
    
    const fruit = {
        id: fruits.length,
        treeIndex: treeIndex,
        x: treeCrownX + Math.random() * treeCrownWidth,
        y: treeCrownY + Math.random() * treeCrownHeight,
        size: 4,
        color: color,
        originalColor: color,
        isEaten: false,
        eatenBy: null,
        eatStartTime: 0
    };
    
    return fruit;
}

function initReeds() {
    const trunkHeight = GAME_HEIGHT * 0.7 * 0.3;
    const reedHeight = trunkHeight * 2 * 0.8;
    
    const wallWidth = 80;
    const wallMargin = 10;
    const wallSpace = wallWidth + wallMargin;
    
    const leftIndent = 200;
    
    reedZone = {
        x: leftIndent,
        y: GAME_HEIGHT - reedHeight,
        width: GAME_WIDTH - leftIndent - wallSpace,
        height: reedHeight
    };
    
    reedBends = [];
    const reedCount = Math.floor(150 * (reedZone.width / (GAME_WIDTH - wallSpace)));
    
    for (let i = 0; i < reedCount; i++) {
        const reedType = Math.floor(Math.random() * 6);
        reedBends.push({
            bendAmount: (Math.random() - 0.5) * 35,
            bendPointRatio: 0.2 + Math.random() * 0.6,
            topBendAmount: (Math.random() - 0.5) * 40,
            reedType: reedType,
            reedColor: ['#8B4513', '#654321', '#A0522D'][Math.floor(Math.random() * 3)],
            topColor: ['#DAA520', '#B8860B', '#8B7355', '#A0522D'][Math.floor(Math.random() * 4)],
            reedWidth: 0.5 + Math.random() * 1.0
        });
    }
}

function initTextStats() {
    for (const birdName of ALL_BIRDS) {
        capturedBirds[birdName] = 0;
        appearedBirds[birdName] = 0;
    }
    updateTextStats();
}

function updateTextStats() {
    const appearedCount = Object.values(appearedBirds).filter(count => count > 0).length;
    const capturedCount = Object.values(capturedBirds).filter(count => count > 0).length;
    
    document.getElementById('appearedCount').textContent = appearedCount;
    document.getElementById('capturedCount').textContent = capturedCount;
}

function updateAlbumStats() {
    const albumStats = document.getElementById('albumStats');
    albumStats.innerHTML = '';
    
    const capturedBirdNames = Object.keys(capturedBirds).filter(name => capturedBirds[name] > 0);
    
    if (capturedBirdNames.length === 0) {
        albumStats.innerHTML = '<div style="color: white; font-size: 14px;">暂无已拍摄鸟类</div>';
        return;
    }
    
    const recordInfo = document.createElement('div');
    recordInfo.className = 'albumStatItem';
    recordInfo.innerHTML = `
        <span>📝 观鸟记录</span>
        <span class="statCount">${birdingRecords.length}</span>
    `;
    albumStats.appendChild(recordInfo);
    
    if (birdingModeActive) {
        const birdingModeInfo = document.createElement('div');
        birdingModeInfo.className = 'albumStatItem';
        birdingModeInfo.innerHTML = `
            <span>🔍 观鸟模式</span>
            <span class="statCount" style="color: #90EE90;">进行中</span>
        `;
        albumStats.appendChild(birdingModeInfo);
    }
    
    capturedBirdNames.forEach(birdName => {
        let birdType = null;
        for (const key in BIRD_TYPES) {
            if (BIRD_TYPES[key].name === birdName) {
                birdType = BIRD_TYPES[key];
                break;
            }
        }
        
        if (!birdType || birdType.isBat) return;
        
        const statItem = document.createElement('div');
        statItem.className = 'albumStatItem';
        statItem.innerHTML = `
            <span>
                <span class="birdIcon" style="background-color: ${birdType.iconColor || birdType.bodyColor || '#FFFFFF'}"></span>
                ${birdName}
            </span>
            <span class="statCount">${capturedBirds[birdName] || 0}</span>
        `;
        albumStats.appendChild(statItem);
    });
}

function handleMouseClick() {
    if (isTakingPhoto) return;
    
    isTakingPhoto = true;
    
    const viewfinderSize = getViewfinderSize();
    const actualViewfinderWidth = viewfinderSize.width;
    const actualViewfinderHeight = viewfinderSize.height;
    
    // 确保 mouseX 和 mouseY 是基于游戏逻辑坐标的
    // 在陀螺仪模式下，mouseX/Y 已经在 handleDeviceOrientation 中被限制在 0-GAME_WIDTH 之间
    // 在普通模式下，handleMouseMove 也已经做了缩放映射
    
    const viewfinderLeft = mouseX - actualViewfinderWidth / 2;
    const viewfinderTop = mouseY - actualViewfinderHeight / 2;
    const viewfinderRight = viewfinderLeft + actualViewfinderWidth;
    const viewfinderBottom = viewfinderTop + actualViewfinderHeight;
    
    // 确保拍照区域在画布范围内，避免黑边
    // 注意：createPhoto 内部会处理边界剪裁，但如果传入坐标完全在画布外，就会全黑
    // 我们主要保证 mouseX/Y 是正确的逻辑坐标即可
    
    const centerRegionWidth = actualViewfinderWidth * 0.7;
    const centerRegionHeight = actualViewfinderHeight * 0.7;
    const centerRegionLeft = mouseX - centerRegionWidth / 2;
    const centerRegionTop = mouseY - centerRegionHeight / 2;
    const centerRegionRight = centerRegionLeft + centerRegionWidth;
    const centerRegionBottom = centerRegionTop + centerRegionHeight;
    
    let capturedBird = null;
    let capturedNightObject = null;
    let maxSize = 0;
    
    for (const bird of birds) {
        const baseSize = 20;
        const birdSize = baseSize * bird.size;
        let birdDisplayX = bird.x;
        
        const isInCenterRegion = birdDisplayX >= centerRegionLeft && birdDisplayX <= centerRegionRight &&
                                  bird.y >= centerRegionTop && bird.y <= centerRegionBottom;
        
        if (isInCenterRegion) {
            if (birdSize > maxSize) {
                maxSize = birdSize;
                capturedBird = bird;
                capturedNightObject = null;
            }
        }
    }
    
    for (const obj of nightObjects) {
        const baseSize = 20;
        const objSize = baseSize * obj.size;
        
        const isInCenterRegion = obj.x >= centerRegionLeft && obj.x <= centerRegionRight &&
                                  obj.y >= centerRegionTop && obj.y <= centerRegionBottom;
        
        if (isInCenterRegion) {
            if (objSize > maxSize) {
                maxSize = objSize;
                capturedBird = null;
                capturedNightObject = obj;
            }
        }
    }
    
    if (!capturedBird && !capturedNightObject) {
        let fallbackCapturedBird = null;
        let fallbackCapturedNightObject = null;
        let fallbackMaxSize = 0;
        
        for (const bird of birds) {
            const baseSize = 20;
            const birdSize = baseSize * bird.size;
            const birdRadius = birdSize / 2;
            let birdDisplayX = bird.x;
            
            const birdLeft = birdDisplayX - birdRadius;
            const birdRight = birdDisplayX + birdRadius;
            const birdTop = bird.y - birdRadius;
            const birdBottom = bird.y + birdRadius;
            
            const overlapX = birdRight >= viewfinderLeft && birdLeft <= viewfinderRight;
            const overlapY = birdBottom >= viewfinderTop && birdTop <= viewfinderBottom;
            const isInViewfinder = overlapX && overlapY;
            
            if (isInViewfinder) {
                if (birdSize > fallbackMaxSize) {
                    fallbackMaxSize = birdSize;
                    fallbackCapturedBird = bird;
                    fallbackCapturedNightObject = null;
                }
            }
        }
        
        for (const obj of nightObjects) {
            const baseSize = 20;
            const objSize = baseSize * obj.size;
            const objRadius = objSize / 2;
            
            const objLeft = obj.x - objRadius;
            const objRight = obj.x + objRadius;
            const objTop = obj.y - objRadius;
            const objBottom = obj.y + objRadius;
            
            const overlapX = objRight >= viewfinderLeft && objLeft <= viewfinderRight;
            const overlapY = objBottom >= viewfinderTop && objTop <= viewfinderBottom;
            const isInViewfinder = overlapX && overlapY;
            
            if (isInViewfinder) {
                if (objSize > fallbackMaxSize) {
                    fallbackMaxSize = objSize;
                    fallbackCapturedBird = null;
                    fallbackCapturedNightObject = obj;
                }
            }
        }
        
        capturedBird = fallbackCapturedBird;
        capturedNightObject = fallbackCapturedNightObject;
    }
    
    createPhoto(viewfinderLeft, viewfinderTop, actualViewfinderWidth, actualViewfinderHeight, capturedBird, capturedNightObject);
    updateTextStats();
    playCameraSound();
    
    if (capturedBird) {
        showCaptureAlert(`拍摄到${capturedBird.name}！`);
    } else if (capturedNightObject) {
        showCaptureAlert(`拍摄到${capturedNightObject.name}！`);
    }
    
    setTimeout(() => {
        isTakingPhoto = false;
    }, 50);
}

function checkIfAllBirdsCollected() {
    for (const birdName of ALL_BIRDS) {
        if (!capturedBirds[birdName] || capturedBirds[birdName] === 0) {
            return false;
        }
    }
    return true;
}

function showAllBirdsAlert() {
    const allBirdsAlert = document.createElement('div');
    allBirdsAlert.id = 'allBirdsAlert';
    allBirdsAlert.innerHTML = `
        <div style="margin-bottom: 20px; font-size: 28px;">🎉 恭喜！ 🎉</div>
        <div style="margin-bottom: 15px;">您已集齐所有小鸟！</div>
        <div style="margin-bottom: 25px; font-size: 20px;">感谢您的游玩！</div>
        <div style="font-size: 18px; color: #FF6347;">
            这是由小红书号：<br>
            <span style="font-size: 22px; color: #FFD700; text-shadow: 0 0 10px rgba(255, 215, 0, 0.7);">S_Asuka_Langley</span>
            <div style="font-size: 18px; color: #FF6347;"> 制作的<br></div>
        </div>
        <div style="margin-top: 25px; font-size: 16px; color: #87CEEB;">
            (提示：您仍然可以继续拍摄鸟类和夜拍物体)
        </div>
        <button id="closeAllBirdsAlert" style="
            margin-top: 20px;
            background-color: #FFD700;
            color: #000;
            border: none;
            padding: 10px 25px;
            border-radius: 25px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        ">确定</button>
    `;
    
    document.getElementById('gameContainer').appendChild(allBirdsAlert);
    
    document.getElementById('closeAllBirdsAlert').addEventListener('click', function() {
        document.getElementById('gameContainer').removeChild(allBirdsAlert);
    });
    
    setTimeout(() => {
        if (document.getElementById('allBirdsAlert')) {
            document.getElementById('gameContainer').removeChild(allBirdsAlert);
        }
    }, 5000);
}

function createPhoto(x, y, width, height, capturedBird, capturedNightObject) {
  const tempCanvas = document.createElement('canvas');
  tempCanvas.width = width;
  tempCanvas.height = height;
  const tempCtx = tempCanvas.getContext('2d');
    
    let sourceX = Math.max(0, Math.min(x, GAME_WIDTH));
    let sourceY = Math.max(0, Math.min(y, GAME_HEIGHT));
    let drawX = 0;
    let drawY = 0;
    let drawWidth = width;
    let drawHeight = height;
    
    if (x < 0) {
        drawX = -x;
        drawWidth = width + x;
    }
    if (y < 0) {
        drawY = -y;
        drawHeight = height + y;
    }
    if (x + width > GAME_WIDTH) {
        drawWidth = GAME_WIDTH - x;
    }
    if (y + height > GAME_HEIGHT) {
        drawHeight = GAME_HEIGHT - y;
    }
    
    sourceX = Math.max(0, sourceX);
    sourceY = Math.max(0, sourceY);
    drawWidth = Math.max(0, drawWidth);
    drawHeight = Math.max(0, drawHeight);
    
    if (drawWidth > 0 && drawHeight > 0) {
        tempCtx.drawImage(
            canvas,
            sourceX, sourceY, drawWidth, drawHeight,
            drawX, drawY, drawWidth, drawHeight
        );
    }
    
    const goldenFilter = document.getElementById('goldenFilter');
    const filterStyle = window.getComputedStyle(goldenFilter);
    const filterColor = filterStyle.backgroundColor;
    
    // 只在非陀螺仪模式下应用滤镜（陀螺仪模式下保持原色）
    if (!gyroModeActive && filterColor && filterColor !== 'rgba(0, 0, 0, 0)' && filterColor !== 'transparent') {
        tempCtx.fillStyle = filterColor;
        tempCtx.fillRect(0, 0, drawWidth, drawHeight);
    }
    
    const finalCanvas = document.createElement('canvas');
    finalCanvas.width = viewfinderBaseWidth;
    finalCanvas.height = viewfinderBaseHeight;
    const finalCtx = finalCanvas.getContext('2d');
    
    finalCtx.drawImage(tempCanvas, 0, 0, width, height, 0, 0, viewfinderBaseWidth, viewfinderBaseHeight);
    
    finalCtx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
    finalCtx.lineWidth = 2;
    finalCtx.strokeRect(0, 0, viewfinderBaseWidth, viewfinderBaseHeight);
    
    if (capturedBird) {
        if (!capturedBird.type.isSpecial && !capturedBird.isBat && capturedBirds[capturedBird.name] !== undefined && !capturedBird.noStats) {
            capturedBirds[capturedBird.name]++;
        }
        
        const highlightColor = 'rgba(255, 255, 255, 0.1)';
        finalCtx.fillStyle = highlightColor;
        finalCtx.fillRect(0, 0, viewfinderBaseWidth, viewfinderBaseHeight);
        
        finalCtx.fillStyle = '#FFFFFF';
        finalCtx.font = '12px Arial';
        finalCtx.textAlign = 'left';
        finalCtx.fillText(capturedBird.name, 5, viewfinderBaseHeight - 5);
    } else if (capturedNightObject) {
        const highlightColor = 'rgba(173, 216, 230, 0.1)';
        finalCtx.fillStyle = highlightColor;
        finalCtx.fillRect(0, 0, viewfinderBaseWidth, viewfinderBaseHeight);
        
        finalCtx.fillStyle = '#87CEEB';
        finalCtx.font = '12px Arial';
        finalCtx.textAlign = 'left';
        finalCtx.fillText(capturedNightObject.name, 5, viewfinderBaseHeight - 5);
    }
    
  const hasCollectedAllBirds = checkIfAllBirdsCollected();
  if (hasCollectedAllBirds && !hasShownAllBirdsAlert) {
    showAllBirdsAlert();
    hasShownAllBirdsAlert = true;
  }
  
  const photo = {
    id: photos.length,
    x: x,
    y: y,
    width: width,
    height: height,
    lens: currentLens,
    time: gameTime,
    bird: capturedBird ? capturedBird.name : null,
    birdType: capturedBird ? capturedBird.type : null,
    nightObject: capturedNightObject ? capturedNightObject.name : null,
    nightObjectType: capturedNightObject ? capturedNightObject.type : null,
    imageData: finalCanvas.toDataURL('image/png')
  };
  
  photos.push(photo);
  
  // 如果拍摄到鸟，并且处于观鸟模式，记录到本次观鸟的拍摄统计中
  if (capturedBird && !capturedBird.type.isSpecial && !capturedBird.isBat && 
      capturedBirds[capturedBird.name] !== undefined && !capturedBird.noStats) {
    capturedBirds[capturedBird.name]++;
    
    // 记录到本次观鸟的拍摄统计
    if (birdingModeActive && birdingModeCapturedSpecies) {
      birdingModeCapturedSpecies.add(capturedBird.name);
    }
  }
  
  updatePhotoPreview();
}

function updatePhotoPreview() {
    const photoPreview = document.getElementById('photoPreview');
    if (photos.length > 0) {
        const latestPhoto = photos[photos.length - 1];
        photoPreview.innerHTML = `<img src="${latestPhoto.imageData}" alt="照片">`;
    } else {
        photoPreview.innerHTML = '<div class="noPhoto">点击查看相册<br>暂无照片</div>';
    }
}

function showSpecialAlert(text) {
    const alertElement = document.getElementById('specialAlert');
    alertElement.textContent = text;
    alertElement.style.opacity = 1;
    
    if (specialBirdAlertTimeout) {
        clearTimeout(specialBirdAlertTimeout);
    }
    specialBirdAlertTimeout = setTimeout(() => {
        alertElement.style.opacity = 0;
    }, 3000);
}

function showCaptureAlert(text) {
    const captureAlert = document.getElementById('captureAlert');
    captureAlert.textContent = text;
    captureAlert.style.opacity = 1;
    
    if (captureAlertTimeout) {
        clearTimeout(captureAlertTimeout);
    }
    captureAlertTimeout = setTimeout(() => {
        captureAlert.style.opacity = 0;
    }, 3000);
}

function playCameraSound() {
    try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator1 = audioContext.createOscillator();
        const oscillator2 = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator1.connect(gainNode);
        oscillator2.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator1.frequency.value = 800;
        oscillator1.type = 'sine';
        oscillator2.frequency.value = 1200;
        oscillator2.type = 'sine';
        
        const currentTime = audioContext.currentTime;
        gainNode.gain.setValueAtTime(0, currentTime);
        gainNode.gain.linearRampToValueAtTime(0.5, currentTime + 0.01);
        gainNode.gain.exponentialRampToValueAtTime(0.01, currentTime + 0.05);
        gainNode.gain.linearRampToValueAtTime(0, currentTime + 0.1);
        
        oscillator1.start(currentTime);
        oscillator2.start(currentTime);
        oscillator1.stop(currentTime + 0.1);
        oscillator2.stop(currentTime + 0.1);
    } catch (e) {
        console.log("音频上下文不支持，跳过音效");
    }
}

function openAlbum() {
    if (!hasShownAllBirdsAlert && checkIfAllBirdsCollected()) {
        showAllBirdsAlert();
        hasShownAllBirdsAlert = true;
    }
    
    pauseGame();
    
    const albumModal = document.getElementById('albumModal');
    const albumPhotos = document.getElementById('albumPhotos');
    albumPhotos.innerHTML = '';
    
    if (photos.length === 0) {
        albumPhotos.innerHTML = '<div style="color: white; font-size: 18px;">暂无照片，快去拍照吧！</div>';
    } else {
        const photosPerRow = Math.ceil(photos.length / 3);
        
        for (let row = 0; row < 3; row++) {
            const rowStart = row * photosPerRow;
            const rowEnd = Math.min((row + 1) * photosPerRow, photos.length);
            
            if (rowStart < photos.length) {
                for (let i = rowStart; i < rowEnd; i++) {
                    const photo = photos[i];
                    const photoDiv = document.createElement('div');
                    photoDiv.className = 'albumPhoto';
                    
                    const lensText = photo.lens ? ` (${LENS_SETTINGS[photo.lens].name})` : '';
                    
                    photoDiv.innerHTML = `
                        <img src="${photo.imageData}" alt="照片">
                        <div class="photoInfo">${i + 1}${photo.bird ? ` - ${photo.bird}${lensText}` : photo.nightObject ? ` - ${photo.nightObject}${lensText}` : lensText}</div>
                    `;
                    
                    albumPhotos.appendChild(photoDiv);
                }
            }
        }
    }
    
    updateAlbumStats();
    albumModal.style.display = 'flex';
}

function closeAlbum() {
    resumeGame();
    document.getElementById('albumModal').style.display = 'none';
}

function pauseGame() {
    gamePaused = true;
    pausedTimeState.gameTime = gameTime;
    pausedTimeState.dayNightTimer = dayNightTimer;
    pausedTimeState.moonPhaseTimer = moonPhaseTimer;
    pausedTimeState.dayModeTimeState = dayModeTimeState;
    pausedTimeState.nightModeTimeState = nightModeTimeState;
    pausedTimeState.nightModeMoonPhaseTimer = nightModeMoonPhaseTimer;
    pausedTimeState.lastFrameTime = lastFrameTime;
    pausedTimeState.lastBirdTime = lastBirdTime;
    pausedTimeState.lastRareBirdTime = lastRareBirdTime;
    pausedTimeState.lastLittleOwlTime = lastLittleOwlTime;
    pausedTimeState.lastOwlSpawnTime = lastOwlSpawnTime;
    pausedTimeState.lastDoveSummonCheck = lastDoveSummonCheck;
    pausedTimeState.pauseStartTime = performance.now();
    pausedTimeState.pauseDeltaOffset = 0;
}

function resumeGame() {
    if (!gamePaused) return;
    
    gamePaused = false;
    const pauseEndTime = performance.now();
    const pauseDuration = pauseEndTime - pausedTimeState.pauseStartTime;
    
    gameTime = pausedTimeState.gameTime;
    dayNightTimer = pausedTimeState.dayNightTimer;
    moonPhaseTimer = pausedTimeState.moonPhaseTimer;
    dayModeTimeState = pausedTimeState.dayModeTimeState;
    nightModeTimeState = pausedTimeState.nightModeTimeState;
    nightModeMoonPhaseTimer = pausedTimeState.nightModeMoonPhaseTimer;
    lastBirdTime = pausedTimeState.lastBirdTime;
    lastRareBirdTime = pausedTimeState.lastRareBirdTime;
    lastLittleOwlTime = pausedTimeState.lastLittleOwlTime;
    lastOwlSpawnTime = pausedTimeState.lastOwlSpawnTime;
    lastDoveSummonCheck = pausedTimeState.lastDoveSummonCheck;
    
    lastFrameTime = performance.now() - pauseDuration;
    
    updateTimeIndicator();
    requestAnimationFrame(gameLoop);
}

function getRandomGroupSize(birdType) {
    if (Array.isArray(birdType.groupSize)) {
        const [min, max] = birdType.groupSize;
        return min + Math.floor(Math.random() * (max - min + 1));
    } else {
        return birdType.groupSize || 1;
    }
}

function generateBird() {
    if (gamePaused) return;
    
    const now = Date.now();
    // 根据观鸟模式调整生成间隔
    let currentInterval = birdInterval;
    let currentVariation = birdIntervalVariation;
    
    if (birdingModeActive) {
        // 观鸟模式：15~25秒
        currentInterval = 20000;  // 20秒基础
        currentVariation = 5000;  // ±5秒变化
    }
    // 使用实际时间计算间隔
        let actualTimePassed = now - lastBirdTime;
        
        if (actualTimePassed < currentInterval + (Math.random() - 0.5) * currentVariation) {
            return;
        }
    lastBirdTime = now;
    
    const isNightMode = gameMode === 'night' || (gameMode === 'normal' && !isDaytime);
    
    if (isNightMode) {
        const rand = Math.random();
        if (rand < NIGHT_OBJECTS.METEOR.probability) {
            generateMeteor(true);
            return;
        }
        if (rand < NIGHT_OBJECTS.METEOR.probability + NIGHT_OBJECTS.COMET.probability) {
            generateComet(true);
            return;
        }
        if (rand < NIGHT_OBJECTS.METEOR.probability + NIGHT_OBJECTS.COMET.probability + NIGHT_OBJECTS.UFO.probability) {
            generateUFO(true);
            return;
        }
    }
    
    if (isNightMode) {
        let eagleOwlPresent = false;
        let eagleOwlCount = 0;
        for (const bird of birds) {
            if (bird.name === "雕鸮") {
                eagleOwlPresent = true;
                eagleOwlCount++;
                break;
            }
        }
        
        if (eagleOwlPresent) {
            for (const bird of birds) {
                if (bird.name === "短耳鸮" && !bird.isFleeing && bird.state !== 'fleeing') {
                    bird.state = 'fleeing';
                    bird.speed = bird.speed * 3;
                    bird.direction = bird.direction === 1 ? -1 : 1;
                    bird.fleeStartTime = gameTime;
                }
            }
        }
        
        let shortEaredOwlCount = 0;
        for (const bird of birds) {
            if (bird.name === "短耳鸮") {
                shortEaredOwlCount++;
            }
        }
        
        let batCount = 0;
        for (const bird of birds) {
            if (bird.isBat) {
                batCount++;
            }
        }
        
        if (batCount < MAX_BAT_COUNT) {
            const batProbability = (gameMode === 'normal' && !isDaytime) ? 0.10 : 0.20;
            if (Math.random() < batProbability) {
                const batType = BIRD_TYPES.BAT;
                const bat = createBat(batType);
                birds.push(bat);
                return;
            }
        }
        
        const rand = Math.random();
        let cumulativeProbability = 0;
        let selectedBirdType = null;
        
        const nocturnalBirds = {};
        for (const key in BIRD_TYPES) {
            if (BIRD_TYPES[key].isOwl || BIRD_TYPES[key].canAppearAtNight || BIRD_TYPES[key].name === "小鸮") {
                nocturnalBirds[key] = BIRD_TYPES[key];
            }
        }
        
        const adjustedProbabilities = {};
        for (const key in nocturnalBirds) {
            let probability = nocturnalBirds[key].probability;
            
            if (gameMode === 'normal' && !isDaytime) {
                probability = probability * 0.5;
            }
            
            if (nocturnalBirds[key].name === "雕鸮" && eagleOwlCount > 0) {
                probability = 0;
            }
            
            if (nocturnalBirds[key].name === "短耳鸮" && shortEaredOwlCount >= MAX_SHORT_EARED_OWL_COUNT) {
                probability *= 0.1;
            }
            
            if (nocturnalBirds[key].name === "夜鹭" && nocturnalBirds[key].nightProbability !== undefined) {
                probability = nocturnalBirds[key].nightProbability;
                if (gameMode === 'normal' && !isDaytime) {
                    probability = probability * 0.5;
                }
            }
            
            adjustedProbabilities[key] = probability;
        }
        
        let totalAdjustedProbability = 0;
        for (const key in adjustedProbabilities) {
            totalAdjustedProbability += adjustedProbabilities[key];
        }
        
        if (rand > totalAdjustedProbability) {
            return;
        }
        
        let normalizedCumulative = 0;
        for (const key in adjustedProbabilities) {
            const normalizedProbability = adjustedProbabilities[key] / totalAdjustedProbability;
            normalizedCumulative += normalizedProbability;
            if (rand <= normalizedCumulative) {
                selectedBirdType = nocturnalBirds[key];
                break;
            }
        }
        
        if (!selectedBirdType) {
            return;
        }
        
        const goldenFilter = document.getElementById('goldenFilter');
        const filterStyle = window.getComputedStyle(goldenFilter);
        const filterColor = filterStyle.backgroundColor;
        let filterAlpha = 0;
        
        if (filterColor && filterColor !== 'rgba(0, 0, 0, 0)' && filterColor !== 'transparent') {
            const rgbaMatch = filterColor.match(/rgba?\((\d+),\s*(\d+),\s*(\d+),\s*([\d.]+)\)/);
            if (rgbaMatch) {
                filterAlpha = parseFloat(rgbaMatch[4]);
            }
        }
        
        if (filterAlpha > 0.01) {
            const dawnDuskRand = Math.random();
            if (dawnDuskRand < 0.15) {
                const raptorChoice = Math.random();
                if (raptorChoice < 0.1) {
                    generatePeregrine();
                    return;
                } else if (raptorChoice < 0.7) {
                    generateKestrel();
                    return;
                } else {
                    generateBlackWingedKite();
                    return;
                }
            }
        }
        
        appearedBirds[selectedBirdType.name]++;
        updateTextStats();
        
        if (selectedBirdType.isOwl || selectedBirdType.name === "小鸮") {
            const fromLeft = Math.random() > 0.5;
            const birdCount = getRandomGroupSize(selectedBirdType);
            const groupId = nextGroupId++;
            birdGroupInfo[groupId] = { direction: fromLeft ? 1 : -1, birds: [] };
            
            for (let i = 0; i < birdCount; i++) {
                let startX, startY;
                
                if (selectedBirdType.flyInLowerHalf) {
                    startX = GAME_WIDTH * 0.5 + (Math.random() - 0.5) * 200;
                    startY = GAME_HEIGHT * 0.7 + Math.random() * 100;
                } else {
                    startX = GAME_WIDTH * 0.5 + (Math.random() - 0.5) * 200;
                    startY = -50;
                }
                
                let baseSpeed = (1.6 + Math.random() * 0.8);
                const speedMultiplier = selectedBirdType.speedMultiplier || 1;
                const finalSpeed = baseSpeed * speedMultiplier;
                
                const bird = {
                    type: selectedBirdType,
                    name: selectedBirdType.name,
                    x: startX,
                    y: startY,
                    size: selectedBirdType.size,
                    speed: finalSpeed,
                    direction: Math.random() > 0.5 ? 1 : -1,
                    state: 'circling',
                    stateTime: 0,
                    circlingTime: 0,
                    circlingRadius: 150 + Math.random() * 50,
                    circlingAngle: Math.random() * Math.PI * 2,
                    circlingCenterX: selectedBirdType.flyInLowerHalf ? GAME_WIDTH * 0.5 : GAME_WIDTH * 0.5,
                    circlingCenterY: selectedBirdType.flyInLowerHalf ? GAME_HEIGHT * 0.7 : GAME_HEIGHT * 0.3,
                    isOwl: selectedBirdType.isOwl || false,
                    circleTime: selectedBirdType.circleTime || 30000,
                    catchPreyChance: selectedBirdType.catchPreyChance || 0,
                    catchPreyType: selectedBirdType.catchPreyType || null,
                    caughtPrey: null,
                    hasGlided: false,
                    glidingStartY: 0,
                    faceDirection: -1,
                    faceChangeTimer: 0,
                    faceChangeInterval: 10000 + Math.random() * 10000,
                    wingsOpen: true,
                    isFleeing: false,
                    fleeStartTime: 0,
                    isEagleOwl: selectedBirdType.name === "雕鸮",
                    wingOffset: selectedBirdType.wingOffset || 0,
                    isNight: true
                };
                
                birds.push(bird);
                birdGroupInfo[groupId].birds.push(bird);
            }
        } else {
            const fromLeft = Math.random() > 0.5;
            const birdCount = getRandomGroupSize(selectedBirdType);
            const groupId = nextGroupId++;
            birdGroupInfo[groupId] = { direction: fromLeft ? 1 : -1, birds: [] };
            
            for (let i = 0; i < birdCount; i++) {
                let startX, startY;
                let behavior = selectedBirdType.behavior;
                let stayTime = selectedBirdType.stayTime || 10;
                
                startX = fromLeft ? -50 : GAME_WIDTH + 50;
                startY = Math.random() * (GAME_HEIGHT * 0.6) + GAME_HEIGHT * 0.2;
                
                let baseSpeed = (1.6 + Math.random() * 0.8);
                const speedMultiplier = selectedBirdType.speedMultiplier || 1;
                const finalSpeed = baseSpeed * speedMultiplier;
                
                const bird = createCommonBird(selectedBirdType, startX, startY, fromLeft, behavior, stayTime, finalSpeed, groupId);
                bird.isNight = true;
                
                birds.push(bird);
                birdGroupInfo[groupId].birds.push(bird);
            }
        }
        
        return;
    }
    
    if (Math.random() < 0.01) {
        generatePeregrine();
        return;
    }
    
    if (Math.random() < 0.02) {
        generateBlackWingedKite();
        return;
    }
    
  // 翠鸟检查（新增）
  // 只在白天出现，概率为0.023
  if (gameMode !== 'night') {
    const kingfisherChance = Math.random();
    // 使用配置中的概率
    const kingfisherProb = BIRD_TYPES.KINGFISHER.probability || 0.023;
    if (kingfisherChance < kingfisherProb) {
      generateKingfisher(true);
      return;
    }
  }

    const rand = Math.random();
    let cumulativeProbability = 0;
    let selectedBirdType = null;
    
    const availableBirds = {};
    for (const key in BIRD_TYPES) {
        if (key !== "PEREGRINE" && key !== "BLACKWINGEDKITE" && !BIRD_TYPES[key].isSpecial && !BIRD_TYPES[key].isOwl && !BIRD_TYPES[key].isBat) {
            availableBirds[key] = BIRD_TYPES[key];
        }
    }
    
    for (const key in availableBirds) {
        cumulativeProbability += availableBirds[key].probability;
        if (rand <= cumulativeProbability) {
            selectedBirdType = availableBirds[key];
            break;
        }
    }
    
    if (!selectedBirdType) {
        selectedBirdType = BIRD_TYPES.SPARROW;
    }
    
    appearedBirds[selectedBirdType.name]++;
    updateTextStats();
    
    const fromLeft = Math.random() > 0.5;
    const birdCount = getRandomGroupSize(selectedBirdType);
    const groupId = nextGroupId++;
    birdGroupInfo[groupId] = { direction: fromLeft ? 1 : -1, birds: [] };
    
    for (let i = 0; i < birdCount; i++) {
        let startX, startY;
        let behavior = selectedBirdType.behavior;
        let stayTime = selectedBirdType.stayTime || 10;
        
        // 修改：白头鹎有30%概率停留在树上15秒
if (selectedBirdType.name === "白头鹎") {
    if (Math.random() < 0.3) {
        behavior = "landOnTree";
        stayTime = 15;
    }
}

// 修改麻雀行为：30%概率飞向芦苇区并停留，70%概率保持原有行为
if (selectedBirdType.name === "麻雀") {
    if (Math.random() < 0.3) {
        behavior = "flyToReedsAndStay";
    } else {
        behavior = "flyThrough";
    }
}

    // 新鸟类：长尾雀、蜡嘴雀、燕雀、罗宾的树顶部/底部停留行为
    if (selectedBirdType.name === "长尾雀" || selectedBirdType.name === "蜡嘴雀" || selectedBirdType.name === "燕雀") {
      behavior = "landOnTreeTop";
      stayTime = 10;
    } else if (selectedBirdType.name === "罗宾") {
      behavior = "landOnTreeBottom";
      stayTime = 5;
    }
        
        if ((selectedBirdType.name === "金眶鸻" || selectedBirdType.name === "12000鸻") && Math.random() < selectedBirdType.landOnReedsChance) {
                   }
        
        if (selectedBirdType.behavior === 'circleThenHuntBird' || selectedBirdType.behavior === 'circleThenHunt') {
            startX = GAME_WIDTH * 0.5 + (Math.random() - 0.5) * 200;
            startY = -50;
        } else if (selectedBirdType.behavior === 'hunt') {
            startX = fromLeft ? -100 : GAME_WIDTH + 100;
            startY = GAME_HEIGHT * 0.3 + Math.random() * (GAME_HEIGHT * 0.4);
        } else if (selectedBirdType.behavior === 'flyInReedsAndStay') {
            startX = fromLeft ? -50 : GAME_WIDTH + 50;
            startY = reedZone.y + Math.random() * reedZone.height;
        } else {
            startX = fromLeft ? -50 : GAME_WIDTH + 50;
            startY = Math.random() * (GAME_HEIGHT * 0.6) + GAME_HEIGHT * 0.2;
        }
        
        let baseSpeed = (1.6 + Math.random() * 0.8);
        if (selectedBirdType.name === "斑鸠") {
            baseSpeed *= 0.8;
        }
        
        const speedMultiplier = selectedBirdType.speedMultiplier || 1;
        const finalSpeed = baseSpeed * speedMultiplier;
        
        const bird = createCommonBird(selectedBirdType, startX, startY, fromLeft, behavior, stayTime, finalSpeed, groupId);

// 针对新鸟类的特殊设置
    if (selectedBirdType.name === "长尾雀" || selectedBirdType.name === "蜡嘴雀" || selectedBirdType.name === "燕雀" || selectedBirdType.name === "罗宾") {
      bird.isVulnerableToRaptors = true;
    }
        
// 设置吃水果的鸟类
    if (selectedBirdType.name === "蜡嘴雀" || selectedBirdType.name === "燕雀") {
      bird.eatFruits = true;
      bird.eatProbability = 0.1;
      bird.eatDuration = 2000;
      bird.originalSize = selectedBirdType.size;
    }

        if (selectedBirdType.behavior === 'appearOnTree' && bird.targetTree) {
            if (bird.name === "小北" || bird.name === "戴菊" || bird.name === "某种柳莺") {
                bird.x = bird.targetTree.x + bird.targetTree.width * 0.4 + Math.random() * bird.targetTree.width * 0.2;
                bird.y = bird.targetTree.y + bird.targetTree.height * 0.2 + Math.random() * bird.targetTree.height * 0.3;
            } else {
                bird.x = bird.targetTree.x + Math.random() * bird.targetTree.width;
                bird.y = bird.targetTree.y + Math.random() * (bird.targetTree.height * 0.7);
            }
            bird.state = 'perching';
            bird.stateTime = 0;
            bird.speed = 0;
            bird.direction = bird.targetTree.side === 'left' ? 1 : -1;
        }
        
        if (behavior === "landOnReeds" && reedZone) {
            bird.reedTargetX = reedZone.x + Math.random() * reedZone.width;
            bird.reedTargetY = reedZone.y + reedZone.height - 3;
            bird.state = 'landingOnReeds';
            bird.groundDirection = Math.random() > 0.5 ? 1 : -1;
            bird.isLandingOnReeds = true;
        }
        
        birds.push(bird);
        birdGroupInfo[groupId].birds.push(bird);
    }
}

function createCommonBird(birdType, startX, startY, fromLeft, behavior, stayTime, speed, groupId) {
    // 对于麻雀的特殊处理：如果行为是飞向芦苇区，设置初始状态为飞向芦苇区
    if (birdType.name === "麻雀" && behavior === "flyToReedsAndStay") {
        behavior = "flyToReedsAndStay";
    }
    
    const bird = {
        type: birdType,
        name: birdType.name,
        x: startX,
        y: startY,
        size: birdType.size,
        speed: speed,
        direction: fromLeft ? 1 : -1,
        state: 'flying',
        stateTime: 0,
        circlingTime: 0,
        hoveringTime: 0,
        circlingRadius: 100 + Math.random() * 50,
        circlingAngle: Math.random() * Math.PI * 2,
        circlingCenterX: 0,
        circlingCenterY: 0,
        variant: birdType.variant ? Math.random() > 0.5 : false,
        whiteEyeRing: birdType.whiteEyeRing || false,
        brownEyeRing: birdType.brownEyeRing || false,
        yellowEyeRing: birdType.yellowEyeRing || false,
        longBlackTail: birdType.longBlackTail || false,
        longWhiteTail: birdType.longWhiteTail || false,
        longBrownTail: birdType.longBrownTail || false,
        targetTree: (behavior === 'landOnTree' || behavior === 'appearOnTree' || behavior === 'landOnTreeThenMove') ? treePositions[Math.floor(Math.random() * treePositions.length)] : null,
        originalBehavior: birdType.behavior,
        actualBehavior: (birdType.name === "喜鹊" || birdType.name === "乌鸦" || birdType.name === "白头鹎") ? "landOnTree" : behavior,
        stayTime: stayTime,
        hasMovedToSecondTree: false,
        isScared: false,
        isChasing: false,
        originalX: undefined,
        spreadDirection: undefined,
        headOffsetX: 0,
        hasLanded: false,
        groundTime: 0,
        isLandingOnReeds: behavior === "landOnReeds",
        reedTargetX: 0,
        reedTargetY: 0,
        peckingState: 0,
        peckingTimer: 0,
        groundDirection: 0,
        chasingTarget: null,
        isBeingChased: false,
        escapeDirection: 0,
        escapeSpeed: 0,
        isEscaping: false,
        escapeStartTime: 0,
        originalState: '',
        originalSpeed: 0,
        groupId: groupId,
        targetX: fromLeft ? GAME_WIDTH + 100 : -100,
        isEating: false,
        eatingFruit: null,
        eatingTime: 0,
        eatAnimationOffset: 0,
        lastPoopTime: 0,
        isFleeingFromRaptor: false,
        isHidingFromRaptor: false,
        isChasingRaptor: false,
        chasingTarget: null,
        isFleeingFromChasers: false,
        originalState: '',
        originalSpeed: 0,
        fleeFromRaptorStartTime: 0,
        fleeFromChasersStartTime: 0,
        chaseStartTime: 0,
        originalY: 0,
        hasCrest: birdType.hasCrest || false,
        crestColor: birdType.crestColor || null,
        doubleBeak: birdType.doubleBeak || false,
        beakOnePointFive: birdType.beakOnePointFive || false,
        beakOnePointThree: birdType.beakOnePointThree || false,
    beakLengthMultiplier: birdType.beakLengthMultiplier || 1,
    isVulnerableToRaptors: birdType.isVulnerableToRaptors || false,
    hideFromRaptors: birdType.hideFromRaptors || false,
    specialSummon: birdType.specialSummon || null,
    summonInterval: birdType.summonInterval || 0,
    summonProbability: birdType.summonProbability || 0,
    headOffsetY: birdType.headOffsetY || 0,
        fifthBeak: birdType.fifthBeak || false,
        riceBallAppearance: birdType.riceBallAppearance || false,
        halfBeakFlying: birdType.halfBeakFlying || false,
        peckingAction: birdType.peckingAction || false,
        hasHeart: birdType.hasHeart || false,
        groundPecking: birdType.groundPecking || false,
        groundMoveSpeed: birdType.groundMoveSpeed || 0.3,
        landOnReedsChance: birdType.landOnReedsChance || 0,
        landOnReedsTime: birdType.landOnReedsTime || 10,
        stayTimePerTree: birdType.stayTimePerTree || 2000,
        eatFruits: birdType.eatFruits || false,
        eatProbability: birdType.eatProbability || 0,
        eatDuration: birdType.eatDuration || 0,
        originalSize: birdType.originalSize || birdType.size,
        poopInterval: birdType.poopInterval || 0,
        poopProbability: birdType.poopProbability || 0,
        poopColor: birdType.poopColor || null,
        isPredator: birdType.isPredator || false,
        diveSpeedMultiplier: birdType.diveSpeedMultiplier || 1,
        catchDoveChance: birdType.catchDoveChance || 0,
        catchMouseChance: birdType.catchMouseChance || 0,
        leaveChance: birdType.leaveChance || 0,
        scareOtherBirds: birdType.scareOtherBirds || false,
        longBeak: birdType.longBeak || false,
        beakReducedQuarter: birdType.beakReducedQuarter || false,
        halfBeak: birdType.halfBeak || false,
        quarterBeak: birdType.quarterBeak || false,
        huntingBird: birdType.behavior === 'circleThenHuntBird',
        huntingMouse: birdType.behavior === 'circleThenHoverThenHuntMouse',
        faceScreen: birdType.faceScreen || false,
        isNight: false
    };
    
    if (birdType.name === "夜鹭") {
        bird.isNight = false;
    }
    
    if (birdType.behavior === 'circleThenHuntBird' || birdType.behavior === 'circleThenHunt' || birdType.behavior === 'circleThenHoverThenHuntMouse') {
        bird.circlingCenterX = GAME_WIDTH * 0.5;
        bird.circlingCenterY = GAME_HEIGHT * 0.3;
        bird.state = 'circling';
        bird.speed = 1.5;
    }
    
    if (birdType.isKingfisher) {
        bird.state = 'flyingToReed';
        bird.targetX = reedZone.x + Math.random() * reedZone.width;
        bird.targetY = reedZone.y + reedZone.height * 0.7;
        // 重新调整初始Y坐标，避免直接生成在目标位置
        bird.y = reedZone.y + reedZone.height * 0.5 + Math.random() * (GAME_HEIGHT * 0.1);
        bird.headAngle = 0;
        bird.turnInterval = birdType.turnInterval[0] + Math.random() * (birdType.turnInterval[1] - birdType.turnInterval[0]);
        bird.stayTime = birdType.stayTime[0] + Math.random() * (birdType.stayTime[1] - birdType.stayTime[0]);
        bird.nextTurnTime = gameTime + bird.turnInterval;
        bird.facingDirection = bird.direction;
    }
    
    return bird;
}

function generateMagpie(countStats = false) {
    const magpieType = BIRD_TYPES.MAGPIE;
    if (countStats) {
        appearedBirds[magpieType.name]++;
        updateTextStats();
    }
    
    const fromLeft = Math.random() > 0.5;
    const birdCount = getRandomGroupSize(magpieType);
    const groupId = nextGroupId++;
    birdGroupInfo[groupId] = { direction: fromLeft ? 1 : -1, birds: [] };
    
    for (let i = 0; i < birdCount; i++) {
        const startX = fromLeft ? -50 : GAME_WIDTH + 50;
        const startY = Math.random() * (GAME_HEIGHT * 0.6) + GAME_HEIGHT * 0.2;
        
        const bird = createCommonBird(
            magpieType, 
            startX, 
            startY, 
            fromLeft, 
            "landOnTree", 
            magpieType.stayTime, 
            (2 + Math.random()) * 2,
            groupId
        );
        
        bird.whiteEyeRing = true;
        bird.longBlackTail = true;
        bird.eatFruits = true;
        bird.eatProbability = 0.1;
        bird.eatDuration = 2000;
        bird.noStats = !countStats;
        bird.isNight = !isDaytime;
        
        birds.push(bird);
        birdGroupInfo[groupId].birds.push(bird);
    }
}

// 步骤1：修改翠鸟生成函数，调整角度和逻辑
function generateKingfisher(countStats = false) {
  const kingfisherType = BIRD_TYPES.KINGFISHER;
  
  if (countStats) {
    appearedBirds[kingfisherType.name] = (appearedBirds[kingfisherType.name] || 0) + 1;
    updateTextStats();
  }
  
  // 从画面外飞入，直接飞向芦苇丛
  const fromLeft = Math.random() > 0.5;
  const startX = fromLeft ? -50 : GAME_WIDTH + 50;
  
  // 飞向芦苇丛区域
  const targetReedX = reedZone.x + Math.random() * reedZone.width;
  const targetReedY = reedZone.y + reedZone.height * 0.7; // 停在芦苇上
  
  // 设置较低的飞行高度 - 从芦苇区域上方一点飞入
  const startY = reedZone.y + reedZone.height * 0.7 + Math.random() * (GAME_HEIGHT * 0.1);
  
  const bird = {
    type: kingfisherType,
    name: kingfisherType.name,
    x: startX,
    y: startY, // 较低的初始高度
    size: kingfisherType.size,
    speed: 2.0,
    direction: fromLeft ? 1 : -1, // 1=向右，-1=向左
    state: 'flyingToReed',
    stateTime: 0,
    targetX: targetReedX,
    targetY: targetReedY,
    
    // 飞入时水平，headAngle = 0
    headAngle: 0, // 水平
    
    // 初始朝向（看向的方向）
    facingDirection: fromLeft ? 1 : -1, // 1=向右，-1=向左
    
    // 换向相关
    nextTurnTime: 0,
    turnInterval: kingfisherType.turnInterval[0] + 
                  Math.random() * (kingfisherType.turnInterval[1] - kingfisherType.turnInterval[0]),
    
    stayTime: kingfisherType.stayTime[0] + 
              Math.random() * (kingfisherType.stayTime[1] - kingfisherType.stayTime[0]),
    
    diveTargetX: 0,
    diveTargetY: 0,
    hasDived: false,
    hasCaughtFish: false,
    caughtFish: null,
    fishOffsetX: 0,
    fishOffsetY: 0,
    fishAngle: 0,
    beakLengthMultiplier: kingfisherType.beakLengthMultiplier,
    isVulnerableToRaptors: true,
    noStats: !countStats,
    isKingfisher: true,
    
    // 身体是否翻转的标志（用于绘制）
    bodyFlipped: false
  };
  
  // 设置转向时间
  bird.nextTurnTime = gameTime + bird.turnInterval;
  
  birds.push(bird);
  
  if (countStats) {
    showSpecialAlert(`发现${kingfisherType.name}！`);
  }
}

function generateHawfinchManual(countStats = false) {
    const hawfinchType = BIRD_TYPES.HAWFINCH;
    
    if (countStats) {
        appearedBirds[hawfinchType.name] = (appearedBirds[hawfinchType.name] || 0) + 1;
        updateTextStats();
    }
    
    const fromLeft = Math.random() > 0.5;
    const birdCount = getRandomGroupSize(hawfinchType);
    const groupId = nextGroupId++;
    
    birdGroupInfo[groupId] = {
        direction: fromLeft ? 1 : -1,
        birds: []
    };
    
    for (let i = 0; i < birdCount; i++) {
        const startX = fromLeft ? -50 : GAME_WIDTH + 50;
        const startY = Math.random() * (GAME_HEIGHT * 0.6) + GAME_HEIGHT * 0.2;
        
        // 蜡嘴雀的行为通常是停在树上
        let behavior = "landOnTreeTop";
        let stayTime = 15;
        
        // 小概率飞行
        if (Math.random() < 0.2) {
            behavior = "flyThrough";
        }
        
        let baseSpeed = 1.6 + Math.random() * 0.8;
        const speedMultiplier = hawfinchType.speedMultiplier || 1;
        const finalSpeed = baseSpeed * speedMultiplier;
        
        const bird = createCommonBird(
            hawfinchType,
            startX,
            startY,
            fromLeft,
            behavior,
            stayTime,
            finalSpeed,
            groupId
        );
        
        // 设置蜡嘴雀特有属性
        bird.quarterBeak = true;
        bird.beakLengthMultiplier = 0.25;
        bird.isVulnerableToRaptors = true;
        bird.eatFruits = true;
        bird.eatProbability = 0.15;
        bird.eatDuration = 2000;
        bird.originalSize = hawfinchType.size;
        bird.noStats = !countStats;
        bird.isNight = !isDaytime;
        
        if (behavior === "landOnTreeTop") {
            bird.targetTree = treePositions[Math.floor(Math.random() * treePositions.length)];
            bird.x = bird.targetTree.x + Math.random() * bird.targetTree.width;
            bird.y = bird.targetTree.y + bird.targetTree.height * 0.2;
            bird.state = 'perching';
            bird.stateTime = 0;
            bird.speed = 0;
            bird.direction = bird.targetTree.side === 'left' ? 1 : -1;
        }
        
        birds.push(bird);
        birdGroupInfo[groupId].birds.push(bird);
    }
    
    // 显示提示信息
    showSpecialAlert(`生成蜡嘴雀 ${birdCount} 只`);
}

function generateBramblingManual(countStats = false) {
    const bramblingType = BIRD_TYPES.BRAMBLING;
    
    if (countStats) {
        appearedBirds[bramblingType.name] = (appearedBirds[bramblingType.name] || 0) + 1;
        updateTextStats();
    }
    
    const fromLeft = Math.random() > 0.5;
    const birdCount = getRandomGroupSize(bramblingType);
    const groupId = nextGroupId++;
    
    birdGroupInfo[groupId] = {
        direction: fromLeft ? 1 : -1,
        birds: []
    };
    
    for (let i = 0; i < birdCount; i++) {
        const startX = fromLeft ? -50 : GAME_WIDTH + 50;
        const startY = Math.random() * (GAME_HEIGHT * 0.6) + GAME_HEIGHT * 0.2;
        
        // 燕雀的行为可以是飞行或停在树上
        let behavior = "flyThrough";
        let stayTime = 10;
        
        if (Math.random() < 0.3) {
            behavior = "landOnTreeTop";
            stayTime = 10;
        }
        
        let baseSpeed = 1.6 + Math.random() * 0.8;
        const speedMultiplier = bramblingType.speedMultiplier || 1;
        const finalSpeed = baseSpeed * speedMultiplier;
        
        const bird = createCommonBird(
            bramblingType,
            startX,
            startY,
            fromLeft,
            behavior,
            stayTime,
            finalSpeed,
            groupId
        );
        
        // 设置燕雀特有属性
        bird.halfBeak = true;
        bird.isVulnerableToRaptors = true;
        bird.eatFruits = true;
        bird.eatProbability = 0.1;
        bird.eatDuration = 1800;
        bird.originalSize = bramblingType.size;
        bird.noStats = !countStats;
        bird.isNight = !isDaytime;
        
        if (behavior === "landOnTreeTop") {
            bird.targetTree = treePositions[Math.floor(Math.random() * treePositions.length)];
            bird.x = bird.targetTree.x + Math.random() * bird.targetTree.width;
            bird.y = bird.targetTree.y + bird.targetTree.height * 0.2;
            bird.state = 'perching';
            bird.stateTime = 0;
            bird.speed = 0;
            bird.direction = bird.targetTree.side === 'left' ? 1 : -1;
        }
        
        birds.push(bird);
        birdGroupInfo[groupId].birds.push(bird);
    }
    
    // 显示提示信息
    showSpecialAlert(`生成燕雀 ${birdCount} 只`);
}

function generateKestrel(countStats = false) {
    const kestrelType = BIRD_TYPES.KESTREL;
    if (countStats) {
        appearedBirds[kestrelType.name]++;
        updateTextStats();
    }
    
    generateGroundMouseForPredator("红隼");
    scareMode = true;
    scareModeEndTime = gameTime + 3000;
    
    const startX = GAME_WIDTH * 0.5 + (Math.random() - 0.5) * 200;
    const startY = -50;
    
    const bird = {
        type: kestrelType,
        name: kestrelType.name,
        x: startX,
        y: startY,
        size: kestrelType.size,
        speed: 1.5,
        direction: Math.random() > 0.5 ? 1 : -1,
        state: 'circling',
        stateTime: 0,
        circlingTime: 0,
        hoveringTime: 0,
        circlingRadius: 100 + Math.random() * 50,
        circlingAngle: Math.random() * Math.PI * 2,
        circlingCenterX: GAME_WIDTH * 0.5,
        circlingCenterY: GAME_HEIGHT * 0.3,
        hasDecided: false,
        decision: null,
        caughtPrey: null,
        isPredator: true,
        diveSpeed: 3.0,
        noStats: !countStats,
        isFleeingFromChasers: false,
        originalState: '',
        originalSpeed: 1.2,
        fleeFromChasersStartTime: 0,
        chasedStartTime: 0,
        maxChasedTime: 15000,
        whiteEyeRing: kestrelType.whiteEyeRing || false,
        yellowEyeRing: kestrelType.yellowEyeRing || false,
        hasBeenNearCenter: false,
        centerArrivalTime: 0,
        requiredCirclingWhenChasedCount: 1 + Math.floor(Math.random() * 3),
        circlingWhenChasedCount: 0,
        circlingWhenChasedStartTime: 0,
        circlingWhenChasedCenterX: 0,
        circlingWhenChasedCenterY: 0,
        circlingWhenChasedAngle: 0,
        circlingWhenChasedRadius: 300,
        isCirclingWhenChased: false,
        forcedToLeave: false,
        fleeDirection: 0,
        fleeSpeed: 0,
        isNight: !isDaytime,
        caughtMouse: null,
        mouseTarget: null,
        hasGeneratedMouse: true,
        hasFoundMouse: false,
        catchMouseChance: kestrelType.catchMouseChance || 0.5,
        catchDoveChance: kestrelType.catchDoveChance || 0.3,
        leaveChance: kestrelType.leaveChance || 0.2
    };
    
    birds.push(bird);
}

function generatePeregrine(countStats = true) {
    const peregrineType = BIRD_TYPES.PEREGRINE;
    if (countStats) {
        appearedBirds[peregrineType.name]++;
        updateTextStats();
    }
    
    const startX = GAME_WIDTH * 0.5 + (Math.random() - 0.5) * 200;
    const startY = -50;
    
    const bird = {
        type: peregrineType,
        name: peregrineType.name,
        x: startX,
        y: startY,
        size: peregrineType.size,
        speed: 1.5,
        direction: Math.random() > 0.5 ? 1 : -1,
        state: 'circling',
        stateTime: 0,
        circlingTime: 0,
        circlingRadius: 100 + Math.random() * 50,
        circlingAngle: Math.random() * Math.PI * 2,
        circlingCenterX: GAME_WIDTH * 0.5,
        circlingCenterY: GAME_HEIGHT * 0.3,
        huntingBird: true,
        hasLanded: false,
        groundTime: 0,
        isBeingChased: false,
        escapeDirection: 0,
        escapeSpeed: 0,
        isEscaping: false,
        escapeStartTime: 0,
        originalState: '',
        originalSpeed: 1.5,
        noStats: !countStats,
        isFleeingFromChasers: false,
        fleeFromChasersStartTime: 0,
        chasedStartTime: 0,
        maxChasedTime: 10000,
        whiteEyeRing: peregrineType.whiteEyeRing || false,
        yellowEyeRing: peregrineType.yellowEyeRing || false,
        hasBeenNearCenter: false,
        centerArrivalTime: 0,
        requiredCirclingWhenChasedCount: 1 + Math.floor(Math.random() * 3),
        circlingWhenChasedCount: 0,
        circlingWhenChasedStartTime: 0,
        circlingWhenChasedCenterX: 0,
        circlingWhenChasedCenterY: 0,
        circlingWhenChasedAngle: 0,
        circlingWhenChasedRadius: 300,
        isCirclingWhenChased: false,
        forcedToLeave: false,
        fleeDirection: 0,
        fleeSpeed: 0,
        isNight: !isDaytime,
        originalState: 'circling',
        hasTriggeredRaptorLeave: false
    };
    
    birds.push(bird);
}

function generateBlackWingedKite(countStats = true) {
    const kiteType = BIRD_TYPES.BLACKWINGEDKITE;
    if (countStats) {
        appearedBirds[kiteType.name]++;
        updateTextStats();
    }
    
    generateGroundMouseForPredator("黑翅鸢");
    
    const startX = GAME_WIDTH * 0.5 + (Math.random() - 0.5) * 200;
    const startY = -50;
    
    const bird = {
        type: kiteType,
        name: kiteType.name,
        x: startX,
        y: startY,
        size: kiteType.size,
        speed: 1.5,
        direction: Math.random() > 0.5 ? 1 : -1,
        state: 'circling',
        stateTime: 0,
        circlingTime: 0,
        hoveringTime: 0,
        circlingRadius: 100 + Math.random() * 50,
        circlingAngle: Math.random() * Math.PI * 2,
        circlingCenterX: GAME_WIDTH * 0.5,
        circlingCenterY: GAME_HEIGHT * 0.3,
        huntingMouse: true,
        caughtMouse: null,
        mouseRelativeX: 15,
        mouseRelativeY: 10,
        mouseSwingAngle: 0,
        mouseSwingSpeed: 0.05 + Math.random() * 0.05,
        hasLanded: false,
        groundTime: 0,
        isBeingChased: false,
        escapeDirection: 0,
        escapeSpeed: 0,
        isEscaping: false,
        escapeStartTime: 0,
        originalState: '',
        originalSpeed: 1.2,
        mouseTarget: null,
        hasGeneratedMouse: false,
        noStats: !countStats,
        isFleeingFromChasers: false,
        fleeFromChasersStartTime: 0,
        chasedStartTime: 0,
        maxChasedTime: 20000,
        whiteEyeRing: kiteType.whiteEyeRing || false,
        hasBeenNearCenter: false,
        centerArrivalTime: 0,
        requiredCirclingWhenChasedCount: 1 + Math.floor(Math.random() * 3),
        circlingWhenChasedCount: 0,
        circlingWhenChasedStartTime: 0,
        circlingWhenChasedCenterX: 0,
        circlingWhenChasedCenterY: 0,
        circlingWhenChasedAngle: 0,
        circlingWhenChasedRadius: 300,
        isCirclingWhenChased: false,
        forcedToLeave: false,
        fleeDirection: 0,
        fleeSpeed: 0,
        isNight: !isDaytime,
        originalState: 'circling',
        hasTriggeredRaptorLeave: false,
        // 黑翅鸢特有属性
        catchMouseChance: 0.5,
        leaveChance: 0.2
    };
    
    birds.push(bird);
}

function generateKentishPlover(countStats = false) {
    const kentishPloverType = BIRD_TYPES.KENTISH_PLOVER;
    
    if (countStats) {
        appearedBirds[kentishPloverType.name]++;
        updateTextStats();
    }
    
    const fromLeft = Math.random() > 0.5;
    const birdCount = getRandomGroupSize(kentishPloverType);
    const groupId = nextGroupId++;
    
    // ✅ 新增：小组统一决定行为
    let groupBehavior = "flyThrough"; // 默认飞过
    let groupStayTime = kentishPloverType.stayTime || 10;
    
    // 整个小组统一决定是否降落在芦苇上
    if (Math.random() < kentishPloverType.landOnReedsChance) {
        groupBehavior = "landOnReeds";
        groupStayTime = kentishPloverType.landOnReedsTime;
    }
    
    // ✅ 新增：为整个小组选择一个统一的芦苇降落区域
    let groupReedTargetX = 0;
    let groupReedTargetY = 0;
    let groupGroundDirection = Math.random() > 0.5 ? 1 : -1;
    
    if (groupBehavior === "landOnReeds" && reedZone) {
        // 小组降落在芦苇的同一个区域附近
        const baseX = reedZone.x + Math.random() * reedZone.width * 0.7;
        const baseY = reedZone.y + reedZone.height - 3;
        groupReedTargetX = baseX;
        groupReedTargetY = baseY;
    }
    
    birdGroupInfo[groupId] = {
        direction: fromLeft ? 1 : -1,
        birds: [],
        behavior: groupBehavior, // 存储小组行为
        reedTargetX: groupReedTargetX,
        reedTargetY: groupReedTargetY,
        groundDirection: groupGroundDirection
    };
    
    for (let i = 0; i < birdCount; i++) {
        let startX, startY;
        
        // 使用小组统一的行为
        startX = fromLeft ? -50 : GAME_WIDTH + 50;
        startY = Math.random() * (GAME_HEIGHT * 0.6) + GAME_HEIGHT * 0.2;
        
        let baseSpeed = (2.6 + Math.random() * 0.8);
        const speedMultiplier = kentishPloverType.speedMultiplier || 1;
        const finalSpeed = baseSpeed * speedMultiplier;
        
        const bird = createCommonBird(
            kentishPloverType, 
            startX, 
            startY, 
            fromLeft, 
            groupBehavior, // 使用小组统一行为
            groupStayTime,  // 使用小组统一停留时间
            finalSpeed, 
            groupId
        );
        
        bird.noStats = true;
        bird.yellowEyeRing = true;
        bird.groundPecking = true;
        bird.groundMoveSpeed = 0.3;
        
        if (groupBehavior === "landOnReeds" && reedZone) {
            // 每只鸟在小组目标位置附近小范围随机分布
            const spreadX = (Math.random() - 0.5) * 60; // ±30像素范围内
            const spreadY = (Math.random() - 0.5) * 20; // ±10像素范围内
            
            bird.reedTargetX = groupReedTargetX + spreadX;
            bird.reedTargetY = groupReedTargetY + spreadY;
            bird.state = 'landingOnReeds';
            bird.groundDirection = groupGroundDirection; // 使用小组统一方向
            bird.isLandingOnReeds = true;
        }
        
        birds.push(bird);
        birdGroupInfo[groupId].birds.push(bird);
    }
}


function generateLittleOwl(countStats = true) {
    if (littleOwl) return;
    
    let cooldown;
    if (gameMode === 'day') {
        cooldown = LITTLE_OWL_DAY_COOLDOWN;
    } else if (gameMode === 'night') {
        cooldown = LITTLE_OWL_NIGHT_COOLDOWN;
    } else {
        cooldown = isDaytime ? LITTLE_OWL_DAY_COOLDOWN : LITTLE_OWL_NIGHT_COOLDOWN;
    }
    
    if (gameTime - lastLittleOwlTime < cooldown) {
        return;
    }
    
    const littleOwlType = BIRD_TYPES.LITTLE_OWL;
    if (countStats) {
        appearedBirds[littleOwlType.name]++;
        updateTextStats();
    }
    
    const baseSize = 20;
    const birdSize = baseSize * littleOwlType.size;
    const birdRadius = birdSize / 2;
    const holeBottomY = hole.y + hole.diameter / 2;
    const owlY = holeBottomY - birdRadius;
    
    const owl = {
        type: littleOwlType,
        name: littleOwlType.name,
        x: hole.x,
        y: owlY,
        size: littleOwlType.size,
        state: 'appearing',
        stateTime: 0,
        stayTime: littleOwlType.stayTime || 15,
        isBackground: littleOwlType.isBackground || false,
        whiteEyeRing: littleOwlType.whiteEyeRing || false,
        noStats: !countStats,
        isNight: !isDaytime
    };
    
    littleOwl = owl;
    birds.push(owl);
    lastLittleOwlTime = gameTime;
}

function generateGroundMouseForPredator(predatorName) {
    const mouse = {
        x: GAME_WIDTH * 0.3 + Math.random() * (GAME_WIDTH * 0.4),
        y: GAME_HEIGHT - 10,
        size: 8,
        color: "#D3D3D3",
        type: "mouse",
        createdAt: gameTime,
        lifetime: 10000,
        predatorTarget: predatorName
    };
    
    groundObjects.push(mouse);
    return mouse;
}

function generateHedgehog() {
    const hedgehog = {
        x: GAME_WIDTH * 0.3 + Math.random() * (GAME_WIDTH * 0.4),
        y: GAME_HEIGHT - 15,
        size: 12,
        color: "#A0522D",
        type: "hedgehog",
        createdAt: gameTime,
        lifetime: 15000,
        spikes: []
    };
    
    for (let i = 0; i < 24; i++) {
        const angle = (i / 24) * Math.PI * 2;
        const length = 3 + Math.random() * 1.5;
        hedgehog.spikes.push({ angle: angle, length: length });
    }
    
    groundObjects.push(hedgehog);
    return hedgehog;
}

function createBat(batType) {
    const startX = GAME_WIDTH * 0.5 + (Math.random() - 0.5) * 200;
    const startY = -50;
    
    const baseSpeed = (1.5 + Math.random());
    const speedMultiplier = batType.speedMultiplier || 1;
    const finalSpeed = baseSpeed * speedMultiplier;
    
    const circlingCenterY = GAME_HEIGHT * 0.25 + Math.random() * (GAME_HEIGHT * 0.25);
    
    const bat = {
        type: batType,
        name: batType.name,
        x: startX,
        y: startY,
        size: batType.size,
        speed: finalSpeed,
        direction: Math.random() > 0.5 ? 1 : -1,
        state: 'circling',
        stateTime: 0,
        circlingTime: 0,
        circlingRadius: 80 + Math.random() * 40,
        circlingAngle: Math.random() * Math.PI * 2,
        circlingCenterX: GAME_WIDTH * 0.5,
        circlingCenterY: circlingCenterY,
        isBat: true,
        circleTime: batType.circleTime || 15000,
        faceDirection: -1,
        faceChangeTimer: 0,
        faceChangeInterval: 10000 + Math.random() * 10000,
        wingsOpen: true,
        isNight: true,
        wingFlapTimer: 0,
        wingFlapSpeed: 0.1 + Math.random() * 0.05,
        maxConcurrent: batType.maxConcurrent || 3
    };
    
    return bat;
}

function spawnNightOwls() {
    let shortEaredOwlCount = 0;
    let eagleOwlCount = 0;
    
    for (const bird of birds) {
        if (bird.name === "短耳鸮") {
            shortEaredOwlCount++;
        } else if (bird.name === "雕鸮") {
            eagleOwlCount++;
        }
    }
    
    if (eagleOwlCount > 0) {
        if (shortEaredOwlCount >= MAX_SHORT_EARED_OWL_COUNT) {
            return;
        }
        const owlType = BIRD_TYPES.SHORT_EARED_OWL;
        createNightOwl(owlType);
        return;
    }
    
    const owlTypes = ['EAGLE_OWL', 'SHORT_EARED_OWL'];
    let selectedType = owlTypes[Math.floor(Math.random() * owlTypes.length)];
    
    if (selectedType === 'SHORT_EARED_OWL' && shortEaredOwlCount >= MAX_SHORT_EARED_OWL_COUNT) {
        selectedType = 'EAGLE_OWL';
    }
    
    const owlType = BIRD_TYPES[selectedType];
    
    appearedBirds[owlType.name]++;
    updateTextStats();
    
    createNightOwl(owlType);
}

function createNightOwl(owlType) {
    const bird = {
        type: owlType,
        name: owlType.name,
        x: GAME_WIDTH * 0.5 + (Math.random() - 0.5) * 200,
        y: owlType.flyInLowerHalf ? GAME_HEIGHT * 0.7 + Math.random() * 100 : -50,
        size: owlType.size,
        speed: 1.1 * (owlType.speedMultiplier || 1),
        direction: Math.random() > 0.5 ? 1 : -1,
        state: 'circling',
        stateTime: 0,
        circlingTime: 0,
        circlingRadius: 150 + Math.random() * 50,
        circlingAngle: Math.random() * Math.PI * 2,
        circlingCenterX: GAME_WIDTH * 0.5,
        circlingCenterY: owlType.flyInLowerHalf ? GAME_HEIGHT * 0.7 : GAME_HEIGHT * 0.3,
        isOwl: true,
        circleTime: owlType.circleTime || 30000,
        catchPreyChance: owlType.catchPreyChance || 0,
        catchPreyType: owlType.catchPreyType || null,
        caughtPrey: null,
        hasGlided: false,
        glidingStartY: 0,
        faceDirection: -1,
        faceChangeTimer: 0,
        faceChangeInterval: 10000 + Math.random() * 10000,
        wingsOpen: true,
        isFleeing: false,
        fleeStartTime: 0,
        isEagleOwl: owlType.name === "雕鸮",
        wingOffset: owlType.wingOffset || 0,
        isNight: true
    };
    
    if (owlType.name === "雕鸮") {
        for (const otherBird of birds) {
            if (otherBird.isOwl && otherBird.name === "短耳鸮") {
                otherBird.state = 'fleeing';
                otherBird.speed = otherBird.speed * 2;
                otherBird.direction = Math.random() > 0.5 ? 1 : -1;
                otherBird.fleeStartTime = gameTime;
            }
        }
    }
    
    birds.push(bird);
}

function startEatingFruit(bird) {
    let nearestFruit = null;
    let minDistance = Infinity;
    
    for (const fruit of fruits) {
        if (!fruit.isEaten && fruit.treeIndex === treePositions.indexOf(bird.targetTree)) {
            const dx = fruit.x - bird.x;
            const dy = fruit.y - bird.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < 50 && distance < minDistance) {
                minDistance = distance;
                nearestFruit = fruit;
            }
        }
    }
    
    if (nearestFruit) {
        bird.isEating = true;
        bird.eatingFruit = nearestFruit;
        bird.eatingTime = 0;
        bird.eatAnimationOffset = 0;
        
        nearestFruit.isEaten = true;
        nearestFruit.eatenBy = bird.name;
        nearestFruit.eatStartTime = gameTime;
        
        if (nearestFruit.color === "red") {
            nearestFruit.color = "#8B0000";
        } else if (nearestFruit.color === "yellow") {
            nearestFruit.color = "#DAA520";
        }
    }
}

function finishEatingFruit(bird) {
    bird.isEating = false;
    bird.eatingFruit = null;
    bird.eatingTime = 0;
    bird.eatAnimationOffset = 0;
    bird.size = bird.type.originalSize;
}

function drawNightObject(obj) {
    const baseSize = 20;
    const objSize = baseSize * obj.size;
    
    ctx.save();
    
    switch (obj.type.type) {
        case 'meteor':
            ctx.fillStyle = obj.color;
            ctx.beginPath();
            ctx.arc(obj.x, obj.y, objSize, 0, Math.PI * 2);
            ctx.fill();
            
            const trailLength = obj.trailLength;
            const trailX = obj.x - Math.cos(obj.angle) * trailLength;
            const trailY = obj.y - Math.sin(obj.angle) * trailLength;
            
            const gradient = ctx.createLinearGradient(trailX, trailY, obj.x, obj.y);
            gradient.addColorStop(0, 'rgba(255, 255, 200, 0)');
            gradient.addColorStop(0.5, obj.trailColor);
            gradient.addColorStop(1, 'rgba(255, 255, 200, 0)');
            
            ctx.strokeStyle = gradient;
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(trailX, trailY);
            ctx.lineTo(obj.x, obj.y);
            ctx.stroke();
            break;
            
        case 'comet':
            const coreRadius = objSize * (1/3);
            ctx.fillStyle = obj.color;
            ctx.beginPath();
            ctx.arc(obj.x, obj.y, coreRadius, 0, Math.PI * 2);
            ctx.fill();
            
            const tailLength = obj.tailLength * 8;
            const tailX = obj.x - Math.cos(obj.angle) * tailLength;
            const tailY = obj.y - Math.sin(obj.angle) * tailLength;
            const halfTailWidth = tailLength * Math.tan(5 * Math.PI / 180);
            const tailWidth = 2 * halfTailWidth;
            
            const tailGradient = ctx.createRadialGradient(
                obj.x, obj.y, 0,
                tailX, tailY, tailLength * 0.8
            );
            tailGradient.addColorStop(0, "rgba(173, 216, 230, 0.4)");
            tailGradient.addColorStop(0.3, obj.tailColor);
            tailGradient.addColorStop(0.7, "rgba(135, 206, 235, 0.2)");
            tailGradient.addColorStop(1, 'rgba(135, 206, 235, 0)');
            
            ctx.fillStyle = tailGradient;
            ctx.beginPath();
            ctx.moveTo(obj.x, obj.y);
            ctx.lineTo(tailX - halfTailWidth, tailY - tailLength * 0.05);
            ctx.lineTo(tailX + halfTailWidth, tailY + tailLength * 0.05);
            ctx.closePath();
            ctx.fill();
            break;
            
        case 'ufo':
            ctx.fillStyle = obj.color;
            ctx.beginPath();
            ctx.ellipse(obj.x, obj.y, objSize * 1.5, objSize * 0.8, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#32CD32';
            ctx.beginPath();
            ctx.ellipse(obj.x, obj.y - objSize * 0.5, objSize, objSize * 0.5, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#FFFF00';
            for (let i = 0; i < 5; i++) {
                const lightX = obj.x - objSize + i * (objSize / 2);
                ctx.beginPath();
                ctx.arc(lightX, obj.y + objSize * 0.3, 2, 0, Math.PI * 2);
                ctx.fill();
            }
            
            if (obj.beamActive) {
                const beamPulse = Math.sin(gameTime * 0.005 + obj.beamPhase) * 0.3 + 0.7;
                const beamGradient = ctx.createLinearGradient(
                    obj.x, obj.y + objSize,
                    obj.x, obj.y + obj.beamLength
                );
                beamGradient.addColorStop(0, `rgba(144, 238, 144, ${0.5 * beamPulse})`);
                beamGradient.addColorStop(1, 'rgba(144, 238, 144, 0)');
                
                ctx.fillStyle = beamGradient;
                ctx.beginPath();
                ctx.ellipse(obj.x, obj.y + obj.beamLength * 0.5, objSize * 0.8, obj.beamLength * 0.5, 0, 0, Math.PI * 2);
                ctx.fill();
            }
            break;
    }
    
    ctx.restore();
}

function updateNightObjects(deltaTime) {
    if (gamePaused) return;
    
    for (let i = nightObjects.length - 1; i >= 0; i--) {
        const obj = nightObjects[i];
        
        if (gameTime - obj.createdAt > obj.duration) {
            nightObjects.splice(i, 1);
            continue;
        }
        
        if (obj.type.type === 'meteor' && !obj.hasSummoned) {
            if (gameTime - obj.createdAt > 500) {
                if (Math.random() < obj.summonProbability) {
                    generateMeteor(false, true, obj.intersectionPoint);
                }
                obj.hasSummoned = true;
            }
        }
        
        switch (obj.type.type) {
            case 'meteor':
                obj.x += Math.cos(obj.angle) * obj.speed;
                obj.y += Math.sin(obj.angle) * obj.speed;
                
                const dx = obj.x - (obj.targetPoint?.x || 0);
                const dy = obj.y - (obj.targetPoint?.y || 0);
                const distanceToTarget = Math.sqrt(dx * dx + dy * dy);
                
                const isOutOfBounds = obj.x < -2000 || obj.x > GAME_WIDTH + 2000 || obj.y < -2000 || obj.y > GAME_HEIGHT + 2000;
                const isBelowMountain = obj.y >= GAME_HEIGHT * 0.55;
                const isNearTarget = distanceToTarget < 50;
                
                if (isOutOfBounds || isBelowMountain || isNearTarget) {
                    nightObjects.splice(i, 1);
                }
                break;
                
            case 'comet':
                obj.x += Math.cos(obj.angle) * obj.speed;
                obj.y += Math.sin(obj.angle) * obj.speed;
                
                if (obj.y > GAME_HEIGHT + 100) {
                    nightObjects.splice(i, 1);
                }
                break;
                
            case 'ufo':
                obj.x += obj.speed * obj.direction * (deltaTime / 1000);
                obj.y += Math.sin(gameTime * 0.001) * 0.5;
                
                if ((obj.direction === -1 && obj.x < -100) || (obj.direction === 1 && obj.x > GAME_WIDTH + 100)) {
                    nightObjects.splice(i, 1);
                }
                break;
        }
    }
}

function drawBackground() {
    const isNightMode = gameMode === 'night' || (gameMode === 'normal' && !isDaytime);
    
    if (!isNightMode) {
        const gradient = ctx.createLinearGradient(0, 0, 0, GAME_HEIGHT);
        gradient.addColorStop(0, '#87CEEB');
        gradient.addColorStop(1, '#E0F7FF');
        ctx.fillStyle = gradient;
    } else {
        const gradient = ctx.createLinearGradient(0, 0, 0, GAME_HEIGHT);
        gradient.addColorStop(0, '#191970');
        gradient.addColorStop(0.5, '#000033');
        gradient.addColorStop(1, '#000000');
        ctx.fillStyle = gradient;
    }
    
    ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
}

function drawSunMoon() {
    if (gameMode !== 'normal') {
        return;
    }
    
    const archHeight = 350;
    const t = sunMoonPosition;
    
    const archX = GAME_WIDTH * (1 - t);
    const verticalOffset = GAME_HEIGHT / 3;
    const archY = (GAME_HEIGHT - verticalOffset) - (Math.sin(t * Math.PI) * archHeight);
    
    const minY = 50;
    const finalY = Math.max(minY, archY);
    
    sunMoonX = archX;
    sunMoonY = finalY;
    
    const isNightMode = gameMode === 'normal' && !isDaytime;
    
    if (!isNightMode) {
        const sunGradient = ctx.createRadialGradient(
            archX, finalY, 0,
            archX, finalY, 40
        );
        sunGradient.addColorStop(0, '#FFFF00');
        sunGradient.addColorStop(0.7, '#FFD700');
        sunGradient.addColorStop(1, 'rgba(255, 215, 0, 0.3)');
        
        ctx.fillStyle = sunGradient;
        ctx.beginPath();
        ctx.arc(archX, finalY, 40, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = 'rgba(255, 255, 200, 0.2)';
        ctx.beginPath();
        ctx.arc(archX, finalY, 60, 0, Math.PI * 2);
        ctx.fill();
    } else {
        drawMoon(archX, finalY);
    }
}

function drawMoon(x, y) {
    const moonRadius = 30;
    
    ctx.save();
    
    const phase = (moonPhaseTimer / MOON_PHASE_CYCLE) % 1;
    
    let glowIntensity = 0.15;
    if (phase === 0.5) {
        glowIntensity = 0.25;
    } else if (phase < 0.25 || phase > 0.75) {
        glowIntensity = 0.05;
    }
    
    ctx.fillStyle = `rgba(240, 240, 255, ${glowIntensity})`;
    ctx.beginPath();
    ctx.arc(x, y, 50, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = '#F0F0F0';
    ctx.beginPath();
    ctx.arc(x, y, moonRadius, 0, Math.PI * 2);
    ctx.fill();
    
    if (phase > 0 && phase < 0.5) {
        const illumination = 0.5 - phase;
        const gradient = ctx.createRadialGradient(
            x + illumination * moonRadius * 2, y, 0,
            x, y, moonRadius
        );
        
        if (phase < 0.25) {
            gradient.addColorStop(0, 'rgba(0, 0, 51, 0.9)');
            gradient.addColorStop(0.3, 'rgba(0, 0, 51, 0.6)');
            gradient.addColorStop(0.6, 'rgba(0, 0, 51, 0.3)');
            gradient.addColorStop(1, 'rgba(0, 0, 51, 0)');
        } else {
            gradient.addColorStop(0, 'rgba(0, 0, 51, 0.7)');
            gradient.addColorStop(0.5, 'rgba(0, 0, 51, 0.4)');
            gradient.addColorStop(1, 'rgba(0, 0, 51, 0)');
        }
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(x, y, moonRadius, 0, Math.PI * 2);
        ctx.fill();
        
        const edgeGradient = ctx.createRadialGradient(
            x, y, moonRadius - 2,
            x, y, moonRadius + 5
        );
        edgeGradient.addColorStop(0, 'rgba(240, 240, 255, 0.3)');
        edgeGradient.addColorStop(1, 'rgba(240, 240, 255, 0)');
        
        ctx.fillStyle = edgeGradient;
        ctx.beginPath();
        ctx.arc(x, y, moonRadius + 5, 0, Math.PI * 2);
        ctx.fill();
    } else if (phase > 0.5 && phase < 1) {
        const illumination = phase - 0.5;
        const gradient = ctx.createRadialGradient(
            x - illumination * moonRadius * 2, y, 0,
            x, y, moonRadius
        );
        
        if (phase < 0.75) {
            gradient.addColorStop(0, 'rgba(0, 0, 51, 0.9)');
            gradient.addColorStop(0.3, 'rgba(0, 0, 51, 0.6)');
            gradient.addColorStop(0.6, 'rgba(0, 0, 51, 0.3)');
            gradient.addColorStop(1, 'rgba(0, 0, 51, 0)');
        } else {
            gradient.addColorStop(0, 'rgba(0, 0, 51, 0.7)');
            gradient.addColorStop(0.5, 'rgba(0, 0, 51, 0.4)');
            gradient.addColorStop(1, 'rgba(0, 0, 51, 0)');
        }
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(x, y, moonRadius, 0, Math.PI * 2);
        ctx.fill();
        
        const edgeGradient = ctx.createRadialGradient(
            x, y, moonRadius - 2,
            x, y, moonRadius + 5
        );
        edgeGradient.addColorStop(0, 'rgba(240, 240, 255, 0.3)');
        edgeGradient.addColorStop(1, 'rgba(240, 240, 255, 0)');
        
        ctx.fillStyle = edgeGradient;
        ctx.beginPath();
        ctx.arc(x, y, moonRadius + 5, 0, Math.PI * 2);
        ctx.fill();
    } else if (phase === 0 || phase === 1) {
        ctx.fillStyle = 'rgba(0, 0, 51, 0.95)';
        ctx.beginPath();
        ctx.arc(x, y, moonRadius, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = 'rgba(240, 240, 255, 0.05)';
        ctx.beginPath();
        ctx.arc(x, y, moonRadius + 3, 0, Math.PI * 2);
        ctx.fill();
    }
    
    if (phase !== 0 && phase !== 1) {
        let craterBrightness = 0.8;
        if (phase < 0.5) {
            craterBrightness = 0.7 + (phase * 0.6);
        } else {
            craterBrightness = 0.7 + ((1 - phase) * 0.6);
        }
        
        ctx.fillStyle = `rgba(208, 208, 208, ${craterBrightness})`;
        
        if (phase < 0.5) {
            ctx.beginPath();
            ctx.arc(x + 10, y - 5, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + 15, y + 10, 8, 0, Math.PI * 2);
            ctx.fill();
        } else if (phase > 0.5) {
            ctx.beginPath();
            ctx.arc(x - 10, y - 5, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x - 15, y + 10, 8, 0, Math.PI * 2);
            ctx.fill();
        }
        
        if (phase > 0.2 && phase < 0.8) {
            ctx.beginPath();
            ctx.arc(x - 20, y + 15, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + 5, y - 15, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + 8, y + 18, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x - 12, y - 10, 3, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    
    ctx.restore();
}

function drawWallAndHole() {
    if (!wall || !hole) return;
    
    ctx.fillStyle = wall.color;
    ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
    
    ctx.strokeStyle = '#A9A9A9';
    ctx.lineWidth = 2;
    
    for (let i = 0; i < 5; i++) {
        const x = wall.x + (i + 1) * wall.width / 6;
        ctx.beginPath();
        ctx.moveTo(x, wall.y);
        ctx.lineTo(x, wall.y + wall.height);
        ctx.stroke();
    }
    
    for (let i = 0; i < 3; i++) {
        const y = wall.y + (i + 1) * wall.height / 4;
        ctx.beginPath();
        ctx.moveTo(wall.x, y);
        ctx.lineTo(wall.x + wall.width, y);
        ctx.stroke();
    }
    
    ctx.save();
    ctx.beginPath();
    ctx.rect(wall.x, wall.y, wall.width, wall.height);
    ctx.arc(hole.x, hole.y, hole.diameter / 2, 0, Math.PI * 2);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
    
    ctx.strokeStyle = '#5D4037';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(hole.x, hole.y, hole.diameter / 2, 0, Math.PI * 2);
    ctx.stroke();
    
    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
    ctx.beginPath();
    ctx.arc(hole.x, hole.y, hole.diameter / 2 - 2, 0, Math.PI * 2);
    ctx.fill();
}

function drawTrees() {
    treePositions.forEach(tree => {
        ctx.fillStyle = '#2F4F4F';
        ctx.fillRect(tree.x + tree.width * 0.4, tree.y + tree.height * 0.7, tree.width * 0.2, tree.height * 0.3);
        
        ctx.fillStyle = '#2E8B57';
        ctx.beginPath();
        ctx.ellipse(tree.x + tree.width/2, tree.y + tree.height * 0.4, tree.width/2, tree.height * 0.5, 0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#228B22';
        
        fixedLeaves.forEach(leaf => {
            if (leaf.treeIndex === treePositions.indexOf(tree)) {
                ctx.save();
                ctx.translate(leaf.x + leaf.offsetX, leaf.y + leaf.offsetY);
                ctx.rotate(leaf.rotation);
                
                ctx.fillStyle = leaf.color;
                if (leaf.type === 0) {
                    ctx.beginPath();
                    ctx.arc(0, 0, leaf.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.strokeStyle = '#1A6B1A';
                    ctx.lineWidth = 0.5;
                    ctx.beginPath();
                    ctx.moveTo(0, -leaf.size/2);
                    ctx.lineTo(0, leaf.size/2);
                    ctx.stroke();
                } else if (leaf.type === 1) {
                    ctx.beginPath();
                    ctx.ellipse(0, 0, leaf.size, leaf.size/1.5, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.strokeStyle = '#1A6B1A';
                    ctx.lineWidth = 0.5;
                    ctx.beginPath();
                    ctx.moveTo(-leaf.size/2, 0);
                    ctx.lineTo(leaf.size/2, 0);
                    ctx.stroke();
                } else {
                    ctx.beginPath();
                    ctx.moveTo(0, -leaf.size);
                    ctx.lineTo(leaf.size/1.5, 0);
                    ctx.lineTo(0, leaf.size);
                    ctx.lineTo(-leaf.size/1.5, 0);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.strokeStyle = '#1A6B1A';
                    ctx.lineWidth = 0.5;
                    ctx.beginPath();
                    ctx.moveTo(0, -leaf.size);
                    ctx.lineTo(0, leaf.size);
                    ctx.stroke();
                }
                
                ctx.restore();
            }
        });
    });
    
    drawFruits();
}

function drawFruits() {
    fruits.forEach(fruit => {
        if (fruit.isEaten) {
            ctx.globalAlpha = 0.6;
        } else {
            ctx.globalAlpha = 1;
        }
        
        if (fruit.color === "red" || fruit.color === "#8B0000") {
            ctx.fillStyle = fruit.isEaten ? "#8B0000" : "#FF4500";
        } else {
            ctx.fillStyle = fruit.isEaten ? "#DAA520" : "#FFD700";
        }
        
        ctx.beginPath();
        ctx.arc(fruit.x, fruit.y, fruit.size, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.strokeStyle = '#8B4513';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(fruit.x, fruit.y - fruit.size);
        ctx.lineTo(fruit.x, fruit.y - fruit.size - 4);
        ctx.stroke();
        
        ctx.globalAlpha = 1;
        
        if (fruit.isEaten && fruit.eatenBy) {
            const timeSinceEaten = gameTime - fruit.eatStartTime;
            if (timeSinceEaten < 1000) {
                ctx.fillStyle = 'rgba(255, 255, 200, 0.3)';
                ctx.beginPath();
                ctx.arc(fruit.x, fruit.y, fruit.size * 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    });
}

function drawReeds() {
    if (!reedZone) return;
    
    const reedCount = reedBends.length;
    
    for (let i = 0; i < reedCount; i++) {
        const reedX = reedZone.x + (i / reedCount) * reedZone.width;
        
        // 从初始化参数中获取芦苇类型
        const reedBend = reedBends[i] || { 
            bendAmount: 0, 
            bendPointRatio: 0.5, 
            topBendAmount: 0,
            reedType: 0,
            reedColor: '#8B4513',
            topColor: '#DAA520',
            reedWidth: 1.0
        };
        
        const reedType = reedBend.reedType;
        
        // 不同类型的芦苇有不同的高度和弯曲特性
        let reedHeight, reedY;
        
        // 根据类型设置不同的高度
        switch(reedType) {
            case 0: // 普通细芦苇
                reedHeight = reedZone.height * (0.5 + ((i % 10) / 25));
                reedY = reedZone.y + reedZone.height - reedHeight;
                break;
            case 1: // 粗芦苇
                reedHeight = reedZone.height * (0.6 + ((i % 8) / 20));
                reedY = reedZone.y + reedZone.height - reedHeight;
                break;
            case 2: // 细长芦苇
                reedHeight = reedZone.height * (0.7 + ((i % 12) / 30));
                reedY = reedZone.y + reedZone.height - reedHeight;
                break;
            case 3: // 弯曲明显的芦苇
                reedHeight = reedZone.height * (0.4 + ((i % 15) / 35));
                reedY = reedZone.y + reedZone.height - reedHeight;
                break;
            case 4: // 矮芦苇
                reedHeight = reedZone.height * (0.3 + ((i % 6) / 15));
                reedY = reedZone.y + reedZone.height - reedHeight;
                break;
            case 5: // 顶部有弯曲的芦苇
                reedHeight = reedZone.height * (0.5 + ((i % 10) / 22));
                reedY = reedZone.y + reedZone.height - reedHeight;
                break;
            default:
                reedHeight = reedZone.height * (0.5 + ((i % 10) / 20));
                reedY = reedZone.y + reedZone.height - reedHeight;
        }
        
        const bendAmount = reedBend.bendAmount;
        const bendPoint = reedHeight * reedBend.bendPointRatio;
        const topBendAmount = reedBend.topBendAmount;
        
        // 绘制芦苇茎
        ctx.strokeStyle = reedBend.reedColor;
        ctx.lineWidth = reedBend.reedWidth;
        ctx.lineCap = 'round';
        
        ctx.beginPath();
        ctx.moveTo(reedX, reedY + reedHeight);
        ctx.bezierCurveTo(
            reedX + bendAmount * (reedType === 3 ? 1.5 : 1),
            reedY + reedHeight - bendPoint,
            reedX + topBendAmount * (reedType === 5 ? 1.8 : 1),
            reedY + reedHeight * 0.2,
            reedX, reedY
        );
        ctx.stroke();
        
        // 绘制芦苇棒（芦苇顶部）
        let topSize;
        
        // 不同类型芦苇的芦苇棒大小
        switch(reedType) {
            case 1: // 粗芦苇的芦苇棒较大
                topSize = 4 + ((i % 5) / 1.5);
                break;
            case 4: // 矮芦苇的芦苇棒较小
                topSize = 2 + ((i % 5) / 3);
                break;
            default: // 其他芦苇
                topSize = 3 + ((i % 5) / 2);
        }
        
        // 绘制芦苇棒（椭圆形的穗状结构）
        ctx.fillStyle = reedBend.topColor;
        
        // 根据芦苇类型绘制不同形状的芦苇棒
        switch(reedType) {
            case 0: // 普通细芦苇 - 简单的椭圆
                ctx.beginPath();
                ctx.ellipse(reedX, reedY, topSize/2, topSize, 0, 0, Math.PI * 2);
                ctx.fill();
                break;
            case 1: // 粗芦苇 - 较大的椭圆
                ctx.beginPath();
                ctx.ellipse(reedX, reedY, topSize/1.5, topSize*1.2, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // 添加一些纹理
                ctx.fillStyle = '#B8860B';
                for (let j = 0; j < 3; j++) {
                    const angle = (j / 3) * Math.PI * 2;
                    const offsetX = Math.cos(angle) * (topSize/3);
                    const offsetY = Math.sin(angle) * (topSize/1.5);
                    ctx.beginPath();
                    ctx.arc(reedX + offsetX, reedY + offsetY, 1, 0, Math.PI * 2);
                    ctx.fill();
                }
                break;
            case 2: // 细长芦苇 - 细长的椭圆
                ctx.beginPath();
                ctx.ellipse(reedX, reedY, topSize/3, topSize*1.3, 0, 0, Math.PI * 2);
                ctx.fill();
                break;
            case 3: // 弯曲明显的芦苇 - 椭圆形
                ctx.beginPath();
                ctx.ellipse(reedX, reedY, topSize/2, topSize*0.8, 0, 0, Math.PI * 2);
                ctx.fill();
                break;
            case 4: // 矮芦苇 - 小圆形
                ctx.beginPath();
                ctx.arc(reedX, reedY, topSize, 0, Math.PI * 2);
                ctx.fill();
                break;
            case 5: // 顶部有弯曲的芦苇 - 椭圆
                ctx.beginPath();
                ctx.ellipse(reedX, reedY, topSize/2, topSize*0.9, topBendAmount * 0.1, 0, Math.PI * 2);
                ctx.fill();
                break;
            default:
                ctx.beginPath();
                ctx.arc(reedX, reedY, topSize, 0, Math.PI * 2);
                ctx.fill();
        }
        
        // 添加一些细节：芦苇节
        if (reedType !== 4) {
            const jointCount = 2 + (i % 3);
            
            for (let j = 1; j <= jointCount; j++) {
                const jointY = reedY + reedHeight * (j / (jointCount + 1));
                const jointSize = reedBend.reedWidth * 0.7;
                
                ctx.fillStyle = '#654321';
                ctx.beginPath();
                ctx.arc(reedX, jointY, jointSize, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    }
}

function drawMountains() {
    const isNightMode = gameMode === 'night' || (gameMode === 'normal' && !isDaytime);
    
    ctx.fillStyle = !isNightMode ? '#4682B4' : '#2F4F4F';
    ctx.strokeStyle = !isNightMode ? '#FFFFFF' : '#1E1E1E';
    ctx.lineWidth = 4;
    
    ctx.beginPath();
    ctx.moveTo(-50, GAME_HEIGHT * 0.7);
    ctx.lineTo(200, GAME_HEIGHT * 0.5);
    ctx.lineTo(450, GAME_HEIGHT * 0.7);
    ctx.lineTo(-50, GAME_HEIGHT * 0.7);
    ctx.fill();
    ctx.stroke();
    
    ctx.beginPath();
    ctx.moveTo(300, GAME_HEIGHT * 0.75);
    ctx.lineTo(600, GAME_HEIGHT * 0.55);
    ctx.lineTo(900, GAME_HEIGHT * 0.75);
    ctx.lineTo(300, GAME_HEIGHT * 0.75);
    ctx.fill();
    ctx.stroke();
    
    ctx.beginPath();
    ctx.moveTo(700, GAME_HEIGHT * 0.8);
    ctx.lineTo(1000, GAME_HEIGHT * 0.6);
    ctx.lineTo(1300, GAME_HEIGHT * 0.8);
    ctx.lineTo(700, GAME_HEIGHT * 0.8);
    ctx.fill();
    ctx.stroke();
    
    ctx.strokeStyle = !isNightMode ? '#2F4F4F' : '#1E1E1E';
    ctx.lineWidth = 1;
    
    for (let i = 0; i < 5; i++) {
        const x = 50 + i * 80;
        ctx.beginPath();
        ctx.moveTo(x, GAME_HEIGHT * 0.7);
        ctx.lineTo(200, GAME_HEIGHT * 0.5 + i * 10);
        ctx.stroke();
    }
    
    for (let i = 0; i < 5; i++) {
        const x = 400 + i * 80;
        ctx.beginPath();
        ctx.moveTo(x, GAME_HEIGHT * 0.75);
        ctx.lineTo(600, GAME_HEIGHT * 0.55 + i * 10);
        ctx.stroke();
    }
}

function drawClouds() {
    const isNightMode = gameMode === 'night' || (gameMode === 'normal' && !isDaytime);
    if (isNightMode) return;
    
    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
    ctx.beginPath();
    ctx.arc(200, 100, 30, 0, Math.PI * 2);
    ctx.arc(240, 90, 40, 0, Math.PI * 2);
    ctx.arc(280, 100, 30, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.beginPath();
    ctx.arc(600, 150, 25, 0, Math.PI * 2);
    ctx.arc(640, 140, 35, 0, Math.PI * 2);
    ctx.arc(680, 150, 25, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.beginPath();
    ctx.arc(1000, 80, 30, 0, Math.PI * 2);
    ctx.arc(1040, 70, 40, 0, Math.PI * 2);
    ctx.arc(1080, 80, 30, 0, Math.PI * 2);
    ctx.fill();
}

// 初始化固定星星
function initStars() {
    stars = [];
    for (let i = 0; i < STARS_COUNT; i++) {
        stars.push({
            x: Math.random() * GAME_WIDTH,
            y: Math.random() * (GAME_HEIGHT * 0.5),
            size: Math.random() * 2 + 0.5,
            alpha: 0.5 + Math.random() * 0.3, // 随机透明度
            twinkleSpeed: 0.5 + Math.random() * 1.5, // 闪烁速度
            twinkleOffset: Math.random() * Math.PI * 2 // 闪烁偏移
        });
    }
}

// 修改后的drawStars函数
function drawStars() {
    const isNightMode = gameMode === 'night' || (gameMode === 'normal' && !isDaytime);
    if (!isNightMode) return;
    
    stars.forEach(star => {
        // 基于时间的闪烁效果
        const twinkle = 0.6 + 0.4 * Math.sin(gameTime * 0.002 * star.twinkleSpeed + star.twinkleOffset);
        
        // 绘制星星主体
        ctx.fillStyle = `rgba(255, 255, 255, ${star.alpha * twinkle})`;
        ctx.beginPath();
        ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
        ctx.fill();
        
        // 添加微小的光晕效果（可选）
        if (twinkle > 0.8) {
            ctx.fillStyle = `rgba(255, 255, 255, ${0.2 * (twinkle - 0.8)})`;
            ctx.beginPath();
            ctx.arc(star.x, star.y, star.size * 1.5, 0, Math.PI * 2);
            ctx.fill();
        }
    });
}

function drawLittleOwl(bird) {
    const baseSize = 20;
    const birdSize = baseSize * bird.size;
    
    ctx.save();
    
    ctx.fillStyle = "#D2B48C";
    ctx.beginPath();
    ctx.arc(bird.x, bird.y, birdSize/2, 0, Math.PI * 2);
    ctx.fill();
    
    let eyeRingColor = "#FFFFFF";
    let eyeColor = "#000000";
    
    if (bird.isNight) {
        eyeRingColor = "#FFFF99";
        eyeColor = "#FFFF99";
    }
    
    ctx.fillStyle = eyeRingColor;
    ctx.beginPath();
    ctx.arc(bird.x - 8, bird.y - 5, 4.2, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(bird.x + 8, bird.y - 5, 4.2, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = eyeColor;
    ctx.beginPath();
    ctx.arc(bird.x - 8, bird.y - 5, 2.1, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(bird.x + 8, bird.y - 5, 2.1, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = "#8B4513";
    ctx.beginPath();
    ctx.moveTo(bird.x - 3, bird.y + 5);
    ctx.lineTo(bird.x + 3, bird.y + 5);
    ctx.lineTo(bird.x, bird.y + 10);
    ctx.closePath();
    ctx.fill();
    
    ctx.strokeStyle = "#8B4513";
    ctx.lineWidth = 1;
    for (let i = 0; i < 6; i++) {
        const angle = (i * Math.PI * 2) / 6;
        const startX = bird.x + Math.cos(angle) * (birdSize/2 - 5);
        const startY = bird.y + Math.sin(angle) * (birdSize/2 - 5);
        const endX = bird.x + Math.cos(angle) * (birdSize/2 - 2);
        const endY = bird.y + Math.sin(angle) * (birdSize/2 - 2);
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(endX, endY);
        ctx.stroke();
    }
    
    ctx.restore();
}

function drawBat(bird) {
    const baseSize = 20;
    const birdSize = baseSize * bird.size;
    
    ctx.save();
    
    bird.wingFlapTimer += bird.wingFlapSpeed;
    const wingFlapOffset = Math.sin(bird.wingFlapTimer) * 5;
    
    const x = bird.x;
    const y = bird.y;
    
    const bodyWidth = 10;
    const bodyHeight = 6;
    
    ctx.fillStyle = "#333333";
    ctx.beginPath();
    ctx.ellipse(x, y, bodyWidth/2, bodyHeight/2, 0, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = "#333333";
    const headSize = 4;
    ctx.beginPath();
    ctx.moveTo(x + bodyWidth/2, y);
    ctx.lineTo(x + bodyWidth/2 + headSize, y - headSize/2);
    ctx.lineTo(x + bodyWidth/2 + headSize, y + headSize/2);
    ctx.closePath();
    ctx.fill();
    
    ctx.fillStyle = "#000000";
    ctx.beginPath();
    ctx.arc(x + bodyWidth/2 + headSize/2, y - headSize/4, 1, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(x + bodyWidth/2 + headSize/2, y + headSize/4, 1, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = "#666666";
    const wingLength = 15;
    const wingHeight = 8 + wingFlapOffset;
    
    const leftWingX = x - bodyWidth/2 - wingLength;
    const leftWingY = y - wingHeight/2;
    ctx.fillRect(leftWingX, leftWingY, wingLength, wingHeight);
    
    const rightWingX = x + bodyWidth/2;
    const rightWingY = y - wingHeight/2;
    ctx.fillRect(rightWingX, rightWingY, wingLength, wingHeight);
    
    ctx.restore();
}

function drawOwlBird(bird) {
    const baseSize = 20;
    const birdSize = baseSize * bird.size;
    
    ctx.save();
    drawOwlFrontNew(bird);
    
    if (bird.caughtPrey) {
        drawOwlPrey(bird);
    }
    
    ctx.restore();
}

function drawOwlFrontNew(bird) {
  const baseSize = 20;
  const birdSize = baseSize * bird.size;
  let bodyDiameter, headRadius, bodyRadius;
  
  if (bird.name === "雕鸮") {
    headRadius = birdSize * 0.4 * 1.2;
    bodyDiameter = headRadius * 1.1 * 2;
    bodyRadius = bodyDiameter / 2;
  } else if (bird.name === "短耳鸮") {
    // 修改：将短耳鸮的头部增大至与身体一样
    // 先计算身体半径
    bodyRadius = birdSize * 0.4 * 1.3;
    bodyDiameter = bodyRadius * 2;
    // 头部半径与身体半径相同
    headRadius = bodyRadius;
  } else {
    bodyDiameter = birdSize * 0.8 * 1.2;
    headRadius = bodyDiameter / 2 * 0.8 * 1.2;
    bodyRadius = bodyDiameter / 2;
  }
  
  // 计算基础翅膀高度
  let wingHeight = bodyDiameter * 0.25 * 2;
  const wingLength = bodyDiameter * 3 * 0.5;
  
  // 修改：短耳鸮的翅膀高度减少1/5
  if (bird.name === "短耳鸮") {
    wingHeight = wingHeight * 0.8; // 减少1/5，即原来的80%
  }
  
  ctx.save();
  const x = bird.x;
  const y = bird.y;
  
  let bodyCenterX = x;
  let bodyCenterY = y;
  let headCenterX = x;
  let headCenterY;
  
  if (bird.name === "雕鸮") {
    headCenterY = y;
  } else if (bird.name === "短耳鸮") {
    headCenterY = y;
    bodyCenterY = y;
  } else {
    headCenterY = y - bodyRadius * 0.3;
    bodyCenterY = y;
  }
  
  // 绘制身体
  if (bird.name === "雕鸮") {
    ctx.fillStyle = "#666666";
  } else if (bird.name === "短耳鸮") {
    ctx.fillStyle = "#FFFFFF";
  } else {
    ctx.fillStyle = bird.type.bodyColor;
  }
  
  ctx.beginPath();
  ctx.arc(bodyCenterX, bodyCenterY, bodyRadius, 0, Math.PI * 2);
  ctx.fill();
  
  // 绘制翅膀
  ctx.fillStyle = bird.type.wingColor;
  const leftWingX = bodyCenterX - bodyRadius - wingLength;
  const leftWingY = bodyCenterY - bodyRadius + (bird.wingOffset || 0) * bodyDiameter;
  ctx.fillRect(leftWingX, leftWingY, wingLength, wingHeight);
  
  const rightWingX = bodyCenterX + bodyRadius;
  const rightWingY = bodyCenterY - bodyRadius + (bird.wingOffset || 0) * bodyDiameter;
  ctx.fillRect(rightWingX, rightWingY, wingLength, wingHeight);
  
  // 绘制头部
  ctx.fillStyle = bird.type.headColor;
  ctx.beginPath();
  ctx.arc(headCenterX, headCenterY, headRadius, 0, Math.PI * 2);
  ctx.fill();
  
  // 修改：重新计算眼睛半径（基于缩小1/4后的头部半径）
  const originalEyeRadius = headRadius * 0.2 * 1.2;
  const smallEyeRadius = originalEyeRadius * 0.75; // 缩小1/4
  
  const eyeSpacing = headRadius * 0.4;
  const eyeY = headCenterY - headRadius * 0.1;
  
// === 短耳鸮的眼睛和眼周矩形效果（在白色覆盖层之前）===
if (bird.name === "短耳鸮" && bird.type.blackEyeRing) {
  // 修改：使用新的头部半径计算黑色眼环
  const outerRadius = headRadius * 1.15 * 1.2;
  const innerRadius = headRadius * 0.8;
  const headGradient = ctx.createRadialGradient(
    headCenterX, headCenterY, innerRadius * 0.5,
    headCenterX, headCenterY, outerRadius
  );
  // 修改：降低白色渐变的透明度
  headGradient.addColorStop(0, 'rgba(255, 255, 255, 0.60)'); // 降低到60%透明度
  headGradient.addColorStop(0.4, 'rgba(240, 240, 240, 0.50)'); // 降低到50%透明度
  headGradient.addColorStop(0.8, 'rgba(220, 220, 220, 0.40)'); // 降低到40%透明度
  headGradient.addColorStop(1, 'rgba(200, 200, 200, 0.30)'); // 降低到30%透明度
  ctx.fillStyle = headGradient;
  ctx.beginPath();
  ctx.arc(headCenterX, headCenterY, outerRadius, 0, Math.PI * 2);
  ctx.fill();
  
  // 绘制黄色眼睛
  ctx.fillStyle = bird.type.eyeColor; // #FFFF99 黄色
  ctx.beginPath();
  ctx.arc(headCenterX - eyeSpacing, eyeY, smallEyeRadius, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(headCenterX + eyeSpacing, eyeY, smallEyeRadius, 0, Math.PI * 2);
  ctx.fill();
}
  
  // === 雕鸮的眼睛（在白色覆盖层之前）===
  if (bird.name === "雕鸮") {
    // 修改：使用缩小后的眼睛半径
    ctx.fillStyle = bird.type.eyeColor;
    ctx.beginPath();
    ctx.arc(headCenterX - eyeSpacing, eyeY, smallEyeRadius, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(headCenterX + eyeSpacing, eyeY, smallEyeRadius, 0, Math.PI * 2);
    ctx.fill();
  }
  
  // === 喙部（在白色覆盖层之前）===
  ctx.fillStyle = "#8B4513";
  const beakWidth = originalEyeRadius * 1.5; // 使用原始眼睛半径计算喙部大小
  const beakHeight = originalEyeRadius * 1.2; // 使用原始眼睛半径计算喙部大小
  const beakY = headCenterY + originalEyeRadius * 0.5; // 使用原始眼睛半径计算喙部位置
  ctx.beginPath();
  ctx.moveTo(headCenterX - beakWidth/2, beakY);
  ctx.lineTo(headCenterX + beakWidth/2, beakY);
  ctx.lineTo(headCenterX, beakY + beakHeight);
  ctx.closePath();
  ctx.fill();
  
  // 雕鸮的耳簇羽
  if (bird.name === "雕鸮") {
    const earLength = headRadius * 0.8;
    const earWidth = headRadius * 0.3;
    
    ctx.save();
    ctx.translate(headCenterX, headCenterY - headRadius * 0.5);
    ctx.rotate(-Math.PI/4);
    ctx.fillStyle = bird.type.headColor;
    ctx.beginPath();
    ctx.ellipse(0, -earLength/2, earWidth/2, earLength/2, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
    
    ctx.save();
    ctx.translate(headCenterX, headCenterY - headRadius * 0.5);
    ctx.rotate(Math.PI/4);
    ctx.fillStyle = bird.type.headColor;
    ctx.beginPath();
    ctx.ellipse(0, -earLength/2, earWidth/2, earLength/2, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
  
  // === 短耳鸮的眼睛（在白色覆盖层之前）===
  if (bird.name === "短耳鸮") {
    // 修改：使用缩小后的眼睛半径
    ctx.fillStyle = bird.type.eyeColor;
    ctx.beginPath();
    ctx.arc(headCenterX - eyeSpacing, eyeY, smallEyeRadius, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(headCenterX + eyeSpacing, eyeY, smallEyeRadius, 0, Math.PI * 2);
    ctx.fill();
  }
  
  // === 为雕鸮和短耳鸮的正面脸部添加30%透明度的#FCFCFC覆盖层（覆盖头部和翅膀）===
  if (bird.name === "雕鸮" || bird.name === "短耳鸮") {
    // 保存当前绘图状态
    ctx.save();
    
    // 1. 首先绘制翅膀的覆盖层
    ctx.fillStyle = 'rgba(252, 252, 252, 0.3)';
    
    // 左侧翅膀覆盖
    ctx.fillRect(leftWingX, leftWingY, wingLength, wingHeight);
    
    // 右侧翅膀覆盖
    ctx.fillRect(rightWingX, rightWingY, wingLength, wingHeight);
    
    // 2. 然后绘制头部的覆盖层
    const overlayGradient = ctx.createRadialGradient(
      headCenterX, headCenterY, headRadius * 0.5,
      headCenterX, headCenterY, headRadius
    );
    
    if (bird.name === "雕鸮") {
      overlayGradient.addColorStop(0, 'rgba(252, 252, 252, 0.25)');
      overlayGradient.addColorStop(0.7, 'rgba(252, 252, 252, 0.30)');
      overlayGradient.addColorStop(1, 'rgba(252, 252, 252, 0.35)');
    } else {
      overlayGradient.addColorStop(0, 'rgba(252, 252, 252, 0.20)');
      overlayGradient.addColorStop(0.7, 'rgba(252, 252, 252, 0.25)');
      overlayGradient.addColorStop(1, 'rgba(252, 252, 252, 0.30)');
    }
    
    ctx.fillStyle = overlayGradient;
    ctx.beginPath();
    ctx.arc(headCenterX, headCenterY, headRadius, 0, Math.PI * 2);
    ctx.fill();
    
    // 恢复绘图状态
    ctx.restore();
  }
  
  ctx.restore();
}

function drawOwlPrey(bird) {
    if (!bird.caughtPrey) return;
    
    ctx.save();
    const prey = bird.caughtPrey;
    const preyX = bird.x + (bird.direction === 1 ? 30 : -30);
    const preyY = bird.y + 20;
    
    if (prey.type === "mouse") {
        ctx.fillStyle = "#D3D3D3";
        const bodyWidth = 10;
        const bodyHeight = 6;
        ctx.beginPath();
        ctx.ellipse(preyX, preyY, bodyWidth/2, bodyHeight/2, 0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = "#D3D3D3";
        const headSize = 4;
        ctx.beginPath();
        ctx.moveTo(preyX + bodyWidth/2, preyY);
        ctx.lineTo(preyX + bodyWidth/2 + headSize, preyY - headSize/2);
        ctx.lineTo(preyX + bodyWidth/2 + headSize, preyY + headSize/2);
        ctx.closePath();
        ctx.fill();
        
        ctx.fillStyle = "#000000";
        ctx.beginPath();
        ctx.arc(preyX + bodyWidth/2 + headSize/2, preyY - headSize/4, 1, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(preyX + bodyWidth/2 + headSize/2, preyY + headSize/4, 1, 0, Math.PI * 2);
        ctx.fill();
    } else if (prey.type === "hedgehog") {
        ctx.fillStyle = "#A0522D";
        const bodySize = 8;
        ctx.beginPath();
        ctx.arc(preyX, preyY, bodySize, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = "#A0522D";
        ctx.beginPath();
        ctx.moveTo(preyX + bodySize, preyY);
        ctx.lineTo(preyX + bodySize * 1.5, preyY - bodySize * 0.5);
        ctx.lineTo(preyX + bodySize * 1.5, preyY + bodySize * 0.5);
        ctx.closePath();
        ctx.fill();
        
        ctx.strokeStyle = "#8B4513";
        ctx.lineWidth = 2;
        ctx.lineCap = "round";
        for (let i = 0; i < 24; i++) {
            const angle = (i / 24) * Math.PI * 2;
            const length = 3 + Math.random() * 1.5;
            const startX = preyX + Math.cos(angle) * bodySize;
            const startY = preyY + Math.sin(angle) * bodySize;
            const endX = preyX + Math.cos(angle) * (bodySize + length);
            const endY = preyY + Math.sin(angle) * (bodySize + length);
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.stroke();
        }
        
        ctx.fillStyle = "#000000";
        ctx.beginPath();
        ctx.arc(preyX + bodySize * 1.2, preyY - bodySize * 0.2, 1, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = "#000000";
        ctx.beginPath();
        ctx.arc(preyX + bodySize * 1.5, preyY, 0.8, 0, Math.PI * 2);
        ctx.fill();
    }
    
    ctx.restore();
}

function drawOwl(bird) {
  const baseSize = 20;
  const birdSize = baseSize * bird.size;
  ctx.save();
  
  // 根据是否是夜间选择眼睛颜色
  let eyeColor = bird.isNight ? "#FFFF99" : "#FFA500"; // 夜间亮黄色，日间橙黄色
  
  ctx.fillStyle = "#8B4513";
  ctx.beginPath();
  ctx.arc(bird.x, bird.y, birdSize/2, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.fillStyle = eyeColor;
  ctx.beginPath();
  ctx.arc(bird.x - 8, bird.y - 5, 4, 0, Math.PI * 2);
  ctx.arc(bird.x + 8, bird.y - 5, 4, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.fillStyle = "#FFFF00";
  ctx.beginPath();
  ctx.moveTo(bird.x - 3, bird.y + 5);
  ctx.lineTo(bird.x + 3, bird.y + 5);
  ctx.lineTo(bird.x, bird.y + 10);
  ctx.closePath();
  ctx.fill();
  
  ctx.fillStyle = "#8B4513";
  ctx.beginPath();
  ctx.moveTo(bird.x - 8, bird.y - birdSize/2 - 16);
  ctx.lineTo(bird.x - 12, bird.y - birdSize/2 + 20 - 16);
  ctx.lineTo(bird.x - 4, bird.y - birdSize/2 + 15 - 16);
  ctx.closePath();
  ctx.fill();
  
  ctx.beginPath();
  ctx.moveTo(bird.x + 8, bird.y - birdSize/2 - 16);
  ctx.lineTo(bird.x + 12, bird.y - birdSize/2 + 20 - 16);
  ctx.lineTo(bird.x + 4, bird.y - birdSize/2 + 15 - 16);
  ctx.closePath();
  ctx.fill();
  
  ctx.restore();
}

function drawBird(bird) {
    ctx.save();
    
    // ✅ 统一处理向左飞行的镜像
    if (bird.direction === -1 && bird.state !== 'perching') {
        ctx.translate(bird.x * 2, 0);
        ctx.scale(-1, 1);
    }
  // 检查是否为翠鸟
  if (bird.isKingfisher) {
    drawKingfisher(bird);
        ctx.restore();
    return;
  }
    if (bird.name === "小鸮") {
        drawLittleOwl(bird);
        ctx.restore();
        return;
    }
    
    if (bird.isBat) {
        drawBat(bird);
        ctx.restore();
        return;
    }
    
    if (bird.isOwl) {
        drawOwlBird(bird);
        ctx.restore();
        return;
    }
    
    if ((bird.name === "啄木鸟" || bird.name === "夜鹭") && bird.state === 'perching') {
        drawPerchingWoodpeckerOrHeron(bird);
        ctx.restore();
        return;
    }
    
    if (bird.name === "戴菊" && bird.state === 'perching' && bird.riceBallAppearance) {
        drawRiceBallBird(bird);
        ctx.restore();
        return;
    }
    
// 新增：长尾雀、蜡嘴雀、燕雀、罗宾的特殊绘制
  if (bird.name === "长尾雀") {
    drawLongtailedFinch(bird);
    ctx.restore();
    return;
  } else if (bird.name === "蜡嘴雀") {
    drawHawfinch(bird);
    ctx.restore();
    return;
  } else if (bird.name === "燕雀") {
    drawBrambling(bird);
    ctx.restore();
    return;
  } else if (bird.name === "罗宾") {
    drawRobin(bird);
    ctx.restore();
    return;
  }

    if ((bird.name === "红隼" || bird.name === "黑翅鸢") && bird.caughtMouse) {
        drawMouseInClaws(bird);
    }
    
    if (bird.name === "长耳鸮" && bird.faceScreen) {
        drawOwl(bird);
        ctx.restore();
        return;
    }
    
    const baseSize = 20;
    let birdSize = baseSize * bird.size;
    const headSize = birdSize * 0.5;
    const bodySize = birdSize;
    
    ctx.save();
    
    let headOffsetY = 0;
    if (bird.isEating && bird.eatAnimationOffset) {
        headOffsetY = bird.eatAnimationOffset;
    }
    
    // Internal flip removed (handled globally)
    
    let bodyColor = bird.type.bodyColor;
    let headColor = bird.type.headColor;
    let wingColor = bird.type.wingColor;
    let tailColor = bird.type.tailColor;
    
    if (bird.name === "夜鹭" && bird.isNight) {
        bodyColor = bird.nightBodyColor || "#808080";
        headColor = bird.nightBodyColor || "#808080";
        wingColor = bird.nightWingColor || "#4682B4";
        tailColor = bird.nightBodyColor || "#808080";
    } else if (bird.name !== "绿头鸭") {
        if (bodyColor === "#00AA00") bodyColor = "#90EE90";
        if (headColor === "#00AA00") headColor = "#90EE90";
        if (wingColor === "#00AA00") wingColor = "#90EE90";
        if (tailColor === "#00AA00") tailColor = "#90EE90";
    }
    
    if (bird.type.variant && bird.variant !== undefined) {
        if (bird.name === "绿头鸭") {
            if (bird.variant) {
                bodyColor = "#8B4513";
                headColor = "#8B4513";
                wingColor = "#8B4513";
            } else {
                bodyColor = "#FFFFFF";
                headColor = "#00AA00";
                wingColor = "#FF0000";
            }
        } else if (bird.name === "山椒鸟") {
            bodyColor = bird.variant ? "#FFFF00" : "#FF0000";
        }
    }
    
    ctx.fillStyle = bodyColor;
    ctx.beginPath();
    ctx.arc(bird.x, bird.y, bodySize/2, 0, Math.PI * 2);
    ctx.fill();
    
    if (bird.name === "白鹡鸰" && bird.hasHeart) {
        const heartX = bird.x;
        const heartY = bird.y - birdSize/6;
        const heartSize = 5;
        
        ctx.fillStyle = "#000000";
        ctx.save();
        ctx.translate(heartX, heartY);
        ctx.scale(1, 0.8);
        ctx.beginPath();
        ctx.moveTo(0, -heartSize/2);
        ctx.bezierCurveTo(
            heartSize/2, -heartSize/2,
            heartSize/2, heartSize/2,
            0, heartSize/2
        );
        ctx.bezierCurveTo(
            -heartSize/2, heartSize/2,
            -heartSize/2, -heartSize/2,
            0, -heartSize/2
        );
        ctx.fill();
        ctx.restore();
    }
    
    ctx.fillStyle = headColor || '#000000';
    ctx.beginPath();
    ctx.arc(
        bird.x + bodySize/2 - headSize/2,
        bird.y - bodySize/2 + headSize/2 + headOffsetY,
        headSize/2, 0, Math.PI * 2
    );
    ctx.fill();
    
    ctx.fillStyle = bird.type.color || '#000000';
    ctx.beginPath();
    
    const beakStartX = bird.x + bodySize/2 - headSize/2 + headSize/2;
    const beakStartY = bird.y - bodySize/2 + headSize/2 + headOffsetY;
    
    let beakLength = 8;
    let beakHeight = 5;
    
    if (bird.isEating) {
        beakHeight = 6;
        beakLength = 9;
    }
    
    if (bird.name === "小北" && bird.fifthBeak) {
        beakLength = 1.6;
        beakHeight = 1;
        ctx.moveTo(beakStartX, beakStartY);
        ctx.lineTo(beakStartX + beakLength, beakStartY);
        ctx.lineTo(beakStartX, beakStartY + beakHeight);
    } else if (bird.name === "绿头鸭" && bird.doubleBeak) {
        if (bird.beakOnePointFive) {
            beakLength = 8 * 1.5;
        } else {
            beakLength = 16;
        }
        beakHeight = 4;
        ctx.fillRect(beakStartX, beakStartY - beakHeight/2, beakLength, beakHeight);
    } else if (bird.name === "赤麻鸭" && bird.beakOnePointThree) {
        beakLength = 8 * 1.3;
        beakHeight = 4;
        ctx.fillRect(beakStartX, beakStartY - beakHeight/2, beakLength, beakHeight);
    } else if (bird.name === "麻雀") {
        beakLength = 4;
        beakHeight = 3;
        ctx.moveTo(beakStartX, beakStartY);
        ctx.lineTo(beakStartX + beakLength, beakStartY);
        ctx.lineTo(beakStartX, beakStartY + beakHeight);
    } else if (bird.name === "夜鹭") {
        beakLength = 24;
        beakHeight = 6;
        ctx.moveTo(beakStartX, beakStartY);
        ctx.lineTo(beakStartX + beakLength, beakStartY);
        ctx.lineTo(beakStartX, beakStartY + beakHeight);
    } else if (bird.name === "啄木鸟" && bird.doubleBeak) {
        beakLength = 8;
        beakHeight = 5;
        ctx.moveTo(beakStartX, beakStartY);
        ctx.lineTo(beakStartX + beakLength, beakStartY);
        ctx.lineTo(beakStartX, beakStartY + beakHeight);
    } else if (bird.name === "戴胜" && bird.beakOnePointFive) {
        beakLength = 8 * 1.5;
        beakHeight = 5;
        ctx.moveTo(beakStartX, beakStartY);
        ctx.lineTo(beakStartX + beakLength, beakStartY);
        ctx.lineTo(beakStartX, beakStartY + beakHeight);
    } else if (bird.name === "戴菊" && bird.state !== 'perching' && bird.halfBeakFlying) {
        beakLength = 4 * 0.5;
        beakHeight = 3;
        ctx.moveTo(beakStartX, beakStartY);
        ctx.lineTo(beakStartX + beakLength, beakStartY);
        ctx.lineTo(beakStartX, beakStartY + beakHeight);
    } else if (bird.name === "山雀" && bird.halfBeak) {
        beakLength = 4;
        beakHeight = 3;
        ctx.moveTo(beakStartX, beakStartY);
        ctx.lineTo(beakStartX + beakLength, beakStartY);
        ctx.lineTo(beakStartX, beakStartY + beakHeight);
    } else if (bird.name === "棕头鸦雀" && bird.quarterBeak) {
        beakLength = 2;
        beakHeight = 2;
        ctx.moveTo(beakStartX, beakStartY);
        ctx.lineTo(beakStartX + beakLength, beakStartY);
        ctx.lineTo(beakStartX, beakStartY + beakHeight);
    } else if (bird.name === "某种柳莺" && bird.halfBeak) {
        beakLength = 4;
        beakHeight = 3;
        ctx.moveTo(beakStartX, beakStartY);
        ctx.lineTo(beakStartX + beakLength, beakStartY);
        ctx.lineTo(beakStartX, beakStartY + beakHeight);
    } else if ((bird.name === "金眶鸻" || bird.name === "12000鸻") && bird.beakOnePointFive) {
        beakLength = 6 * 1.5;
        beakHeight = 3;
        ctx.moveTo(beakStartX, beakStartY);
        ctx.lineTo(beakStartX + beakLength, beakStartY);
        ctx.lineTo(beakStartX, beakStartY + beakHeight);
    } else if (bird.name === "金翅雀" && bird.halfBeak) {
        beakLength = 4;
        beakHeight = 3;
        ctx.moveTo(beakStartX, beakStartY);
        ctx.lineTo(beakStartX + beakLength, beakStartY);
        ctx.lineTo(beakStartX, beakStartY + beakHeight);
    } else {
        ctx.moveTo(beakStartX, beakStartY);
        ctx.lineTo(beakStartX + beakLength, beakStartY);
        ctx.lineTo(beakStartX, beakStartY + beakHeight);
    }
    
    if (!((bird.name === "绿头鸭" && bird.doubleBeak) || (bird.name === "赤麻鸭" && bird.beakOnePointThree))) {
        ctx.closePath();
        ctx.fill();
    }
    
    const eyeColor = bird.type.eyeColor || '#000000';
    const eyeX = bird.x + bodySize/2 - headSize/2 + headSize/4;
    const eyeY = bird.y - bodySize/2 + headSize/3 + headOffsetY;
    
    if (bird.yellowEyeRing) {
        ctx.fillStyle = '#FFFF00';
        ctx.beginPath();
        ctx.arc(eyeX, eyeY, 4, 0, Math.PI * 2);
        ctx.fill();
    } else if (bird.whiteEyeRing) {
        ctx.fillStyle = '#FFFFFF';
        ctx.beginPath();
        ctx.arc(eyeX, eyeY, 3, 0, Math.PI * 2);
        ctx.fill();
    }
    
    if (bird.name === "斑鸠" && bird.brownEyeRing) {
        ctx.fillStyle = '#8B4513';
        ctx.beginPath();
        ctx.arc(eyeX, eyeY, 4, 0, Math.PI * 2);
        ctx.fill();
    }
    
    if (bird.name === "小北") {
        ctx.fillStyle = eyeColor;
        ctx.beginPath();
        ctx.arc(eyeX, eyeY, 1, 0, Math.PI * 2);
        ctx.fill();
    } else {
        ctx.fillStyle = eyeColor;
        ctx.beginPath();
        ctx.arc(eyeX, eyeY, 2, 0, Math.PI * 2);
        ctx.fill();
    }
    
    ctx.fillStyle = wingColor || '#000000';
    ctx.fillRect(
        bird.x - bodySize/4 - headSize/2,
        bird.y - bodySize/2,
        bodySize/2,
        bodySize/3
    );
    
    if (bird.name === "喜鹊" && bird.longBlackTail) {
        ctx.fillStyle = "#000000";
        const tailWidth = 8;
        const tailLength = bodySize;
        const tailStartX = bird.x - bodySize/2;
        const tailStartY = bird.y;
        ctx.fillRect(tailStartX, tailStartY - tailWidth/2, -tailLength, tailWidth);
    } else if (bird.name === "白鹡鸰" && bird.longBlackTail) {
        ctx.fillStyle = "#000000";
        const tailWidth = 3;
        const tailLength = 20;
        const tailStartX = bird.x - bodySize/2;
        const tailStartY = bird.y - bodySize/8;
        ctx.fillRect(tailStartX, tailStartY - tailWidth/2, -tailLength, tailWidth);
        
        ctx.fillStyle = "#000000";
        const blackLineY = tailStartY + tailWidth/2 + 1;
        ctx.fillRect(tailStartX, blackLineY, -tailLength, 1);
    } else if (bird.name === "棕头鸦雀" && bird.longBrownTail) {
        ctx.fillStyle = tailColor || "#8B4513";
        const tailWidth = 2;
        const tailLength = bodySize;
        const tailStartX = bird.x - bodySize/2;
        const tailStartY = bird.y;
        ctx.fillRect(tailStartX, tailStartY - tailWidth/2, -tailLength, tailWidth);
    } else if (bird.name === "黑翅鸢") {
        ctx.fillStyle = "#FFFFFF";
        const tailStartX = bird.x - bodySize/2;
        const tailStartY = bird.y - bodySize/8;
        const tailHeight = bodySize/4;
        ctx.beginPath();
        ctx.moveTo(tailStartX, tailStartY);
        ctx.lineTo(tailStartX - 8, tailStartY - tailHeight/2);
        ctx.lineTo(tailStartX - 8, tailStartY + tailHeight/2);
        ctx.lineTo(tailStartX, tailStartY);
        ctx.closePath();
        ctx.fill();
    } else if (bird.name === "金翅雀") {
        ctx.fillStyle = tailColor || "#FFD700";
        const tailStartX = bird.x - bodySize/2;
        const tailStartY = bird.y - bodySize/8;
        const tailHeight = bodySize/4;
        ctx.beginPath();
        ctx.moveTo(tailStartX, tailStartY);
        ctx.lineTo(tailStartX - 8, tailStartY - tailHeight/2);
        ctx.lineTo(tailStartX - 8, tailStartY + tailHeight/2);
        ctx.lineTo(tailStartX, tailStartY);
        ctx.closePath();
        ctx.fill();
    } else if (bird.name === "金眶鸻" || bird.name === "12000鸻") {
        ctx.fillStyle = tailColor || "#D2B48C";
        const tailStartX = bird.x - bodySize/2;
        const tailStartY = bird.y - bodySize/8;
        const tailHeight = bodySize/4;
        ctx.beginPath();
        ctx.moveTo(tailStartX, tailStartY);
        ctx.lineTo(tailStartX - 8, tailStartY - tailHeight/2);
        ctx.lineTo(tailStartX - 8, tailStartY + tailHeight/2);
        ctx.lineTo(tailStartX, tailStartY);
        ctx.closePath();
        ctx.fill();
    } else {
        ctx.fillStyle = tailColor || "#000000";
        const tailStartX = bird.x - bodySize/2;
        const tailStartY = bird.y - bodySize/8;
        const tailHeight = bodySize/4;
        ctx.beginPath();
        ctx.moveTo(tailStartX, tailStartY);
        ctx.lineTo(tailStartX - 8, tailStartY - tailHeight/2);
        ctx.lineTo(tailStartX - 8, tailStartY + tailHeight/2);
        ctx.lineTo(tailStartX, tailStartY);
        ctx.closePath();
        ctx.fill();
    }
    
    if (bird.hasCrest && bird.crestColor) {
        ctx.fillStyle = bird.crestColor || '#D2B48C';
        ctx.beginPath();
        const centerX = bird.x;
        const centerY = bird.y - bodySize/2;
        const radius = 10;
        const startAngle = -Math.PI/2 - Math.PI/9 - Math.PI/18;
        const endAngle = -Math.PI/2 + Math.PI/3.6 - Math.PI/18;
        
        ctx.moveTo(centerX, centerY);
        for (let i = 0; i <= 6; i++) {
            const angle = startAngle + (endAngle - startAngle) * (i / 6);
            const x = centerX + Math.cos(angle) * radius;
            const y = centerY + Math.sin(angle) * radius;
            ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.fill();
        
        for (let i = 0; i < 5; i++) {
            const pointAngle = startAngle + (endAngle - startAngle) * ((i+1)/6);
            const pointRadius = radius * 0.6;
            const pointX = centerX + Math.cos(pointAngle) * pointRadius;
            const pointY = centerY + Math.sin(pointAngle) * pointRadius;
            const pointSize = 2;
            
            if (i % 2 === 0) {
                ctx.fillStyle = "#000000";
            } else {
                ctx.fillStyle = "#FFFFFF";
            }
            
            ctx.beginPath();
            ctx.arc(pointX, pointY, pointSize, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    
    ctx.restore();
    
    if ((bird.name === "黑翅鸢" || bird.name === "红隼") && bird.caughtMouse) {
        drawMouseInClaws(bird);
    }
    
    if (bird.name === "游隼" && bird.caughtBird) {
        ctx.save();
        ctx.fillStyle = "#A0522D";
        const preySize = 10;
        const preyX = bird.x + (bird.direction === 1 ? 20 : -20);
        const preyY = bird.y + 15;
        ctx.beginPath();
        ctx.arc(preyX, preyY, preySize, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }
    
    if (bird.name === "红隼" && bird.caughtDove) {
        ctx.save();
        ctx.fillStyle = "#808080";
        const doveSize = 12;
        const doveX = bird.x + (bird.direction === 1 ? 20 : -20);
        const doveY = bird.y + 15;
        ctx.beginPath();
        ctx.arc(doveX, doveY, doveSize, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = "#A0522D";
        const wingWidth = doveSize * 0.8;
        const wingHeight = doveSize * 0.4;
        ctx.fillRect(doveX - wingWidth/2, doveY - wingHeight/2, wingWidth, wingHeight);
        ctx.restore();
    }
    
    if (bird.isEating && bird.eatingFruit) {
        const timeSinceStart = bird.eatingTime;
        const pulse = Math.sin(timeSinceStart * 0.01) * 0.5 + 0.5;
        
        ctx.save();
        ctx.fillStyle = `rgba(255, 200, 0, ${0.3 * pulse})`;
        ctx.beginPath();
        ctx.arc(
            bird.x + (bird.direction === 1 ? 30 : -30),
            bird.y - 10,
            3 + pulse * 2,
            0, Math.PI * 2
        );
        ctx.fill();
        ctx.restore();
    }
    
    ctx.restore();
}

function drawPerchingWoodpeckerOrHeron(bird) {
    const baseSize = 20;
    const birdSize = baseSize * bird.size;
    const bodySize = birdSize;
    
    ctx.save();
    
    let beakDirection = 1;
    if (bird.targetTree && bird.targetTree.side === 'right') {
        beakDirection = -1;
    }
    
    let bodyColor = bird.type.bodyColor;
    let headColor = bird.type.headColor || '#000000';
    let wingColor = bird.type.wingColor || '#000000';
    let tailColor = bird.type.tailColor || "#000000";
    
    if (bird.name === "夜鹭" && bird.isNight) {
        bodyColor = bird.nightBodyColor || "#808080";
        headColor = bird.nightBodyColor || "#808080";
        wingColor = bird.nightWingColor || "#4682B4";
        tailColor = bird.nightBodyColor || "#808080";
    }
    
    ctx.fillStyle = bodyColor;
    ctx.beginPath();
    ctx.ellipse(bird.x, bird.y, bodySize/3, bodySize/2, 0, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = headColor;
    const headSize = bodySize * 0.4;
    const headY = bird.y - bodySize/2 - headSize/2;
    const headX = bird.x + (bird.headOffsetX || 0);
    
    ctx.beginPath();
    ctx.arc(headX, headY, headSize/2, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = bird.type.color || '#000000';
    ctx.beginPath();
    
    let beakLength = 8;
    let beakHeight = 5;
    
    if (bird.name === "夜鹭") {
        beakLength = 24;
        beakHeight = 6;
    } else if (bird.name === "啄木鸟" && bird.doubleBeak) {
        beakLength = 8;
        beakHeight = 5;
    }
    
    const beakStartX = headX + (headSize/2 * beakDirection);
    const beakStartY = headY;
    const beakEndX = beakStartX + beakLength * beakDirection + (bird.headOffsetX || 0);
    
    ctx.moveTo(beakStartX, beakStartY);
    ctx.lineTo(beakEndX, beakStartY);
    ctx.lineTo(beakStartX, beakStartY + beakHeight);
    ctx.closePath();
    ctx.fill();
    
    const eyeColor = bird.type.eyeColor || '#000000';
    const eyeX = headX + headSize/4 * beakDirection;
    const eyeY = headY - headSize/8;
    
    if (bird.whiteEyeRing) {
        ctx.fillStyle = '#FFFFFF';
        ctx.beginPath();
        ctx.arc(eyeX, eyeY, 3, 0, Math.PI * 2);
        ctx.fill();
    }
    
    ctx.fillStyle = eyeColor;
    ctx.beginPath();
    ctx.arc(eyeX, eyeY, 2, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = wingColor;
    const wingWidth = bodySize/8;
    const wingHeight = bodySize/3;
    const wingY = bird.y - wingHeight/2;
    
    if (bird.name === "夜鹭") {
        if (beakDirection === 1) {
            ctx.fillRect(
                bird.x - bodySize/3 - wingWidth/2,
                wingY,
                wingWidth,
                wingHeight
            );
        } else {
            ctx.fillRect(
                bird.x + bodySize/3 - wingWidth/2,
                wingY,
                wingWidth,
                wingHeight
            );
        }
    } else {
        if (bird.targetTree.side === 'left') {
            ctx.fillRect(
                bird.x + bodySize/2 - wingWidth/2,
                wingY,
                wingWidth,
                wingHeight
            );
        } else {
            ctx.fillRect(
                bird.x - bodySize/2 - wingWidth/2,
                wingY,
                wingWidth,
                wingHeight
            );
        }
    }
    
    ctx.fillStyle = tailColor;
    const tailStartX = bird.x;
    const tailStartY = bird.y + bodySize/2;
    const tailHeight = bodySize/4;
    const tailWidth = bodySize/3;
    
    ctx.beginPath();
    ctx.moveTo(tailStartX - tailWidth/2, tailStartY);
    ctx.lineTo(tailStartX + tailWidth/2, tailStartY);
    ctx.lineTo(tailStartX, tailStartY + tailHeight);
    ctx.closePath();
    ctx.fill();
    
    ctx.restore();
}

function drawRiceBallBird(bird) {
    const baseSize = 20;
    const birdSize = baseSize * bird.size;
    const bodySize = birdSize;
    
    ctx.save();
    
    let riceBallColor;
    let dotColor = "#000000";
    let eyeRingColor = "#FFFFFF";
    let topSquareColor = "#FF8C00";
    
    if (bird.name === "戴菊") {
        riceBallColor = "#90EE90";
    }
    
    ctx.fillStyle = riceBallColor;
    ctx.beginPath();
    ctx.arc(bird.x, bird.y, bodySize/2, 0, Math.PI * 2);
    ctx.fill();
    
    const highlightGradient = ctx.createRadialGradient(
        bird.x - bodySize/4, bird.y - bodySize/4, 0,
        bird.x, bird.y, bodySize
    );
    highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
    highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
    
    ctx.fillStyle = highlightGradient;
    ctx.beginPath();
    ctx.arc(bird.x, bird.y, bodySize/2, 0, Math.PI * 2);
    ctx.fill();
    
    const eyeSpacing = bodySize * 0.4;
    const leftEyeX = bird.x - eyeSpacing/2;
    const rightEyeX = bird.x + eyeSpacing/2;
    const eyeY = bird.y - bodySize/6;
    const mouthX = bird.x;
    const mouthY = bird.y + bodySize/6;
    
    const eyeRadius = 0.25;
    const mouthRadius = 0.25;
    
    if (bird.name === "戴菊") {
        ctx.fillStyle = eyeRingColor;
        ctx.beginPath();
        ctx.arc(leftEyeX, eyeY, eyeRadius + 0.125, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(rightEyeX, eyeY, eyeRadius + 0.125, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = dotColor;
        ctx.beginPath();
        ctx.arc(leftEyeX, eyeY, eyeRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(rightEyeX, eyeY, eyeRadius, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.beginPath();
        ctx.arc(mouthX, mouthY, mouthRadius, 0, Math.PI * 2);
        ctx.fill();
        
        const squareSize = bodySize * 0.3;
        ctx.fillStyle = topSquareColor;
        
        const roundRect = (x, y, width, height, radius) => {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            ctx.fill();
        };
        
        roundRect(bird.x - squareSize/2, bird.y - bodySize/2 - squareSize/2, squareSize, squareSize, 2);
    }
    
    ctx.fillStyle = riceBallColor;
    const tailWidth = bodySize * 0.15;
    const tailHeight = bodySize * 0.2;
    const tailX = bird.x + bodySize/2 - tailWidth/2;
    const tailY = bird.y + bodySize/2 - tailHeight/2;
    
    ctx.beginPath();
    ctx.moveTo(tailX, tailY);
    ctx.lineTo(tailX + tailWidth, tailY);
    ctx.lineTo(tailX + tailWidth/2, tailY + tailHeight);
    ctx.closePath();
    ctx.fill();
    
    ctx.restore();
}

function drawLongtailedFinch(bird) {
  const baseSize = 20;
  let birdSize = baseSize * bird.size;
  const headSize = birdSize * 0.5;
  const bodySize = birdSize;
  
  ctx.save();
  let headOffsetY = 0;
  
  ctx.fillStyle = bird.type.bodyColor;
  ctx.beginPath();
  ctx.arc(bird.x, bird.y, bodySize/2, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.fillStyle = bird.type.headColor;
  ctx.beginPath();
  ctx.arc(
    bird.x + bodySize/2 - headSize/2,
    bird.y - bodySize/2 + headSize/2,
    headSize/2, 0, Math.PI * 2
  );
  ctx.fill();
  
  ctx.fillStyle = bird.type.color;
  const beakLength = 8 * 0.5;
  const beakHeight = 4;
  const beakStartX = bird.x + bodySize/2 - headSize/2 + headSize/2;
  const beakStartY = bird.y - bodySize/2 + headSize/2;
  
  ctx.beginPath();
  ctx.moveTo(beakStartX, beakStartY);
  ctx.lineTo(beakStartX + beakLength, beakStartY);
  ctx.lineTo(beakStartX, beakStartY + beakHeight);
  ctx.closePath();
  ctx.fill();
  
  ctx.fillStyle = bird.type.eyeColor;
  const eyeX = bird.x + bodySize/2 - headSize/2 + headSize/4;
  const eyeY = bird.y - bodySize/2 + headSize/3;
  
  ctx.beginPath();
  ctx.arc(eyeX, eyeY, 2, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.fillStyle = bird.type.wingColor;
  ctx.fillRect(
    bird.x - bodySize/4 - headSize/2,
    bird.y - bodySize/2,
    bodySize/2, bodySize/3
  );
  
  // 修改尾巴样式为白鹡鸰样式
  ctx.fillStyle = "#000000"; // 使用黑色，与白鹡鸰一致
  const tailWidth = 3;
  const tailLength = 20; // 保持与白鹡鸰相同的长度
  const tailStartX = bird.x - bodySize/2;
  const tailStartY = bird.y - bodySize/8; // 调整位置
  
  // 绘制尾巴主体
  ctx.fillRect(tailStartX, tailStartY - tailWidth/2, -tailLength, tailWidth);
  
  // 绘制尾巴下面的横线（白鹡鸰样式）
  ctx.fillStyle = "#000000";
  const blackLineY = tailStartY + tailWidth/2 + 1;
  ctx.fillRect(tailStartX, blackLineY, -tailLength, 1);
  
  ctx.restore();
}

function drawHawfinch(bird) {
    const baseSize = 20;
    let birdSize = baseSize * bird.size;
    const headSize = birdSize * 0.5;
    const bodySize = birdSize;
    
    // ✅ 移除原有的方向处理
    ctx.fillStyle = bird.type.bodyColor;
    ctx.beginPath();
    ctx.arc(bird.x, bird.y, bodySize/2, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = bird.type.headColor;
    ctx.beginPath();
    ctx.arc(
        bird.x + bodySize/2 - headSize/2,
        bird.y - bodySize/2 + headSize/2,
        headSize/2,
        0,
        Math.PI * 2
    );
    ctx.fill();

    // 喙
    ctx.fillStyle = bird.type.beakColor || bird.type.color || "#000000";
    const beakStartX = bird.x + bodySize/2 - headSize/2 + headSize/2;
    const beakStartY = bird.y - bodySize/2 + headSize/2;
    const beakLength = 4;
    const beakHeight = 6;
    ctx.beginPath();
    ctx.moveTo(beakStartX, beakStartY);
    ctx.lineTo(beakStartX + beakLength, beakStartY);
    ctx.lineTo(beakStartX, beakStartY + beakHeight);
    ctx.closePath();
    ctx.fill();

    // 眼睛
    ctx.fillStyle = bird.type.eyeColor;
    const eyeX = bird.x + bodySize/2 - headSize/2 + headSize/4;
    const eyeY = bird.y - bodySize/2 + headSize/3;
    ctx.beginPath();
    ctx.arc(eyeX, eyeY, 2, 0, Math.PI * 2);
    ctx.fill();

    // 翅膀
    ctx.fillStyle = bird.type.wingColor;
    ctx.fillRect(
        bird.x - bodySize/4 - headSize/2,
        bird.y - bodySize/2,
        bodySize/2,
        bodySize/3
    );

    // 尾巴
    ctx.fillStyle = bird.type.tailColor;
    const tailStartX = bird.x - bodySize/2;
    const tailStartY = bird.y - bodySize/8;
    const tailHeight = bodySize/4;
    ctx.beginPath();
    ctx.moveTo(tailStartX, tailStartY);
    ctx.lineTo(tailStartX - 8, tailStartY - tailHeight/2);
    ctx.lineTo(tailStartX - 8, tailStartY + tailHeight/2);
    ctx.lineTo(tailStartX, tailStartY);
    ctx.closePath();
    ctx.fill();
}

function drawBrambling(bird) {
    const baseSize = 20;
    let birdSize = baseSize * bird.size;
    const headSize = birdSize * 0.5;
    const bodySize = birdSize;
    
    // ✅ 移除原有的方向处理，使用统一的镜像逻辑
    ctx.fillStyle = bird.type.bodyColor;
    ctx.beginPath();
    ctx.arc(bird.x, bird.y, bodySize/2, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = bird.type.headColor;
    ctx.beginPath();
    ctx.arc(
        bird.x + bodySize/2 - headSize/2,
        bird.y - bodySize/2 + headSize/2,
        headSize/2,
        0,
        Math.PI * 2
    );
    ctx.fill();

    // 喙
    ctx.fillStyle = bird.type.beakColor || bird.type.color || "#000000";
    const beakStartX = bird.x + bodySize/2 - headSize/2 + headSize/2;
    const beakStartY = bird.y - bodySize/2 + headSize/2;
    const beakLength = 4;
    const beakHeight = 3;
    ctx.beginPath();
    ctx.moveTo(beakStartX, beakStartY);
    ctx.lineTo(beakStartX + beakLength, beakStartY);
    ctx.lineTo(beakStartX, beakStartY + beakHeight);
    ctx.closePath();
    ctx.fill();

    // 眼睛
    ctx.fillStyle = bird.type.eyeColor;
    const eyeX = bird.x + bodySize/2 - headSize/2 + headSize/4;
    const eyeY = bird.y - bodySize/2 + headSize/3;
    ctx.beginPath();
    ctx.arc(eyeX, eyeY, 2, 0, Math.PI * 2);
    ctx.fill();

    // 翅膀
    ctx.fillStyle = bird.type.wingColor;
    ctx.fillRect(
        bird.x - bodySize/4 - headSize/2,
        bird.y - bodySize/2,
        bodySize/2,
        bodySize/3
    );

    // 尾巴
    ctx.fillStyle = bird.type.tailColor;
    const tailStartX = bird.x - bodySize/2;
    const tailStartY = bird.y - bodySize/8;
    const tailHeight = bodySize/4;
    ctx.beginPath();
    ctx.moveTo(tailStartX, tailStartY);
    ctx.lineTo(tailStartX - 8, tailStartY - tailHeight/2);
    ctx.lineTo(tailStartX - 8, tailStartY + tailHeight/2);
    ctx.lineTo(tailStartX, tailStartY);
    ctx.closePath();
    ctx.fill();
}

// 新增：罗宾绘制函数
function drawRobin(bird) {
  const baseSize = 20;
  let birdSize = baseSize * bird.size;
  const headSize = birdSize * 0.5;
  const bodySize = birdSize;
  ctx.save();
  
  // 身体 - 浅灰色
  ctx.fillStyle = bird.type.bodyColor;
  ctx.beginPath();
  ctx.arc(bird.x, bird.y, bodySize/2, 0, Math.PI * 2);
  ctx.fill();
  
  // 头部 - 橙色
  ctx.fillStyle = bird.type.headColor;
  ctx.beginPath();
  ctx.arc(
    bird.x + bodySize/2 - headSize/2,
    bird.y - bodySize/2 + headSize/2,
    headSize/2, 0, Math.PI * 2
  );
  ctx.fill();
  
  // 嘴 - 棕色，0.8倍长
  ctx.fillStyle = bird.type.color;
  const beakLength = 8 * 0.8;
  const beakHeight = 4;
  const beakStartX = bird.x + bodySize/2 - headSize/2 + headSize/2;
  const beakStartY = bird.y - bodySize/2 + headSize/2;
  ctx.beginPath();
  ctx.moveTo(beakStartX, beakStartY);
  ctx.lineTo(beakStartX + beakLength, beakStartY);
  ctx.lineTo(beakStartX, beakStartY + beakHeight);
  ctx.closePath();
  ctx.fill();
  
  // 眼睛 - 黑色
  ctx.fillStyle = bird.type.eyeColor;
  const eyeX = bird.x + bodySize/2 - headSize/2 + headSize/4;
  const eyeY = bird.y - bodySize/2 + headSize/3;
  ctx.beginPath();
  ctx.arc(eyeX, eyeY, 2, 0, Math.PI * 2);
  ctx.fill();
  
  // 翅膀 - 棕色
  ctx.fillStyle = bird.type.wingColor;
  ctx.fillRect(
    bird.x - bodySize/4 - headSize/2,
    bird.y - bodySize/2,
    bodySize/2,
    bodySize/3
  );
  
  // 尾巴 - 棕色
  ctx.fillStyle = bird.type.tailColor;
  const tailStartX = bird.x - bodySize/2;
  const tailStartY = bird.y - bodySize/8;
  const tailHeight = bodySize/4;
  ctx.beginPath();
  ctx.moveTo(tailStartX, tailStartY);
  ctx.lineTo(tailStartX - 8, tailStartY - tailHeight/2);
  ctx.lineTo(tailStartX - 8, tailStartY + tailHeight/2);
  ctx.lineTo(tailStartX, tailStartY);
  ctx.closePath();
  ctx.fill();
  
  ctx.restore();
}

function drawMouseInClaws(bird) {
    ctx.save();
    
    const clawOffsetX = 20;
    const clawOffsetY = 15;
    
    let mouseX = bird.x + clawOffsetX;
    let mouseY = bird.y + clawOffsetY;
    
    if (bird.mouseSwingAngle !== undefined) {
        bird.mouseSwingAngle += bird.mouseSwingSpeed || 0.05;
    }
    
    const swingOffset = Math.sin(bird.mouseSwingAngle || 0) * 3;
    mouseX += swingOffset;
    mouseY += Math.abs(swingOffset) * 0.5;
    
    ctx.fillStyle = "#D3D3D3";
    const bodyWidth = 12;
    const bodyHeight = 8;
    ctx.beginPath();
    ctx.ellipse(mouseX, mouseY, bodyWidth/2, bodyHeight/2, 0, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = "#D3D3D3";
    const headSize = 6;
    let headX, headY;
    
    headX = mouseX + bodyWidth/2;
    headY = mouseY;
    
    ctx.save();
    ctx.translate(headX, headY);
    ctx.rotate(swingOffset * 0.1);
    
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(headSize, -headSize/2);
    ctx.lineTo(headSize, headSize/2);
    ctx.closePath();
    ctx.fill();
    
    ctx.fillStyle = "#000000";
    const eyeX = headSize/2;
    ctx.beginPath();
    ctx.arc(eyeX, -headSize/4, 1.5, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(eyeX, headSize/4, 1.5, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.restore();
    
    ctx.save();
    ctx.translate(mouseX, mouseY);
    
    let tailStartX, tailStartY;
    tailStartX = -bodyWidth/2;
    tailStartY = 0;
    
    const tailLength = 15;
    const tailAngle = swingOffset * 0.2;
    
    let tailEndX, tailEndY;
    tailEndX = tailStartX - Math.cos(tailAngle) * tailLength;
    tailEndY = tailStartY + Math.sin(tailAngle) * tailLength;
    
    ctx.strokeStyle = "#D3D3D3";
    ctx.lineWidth = 2;
    ctx.lineCap = "round";
    ctx.beginPath();
    ctx.moveTo(tailStartX, tailStartY);
    ctx.lineTo(tailEndX, tailEndY);
    ctx.stroke();
    
    ctx.restore();
    ctx.restore();
}

function updateDayNight(deltaTime) {
    if (gamePaused) return;
    
    gameTime += deltaTime;
    
    // 应用时间加速
    let effectiveDeltaTime = deltaTime;
    let isAccelerated = false;
    
    if (isNightAccelerated && gameMode === 'normal' && !isDaytime) {
        effectiveDeltaTime = deltaTime * nightAccelerationMultiplier;
        isAccelerated = true;
    }
    
    // 稀有鸟类生成（使用实际时间，不受加速影响）
    let rareBirdDelta = deltaTime; // 始终使用实际时间
    if (birdingModeActive) {
        // 观鸟模式中，稀有鸟类生成间隔更长
        rareBirdDelta = deltaTime;
    }
    lastRareBirdTime += rareBirdDelta;
    
    // 检查是否生成稀有鸟类（使用实际时间）
    if (gameTime - lastRareBirdTime >= RARE_BIRD_INTERVAL && !birdingModeActive) {
        generateRareBird();
        lastRareBirdTime = gameTime;
    }
    
    // 普通模式：日夜循环
    if (gameMode === 'normal') {
        // 只在这里累加日夜时间
        dayNightTimer += effectiveDeltaTime;
        
        moonPhaseTimer += deltaTime; // 月亮相位使用实际时间
        if (moonPhaseTimer >= MOON_PHASE_CYCLE) {
            moonPhaseTimer = 0;
        }
        
        updateGoldenFilter();
        
        // 检查日夜切换
        if (dayNightTimer >= DAY_NIGHT_CYCLE_DURATION) {
            isDaytime = !isDaytime;
            dayNightTimer = 0;
            
            // 夜晚切换为白天时，重置加速状态
            if (isDaytime && isNightAccelerated) {
                isNightAccelerated = false;
                showSpecialAlert("黎明到来，恢复正常时间流速");
            }
            
            if (!isDaytime) {
                moonPhaseTimer = Math.random() * MOON_PHASE_CYCLE;
            }
            
            updateModeToggleButtons();
            // 更新营地可见性
            updateCampsiteVisibility();
            showSpecialAlert(isDaytime ? "天亮了！" : "天黑了！");
            
            // 切换时清理不符合当前时间的生物
            if (!isDaytime) {
                for (let i = birds.length - 1; i >= 0; i--) {
                    if (!birds[i].isOwl && !birds[i].isBat && birds[i].name !== "小鸮" && birds[i].name !== "夜鹭") {
                        birds.splice(i, 1);
                    }
                }
                nightObjects = [];
            } else {
                for (let i = birds.length - 1; i >= 0; i--) {
                    if (birds[i].isOwl || birds[i].isBat) {
                        birds.splice(i, 1);
                    }
                }
                
                if (littleOwl) {
                    birds.splice(birds.indexOf(littleOwl), 1);
                    littleOwl = null;
                }
                nightObjects = [];
            }
        }
        
        // 更新太阳/月亮位置
        sunMoonPosition = dayNightTimer / DAY_NIGHT_CYCLE_DURATION;
    } 
    // 永久日间模式
    else if (gameMode === 'day') {
        dayModeTimeState += deltaTime;
        dayNightTimer = dayModeTimeState;
        
        // 确保加速状态被重置
        if (isNightAccelerated) {
            isNightAccelerated = false;
        }
        
        const goldenFilter = document.getElementById('goldenFilter');
        goldenFilter.style.backgroundColor = 'rgba(255, 215, 0, 0.1)';
        
        // 更新营地可见性
        updateCampsiteVisibility();
    } 
    // 永久夜间模式
    else if (gameMode === 'night') {
        nightModeTimeState += deltaTime;
        nightModeMoonPhaseTimer += deltaTime;
        dayNightTimer = nightModeTimeState;
        moonPhaseTimer = nightModeMoonPhaseTimer;
        
        if (moonPhaseTimer >= MOON_PHASE_CYCLE) {
            moonPhaseTimer = 0;
            nightModeMoonPhaseTimer = 0;
        }
        
        // 确保加速状态被重置
        if (isNightAccelerated) {
            isNightAccelerated = false;
        }
        
        const goldenFilter = document.getElementById('goldenFilter');
        goldenFilter.style.backgroundColor = 'rgba(255, 215, 0, 0)';
        
        // 更新营地可见性
        updateCampsiteVisibility();
    }
    
    updateTimeIndicator();
    
    // 小鸮生成逻辑（使用实际时间）
    if (!littleOwl) {
        let cooldown;
        if (gameMode === 'day') {
            cooldown = LITTLE_OWL_DAY_COOLDOWN;
        } else if (gameMode === 'night') {
            cooldown = LITTLE_OWL_NIGHT_COOLDOWN;
        } else {
            cooldown = isDaytime ? LITTLE_OWL_DAY_COOLDOWN : LITTLE_OWL_NIGHT_COOLDOWN;
        }
        
        // 使用实际时间计算
        let actualTimePassed = deltaTime;
        lastLittleOwlTime += actualTimePassed;
        
        if (gameTime - lastLittleOwlTime > cooldown) {
            generateLittleOwl(true);
            lastLittleOwlTime = gameTime;
        }
    }
    
    // 夜间猫头鹰生成（使用实际时间）
    if ((gameMode === 'night' || (gameMode === 'normal' && !isDaytime))) {
        let actualTimePassed = deltaTime;
        lastOwlSpawnTime += actualTimePassed;
        
        if (gameTime - lastOwlSpawnTime > NIGHT_OWL_SPAWN_INTERVAL) {
            spawnNightOwls();
            lastOwlSpawnTime = gameTime;
        }
    }
}

function generateRareBird() {
  const isNightMode = gameMode === 'night' || (gameMode === 'normal' && !isDaytime);
  let availableRareBirds = RARE_BIRDS.filter(birdKey => {
    const birdType = BIRD_TYPES[birdKey];
    if (!birdType) return false; // 添加保护性检查
    if (birdType.isNocturnal || birdType.canAppearAtNight) {
      return isNightMode;
    }
    return !isNightMode;
  });
  
  if (availableRareBirds.length === 0) {
    if (isNightMode) {
      availableRareBirds = ['OWL'];
    } else {
      // 确保白天可用的稀有鸟类包含所有白天鸟类
      availableRareBirds = ['KENTISH_PLOVER', 'MINIVET', 'GOLDCREST', 'LITTLEGREBE', 'LONGTAILED_FINCH', 'ROBIN'];
    }
  }
  
  const capturedRareBirds = availableRareBirds.filter(birdKey => {
    const birdName = BIRD_TYPES[birdKey]?.name;
    return birdName && capturedBirds[birdName] && capturedBirds[birdName] > 0;
  });
  
  const uncapturedRareBirds = availableRareBirds.filter(birdKey => {
    const birdName = BIRD_TYPES[birdKey]?.name;
    return birdName && (!capturedBirds[birdName] || capturedBirds[birdName] === 0);
  });
  
  let randomBirdKey;
  if (uncapturedRareBirds.length > 0) {
    randomBirdKey = uncapturedRareBirds[Math.floor(Math.random() * uncapturedRareBirds.length)];
  } else {
    randomBirdKey = availableRareBirds[Math.floor(Math.random() * availableRareBirds.length)];
  }
  
  // 确保 randomBirdKey 有对应的处理
  switch (randomBirdKey) {
    case 'KENTISH_PLOVER':
      generateKentishPlover(false);
      showSpecialAlert("稀有鸟类出现：金眶鸻！");
      break;
    case 'MINIVET':
      generateMinivetRare(false);
      showSpecialAlert("稀有鸟类出现：山椒鸟！");
      break;
    case 'GOLDCREST':
      generateGoldcrest(false);
      showSpecialAlert("稀有鸟类出现：戴菊！");
      break;
    case 'OWL':
      generateOwlRare(false);
      showSpecialAlert("稀有鸟类出现：长耳鸮！");
      break;
    case 'LITTLEGREBE':
      generateLittleGrebe(false);
      showSpecialAlert("稀有鸟类出现：小北！");
      break;
    case 'LONGTAILED_FINCH':
      generateLongtailedFinchRare(false);
      showSpecialAlert("稀有鸟类出现：长尾雀！");
      break;
    case 'ROBIN':
      generateRobinRare(false);
      showSpecialAlert("稀有鸟类出现：罗宾！");
      break;
default:
      console.log("未处理的稀有鸟类键:", randomBirdKey);
      // 默认生成一个已知的稀有鸟类
      generateKentishPlover(false);
      showSpecialAlert("稀有鸟类出现：金眶鸻！");
      break;
  }
}
// 新增：长尾雀稀有生成函数
function generateLongtailedFinchRare(countStats = true) {
  const longtailedFinchType = BIRD_TYPES.LONGTAILED_FINCH;
  if (countStats) {
    appearedBirds[longtailedFinchType.name]++;
    updateTextStats();
  }
  
  const fromLeft = Math.random() > 0.5;
  const birdCount = getRandomGroupSize(longtailedFinchType);
  const groupId = nextGroupId++;
  birdGroupInfo[groupId] = { direction: fromLeft ? 1 : -1, birds: [] };
  
  for (let i = 0; i < birdCount; i++) {
    const startX = fromLeft ? -50 : GAME_WIDTH + 50;
    const startY = Math.random() * (GAME_HEIGHT * 0.6) + GAME_HEIGHT * 0.2;
    const bird = createCommonBird(
      longtailedFinchType,
      startX,
      startY,
      fromLeft,
      "landOnTreeTop",
      longtailedFinchType.stayTime,
      2 + Math.random(),
      groupId
    );
    bird.halfBeak = true;
    bird.isVulnerableToRaptors = true;
    bird.noStats = !countStats;
    bird.isNight = !isDaytime;
    birds.push(bird);
    birdGroupInfo[groupId].birds.push(bird);
  }
}

// 新增：罗宾稀有生成函数
function generateRobinRare(countStats = true) {
  const robinType = BIRD_TYPES.ROBIN;
  if (countStats) {
    appearedBirds[robinType.name]++;
    updateTextStats();
  }
  
  const fromLeft = Math.random() > 0.5;
  const birdCount = getRandomGroupSize(robinType);
  const groupId = nextGroupId++;
  birdGroupInfo[groupId] = { direction: fromLeft ? 1 : -1, birds: [] };
  
  for (let i = 0; i < birdCount; i++) {
    const startX = fromLeft ? -50 : GAME_WIDTH + 50;
    const startY = Math.random() * (GAME_HEIGHT * 0.6) + GAME_HEIGHT * 0.2;
    const bird = createCommonBird(
      robinType,
      startX,
      startY,
      fromLeft,
      "landOnTreeBottom",
      robinType.stayTime,
      2 + Math.random(),
      groupId
    );
    bird.beakLengthMultiplier = 0.8;
    bird.isVulnerableToRaptors = true;
    bird.noStats = !countStats;
    bird.isNight = !isDaytime;
    birds.push(bird);
    birdGroupInfo[groupId].birds.push(bird);
  }
}

function generateMinivetRare(countStats = true) {
    const minivetType = BIRD_TYPES.MINIVET;
    if (countStats) {
        appearedBirds[minivetType.name]++;
        updateTextStats();
    }
    
    const fromLeft = Math.random() > 0.5;
    const birdCount = getRandomGroupSize(minivetType);
    const groupId = nextGroupId++;
    birdGroupInfo[groupId] = { direction: fromLeft ? 1 : -1, birds: [] };
    
    for (let i = 0; i < birdCount; i++) {
        let startX, startY;
        const behavior = minivetType.behavior;
        const stayTime = minivetType.stayTime || 10;
        
        startX = fromLeft ? -50 : GAME_WIDTH + 50;
        startY = Math.random() * (GAME_HEIGHT * 0.6) + GAME_HEIGHT * 0.2;
        
        let baseSpeed = (1.6 + Math.random() * 0.8);
        const speedMultiplier = minivetType.speedMultiplier || 1;
        const finalSpeed = baseSpeed * speedMultiplier;
        
        const bird = createCommonBird(minivetType, startX, startY, fromLeft, behavior, stayTime, finalSpeed, groupId);
        bird.variant = Math.random() > 0.5;
        bird.iconColor = bird.variant ? "#FFFF00" : "#FF0000";
        bird.noStats = !countStats;
        bird.isNight = !isDaytime;
        
        birds.push(bird);
        birdGroupInfo[groupId].birds.push(bird);
    }
}

function generateOwlRare(countStats = true) {
    const owlType = BIRD_TYPES.OWL;
    if (countStats) {
        appearedBirds[owlType.name]++;
        updateTextStats();
    }
    
    const targetTree = treePositions[Math.floor(Math.random() * treePositions.length)];
    const x = targetTree.x + targetTree.width * 0.4 + Math.random() * targetTree.width * 0.2;
    const y = targetTree.y + targetTree.height * 0.2 + Math.random() * targetTree.height * 0.3;
    
    const isNightMode = gameMode === 'night' || (gameMode === 'normal' && !isDaytime);
    
    const bird = {
        type: owlType,
        name: owlType.name,
        x: x,
        y: y,
        size: owlType.size,
        speed: 0,
        direction: targetTree.side === 'left' ? 1 : -1,
        state: 'perching',
        stateTime: 0,
        stayTime: owlType.stayTime || 15,
        faceScreen: true,
        iconColor: owlType.iconColor,
        eyeColor: isNightMode ? "#FFFF99" : "#FFA500", // 夜晚黄色，白天橙色
        whiteEyeRing: true,
        noStats: !countStats,
        isNight: isNightMode,
        // ✅ 新增：标记为直接消失的鸟类
        shouldVanishInsteadOfFlying: true,
        behavior: "appearOnTree" // 明确行为类型
    };
    
    birds.push(bird);
    showSpecialAlert("稀有鸟类出现：长耳鸮！");
    return bird;
}

function updateGoldenFilter() {
    const goldenFilter = document.getElementById('goldenFilter');
    
    if (gameMode === 'normal' && isDaytime) {
        const oneMinute = 1 * 60 * 1000;
        const dayDuration = DAY_NIGHT_CYCLE_DURATION;
        const currentDayTime = dayNightTimer;
        
        let intensity = 0;
        if (currentDayTime < oneMinute) {
            intensity = 0.3 * (1 - currentDayTime / oneMinute);
        } else if (currentDayTime > dayDuration - oneMinute) {
            const timeLeft = dayDuration - currentDayTime;
            intensity = 0.3 * (1 - timeLeft / oneMinute);
        } else {
            intensity = 0;
        }
        
        goldenFilter.style.backgroundColor = `rgba(255, 215, 0, ${intensity})`;
        isGoldenFilterActive = intensity > 0.01;
    } else {
        goldenFilter.style.backgroundColor = 'rgba(255, 215, 0, 0)';
        isGoldenFilterActive = false;
    }
}

function updateBirds(deltaTime) {
    if (gamePaused) return;
    
    raptorsPresent = birds.filter(bird => bird.name === "游隼" || bird.name === "红隼" || bird.name === "黑翅鸢");
    
    raptorsPresent.forEach(raptor => {
        if (!raptor.hasBeenNearCenter) {
            const centerX = GAME_WIDTH / 2;
            const centerY = GAME_HEIGHT / 2;
            const distanceX = Math.abs(raptor.x - centerX);
            const distanceY = Math.abs(raptor.y - centerY);
            if (distanceX < 400 && distanceY < 300) {
                raptor.hasBeenNearCenter = true;
                raptor.centerArrivalTime = gameTime;
            }
        }
    });
    
    const isNightMode = gameMode === 'night' || (gameMode === 'normal' && !isDaytime);
    const qualifiedRaptors = raptorsPresent.filter(raptor => raptor.hasBeenNearCenter && gameTime - raptor.centerArrivalTime >= 1000);
    
    if (qualifiedRaptors.length > 0) {
        birds.forEach(bird => {
            const exemptBirds = [
                "喜鹊", "乌鸦", "夜鹭", "绿头鸭", "赤麻鸭", "小北", "戴菊", "山雀", 
                "棕头鸦雀", "金眶鸻", "12000鸻", "游隼", "红隼", "黑翅鸢", 
                "长耳鸮", "雕鸮", "短耳鸮", "小鸮", "蝙蝠"
            ];
            
            if (exemptBirds.includes(bird.name)) {
                return;
            }
            
            if (!bird.isFleeingFromRaptor) {
                bird.isFleeingFromRaptor = true;
                bird.originalState = bird.state;
                bird.originalSpeed = bird.speed;
                bird.fleeFromRaptorStartTime = gameTime;
                bird.speed = bird.originalSpeed * 1.5;
                
                let nearestRaptor = null;
                let minDistance = Infinity;
                qualifiedRaptors.forEach(raptor => {
                    const dx = raptor.x - bird.x;
                    const dy = raptor.y - bird.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < minDistance) {
                        minDistance = distance;
                        nearestRaptor = raptor;
                    }
                });
                
                if (nearestRaptor) {
                    bird.direction = nearestRaptor.x > bird.x ? -1 : 1;
                }
                bird.state = 'flying';
            }
        });
        
        birds.forEach(bird => {
            if (bird.name === "金眶鸻" || bird.name === "12000鸻") {
                if (bird.state === 'flying' || bird.state === 'landingOnReeds' || bird.state === 'takingOff') {
                    if (!bird.isFleeingFromRaptor) {
                        bird.isFleeingFromRaptor = true;
                        bird.originalState = bird.state;
                        bird.originalSpeed = bird.speed;
                        bird.speed = bird.originalSpeed * 3;
                        bird.state = 'flying';
                        bird.direction = Math.random() > 0.5 ? 1 : -1;
                    }
                } else if (bird.state === 'onReedsGround') {
                    if (!bird.isHidingFromRaptor) {
                        bird.isHidingFromRaptor = true;
                        bird.originalY = bird.y;
                        bird.originalSpeed = bird.speed;
                        bird.speed = 0;
                        bird.y = bird.originalY + (20 * bird.size * 0.5);
                    }
                }
            }
        });
        
        // 只在猛禽没有被追逐巡逻时触发新的追逐
        if (Math.random() > 1/3) {
            if (raptorsPresent.length > 0) {
                const availableMagpiesCrows = birds.filter(bird => 
                    (bird.name === "喜鹊" || bird.name === "乌鸦") && 
                    !bird.isChasingRaptor && 
                    !bird.isFleeingFromRaptor && 
                    !bird.isFleeingFromChasers
                );
                
                raptorsPresent.forEach(raptor => {
                    // 如果猛禽已经在被追逐巡逻中，或者正在逃离追逐，或者已经被追逐过（免疫状态），不重新触发
                    if (raptor.isChasedPatrolling || raptor.isFleeingFromChasers || raptor.hasBeenChased) {
                        return;
                    }
                    
                    const currentChasers = chasingMagpiesCrows.filter(chaser => chaser.chasingTarget === raptor);
                    const neededChasers = raptor.name === "游隼" ? 2 : 1;
                    
                    if (currentChasers.length < neededChasers) {
                        const potentialChasers = availableMagpiesCrows.filter(bird => !bird.chasingTarget);
                        const newChasers = potentialChasers.slice(0, neededChasers - currentChasers.length);
                        
                        if (newChasers.length > 0 && !raptor.hasPatrolStarted) {
                            // 标记为已开始巡逻，防止重复触发
                            raptor.hasPatrolStarted = true;
                            
                            newChasers.forEach(chaser => {
                                if (chaser.state === 'perching' || chaser.state === 'landing') {
                                    chaser.state = 'takingOff';
                                    chaser.speed = 2.0;
                                    setTimeout(() => {
                                        if (birds.includes(chaser) && birds.includes(raptor)) {
                                            chaser.chasingTarget = raptor;
                                            chaser.isChasingRaptor = true;
                                            chaser.originalState = chaser.state;
                                            chaser.originalSpeed = chaser.speed;
                                            chaser.chaseStartTime = gameTime;
                                            chaser.willFollowCircles = true;
                                            chaser.circleFollowingCount = 0;
                                            chaser.state = 'chasingRaptor';
                                            chasingMagpiesCrows.push(chaser);
                                        }
                                    }, 500);
                                } else {
                                    chaser.chasingTarget = raptor;
                                    chaser.isChasingRaptor = true;
                                    chaser.originalState = chaser.state;
                                    chaser.originalSpeed = chaser.speed;
                                    chaser.chaseStartTime = gameTime;
                                    chaser.willFollowCircles = true;
                                    chaser.circleFollowingCount = 0;
                                    chaser.state = 'chasingRaptor';
                                    chasingMagpiesCrows.push(chaser);
                                }
                            });
                            
                            // 启动追逐巡逻
                            raptor.isChasedPatrolling = true;
                            raptor.originalState = raptor.state;
                            raptor.originalSpeed = raptor.speed;
                            raptor.chasedPatrolStartTime = gameTime;
                            raptor.chasedPatrolStage = 0; // 0: 从中央飞出右侧
                            raptor.chasedPatrolLoops = 0;
                            raptor.maxPatrolLoops = 2 + Math.floor(Math.random() * 3); // 2-4次循环
                            raptor.state = 'chasedPatrolling';
                            raptor.forcedToLeave = false;
                            
                            // a) 从中央飞出右侧
                            raptor.x = GAME_WIDTH / 2;
                            raptor.y = GAME_HEIGHT * 0.3 + Math.random() * (GAME_HEIGHT * 0.2);
                            raptor.direction = 1; // 向右
                            raptor.speed = 2.0;
                            console.log("猛禽开始追逐巡逻，阶段0: 从中央飞出右侧，最大循环次数: " + raptor.maxPatrolLoops);
                        }
                    }
                });
            }
        }
    } else {
        for (let i = chasingMagpiesCrows.length - 1; i >= 0; i--) {
            const chaser = chasingMagpiesCrows[i];
            chaser.isChasingRaptor = false;
            chaser.chasingTarget = null;
            if (chaser.originalState) {
                chaser.state = chaser.originalState;
            }
            if (chaser.originalSpeed) {
                chaser.speed = chaser.originalSpeed;
            }
        }
        chasingMagpiesCrows = [];
    }
    
    for (let i = chasingMagpiesCrows.length - 1; i >= 0; i--) {
        const chaser = chasingMagpiesCrows[i];
        if (chaser.chasingTarget && birds.includes(chaser.chasingTarget)) {
            const raptor = chaser.chasingTarget;
            const dx = raptor.x - chaser.x;
            const dy = raptor.y - chaser.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const baseSize = 20;
            const birdSize = baseSize * chaser.size;
            const minDistance = birdSize * 0.5;
            const maxDistance = birdSize * 0.8;
            const targetDistance = minDistance + Math.random() * (maxDistance - minDistance);
            
            if (chaser.isChasingRaptor && chaser.state === 'chasingRaptor') {
                const chaseDuration = gameTime - chaser.chaseStartTime;
                
                // 检查喜鹊/乌鸦是否放弃追逐 - 修改：只在猛禽在屏幕内时才可能放弃
                if (chaseDuration > 3000) {
                    const timeSinceLastCheck = chaseDuration % 2000;
                    if (timeSinceLastCheck < 50) {
                        // 检查猛禽是否在屏幕内
                        const isRaptorOnScreen = raptor.x >= -250 && raptor.x <= GAME_WIDTH + 250 && 
                                                raptor.y >= -250 && raptor.y <= GAME_HEIGHT + 250;
                        
                        // 只在猛禽在屏幕内时才可能放弃追逐
                        if (isRaptorOnScreen) {
                            let abandonChance = 0;
                            if (chaser.name === "喜鹊") {
                                abandonChance = 0.03;
                            } else if (chaser.name === "乌鸦") {
                                abandonChance = 0.01;
                            }
                            
                            if (Math.random() < abandonChance) {
                                chaser.isChasingRaptor = false;
                                chaser.chasingTarget = null;
                                if (chaser.originalState) {
                                    chaser.state = chaser.originalState;
                                }
                                if (chaser.originalSpeed) {
                                    chaser.speed = chaser.originalSpeed;
                                }
                                const index = chasingMagpiesCrows.indexOf(chaser);
                                if (index !== -1) {
                                    chasingMagpiesCrows.splice(index, 1);
                                }
                                
                                // 如果所有追逐者都放弃了，猛禽恢复正常并标记为已被追逐过
                                if (raptor && raptor.isChasedPatrolling) {
                                    const remainingChasers = chasingMagpiesCrows.filter(c => c.chasingTarget === raptor);
                                    if (remainingChasers.length === 0) {
                                        raptor.isChasedPatrolling = false;
                                        raptor.isFleeingFromChasers = false;
                                        raptor.forcedToLeave = false;
                                        raptor.hasPatrolStarted = false;
                                        raptor.hasBeenChased = true; // 标记为已被追逐过
                                        if (raptor.originalState) {
                                            raptor.state = raptor.originalState;
                                        }
                                        if (raptor.originalSpeed) {
                                            raptor.speed = raptor.originalSpeed;
                                        }
                                        console.log("所有追逐者放弃，猛禽恢复正常，标记为已被追逐过");
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            // 更新追逐者位置
            let dynamicTargetDistance = targetDistance;
            if (distance > birdSize * 1.5) {
                dynamicTargetDistance = birdSize * 0.4;
            } else if (distance < birdSize * 0.3) {
                dynamicTargetDistance = birdSize * 1.0;
            }
            
            const angle = Math.atan2(dy, dx);
            const targetX = raptor.x - Math.cos(angle) * dynamicTargetDistance;
            const targetY = raptor.y - Math.sin(angle) * dynamicTargetDistance;
            const targetDx = targetX - chaser.x;
            const targetDy = targetY - chaser.y;
            const targetDist = Math.sqrt(targetDx * targetDx + targetDy * targetDy);
            
            if (targetDist > 5) {
                const moveSpeed = chaser.speed;
                chaser.x += (targetDx / targetDist) * moveSpeed;
                chaser.y += (targetDy / targetDist) * moveSpeed;
                chaser.direction = targetDx > 0 ? 1 : -1;
            } else {
                chaser.x = targetX;
                chaser.y = targetY;
                chaser.direction = raptor.direction;
            }
            
            // 如果猛禽已经飞离，追逐者放弃
            if (!birds.includes(raptor)) {
                chaser.isChasingRaptor = false;
                chaser.chasingTarget = null;
                chaser.state = 'fleeing';
                chaser.speed = 2.0;
                chaser.direction = -1;
                const index = chasingMagpiesCrows.indexOf(chaser);
                if (index !== -1) {
                    chasingMagpiesCrows.splice(index, 1);
                }
            }
        } else {
            chaser.isChasingRaptor = false;
            chaser.chasingTarget = null;
            if (chaser.originalState) {
                chaser.state = chaser.originalState;
            }
            if (chaser.originalSpeed) {
                chaser.speed = chaser.originalSpeed;
            }
            chasingMagpiesCrows.splice(i, 1);
        }
    }
    
    // 更新猛禽的追逐巡逻行为
    raptorsPresent.forEach(raptor => {
        if (raptor.state === 'chasedPatrolling' && raptor.isChasedPatrolling) {
            const patrolDuration = gameTime - raptor.chasedPatrolStartTime;
            
            switch (raptor.chasedPatrolStage) {
                case 0: // a) 从中央飞出右侧
                    raptor.x += raptor.speed * raptor.direction;
                    raptor.y += Math.sin(gameTime * 0.005) * 1; // 轻微上下波动
                    
                    // 飞出右侧后进入下一阶段
                    if (raptor.x > GAME_WIDTH + 100) {
                        raptor.chasedPatrolStage = 1;
                        raptor.chasedPatrolStartTime = gameTime;
                        // b) 1-2秒后再从右侧飞入
                        raptor.chasedPatrolDelay = 1000 + Math.random() * 1000;
                        raptor.direction = -1; // 向左飞
                        raptor.x = GAME_WIDTH + 100; // 重置到右侧外
                        raptor.y = GAME_HEIGHT * 0.3 + Math.random() * (GAME_HEIGHT * 0.2);
                        console.log("猛禽进入阶段1: 等待后从右侧飞入");
                    }
                    break;
                    
                case 1: // b) 从右侧飞入至左侧飞出
                    if (patrolDuration < raptor.chasedPatrolDelay) {
                        // 等待延迟
                        // 位置已经在上一个阶段设置好了
                    } else {
                        // 从右侧飞入
                        raptor.x += raptor.speed * raptor.direction;
                        raptor.y += Math.sin(gameTime * 0.005) * 1;
                        
                        // 飞出左侧后进入下一阶段
                        if (raptor.x < -100) {
                            raptor.chasedPatrolStage = 2;
                            raptor.chasedPatrolStartTime = gameTime;
                            // c) 0.5-1秒再从左侧飞入
                            raptor.chasedPatrolDelay = 500 + Math.random() * 500;
                            raptor.direction = 1; // 向右飞
                            raptor.x = -100; // 重置到左侧外
                            raptor.y = GAME_HEIGHT * 0.3 + Math.random() * (GAME_HEIGHT * 0.2);
                            
                            // 这里不增加循环次数，因为这是一个完整的来回
                            console.log("猛禽进入阶段2: 等待后从左侧飞入");
                        }
                    }
                    break;
                    
                case 2: // c) 从左侧飞入至右侧飞出
                    if (patrolDuration < raptor.chasedPatrolDelay) {
                        // 等待延迟
                        // 位置已经在上一个阶段设置好了
                    } else {
                        // 从左侧飞入
                        raptor.x += raptor.speed * raptor.direction;
                        raptor.y += Math.sin(gameTime * 0.005) * 1;
                        
                        // 飞出右侧后回到阶段1，增加循环次数
                        if (raptor.x > GAME_WIDTH + 100) {
                            raptor.chasedPatrolStage = 1;
                            raptor.chasedPatrolStartTime = gameTime;
                            raptor.chasedPatrolDelay = 1000 + Math.random() * 1000;
                            raptor.chasedPatrolLoops++;
                            raptor.direction = -1; // 向左飞
                            raptor.x = GAME_WIDTH + 100; // 重置到右侧外
                            raptor.y = GAME_HEIGHT * 0.3 + Math.random() * (GAME_HEIGHT * 0.2);
                            console.log("猛禽回到阶段1: 等待后从右侧飞入，循环次数: " + raptor.chasedPatrolLoops + "/" + raptor.maxPatrolLoops);
                            
                            // 检查循环次数
                            if (raptor.chasedPatrolLoops >= raptor.maxPatrolLoops) {
                                // 如果喜鹊或乌鸦还没有放弃追逐，猛禽飞离
                                const remainingChasers = chasingMagpiesCrows.filter(c => c.chasingTarget === raptor);
                                if (remainingChasers.length > 0) {
                                    raptor.isChasedPatrolling = false;
                                    raptor.isFleeingFromChasers = true;
                                    raptor.fleeFromChasersStartTime = gameTime;
                                    raptor.fleeDirection = -1;
                                    raptor.fleeSpeed = raptor.originalSpeed * 1.2;
                                    raptor.state = 'fleeingFromChasers';
                                    raptor.hasPatrolStarted = false;
                                    raptor.hasBeenChased = true; // 标记为已被追逐过
                                    
                                    // 清除追逐者
                                    for (let j = chasingMagpiesCrows.length - 1; j >= 0; j--) {
                                        const chaser = chasingMagpiesCrows[j];
                                        if (chaser.chasingTarget === raptor) {
                                            chaser.isChasingRaptor = false;
                                            chaser.chasingTarget = null;
                                            if (chaser.originalState) {
                                                chaser.state = chaser.originalState;
                                            }
                                            if (chaser.originalSpeed) {
                                                chaser.speed = chaser.originalSpeed;
                                            }
                                            chasingMagpiesCrows.splice(j, 1);
                                        }
                                    }
                                    console.log("猛禽飞离，循环完成，标记为已被追逐过");
                                } else {
                                    // 没有追逐者了，恢复正常并标记为已被追逐过
                                    raptor.isChasedPatrolling = false;
                                    raptor.hasPatrolStarted = false;
                                    raptor.hasBeenChased = true; // 标记为已被追逐过
                                    if (raptor.originalState) {
                                        raptor.state = raptor.originalState;
                                    }
                                    if (raptor.originalSpeed) {
                                        raptor.speed = raptor.originalSpeed;
                                    }
                                    console.log("猛禽恢复正常，无追逐者，标记为已被追逐过");
                                }
                            }
                        }
                    }
                    break;
            }
        }
        
        if (raptor.isFleeingFromChasers && raptor.state === 'fleeingFromChasers') {
            const fleeAngle = (15 + Math.random() * 10) * Math.PI / 180;
            raptor.x += raptor.fleeSpeed * raptor.fleeDirection * Math.cos(fleeAngle);
            raptor.y -= raptor.fleeSpeed * Math.sin(fleeAngle);
            
            // 飞出屏幕后移除
            if (raptor.x < -500 || raptor.x > GAME_WIDTH + 500 || raptor.y < -500) {
                const index = birds.indexOf(raptor);
                if (index !== -1) {
                    birds.splice(index, 1);
                    console.log("猛禽飞出屏幕被移除");
                }
            }
        }
    });
    
    // 更新追逐者位置（针对正在追逐的猛禽）
    chasingMagpiesCrows.forEach(chaser => {
        if (chaser.chasingTarget && birds.includes(chaser.chasingTarget)) {
            const raptor = chaser.chasingTarget;
            const dx = raptor.x - chaser.x;
            const dy = raptor.y - chaser.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const birdSize = 20 * chaser.size;
            const targetDistance = birdSize * 1.5;
            
            const angle = Math.atan2(dy, dx);
            const targetX = raptor.x - Math.cos(angle) * targetDistance;
            const targetY = raptor.y - Math.sin(angle) * targetDistance;
            const targetDx = targetX - chaser.x;
            const targetDy = targetY - chaser.y;
            const targetDist = Math.sqrt(targetDx * targetDx + targetDy * targetDy);
            
            if (targetDist > 5) {
                chaser.x += (targetDx / targetDist) * chaser.speed;
                chaser.y += (targetDy / targetDist) * chaser.speed;
                chaser.direction = targetDx > 0 ? 1 : -1;
            } else {
                chaser.speed = raptor.speed;
                chaser.x = targetX;
                chaser.y = targetY;
                chaser.direction = raptor.direction;
            }
        }
    });
    
    let hasKestrel = false;
    for (const bird of birds) {
        if (bird.name === "红隼") {
            hasKestrel = true;
            break;
        }
    }
    
    if (!isNightMode && gameTime - lastDoveSummonCheck > DOVE_SUMMON_INTERVAL && !hasKestrel) {
        let doveCount = 0;
        for (const bird of birds) {
            if (bird.name === "斑鸠") {
                doveCount++;
            }
        }
        if (doveCount >= 2 && Math.random() < 0.8) {
            generateKestrel(true);
        }
        lastDoveSummonCheck = gameTime;
    }
    
    // 更新普通鸟类的行为
    for (let i = birds.length - 1; i >= 0; i--) {
        const bird = birds[i];
    
    // 翠鸟特殊行为逻辑
    if (bird.isKingfisher) {
      updateKingfisher(bird, deltaTime);
      continue;
    }
        // 长耳鸮的特殊消失逻辑
    if (bird.name === "长耳鸮" && bird.state === 'perching') {
      bird.stateTime += deltaTime;
      
      // 停留时间结束后直接消失（不是飞离）
      if (bird.stateTime >= (bird.stayTime * 1000)) {
        // 直接移除，不从树上飞离
        birds.splice(i, 1);
        continue;
 // 第3项修改开始：小组协调逻辑
    if (bird.groupId && birdGroupInfo[bird.groupId]) {
        const group = birdGroupInfo[bird.groupId];

        // 为金眶鸻和12000鸻添加小组协调
        if ((bird.name === "金眶鸻" || bird.name === "12000鸻") && group.behavior) {
            // 如果小组决定降落芦苇，确保所有成员都执行
            if (group.behavior === "landOnReeds" && reedZone) {
                // 如果这只鸟不在降落状态，但小组在降落，则让它也开始降落
                if (!bird.isLandingOnReeds && bird.state !== 'landingOnReeds' && bird.state !== 'onReedsGround') {
                    bird.reedTargetX = group.reedTargetX + (Math.random() - 0.5) * 40;
                    bird.reedTargetY = group.reedTargetY + (Math.random() - 0.5) * 15;
                    bird.state = 'landingOnReeds';
                    bird.groundDirection = group.groundDirection;
                    bird.isLandingOnReeds = true;
                }
            }

            // 如果小组决定飞走，确保所有成员都离开
            if (group.behavior === "flyThrough") {
                // 确保所有成员都在飞行状态
                if (bird.state === 'landingOnReeds' || bird.state === 'onReedsGround') {
                    bird.state = 'takingOff';
                    bird.stateTime = 0;
                    bird.speed = 2.5 + Math.random();
                    bird.direction = group.direction;
                    bird.isLandingOnReeds = false;
                }
            }
        }
    }
      }
    }
        // 跳过特殊状态的鸟
        if (bird.isChasingRaptor || bird.isFleeingFromChasers || bird.isChasedPatrolling) {
            continue;
        }
        
        // 处理被猛禽惊吓的鸟
        if (bird.isFleeingFromRaptor && !(bird.name === "金眶鸻" || bird.name === "12000鸻")) {
            const fleeAngle = (10 + Math.random() * 10) * Math.PI / 180;
            bird.x += bird.speed * bird.direction * Math.cos(fleeAngle);
            bird.y -= bird.speed * Math.sin(fleeAngle);
            
            if (bird.x < -500 || bird.x > GAME_WIDTH + 500 || bird.y < -500 || bird.y > GAME_HEIGHT + 500) {
                birds.splice(i, 1);
            }
            continue;
        }
                     
    
    
    if (bird.isHidingFromRaptor) {
        continue;
    }
    
    if (bird.isChasingRaptor) {
        continue;
    }
    
    if (bird.isFleeingFromChasers) {
        continue;
    }
    
    bird.stateTime += deltaTime;
    
    if (bird.name === "小鸮") {
        if (bird.state === 'appearing') {
            bird.state = 'perching';
        }
        
        if (bird.stateTime > (bird.stayTime || 15) * 1000) {
            if (littleOwl === bird) {
                littleOwl = null;
            }
            birds.splice(i, 1);
            continue;
        }
        continue;
    }
    
    if (bird.isBat) {
        updateBat(bird, deltaTime);
        continue;
    }
    
    if (bird.isOwl) {
        updateOwlBird(bird, deltaTime);
        continue;
    }
    
    const behavior = bird.actualBehavior || bird.type.behavior;
    
    if (bird.state === 'perching' && bird.eatFruits && !bird.isEating) {
            if (Math.random() < bird.eatProbability * (deltaTime / 1000)) {
                startEatingFruit(bird);
            }
        }
        
        if (bird.isEating && bird.eatingFruit) {
            bird.eatingTime += deltaTime;
            bird.eatAnimationOffset = Math.sin(bird.eatingTime * 0.01) * 3;
            bird.size = bird.originalSize + Math.sin(bird.eatingTime * 0.005) * 0.1;
            
            if (bird.eatingTime > bird.eatDuration) {
                finishEatingFruit(bird);
            }
        }
        
if (bird.name === "乌鸫" && bird.state === 'flying') {
            if (!bird.lastPoopTime) {
                bird.lastPoopTime = gameTime;
            }
            
            // 检查是否到了拉屎的时间间隔
            if (gameTime - bird.lastPoopTime > bird.poopInterval) {
                // 检查概率
                if (Math.random() < bird.poopProbability) {
                    // 计算粪便位置
                    let poopX, poopY;
                    const baseSize = 20;
                    const birdSize = baseSize * bird.size;
                    const bodyRadius = birdSize / 2;
                    
                    // 创建粪便
                    const poopSize = (2.5 + Math.random());
                    const poop = {
                        x: bird.x,
            y: bird.y + bodyRadius,
                        size: poopSize,
                        color: bird.poopColor || "#FFFFFF",
                        speed: 1 + Math.random() * 0.5,
                        createdAt: gameTime,
                        lifetime: 10000, // 10秒后消失
                        direction: bird.direction
                    };
                    
                    poops.push(poop);
                }
                // 无论是否拉屎，都重置计时器
                bird.lastPoopTime = gameTime;
            }
        }
        
        if (bird.name === "啄木鸟" && bird.state === 'perching') {
            if (bird.stateTime % 1000 < 200) {
                bird.headOffsetX = 5 * (bird.targetTree.side === 'left' ? 1 : -1);
            } else {
                bird.headOffsetX = 0;
            }
        }
  
// 修复：确保观鸟模式下树栖鸟的离开行为正常工作
if (bird.state === 'perching' && bird.targetTree) {
  // 确保观鸟模式不影响离开时间
  if (bird.stateTime > (bird.stayTime || 10) * 1000) {
// 如果是长耳鸮，则跳过通用处理
        if (bird.name === "长耳鸮") {
            continue;
        }
    // 如果鸟有离开条件（比如吃完果实），就离开
    if (!bird.isEating || bird.eatingTime > (bird.eatDuration || 2000)) {
      bird.state = 'takingOff';
      bird.speed = 2.0;
      bird.direction = bird.targetTree.side === 'left' ? 1 : -1;
      bird.stateTime = 0;
      // 修复：确保鸟不会在观鸟模式下卡住
      bird.isChasingRaptor = false;
      bird.isFleeingFromRaptor = false;
      bird.isFleeingFromChasers = false;
    }
  }
}      
        // 在 updateBirds 函数中，找到棕头鸦雀的处理部分，修改如下：

if (bird.name === "棕头鸦雀" && behavior === "flyInReedsAndStay") {
    // 确保每只鸟都有速度差异参数（在进入芦苇区时初始化）
    if (!bird.reedSpeedFactor) {
        // 为每只鸟生成随机速度差异参数（±25%，最大50%差异）
        bird.reedSpeedFactor = 0.75 + Math.random() * 0.5; // 0.75 ~ 1.25
    }
    
    if (bird.state === 'flying') {
        if (bird.y < reedZone.y) {
            bird.y = reedZone.y + Math.random() * 10;
        } else if (bird.y > reedZone.y + reedZone.height) {
            bird.y = reedZone.y + reedZone.height - Math.random() * 10;
        }
        
        if (bird.x > reedZone.x && bird.x < reedZone.x + reedZone.width) {
            bird.state = 'stayingInReeds';
            bird.stateTime = 0;
            // 应用个体速度差异
            bird.speed = 0.5 * bird.reedSpeedFactor; // 基准速度0.5，乘以速度因子
        }
    } else if (bird.state === 'stayingInReeds') {
        // 应用个体速度差异的横向移动
        bird.x += bird.speed * bird.direction;
        bird.y += Math.sin(bird.stateTime * 0.005) * 0.3;
        
        if (bird.x < reedZone.x || bird.x > reedZone.x + reedZone.width) {
            bird.state = 'takingOff';
            // 起飞速度也应用个体差异
            bird.speed = 1.0 * bird.reedSpeedFactor;
            if (bird.groupId && birdGroupInfo[bird.groupId]) {
                bird.direction = birdGroupInfo[bird.groupId].direction;
            }
        }
    }
}
        
// 在 updateBirds 函数中，修改麻雀和小北的处理逻辑：

if ((bird.name === "麻雀" || bird.name === "小北") && 
    (bird.actualBehavior === "flyToReedsAndStay" || 
     bird.type.behavior === "flyToReedsAndStay")) {
    
    let reedStayTime = bird.reedStayTime;
    if (!reedStayTime) {
        reedStayTime = bird.name === "麻雀" ? 15000 : 20000;
    }
    
    let reedMoveSpeed = bird.reedMoveSpeed;
    if (!reedMoveSpeed) {
        reedMoveSpeed = bird.name === "麻雀" ? 0.5 * 0.2 : 0.6 * 0.2; // 降为原来的1/5
    }
    
    switch (bird.state) {
        case 'flying':
            // 只在进入芦苇区前设置一次目标点，避免重复设置导致跳变
            if (!bird.reedTargetX && reedZone) {
                // 设置目标点在芦苇区中心三分之一区域内
                const centerThirdWidth = reedZone.width / 3;
                const centerThirdLeft = reedZone.x + reedZone.width / 3;
                
                bird.reedTargetX = centerThirdLeft + Math.random() * centerThirdWidth;
                bird.reedTargetY = reedZone.y + reedZone.height * 0.5 + Math.random() * reedZone.height * 0.3;
                
                // 记录开始降落的时间，用于平滑过渡
                bird.landingStartTime = gameTime;
                bird.landingDuration = (1000 + Math.random() * 500) * 5; // 延长5倍，降低速度
                bird.landingStartX = bird.x;
                bird.landingStartY = bird.y;
                
                // 降低飞行速度到原来的1/5
                bird.speed *= 0.2;
            }
            
            if (bird.reedTargetX && bird.reedTargetY) {
                const elapsedTime = gameTime - bird.landingStartTime;
                const progress = Math.min(elapsedTime / bird.landingDuration, 1);
                
                // 使用缓动函数实现平滑降落
                const easeProgress = easeInOutQuad(progress);
                
                // 计算平滑的降落位置
                bird.x = bird.landingStartX + (bird.reedTargetX - bird.landingStartX) * easeProgress;
                bird.y = bird.landingStartY + (bird.reedTargetY - bird.landingStartY) * easeProgress;
                
                // 在降落过程中保持合理的速度感
                const speedFactor = 1 - (progress * 0.7); // 越接近目标速度越慢
                bird.direction = (bird.reedTargetX - bird.landingStartX) > 0 ? 1 : -1;
                
                // 当非常接近目标点时，切换到停留状态
                if (progress >= 0.95 || elapsedTime > bird.landingDuration) {
                    // 确保最终位置在芦苇区内
                    const centerThirdWidth = reedZone.width / 3;
                    const centerThirdLeft = reedZone.x + reedZone.width / 3;
                    const centerThirdRight = centerThirdLeft + centerThirdWidth;
                    
                    bird.x = Math.max(centerThirdLeft, Math.min(centerThirdRight, bird.reedTargetX));
                    bird.y = Math.max(reedZone.y, Math.min(reedZone.y + reedZone.height, bird.reedTargetY));
                    
                    // 平滑切换到停留状态
                    bird.state = 'stayingInReeds';
                    bird.stateTime = 0;
                    bird.speed = reedMoveSpeed;
                    bird.reedStayTime = reedStayTime;
                    
                    // 设置一个小的随机移动范围，避免完全静止
                    bird.reedsMoveRangeX = 15;
                    bird.reedsMoveRangeY = 8;
                    bird.reedsMoveTimer = 0;
                    bird.reedsMoveSpeed = (0.2 + Math.random() * 0.3) * 1; 
                    
                    // 清除降落数据
                    bird.reedTargetX = null;
                    bird.reedTargetY = null;
                    bird.landingStartTime = null;
                }
            }
            break;
            
        case 'stayingInReeds':
    bird.stateTime += deltaTime;
    
    // 初始化跳跃相关属性
    if (bird.jumpInterval === undefined) {
        bird.jumpInterval = 2000 + Math.random() * 3000; // 2-5秒随机间隔
        bird.lastJumpTime = gameTime;
        bird.jumpDirection = bird.direction; // 头部朝向决定跳跃方向
    }
    
    // 检查是否到达芦苇顶部
    const reedTopThreshold = reedZone.y + 20; // 芦苇顶部阈值
    if (bird.y <= reedTopThreshold && !bird.reachedTop) {
        bird.reachedTop = true;
        bird.topStayStartTime = gameTime;
        bird.speed = 0; // 到达顶部后停止移动
    }
    
    // 如果到达顶部，停留5秒后离开
    if (bird.reachedTop) {
        if (gameTime - bird.topStayStartTime > 5000) {
            bird.state = 'takingOffFromReeds';
            bird.stateTime = 0;
            bird.speed = (bird.name === "麻雀" ? 1.5 : 1.3);
            bird.direction = Math.random() > 0.5 ? 1 : -1;
            bird.takeoffStartX = bird.x;
            bird.takeoffStartY = bird.y;
            bird.takeoffStartTime = gameTime;
            bird.takeoffDuration = (1000 + Math.random() * 500) * 3;
            bird.takeoffTargetX = bird.x + (bird.direction === 1 ? 300 : -300);
            bird.takeoffTargetY = -50;
        }
        continue;
    }
    
    // 每隔1-5秒跳跃一次
    if (gameTime - bird.lastJumpTime > bird.jumpInterval) {
        bird.lastJumpTime = gameTime;
        bird.jumpInterval = 1000 + Math.random() * 4000; // 重新设置跳跃间隔
        
        // 根据头部朝向决定跳跃方向
        const jumpAngle = bird.jumpDirection === 1 ? 
            -Math.PI/4 :  // 向右上跳（45度角）
            -3*Math.PI/4; // 向左上跳（135度角）
        
        // 跳跃距离（一个身位）
        const jumpDistance = 40 * bird.size;
        
        // 计算新位置
        const newX = bird.x + Math.cos(jumpAngle) * jumpDistance;
        const newY = bird.y + Math.sin(jumpAngle) * jumpDistance;
        
        // 检查是否在芦苇区域内
        const centerThirdWidth = reedZone.width / 3;
        const centerThirdLeft = reedZone.x + reedZone.width / 3;
        const centerThirdRight = centerThirdLeft + centerThirdWidth;
        
        // 限制在芦苇区域内
        bird.x = Math.max(centerThirdLeft, Math.min(centerThirdRight, newX));
        bird.y = Math.max(reedZone.y, Math.min(reedZone.y + reedZone.height, newY));
        
        // 跳跃动画效果
        bird.isJumping = true;
        bird.jumpStartTime = gameTime;
        bird.jumpDuration = 300; // 跳跃动画持续时间
        bird.originalY = bird.y;
    }
    
    // 跳跃动画
    if (bird.isJumping) {
        const jumpElapsed = gameTime - bird.jumpStartTime;
        const jumpProgress = Math.min(jumpElapsed / bird.jumpDuration, 1);
        
        // 使用缓动函数使跳跃更自然
        const easeProgress = easeInOutQuad(jumpProgress);
        
        // 计算跳跃高度（抛物线轨迹）
        const maxJumpHeight = 10; // 最大跳跃高度
        const jumpHeight = 4 * maxJumpHeight * easeProgress * (1 - easeProgress);
        
        bird.y = bird.originalY - jumpHeight;
        
        // 跳跃结束
        if (jumpProgress >= 1) {
            bird.isJumping = false;
            bird.y = bird.originalY; // 回到原始高度
        }
    }
    
   
    // 检查总停留时间是否结束
    if (bird.stateTime > bird.reedStayTime && !bird.reachedTop) {
        bird.state = 'takingOffFromReeds';
        bird.stateTime = 0;
        bird.speed = (bird.name === "麻雀" ? 1.5 : 1.3);
        bird.direction = Math.random() > 0.5 ? 1 : -1;
        bird.takeoffStartX = bird.x;
        bird.takeoffStartY = bird.y;
        bird.takeoffStartTime = gameTime;
        bird.takeoffDuration = (1000 + Math.random() * 500) * 3;
        bird.takeoffTargetX = bird.x + (bird.direction === 1 ? 300 : -300);
        bird.takeoffTargetY = -50;
    }
    break;
            
// 在 updateBirds 函数中，修改麻雀和小北的起飞阶段：

case 'takingOffFromReeds':
    bird.stateTime += deltaTime;
    if (!bird.takeoffInitialized) {
        bird.takeoffInitialized = true;
        bird.takeoffSpeed = bird.speed;
        // 修改这里：起飞角度不超过20度
        bird.takeoffAngle = (10 + Math.random() * 10) * Math.PI / 180; // 10-20度
        bird.takeoffVx = Math.cos(bird.takeoffAngle) * bird.takeoffSpeed * bird.direction;
        bird.takeoffVy = -Math.sin(bird.takeoffAngle) * bird.takeoffSpeed;
        bird.startTakeoffY = bird.y;
        bird.maxClimbHeight = Math.max(GAME_HEIGHT * 0.3, reedZone.y - 50);
    }
    bird.x += bird.takeoffVx;
    bird.y += bird.takeoffVy;
    if (bird.y < bird.maxClimbHeight) {
        bird.y = bird.maxClimbHeight;
        bird.takeoffVy = 0;
        if (bird.y < bird.startTakeoffY - 50) {
            bird.takeoffVy = -bird.takeoffSpeed * 0.1;
        }
    }
    const margin = 100;
    if (bird.x < -margin || bird.x > GAME_WIDTH + margin || bird.y < -margin || bird.y > GAME_HEIGHT + margin) {
        birds.splice(i, 1);
    }
    if (bird.stateTime > 15000) {
        birds.splice(i, 1);
    }
    break;
    }
    
    if (bird.state === 'stayingInReeds' || bird.state === 'takingOffFromReeds') {
        continue;
    }
}

// 修改其他鸟类在芦苇区的行为，使其适应新的芦苇区宽度
if ((bird.name === "金眶鸻" || bird.name === "12000鸻") && bird.isLandingOnReeds) {
    switch (bird.state) {
        case 'landingOnReeds':
            // 在金眶鸻和12000鸻的代码中，修改目标点选择：
if (!bird.reedTargetX && reedZone) {
    // 在整个芦苇区宽度内选择目标点（注意芦苇区左侧有200像素缩进）
    bird.reedTargetX = reedZone.x + Math.random() * reedZone.width;
    bird.reedTargetY = reedZone.y + reedZone.height - 3;
}
            
            if (bird.reedTargetX && bird.reedTargetY) {
                const dx = bird.reedTargetX - bird.x;
                const dy = bird.reedTargetY - bird.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 2) {
                    bird.state = 'onReedsGround';
                    bird.groundTime = 0;
                    bird.groundDirection = Math.random() > 0.5 ? 1 : -1;
                    bird.speed = bird.groundMoveSpeed || 0.3;
                } else {
                    bird.x += (dx / distance) * 2;
                    bird.y += (dy / distance) * 2;
                }
            }
            break;
            
case 'onReedsGround':
    bird.groundTime += deltaTime;
    
    // ✅ 新增：小组协调地面移动
    // 如果有小组信息，使用小组统一的地面移动方向
    if (bird.groupId && birdGroupInfo[bird.groupId] && 
        (bird.name === "金眶鸻" || bird.name === "12000鸻")) {
        
        const group = birdGroupInfo[bird.groupId];
        
        // 使用小组统一的地面移动方向
        if (group.groundDirection) {
            bird.groundDirection = group.groundDirection;
        }
        
        // 如果小组有统一的目标位置，确保鸟不要离得太远
        if (group.reedTargetX) {
            const distanceFromGroupCenter = Math.abs(bird.x - group.reedTargetX);
            
            // 如果离小组中心太远（超过30像素），调整方向向中心移动
            if (distanceFromGroupCenter > 30) {
                bird.groundDirection = bird.x > group.reedTargetX ? -1 : 1;
                // 更新小组方向，确保其他成员也跟随
                group.groundDirection = bird.groundDirection;
            }
        }
        
        // ✅ 小组统一改变方向的逻辑
        // 不再每只鸟独立改变方向，而是由小组统一决定
        // 当小组统一改变方向时，所有成员一起改变
        if (group.lastDirectionChange && (bird.groundTime - group.lastDirectionChange) > 3000) {
            // 每3秒小组可能改变方向
            if (Math.random() < 0.3) { // 30%概率改变方向
                group.groundDirection *= -1;
                group.lastDirectionChange = bird.groundTime;
            }
        } else if (!group.lastDirectionChange) {
            group.lastDirectionChange = bird.groundTime;
        }
    } else {
        // 原有的独立行为：每3秒可能独立改变方向
        if (bird.groundTime % 3000 < deltaTime) {
            bird.groundDirection = Math.random() > 0.5 ? 1 : -1;
        }
    }
    
    // 缓慢移动（使用小组协调后的方向）
    bird.x += (bird.groundMoveSpeed || 0.3) * bird.groundDirection;
    
    // 保持在芦苇区内（考虑小组协调）
    if (bird.x < reedZone.x) {
        bird.x = reedZone.x;
        bird.groundDirection = 1;
        // 如果是小组，更新小组方向
        if (bird.groupId && birdGroupInfo[bird.groupId]) {
            birdGroupInfo[bird.groupId].groundDirection = 1;
        }
    } else if (bird.x > reedZone.x + reedZone.width) {
        bird.x = reedZone.x + reedZone.width;
        bird.groundDirection = -1;
        // 如果是小组，更新小组方向
        if (bird.groupId && birdGroupInfo[bird.groupId]) {
            birdGroupInfo[bird.groupId].groundDirection = -1;
        }
    }
    
    // 啄食动画
    if (bird.groundTime % 1500 < deltaTime) {
        bird.peckingState = 1; // 开始啄食
        bird.peckingTimer = 0;
    }
    
    if (bird.peckingState > 0) {
        bird.peckingTimer += deltaTime;
        if (bird.peckingTimer > 200) {
            bird.peckingState = 0; // 啄食结束
        }
    }
    
    // ✅ 新增：小组统一停留时间，避免有的鸟飞走有的留下
    // 计算停留时间时考虑小组统一性
    let adjustedStayTime = (bird.stayTime || 30) * 1000;
    
    // 如果有小组，使用小组统一的停留时间
    if (bird.groupId && birdGroupInfo[bird.groupId]) {
        const group = birdGroupInfo[bird.groupId];
        
        // 记录小组开始停留的时间（如果没有记录的话）
        if (!group.groundStartTime) {
            group.groundStartTime = bird.groundTime;
        }
        
        // 计算小组已经停留的时间
        const groupStayTime = bird.groundTime - group.groundStartTime;
        
        // 如果小组停留时间到了，所有成员一起起飞
        if (groupStayTime > adjustedStayTime) {
            bird.state = 'takingOff';
            bird.speed = 1.5 + Math.random() * 0.5;
            bird.direction = Math.random() > 0.5 ? 1 : -1;
            
            // 如果是小组，确保所有成员有相同的起飞方向
            if (group.groundDirection) {
                bird.direction = group.groundDirection > 0 ? 1 : -1;
            }
            
            continue;
        }
    } else {
        // 原有的独立起飞逻辑
        if (bird.groundTime > adjustedStayTime) {
            bird.state = 'takingOff';
            bird.speed = 1.5;
            bird.direction = Math.random() > 0.5 ? 1 : -1;
        }
    }
    break;
    }
    
    if (bird.state === 'landingOnReeds' || bird.state === 'onReedsGround') {
        continue;
    }
}
        
        if (bird.name === "黑翅鸢" && bird.state === 'circling' && !bird.hasGeneratedMouse) {
            bird.mouseTarget = generateGroundMouseForPredator(bird.name);
            bird.hasGeneratedMouse = true;
            bird.circlingTime = 0;
        }
        
        switch (bird.state) {
            case 'circling':
                bird.circlingTime += deltaTime;
                
                
                bird.circlingAngle += 0.01;
                bird.x = bird.circlingCenterX + Math.cos(bird.circlingAngle) * bird.circlingRadius;
                bird.y = bird.circlingCenterY + Math.sin(bird.circlingAngle) * bird.circlingRadius;
                
                const tangentAngle = bird.circlingAngle + Math.PI / 2;
                bird.direction = Math.cos(tangentAngle) > 0 ? 1 : -1;
                
                if (bird.name === "红隼" && !bird.mouseTarget) {
                    for (let j = groundObjects.length - 1; j >= 0; j--) {
                        const mouse = groundObjects[j];
                        if (mouse.type === "mouse" && mouse.predatorTarget === "红隼") {
                            bird.mouseTarget = mouse;
                            bird.hasFoundMouse = true;
                            break;
                        }
                    }
                }
                
                if (bird.name === "黑翅鸢" && !bird.hasGeneratedMouse) {
                    bird.mouseTarget = generateGroundMouseForPredator(bird.name);
                    bird.hasGeneratedMouse = true;
                    bird.circlingTime = 0;
                }
                
                if (bird.name === "黑翅鸢" && bird.huntingMouse) {
                    if (bird.circlingTime > 2000 + Math.random() * 2000) {
                        bird.state = 'hovering';
                        bird.speed = 0;
                        bird.hoveringTime = 0;
                    }
                } else if (bird.name === "红隼" && bird.isPredator) {
                    if (bird.circlingTime > 2000 + Math.random() * 2000) {
                        if (bird.mouseTarget) {
                            bird.state = 'hovering';
                            bird.speed = 0;
                            bird.hoveringTime = 0;
                        } else {
                            bird.state = 'hunting';
                            bird.speed = (3 + Math.random() * 2);
                            bird.direction = Math.random() > 0.5 ? 1 : -1;
                        }
                    }
                } else if (bird.name === "游隼" && bird.huntingBird) {
                    if (bird.circlingTime > 2000 + Math.random() * 2000) {
                        bird.state = 'huntingBird';
                        bird.speed = (3 + Math.random() * 2) * 3;
                        bird.direction = Math.random() > 0.5 ? 1 : -1;
                    }
                }
                break;
                
            case 'divingToMouse':
                if (bird.mouseTarget && bird.mouseTarget.type === "mouse") {
                    const dx = bird.mouseTarget.x - bird.x;
                    const dy = bird.mouseTarget.y - bird.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < 25) {
                        if (Math.random() < bird.catchMouseChance) {
                            bird.caughtMouse = { x: 0, y: 0, size: 8, type: "mouse" };
                            bird.state = 'flyingWithMouse';
                            bird.speed = 1.5;
                            bird.direction = 1;
                            
                            const index = groundObjects.indexOf(bird.mouseTarget);
                            if (index !== -1) {
                                groundObjects.splice(index, 1);
                            }
                            bird.mouseTarget = null;
                            
                            scareMode = true;
                            scareModeEndTime = gameTime + 5000;
                        } else {
                            const index = groundObjects.indexOf(bird.mouseTarget);
                            if (index !== -1) {
                                groundObjects.splice(index, 1);
                            }
                            bird.mouseTarget = null;
                            bird.state = 'takingOffToCircle';
                            bird.speed = 1.5;
                            bird.direction = 1;
                            bird.takeoffStartTime = gameTime;
                            bird.takeoffDuration = 3000;
                            bird.startX = bird.x;
                            bird.startY = bird.y;
                            bird.targetX = bird.circlingCenterX;
                            bird.targetY = bird.circlingCenterY;
                            bird.hasGeneratedMouse = false;
                        }
                    } else {
                        bird.x += (dx / distance) * bird.speed;
                        bird.y += (dy / distance) * bird.speed;
                        bird.direction = dx > 0 ? 1 : -1;
                    }
                } else {
                    bird.state = 'takingOffToCircle';
                    bird.speed = 1.5;
                    bird.direction = 1;
                    bird.takeoffStartTime = gameTime;
                    bird.takeoffDuration = 3000;
                    bird.startX = bird.x;
                    bird.startY = bird.y;
                    bird.targetX = bird.circlingCenterX;
                    bird.targetY = bird.circlingCenterY;
                    bird.mouseTarget = null;
                    bird.hasGeneratedMouse = false;
                }
                break;
                
            case 'takingOffToCircle':
                const elapsedTime = gameTime - bird.takeoffStartTime;
                const progress = Math.min(elapsedTime / bird.takeoffDuration, 1);
                const easeProgress = easeInOutQuad(progress);
                
                bird.x = bird.startX + (bird.targetX - bird.startX) * easeProgress;
                bird.y = bird.startY + (bird.targetY - bird.startY) * easeProgress;
                
                if (progress < 0.3) {
                    bird.y -= 1;
                } else if (progress < 0.7) {
                    bird.y -= 0.5;
                } else {
                    bird.y += 0.2;
                }
                
                bird.direction = (bird.targetX - bird.startX) > 0 ? 1 : -1;
                
                if (progress >= 1) {
                    bird.state = 'circling';
                    bird.circlingTime = 0;
                    bird.circlingAngle = Math.random() * Math.PI * 2;
                    bird.x = bird.targetX;
                    bird.y = bird.targetY;
                }
                break;
                
            case 'followingMousePath':
                if (bird.mouseFlightIndex < bird.mouseFlightPath.length) {
                    const targetPoint = bird.mouseFlightPath[bird.mouseFlightIndex];
                    const dx = targetPoint.x - bird.x;
                    const dy = targetPoint.y - bird.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < 5) {
                        bird.mouseFlightIndex++;
                    } else {
                        bird.x += (dx / distance) * bird.speed;
                        bird.y += (dy / distance) * bird.speed;
                        bird.direction = dx > 0 ? 1 : -1;
                    }
                    
                    if (bird.mouseFlightIndex >= bird.mouseFlightPath.length) {
                        if (bird.name === "黑翅鸢") {
                            bird.state = 'huntingMouse';
                            bird.hasLanded = false;
                            bird.groundTime = 0;
                        } else if (bird.name === "游隼") {
                            bird.state = 'huntingBird';
                        }
                    }
                }
                break;
                
            case 'hovering':
                bird.hoveringTime += deltaTime;
                bird.y += Math.sin(bird.hoveringTime * 0.005) * 0.5;
                
                if (bird.name === "红隼") {
                    if (bird.hoveringTime > 3000) {
                        if (bird.mouseTarget && bird.mouseTarget.type === "mouse") {
                            bird.state = 'divingToMouse';
                            bird.speed = 3.0;
                        } else {
                            bird.state = 'hunting';
                            bird.speed = 3 + Math.random() * 2;
                            bird.direction = Math.random() > 0.5 ? 1 : -1;
                        }
                    }
                } else if (bird.hoveringTime > 5000) {
                    bird.state = 'huntingMouse';
                    bird.speed = 3 + Math.random() * 2;
                    bird.direction = Math.random() > 0.5 ? 1 : -1;
                }
                break;
                
            case 'huntingMouse':
                if (!bird.hasLanded) {
                    bird.x += bird.speed * bird.direction * 0.3;
                    bird.y += bird.speed * 1.5;
                    
                    if (bird.y >= GAME_HEIGHT - 50) {
                        bird.hasLanded = true;
                        bird.groundTime = 0;
                        bird.y = GAME_HEIGHT - 30;
                    }
                } else {
                    bird.groundTime += deltaTime;
                    if (bird.groundTime > 500 && !bird.caughtMouse) {
                        if (Math.random() < 0.5) {
                            bird.caughtMouse = { x: 0, y: 0, size: 8 };
                            bird.state = 'flyingWithMouse';
                            bird.speed = 1.5;
                            bird.direction = 1;
                            scareMode = true;
                            scareModeEndTime = gameTime + 5000;
                        } else {
                            bird.state = 'takingOff';
                            bird.speed = 1.5;
                            bird.direction = 1;
                        }
                    }
                }
                
                if (bird.y > GAME_HEIGHT + 100) {
                    birds.splice(i, 1);
                }
                break;
                
            case 'hunting':
                bird.x += bird.speed * bird.direction * 0.3;
                if (bird.y < GAME_HEIGHT - 50) {
                    bird.y += bird.speed * 1.5;
                }
                
                if (bird.y >= GAME_HEIGHT - 50 && !bird.caughtDove && !bird.caughtMouse) {
                    bird.y = GAME_HEIGHT - 50;
                    
                    if (Math.random() < bird.catchDoveChance) {
                        bird.caughtDove = { x: 0, y: 0, size: 12 };
                        bird.state = 'flyingWithDove';
                        bird.speed = 1.5;
                        bird.direction = 1;
                        scareMode = true;
                        scareModeEndTime = gameTime + 5000;
                    } else if (Math.random() < bird.catchMouseChance) {
                        bird.caughtMouse = { x: 0, y: 0, size: 8 };
                        bird.state = 'flyingWithMouse';
                        bird.speed = 1.5;
                        bird.direction = 1;
                        scareMode = true;
                        scareModeEndTime = gameTime + 5000;
                    } else if (Math.random() < bird.leaveChance) {
                        bird.state = 'flyingAway';
                        bird.speed = 1.5;
                        bird.direction = 1;
                    } else {
                        bird.state = 'flyingAway';
                        bird.speed = 1.5;
                        bird.direction = 1;
                    }
                }
                
                if (bird.y > GAME_HEIGHT + 100) {
                    birds.splice(i, 1);
                }
                break;
                
            case 'huntingBird':
                bird.x += bird.speed * bird.direction * 0.3;
                bird.y += bird.speed * 1.5;
                
                if (bird.y > GAME_HEIGHT - 100 && !bird.caughtBird && Math.random() < 0.8) {
                    bird.caughtBird = { x: 0, y: 0, size: 10 };
                    bird.state = 'flyingWithBird';
                    bird.speed = 1.5;
                    bird.direction = 1;
                    bird.y -= 50;
                    scareMode = true;
                    scareModeEndTime = gameTime + 5000;
                }
                
                if (bird.y > GAME_HEIGHT + 100) {
                    birds.splice(i, 1);
                }
                break;
                
            case 'flyingWithMouse':
case 'flyingWithBird':
case 'flyingWithDove':
    // 水平斜上飞，角度不超过20度
    const flyingAwayAngle = (8 + Math.random() * 12) * Math.PI / 180; // 8-20度
    bird.x += bird.speed * Math.cos(flyingAwayAngle);
    bird.y -= bird.speed * Math.sin(flyingAwayAngle);
    if (bird.x > GAME_WIDTH + 100 || bird.y < -100) {
        birds.splice(i, 1);
    }
    break;
                
            case 'flying':
                let speedFactor = 1;
                if (bird.direction === -1 && !bird.isChasing && !bird.isBeingChased) {
                    speedFactor = 0.3;
                }
                
                if (bird.name === "麻雀") {
                    // 麻雀的原有行为：直接飞过屏幕
                    bird.x += bird.speed * bird.direction * speedFactor;
                    if ((bird.direction === 1 && bird.x > GAME_WIDTH + 200) || (bird.direction === -1 && bird.x < -200)) {
                        birds.splice(i, 1);
                        continue;
                    }
                } else if (bird.hunting) {
                    bird.x += bird.speed * bird.direction * speedFactor;
                    bird.y += bird.speed * 0.7 * speedFactor;
                } else {
                    bird.x += bird.speed * bird.direction * speedFactor;
                    if (behavior === 'waveFlight') {
                        bird.y += Math.sin(bird.stateTime * 0.01) * 2 * speedFactor;
                    }
                }
                
                if ((behavior === 'landOnTree' || behavior === 'appearOnTree') && bird.targetTree) {
                    const treeCenterX = bird.targetTree.x + bird.targetTree.width / 2;
                    const distanceToTree = Math.abs(bird.x - treeCenterX);
                    
                    if (distanceToTree < 50) {
                        bird.state = 'landing';
                        const tree = bird.targetTree;
                        const crownTopArea = {
                            x: tree.x + tree.width * 0.2,
                            y: tree.y + tree.height * 0.1,
                            width: tree.width * 0.6,
                            height: tree.height * 0.25
                        };
                        
                        if (bird.name === "喜鹊" || bird.name === "乌鸦") {
                            const targetX = crownTopArea.x + Math.random() * crownTopArea.width;
                            const targetY = crownTopArea.y + Math.random() * crownTopArea.height;
                            bird.targetX = targetX;
                            bird.targetY = targetY;
                        } else {
                            const treeCenterY = tree.y + tree.height * 0.35;
                            const angle = Math.atan2(treeCenterY - bird.y, treeCenterX - bird.x);
                            const distance = 30 + Math.random() * 20;
                            bird.targetX = bird.x + Math.cos(angle) * distance;
                            bird.targetY = bird.y + Math.sin(angle) * distance;
                            
                            bird.targetX = Math.max(tree.x, Math.min(tree.x + tree.width, bird.targetX));
                            bird.targetY = Math.max(tree.y, Math.min(tree.y + tree.height * 0.7, bird.targetY));
                        }
                    }
                }
                
                if ((bird.direction === 1 && bird.x > GAME_WIDTH + 200) || (bird.direction === -1 && bird.x < -200) || bird.y > GAME_HEIGHT + 200) {
                    birds.splice(i, 1);
                    continue;
                }
                break;
                
            case 'landing':
                const dx = bird.targetX - bird.x;
                const dy = bird.targetY - bird.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 2) {
                    bird.state = 'perching';
                    bird.x = bird.targetX;
                    bird.y = bird.targetY;
                    bird.speed = 0;
                } else {
                    let landingSpeedFactor = 1;
                    if (bird.direction === -1 && !bird.isChasing && !bird.isBeingChased) {
                        landingSpeedFactor = 0.3;
                    }
                    
                    bird.x += (dx / distance) * 2 * landingSpeedFactor;
                    bird.y += (dy / distance) * 2 * landingSpeedFactor;
                }
                break;
                
            case 'perching':
                if (bird.name === "长耳鸮") {
                    if (bird.stateTime > (bird.stayTime || 15) * 1000) {
                        birds.splice(i, 1);
                        continue;
                    }
                }
                
                if (behavior === 'landOnTreeThenMove') {
                    if (bird.stateTime > (bird.stayTimePerTree || 2000)) {
                        if (!bird.hasMovedToSecondTree) {
                            bird.state = 'movingToSecondTree';
                            bird.hasMovedToSecondTree = true;
                            bird.stateTime = 0;
                            
                            const currentTreeSide = bird.targetTree.side;
                            const oppositeTree = treePositions.find(tree => tree.side !== currentTreeSide);
                            
                            if (oppositeTree) {
                                bird.targetTree = oppositeTree;
                                const treeCenterX = oppositeTree.x + oppositeTree.width / 2;
                                const treeCenterY = oppositeTree.y + oppositeTree.height * 0.35;
                                const angle = Math.atan2(treeCenterY - bird.y, treeCenterX - bird.x);
                                const distance = 30 + Math.random() * 20;
                                
                                bird.targetX = bird.x + Math.cos(angle) * distance;
                                bird.targetY = bird.y + Math.sin(angle) * distance;
                                
                                bird.targetX = Math.max(oppositeTree.x, Math.min(oppositeTree.x + oppositeTree.width, bird.targetX));
                                bird.targetY = Math.max(oppositeTree.y, Math.min(oppositeTree.y + oppositeTree.height * 0.7, bird.targetY));
                                
                                bird.speed = 1.5;
                                bird.direction = bird.targetX > bird.x ? 1 : -1;
                            } else {
                                bird.state = 'takingOff';
                                bird.speed = 1;
                                if (bird.groupId && birdGroupInfo[bird.groupId]) {
                                    bird.direction = birdGroupInfo[bird.groupId].direction;
                                } else {
                                    bird.direction = Math.random() > 0.5 ? 1 : -1;
                                }
                            }
                        } else {
                            bird.state = 'takingOff';
                            bird.speed = 1;
                            if (bird.groupId && birdGroupInfo[bird.groupId]) {
                                bird.direction = birdGroupInfo[bird.groupId].direction;
                            } else {
                                bird.direction = Math.random() > 0.5 ? 1 : -1;
                            }
                        }
                    }
                } else {
                    if (bird.stateTime > (bird.stayTime || 10) * 1000) {
                        bird.state = 'takingOff';
                        bird.speed = 1;
                        if (bird.groupId && birdGroupInfo[bird.groupId]) {
                            bird.direction = birdGroupInfo[bird.groupId].direction;
                        } else {
                            bird.direction = Math.random() > 0.5 ? 1 : -1;
                        }
                    }
                }
                break;
                
            case 'takingOff':
    let takeoffSpeedFactor = 1;
    if (bird.direction === -1 && !bird.isChasing && !bird.isBeingChased) {
        takeoffSpeedFactor = 0.3;
    }
    // 水平斜上飞，角度不超过20度
    const takeoffAngle = (5 + Math.random() * 15) * Math.PI / 180; // 5-20度
    bird.x += bird.speed * bird.direction * takeoffSpeedFactor * Math.cos(takeoffAngle);
    bird.y -= bird.speed * takeoffSpeedFactor * Math.sin(takeoffAngle);
    if (bird.x < -100 || bird.x > GAME_WIDTH + 100 || bird.y < -100) {
        birds.splice(i, 1);
    }
    break;
                
            case 'movingToSecondTree':
                if (bird.targetTree) {
                    const moveDx = bird.targetX - bird.x;
                    const moveDy = bird.targetY - bird.y;
                    const moveDistance = Math.sqrt(moveDx * moveDx + moveDy * moveDy);
                    
                    let moveSpeedFactor = 1;
                    if (bird.direction === -1 && !bird.isChasing && !bird.isBeingChased) {
                        moveSpeedFactor = 0.3;
                    }
                    
                    if (moveDistance < 2) {
                        bird.state = 'perching';
                        bird.x = bird.targetX;
                        bird.y = bird.targetY;
                        bird.speed = 0;
                        bird.stateTime = 0;
                        bird.direction = bird.targetTree.side === 'left' ? 1 : -1;
                    } else {
                        bird.x += (moveDx / moveDistance) * bird.speed * moveSpeedFactor;
                        bird.y += (moveDy / moveDistance) * bird.speed * moveSpeedFactor;
                        bird.direction = moveDx > 0 ? 1 : -1;
                    }
                } else {
                    bird.state = 'takingOff';
                    bird.speed = 1;
                    if (bird.groupId && birdGroupInfo[bird.groupId]) {
                        bird.direction = birdGroupInfo[bird.groupId].direction;
                    } else {
                        bird.direction = Math.random() > 0.5 ? 1 : -1;
                    }
                }
                break;
                
            case 'stayingInReeds':
                if (bird.name === "棕头鸦雀") {
                    bird.y += Math.sin(bird.stateTime * 0.005) * 0.3;
                }
                break;
                
            case 'flyingAway':
    // 水平斜上飞，角度不超过20度
    const flyingAwayAngle2 = (5 + Math.random() * 15) * Math.PI / 180; // 5-20度
    bird.x += bird.speed * bird.direction * Math.cos(flyingAwayAngle2);
    bird.y -= bird.speed * Math.sin(flyingAwayAngle2);
    if ((bird.direction === 1 && bird.x > GAME_WIDTH + 200) || (bird.direction === -1 && bird.x < -200) || bird.y < -200) {
        birds.splice(i, 1);
    }
    break;
                
            case 'fleeing':
    // 水平斜上飞，角度不超过20度
    const fleeVerticalAngle = (10 + Math.random() * 10) * Math.PI / 180; // 10-20度
    bird.x += bird.speed * bird.direction * Math.cos(fleeVerticalAngle);
    bird.y -= bird.speed * Math.sin(fleeVerticalAngle);
    if (bird.y < -100) {
        birds.splice(i, 1);
    }
    break;
        }
    }
    
    if (scareMode && gameTime >= scareModeEndTime) {
        scareMode = false;
        birds.forEach(bird => {
            if (bird.isScared) {
                bird.speed = bird.speed / 1.5;
                bird.isScared = false;
            }
            if (bird.isChasing && !bird.chasingTarget) {
                bird.isChasing = false;
            }
        });
    }
}

// 修改翠鸟生成函数，从较低高度水平飞入
function generateKingfisher(countStats = false) {
  const kingfisherType = BIRD_TYPES.KINGFISHER;
  
  if (countStats) {
    appearedBirds[kingfisherType.name] = (appearedBirds[kingfisherType.name] || 0) + 1;
    updateTextStats();
  }
  
  // 从画面外飞入，直接飞向芦苇丛
  const fromLeft = Math.random() > 0.5;
  const startX = fromLeft ? -50 : GAME_WIDTH + 50;
  
  // 飞向芦苇丛区域
  const targetReedX = reedZone.x + Math.random() * reedZone.width;
  const targetReedY = reedZone.y + reedZone.height * 0.5; // 停在芦苇上
  
  // 设置较低的飞行高度 - 从芦苇区域上方一点飞入
  const startY = reedZone.y + reedZone.height * 0.5 + Math.random() * (GAME_HEIGHT * 0.1);
  
  const bird = {
    type: kingfisherType,
    name: kingfisherType.name,
    x: startX,
    y: startY, // 较低的初始高度
    size: kingfisherType.size,
    speed: 2.0,
    direction: fromLeft ? 1 : -1, // 1=向右，-1=向左
    state: 'flyingToReed',
    stateTime: 0,
    targetX: targetReedX,
    targetY: targetReedY,
    
    // 飞入时水平，headAngle = 0
    headAngle: 0, // 水平
    
    // 初始朝向（看向的方向）
    facingDirection: fromLeft ? 1 : -1, // 1=向右，-1=向左
    
    // 换向相关
    nextTurnTime: 0,
    turnInterval: kingfisherType.turnInterval[0] + 
                  Math.random() * (kingfisherType.turnInterval[1] - kingfisherType.turnInterval[0]),
    
    stayTime: kingfisherType.stayTime[0] + 
              Math.random() * (kingfisherType.stayTime[1] - kingfisherType.stayTime[0]),
    
    diveTargetX: 0,
    diveTargetY: 0,
    hasDived: false,
    hasCaughtFish: false,
    caughtFish: null,
    fishOffsetX: 0,
    fishOffsetY: 0,
    fishAngle: 0,
    beakLengthMultiplier: kingfisherType.beakLengthMultiplier,
    isVulnerableToRaptors: true,
    noStats: !countStats,
    isKingfisher: true,
    
    // 身体是否翻转的标志（用于绘制）
    bodyFlipped: false
  };
  
  // 设置转向时间
  bird.nextTurnTime = gameTime + bird.turnInterval;
  
  birds.push(bird);
  
  if (countStats) {
    showSpecialAlert(`发现${kingfisherType.name}！`);
  }
}

// 修改飞行逻辑，确保水平飞入
function updateKingfisher(bird, deltaTime) {
  bird.stateTime += deltaTime;
  
  // 检查是否有猛禽靠近（惊吓条件）
  let raptorNearby = false;
  for (let otherBird of birds) {
    // 检查是否是猛禽类型
    if ((otherBird.name === "游隼" || otherBird.name === "红隼" || otherBird.name === "黑翅鸢") && 
        otherBird.state !== 'fleeing') {
      const dx = otherBird.x - bird.x;
      const dy = otherBird.y - bird.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      // 如果猛禽在1000像素范围内
      if (distance < 1000) {
        raptorNearby = true;
        break;
      }
    }
  }
  
  // 如果猛禽靠近且翠鸟不在逃跑状态，立即开始逃跑
  if (raptorNearby && bird.state !== 'fleeingFromRaptor' && bird.state !== 'flyingAway') {
    bird.state = 'fleeingFromRaptor';
    bird.stateTime = 0;
    bird.speed = 3.5; // 惊吓逃跑速度更快
    bird.direction = Math.random() > 0.5 ? 1 : -1; // 随机方向逃跑
    bird.facingDirection = bird.direction;
    bird.headAngle = 0; // 水平飞行
    bird.bodyFlipped = (bird.facingDirection === -1);
    return; // 立即返回，不执行后续状态逻辑
  }
  
  switch (bird.state) {
    case 'flyingToReed':
      // 飞向芦苇丛 - 保持水平飞行，不改变y坐标
      const dx = bird.targetX - bird.x;
      const horizontalDistance = Math.abs(dx);
      
      if (horizontalDistance < 5) {
        // 到达目标x坐标，检查是否需要下降
        if (Math.abs(bird.y - bird.targetY) < 5) {
          // 已经到达目标位置，切换到停留状态
          bird.state = 'perchingOnReed';
          bird.stateTime = 0;
          bird.speed = 0;
          bird.x = bird.targetX;
          bird.y = bird.targetY;
          
          // 到达芦苇后，头和嘴斜向下45度
          bird.headAngle = Math.PI/4;
        } else {
          // 需要垂直下降
          const dy = bird.targetY - bird.y;
          const verticalDistance = Math.abs(dy);
          
          if (verticalDistance < 2) {
            bird.y = bird.targetY;
          } else {
            // 垂直下降
            bird.y += (dy / verticalDistance) * bird.speed * 0.5;
          }
        }
      } else {
        // 水平飞向目标x坐标
        bird.x += (dx / horizontalDistance) * bird.speed;
        // 保持水平飞行，不改变y坐标
        bird.headAngle = 0; // 飞行时保持水平
      }
      break;
      
    case 'perchingOnReed':
      // 在芦苇上停留
      if (bird.stateTime > bird.stayTime) {
        // 停留时间结束，开始俯冲捉鱼
        bird.state = 'divingForFish';
        bird.stateTime = 0;
        
        // 设置俯冲目标（水面位置）
        // 根据当前朝向决定俯冲方向
        bird.diveTargetX = bird.x + (bird.facingDirection > 0 ? 100 : -100);
        bird.diveTargetY = reedZone.y + reedZone.height - 10;
        bird.speed = bird.type.diveSpeed || 3.0;
      } else {
        // 每隔一段时间换方向
        if (gameTime > bird.nextTurnTime) {
          // 水平换向：改变facingDirection（从向右变成向左，或反之）
          bird.facingDirection *= -1;
          bird.direction = bird.facingDirection; // 同步更新 direction 以触发全局翻转
          bird.bodyFlipped = (bird.facingDirection === -1);
          
          // 不需要改变headAngle，因为绘制时会根据facingDirection翻转
          bird.nextTurnTime = gameTime + bird.turnInterval;
        }
      }
      break;
      
    case 'divingForFish':
      // 俯冲捉鱼
      const diveDx = bird.diveTargetX - bird.x;
      const diveDy = bird.diveTargetY - bird.y;
      const diveDistance = Math.sqrt(diveDx * diveDx + diveDy * diveDy);
      
      // 更新朝向：根据俯冲方向设置
      bird.direction = diveDx > 0 ? 1 : -1;
      
      if (diveDistance < 10 || bird.stateTime > 2000) {
        // 到达水面，捉到鱼
        bird.state = 'caughtFish';
        bird.stateTime = 0;
        bird.hasCaughtFish = true;
        
        // 创建鱼对象
        bird.caughtFish = {
          x: 0,
          y: 0,
          size: bird.type.fishSize,
          color: bird.type.fishColor,
          angle: Math.PI/2 // 鱼横向垂直于嘴
        };
        
        // 向上飞起
        bird.speed = 2.0;
        bird.direction = -1; // 向上？这里direction应该是左右方向。
        // 如果是垂直向上，direction保持原样或者随机？
        // 原代码写的是 direction = -1，这会让它向左飞。
        // 应该是保持当前朝向，或者随机选一个。
        // 这里暂时保持原样，或者修复它。
        // 假设向上飞时保持之前的朝向
        // bird.direction = bird.direction; 
        
        bird.headAngle = 0; // 向上飞时水平
        bird.bodyFlipped = false; // 取消翻转
      } else {
        // 继续俯冲
        // 计算相对于行进方向的角度
        // 使用 abs(diveDx) 确保角度始终指向“前方”
        const diveAngle = Math.atan2(diveDy, Math.abs(diveDx));
        
        // 移动逻辑保持使用真实的 diveDx, diveDy
        // 或者使用 angle * direction ? 
        // 最简单的是：
        const moveAngle = Math.atan2(diveDy, diveDx);
        bird.x += Math.cos(moveAngle) * bird.speed;
        bird.y += Math.sin(moveAngle) * bird.speed;
        
        // 头部朝向俯冲方向（相对于身体）
        bird.headAngle = diveAngle;
      }
      break;
      
    case 'caughtFish':
      // 捉到鱼后向上飞
      if (bird.stateTime < 600) {
        // 向上飞半个芦苇高
        bird.y -= bird.speed;
        
        // 计算鱼的正确位置（在嘴尖）
        const beakLength = 8 * bird.beakLengthMultiplier; // 嘴的实际长度
        const fishDistance = beakLength + bird.caughtFish.size/2; // 鱼应该在嘴尖外一点
        
        // 计算鱼相对于翠鸟身体中心的位置
        // 注意：鱼的横向垂直于嘴，所以需要旋转90度
        const angleForFish = bird.headAngle + Math.PI/2;
        
        // 鱼的偏移量（从翠鸟身体中心到鱼的中心）
        bird.fishOffsetX = Math.cos(bird.headAngle) * fishDistance;
        bird.fishOffsetY = Math.sin(bird.headAngle) * fishDistance;
        
        // 鱼自身的角度（横向垂直于嘴）
        bird.fishAngle = angleForFish;
      } else {
        // 向上飞后飞走
        bird.state = 'flyingAway';
        bird.speed = 2.5;
        bird.direction = Math.random() > 0.5 ? 1 : -1;
        bird.facingDirection = bird.direction; // 面向飞行方向
        bird.headAngle = 0; // 水平飞行
        bird.bodyFlipped = (bird.facingDirection === -1);
      }
      break;
      
    case 'flyingAway':
      // 正常飞离画面
      bird.x += bird.direction * bird.speed;
      bird.headAngle = 0; // 水平飞行
      
      if (bird.x < -100 || bird.x > GAME_WIDTH + 100) {
        // 飞出画面，移除
        birds.splice(birds.indexOf(bird), 1);
      }
      break;
      
case 'fleeingFromRaptor':
  // 受惊吓飞走，但保持原有的鱼位置
  bird.x += bird.direction * bird.speed;
  bird.headAngle = 0; // 水平飞行
  bird.bodyFlipped = (bird.direction === -1);
  
  // 更新鱼的位置（保持原有逻辑）
  if (bird.caughtFish) {
    // 计算嘴尖的全局位置
    const beakLength = 10 * bird.beakLengthMultiplier;
    const localBeakTipX = bird.direction === 1 ? beakLength : -beakLength;
    const globalBeakTipX = bird.x + localBeakTipX;
    const globalBeakTipY = bird.y;
    
    // 鱼的位置应该在嘴里面一点
    const fishDistance = -bird.caughtFish.size/3; // 负值表示向里（向翠鸟头部方向）
    const fishX = globalBeakTipX + Math.cos(bird.headAngle) * fishDistance;
    const fishY = globalBeakTipY + Math.sin(bird.headAngle) * fishDistance;
    
    bird.fishOffsetX = fishX - bird.x;
    bird.fishOffsetY = fishY - bird.y;
    bird.fishAngle = bird.headAngle + Math.PI/2;
  }
  
  if (bird.x < -100 || bird.x > GAME_WIDTH + 100) {
    // 飞出画面，移除
    birds.splice(birds.indexOf(bird), 1);
  }
  break;
  }
  
  // 更新身体翻转状态
  // 当面向左边时，身体需要翻转
  if (bird.state !== 'fleeingFromRaptor' && bird.state !== 'flyingAway') {
    bird.bodyFlipped = (bird.facingDirection === -1);
  }
}

// 修改翠鸟绘制函数，实现整体左右翻转
function drawKingfisher(bird) {
  const baseSize = 20;
  const birdSize = baseSize * bird.size;
  
  ctx.save();
  
  // 翠鸟的特殊处理：内部翻转逻辑移除，依赖全局翻转
  // if (bird.bodyFlipped) { ... } REMOVED
  
  // 绘制身体
  ctx.fillStyle = bird.type.bodyColor; // 橙色身体
  ctx.beginPath();
  ctx.arc(bird.x, bird.y, birdSize/2, 0, Math.PI * 2);
  ctx.fill();
  
  // 保存画布状态，准备绘制头部
  ctx.save();
  
  // 平移画布到头部位置
  const headX = bird.x + birdSize/2 - (birdSize * 0.5)/2;
  const headY = bird.y - birdSize/2 + (birdSize * 0.5)/2;
  ctx.translate(headX, headY);
  
  // 根据头部角度旋转画布（头和嘴一起旋转）
  ctx.rotate(bird.headAngle);
  
  // 绘制头部（在旋转后的坐标系中绘制）
  ctx.fillStyle = bird.type.headColor; // 青色头部
  ctx.beginPath();
  ctx.arc(0, 0, (birdSize * 0.5)/2, 0, Math.PI * 2);
  ctx.fill();
  
  // 绘制长嘴
  const beakLength = 8 * bird.beakLengthMultiplier;
  const beakHeight = 3;
  
  ctx.fillStyle = bird.type.beakColor; // 黑色嘴
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(beakLength, 0);
  ctx.lineTo(0, beakHeight);
  ctx.closePath();
  ctx.fill();
  
  // 绘制眼睛和橙色眼圈
  const eyeX = (birdSize * 0.5)/4;
  const eyeY = 0;
  
  // 橙色眼圈
  ctx.fillStyle = bird.type.eyeRingColor;
  ctx.beginPath();
  ctx.arc(eyeX, eyeY, 4, 0, Math.PI * 2);
  ctx.fill();
  
  // 黑色眼睛
  ctx.fillStyle = bird.type.eyeColor;
  ctx.beginPath();
  ctx.arc(eyeX, eyeY, 2, 0, Math.PI * 2);
  ctx.fill();
  
  // 恢复画布状态
  ctx.restore();
  
  // 绘制翅膀
  ctx.fillStyle = bird.type.wingColor; // 蓝色翅膀
  ctx.fillRect(
    bird.x - birdSize/4 - (birdSize * 0.5)/2,
    bird.y - birdSize/2,
    birdSize/2,
    birdSize/3
  );
  
  // 绘制尾部
  ctx.fillStyle = bird.type.tailColor; // 青色尾部
  const tailStartX = bird.x - birdSize/2;
  const tailStartY = bird.y - birdSize/8;
  const tailHeight = birdSize/4;
  
  ctx.beginPath();
  ctx.moveTo(tailStartX, tailStartY);
  ctx.lineTo(tailStartX - 8, tailStartY - tailHeight/2);
  ctx.lineTo(tailStartX - 8, tailStartY + tailHeight/2);
  ctx.lineTo(tailStartX, tailStartY);
  ctx.closePath();
  ctx.fill();
  
  // 如果捉到鱼，绘制鱼
  if (bird.hasCaughtFish && bird.caughtFish) {
    ctx.save();
    
    // 计算鱼的正确位置
    // 首先计算嘴尖的位置（头部位置 + 嘴长）
    const headX = bird.x + birdSize/2 - (birdSize * 0.5)/2;
    const headY = bird.y - birdSize/2 + (birdSize * 0.5)/2;
    
    // 嘴尖在旋转坐标系中的位置
    const beakTipX = Math.cos(bird.headAngle) * beakLength;
    const beakTipY = Math.sin(bird.headAngle) * beakLength;
    
    // 鱼的位置应该在嘴里面一点，不是嘴尖
    const fishDistance = -bird.caughtFish.size/4; // 负值表示向里（向翠鸟头部方向）
    
    // 直接使用全局坐标（假设面朝右），全局翻转会自动处理面朝左的情况
    // 嘴尖在旋转坐标系中的位置（相对于头部中心）
    // 注意：我们需要先旋转再平移，或者直接计算旋转后的坐标
    // 这里我们直接在头部中心的基础上，加上旋转后的向量
    
    // 头部中心坐标
    const headCenterX = bird.x + birdSize/2 - (birdSize * 0.5)/2;
    const headCenterY = bird.y - birdSize/2 + (birdSize * 0.5)/2;
    
    // 鱼在嘴上的位置（相对于头部中心）
    // 嘴长是 beakLength
    // 鱼在嘴上的距离是 beakLength + fishDistance (从头中心算起吗？)
    // 之前的 beakTipX 是嘴尖。
    // 让我们重新计算：
    // 嘴是从 (0,0) 画到 (beakLength, 0) （在头部局部坐标系中）
    // 鱼应该在 (beakLength + fishDistance, 0) （在头部局部坐标系中）
    
    const fishLocalX = beakLength + fishDistance;
    const fishLocalY = 0;
    
    // 将局部坐标转换为全局坐标（考虑 headAngle）
    const fishGlobalX = headCenterX + Math.cos(bird.headAngle) * fishLocalX - Math.sin(bird.headAngle) * fishLocalY;
    const fishGlobalY = headCenterY + Math.sin(bird.headAngle) * fishLocalX + Math.cos(bird.headAngle) * fishLocalY;
    
    let fishAngle = bird.headAngle + Math.PI/2;
    
    ctx.translate(fishGlobalX, fishGlobalY);
    ctx.rotate(fishAngle);
    
    // 绘制鱼身
    ctx.fillStyle = bird.caughtFish.color;
    ctx.beginPath();
    ctx.ellipse(0, 0, bird.caughtFish.size/2, bird.caughtFish.size/4, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // 绘制鱼尾
    ctx.beginPath();
    ctx.moveTo(-bird.caughtFish.size/3, 0);
    ctx.lineTo(-bird.caughtFish.size/2, -bird.caughtFish.size/4);
    ctx.lineTo(-bird.caughtFish.size/2, bird.caughtFish.size/4);
    ctx.closePath();
    ctx.fill();
    
    // 绘制鱼眼
    ctx.fillStyle = "#000000";
    ctx.beginPath();
    ctx.arc(bird.caughtFish.size/4, 0, 1, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.restore();
  }
  
  ctx.restore();
}

function updateBat(bird, deltaTime) {
    if (gamePaused) return;
    bird.stateTime += deltaTime;
    bird.circlingTime += deltaTime;
    bird.wingFlapTimer += bird.wingFlapSpeed;
    if (gameMode === 'normal' && isDaytime) {
        bird.state = 'fleeing';
        bird.speed = bird.speed * 1.5;
        bird.direction = 1;
        bird.fleeStartTime = gameTime;
    }
    if (bird.circlingTime > bird.circleTime) {
        bird.state = 'leaving';
        bird.speed = 1.5;
        bird.direction = 1;
    }
    if (!bird.irregularParams) {
        bird.irregularParams = {
            radiusVariation: 0.3 + Math.random() * 0.4,
            angleVariation: 0.02 + Math.random() * 0.03,
            radiusChangeSpeed: 0.001 + Math.random() * 0.002,
            centerDriftSpeed: 0.05 + Math.random() * 0.1,
            verticalDriftSpeed: 0.02 + Math.random() * 0.03,
            currentRadius: bird.circlingRadius,
            targetRadius: bird.circlingRadius * (0.7 + Math.random() * 0.6),
            radiusDirection: Math.random() > 0.5 ? 1 : -1,
            centerDriftX: (Math.random() - 0.5) * 2,
            centerDriftY: (Math.random() - 0.5) * 2,
            verticalDrift: 0,
            verticalDirection: Math.random() > 0.5 ? 1 : -1
        };
    }
    const params = bird.irregularParams;
    switch (bird.state) {
        case 'circling':
            bird.circlingAngle += params.angleVariation * (bird.type.speedMultiplier || 1);
            params.currentRadius += params.radiusChangeSpeed * params.radiusDirection;
            if (Math.abs(params.currentRadius - params.targetRadius) < 5) {
                params.targetRadius = bird.circlingRadius * (0.7 + Math.random() * 0.6);
                params.radiusDirection *= -1;
            }
            params.currentRadius = Math.max(
                bird.circlingRadius * 0.5,
                Math.min(bird.circlingRadius * 1.5, params.currentRadius)
            );
            bird.circlingCenterX += params.centerDriftX * params.centerDriftSpeed;
            bird.circlingCenterY += params.centerDriftY * params.centerDriftSpeed;
            bird.circlingCenterX = Math.max(
                GAME_WIDTH * 0.3,
                Math.min(GAME_WIDTH * 0.7, bird.circlingCenterX)
            );
            bird.circlingCenterY = Math.max(
                GAME_HEIGHT * 0.2,
                Math.min(GAME_HEIGHT * 0.4, bird.circlingCenterY)
            );
            params.verticalDrift += params.verticalDriftSpeed * params.verticalDirection;
            if (Math.abs(params.verticalDrift) > 20) {
                params.verticalDirection *= -1;
            }
            const effectiveRadiusX = params.currentRadius * (1 + Math.sin(bird.circlingAngle * 0.5) * 0.2);
            const effectiveRadiusY = params.currentRadius * (1 + Math.cos(bird.circlingAngle * 0.3) * 0.2);
            bird.x = bird.circlingCenterX + Math.cos(bird.circlingAngle) * effectiveRadiusX;
            bird.y = bird.circlingCenterY + Math.sin(bird.circlingAngle) * effectiveRadiusY + params.verticalDrift;
            if (bird.y > GAME_HEIGHT * 0.5) {
                bird.y = GAME_HEIGHT * 0.5 - 10;
                bird.circlingAngle += Math.PI * 0.2;
                params.verticalDrift = -10;
                params.verticalDirection = -1;
            }
            if (bird.y < GAME_HEIGHT * 0.15) {
                bird.y = GAME_HEIGHT * 0.15 + 10;
                bird.circlingAngle += Math.PI * 0.2;
                params.verticalDrift = 10;
                params.verticalDirection = 1;
            }
            if (Math.random() < 0.01) {
                params.centerDriftX = (Math.random() - 0.5) * 2;
                params.centerDriftY = (Math.random() - 0.5) * 2;
            }
            if (Math.random() < 0.02) {
                params.verticalDirection *= -1;
            }
            const tangentAngle = bird.circlingAngle + Math.PI / 2;
            bird.direction = Math.cos(tangentAngle) > 0 ? 1 : -1;
            if (Math.random() < 0.005) {
                bird.direction *= -1;
                bird.circlingAngle += Math.PI * 0.5;
            }
            break;
        case 'leaving':
        case 'fleeing':
            // 水平斜上飞，角度不超过20度
            const batLeavingAngle = (8 + Math.random() * 12) * Math.PI / 180; // 8-20度
            bird.x += bird.speed * Math.cos(batLeavingAngle);
            bird.y -= bird.speed * Math.sin(batLeavingAngle);
            // 保持原有的摆动效果，但减小幅度
            bird.y += Math.sin(gameTime * 0.001) * 0.1; // 减小垂直摆动幅度
            bird.x += Math.sin(gameTime * 0.002) * 0.2; // 减小水平摆动幅度
            if (bird.x > GAME_WIDTH + 100 || bird.y < -100) {
                birds.splice(birds.indexOf(bird), 1);
            }
            break;
    }
}

function updateOwlBird(bird, deltaTime) {
    bird.stateTime += deltaTime;
    bird.faceChangeTimer += deltaTime;
    if (bird.faceChangeTimer > bird.faceChangeInterval) {
        bird.faceChangeTimer = 0;
        bird.faceChangeInterval = 10000 + Math.random() * 10000;
    }
    if (bird.name !== "雕鸮" && bird.state !== 'fleeing') {
        for (const otherBird of birds) {
            if (otherBird.name === "雕鸮" && otherBird.state !== 'fleeing') {
                bird.state = 'fleeing';
                bird.speed = bird.speed * 2;
                bird.direction = Math.random() > 0.5 ? 1 : -1;
                bird.fleeStartTime = gameTime;
                break;
            }
        }
    }
    if (gameMode === 'normal' && isDaytime && bird.state !== 'fleeing') {
        bird.state = 'fleeing';
        bird.speed = bird.speed * 1.5;
        bird.direction = 1;
        bird.fleeStartTime = gameTime;
    }
    switch (bird.state) {
        case 'circling':
            bird.circlingTime += deltaTime;
            bird.circlingAngle += 0.01 * (bird.type.speedMultiplier || 1);
            bird.x = bird.circlingCenterX + Math.cos(bird.circlingAngle) * bird.circlingRadius;
            bird.y = bird.circlingCenterY + Math.sin(bird.circlingAngle) * bird.circlingRadius;
            const tangentAngle = bird.circlingAngle + Math.PI / 2;
            bird.direction = Math.cos(tangentAngle) > 0 ? 1 : -1;
            if (bird.circlingTime > bird.circleTime) {
                bird.state = 'glidingToGround';
                bird.speed = 0.8 * (bird.type.speedMultiplier || 1);
                bird.direction = Math.random() > 0.5 ? 1 : -1;
                bird.glidingStartY = bird.y;
            }
            break;
        case 'glidingToGround':
            bird.x += bird.speed * bird.direction * 0.3;
            bird.y += bird.speed * 1.5;
            if (bird.y >= GAME_HEIGHT - 60) {
                if (Math.random() < bird.catchPreyChance) {
                    if (bird.catchPreyType === "hedgehog") {
                        bird.caughtPrey = generateHedgehog();
                    } else if (bird.catchPreyType === "mouse") {
                        bird.caughtPrey = generateGroundMouseForPredator(bird.name);
                    }
                    if (bird.caughtPrey) {
                        const index = groundObjects.indexOf(bird.caughtPrey);
                        if (index !== -1) {
                            groundObjects.splice(index, 1);
                        }
                    }
                    bird.state = 'flyingWithPrey';
                    bird.speed = 1.5;
                    bird.direction = 1;
                    bird.y -= 50;
                } else {
                    bird.state = 'leaving';
                    bird.speed = 1.5;
                    bird.direction = 1;
                }
            }
            break;
        case 'flyingWithPrey':
        case 'leaving':
            // 水平斜上飞，角度不超过20度
            const owlLeavingAngle = (10 + Math.random() * 10) * Math.PI / 180; // 10-20度
            bird.x += bird.speed * Math.cos(owlLeavingAngle);
            bird.y -= bird.speed * Math.sin(owlLeavingAngle);
            if (bird.x > GAME_WIDTH + 100 || bird.y < -100) {
                birds.splice(birds.indexOf(bird), 1);
            }
            break;
        case 'fleeing':
            // 水平斜上飞，角度不超过20度
            const owlFleeAngle = (12 + Math.random() * 8) * Math.PI / 180; // 12-20度
            bird.x += bird.speed * bird.direction * Math.cos(owlFleeAngle);
            bird.y -= bird.speed * Math.sin(owlFleeAngle);
            if (bird.x < -100 || bird.x > GAME_WIDTH + 100 || bird.y < -100) {
                birds.splice(birds.indexOf(bird), 1);
            }
            break;
    }
}

function updatePoops(deltaTime) {
    if (gamePaused) return;
    
    // 更新所有粪便的位置（下落）
    for (let i = poops.length - 1; i >= 0; i--) {
        const poop = poops[i];
        
        // 下落效果
        poop.y += poop.speed * (deltaTime / 16); // 标准化速度
        
        // 添加一点左右摆动效果，使粪便看起来更自然
        poop.x += Math.sin(gameTime * 0.001 + i) * 0.1;
        
        // 检查是否落地或过期
        const isOutOfBounds = poop.y > GAME_HEIGHT || poop.x < 0 || poop.x > GAME_WIDTH;
        const isExpired = gameTime - poop.createdAt > poop.lifetime;
        
        if (isOutOfBounds || isExpired) {
            poops.splice(i, 1);
        }
    }
}

function drawPoops() {
    poopCtx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT); // 清除之前的绘制
    poops.forEach(poop => {
        poopCtx.fillStyle = poop.color;
        poopCtx.beginPath();
        poopCtx.arc(poop.x, poop.y, poop.size, 0, Math.PI * 2);
        poopCtx.fill();
    });
}

function updateGroundObjects(deltaTime) {
    for (let i = groundObjects.length - 1; i >= 0; i--) {
        const obj = groundObjects[i];
        
        if (gameTime - obj.createdAt > obj.lifetime) {
            groundObjects.splice(i, 1);
        }
    }
}

function drawGroundObjects() {
    groundObjects.forEach(obj => {
        if (obj.type === "mouse") {
            ctx.fillStyle = obj.color;
            ctx.beginPath();
            ctx.ellipse(obj.x, obj.y, obj.size, obj.size/1.5, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = obj.color;
            ctx.beginPath();
            ctx.arc(obj.x + obj.size, obj.y, obj.size/2, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = "#000000";
            ctx.beginPath();
            ctx.arc(obj.x + obj.size + 2, obj.y - 1, 1, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = obj.color;
            ctx.lineWidth = 2;
            ctx.lineCap = "round";
            ctx.beginPath();
            ctx.moveTo(obj.x - obj.size, obj.y);
            ctx.lineTo(obj.x - obj.size - 10, obj.y + 3);
            ctx.stroke();
            
            obj.x += Math.sin(gameTime * 0.001) * 0.1;
        } else if (obj.type === "hedgehog") {
            ctx.fillStyle = obj.color;
            ctx.beginPath();
            ctx.arc(obj.x, obj.y, obj.size, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = obj.color;
            ctx.beginPath();
            ctx.moveTo(obj.x + obj.size, obj.y);
            ctx.lineTo(obj.x + obj.size * 1.5, obj.y - obj.size * 0.5);
            ctx.lineTo(obj.x + obj.size * 1.5, obj.y + obj.size * 0.5);
            ctx.closePath();
            ctx.fill();
            
            ctx.strokeStyle = "#8B4513";
            ctx.lineWidth = 2;
            ctx.lineCap = "round";
            for (let i = 0; i < 24; i++) {
                const angle = (i / 24) * Math.PI * 2;
                const length = 3 + Math.random() * 1.5;
                const startX = obj.x + Math.cos(angle) * obj.size;
                const startY = obj.y + Math.sin(angle) * obj.size;
                const endX = obj.x + Math.cos(angle) * (obj.size + length);
                const endY = obj.y + Math.sin(angle) * (obj.size + length);
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.stroke();
            }
            
            ctx.fillStyle = "#000000";
            ctx.beginPath();
            ctx.arc(obj.x + obj.size * 1.2, obj.y - obj.size * 0.2, 1, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = "#000000";
            ctx.beginPath();
            ctx.arc(obj.x + obj.size * 1.5, obj.y, 0.8, 0, Math.PI * 2);
            ctx.fill();
            
            obj.x += Math.sin(gameTime * 0.001) * 0.05;
        }
    });
}

function updateFruits(deltaTime) {
    fruits.forEach(fruit => {
        if (fruit.isEaten && gameTime - fruit.eatStartTime > 10000) {
            fruit.isEaten = false;
            fruit.color = fruit.originalColor;
            fruit.eatenBy = null;
        }
    });
}

function drawViewfinder() {
    const viewfinderSize = getViewfinderSize();
    const actualViewfinderWidth = viewfinderSize.width;
    const actualViewfinderHeight = viewfinderSize.height;
    
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
    ctx.lineWidth = 2;
    ctx.setLineDash([5, 5]);
    ctx.strokeRect(
        mouseX - actualViewfinderWidth / 2,
        mouseY - actualViewfinderHeight / 2,
        actualViewfinderWidth,
        actualViewfinderHeight
    );
    ctx.setLineDash([]);
}

// 修改gameLoop函数，在陀螺仪模式下更新取景框
function gameLoop(timestamp) {
  if (gamePaused) {
    requestAnimationFrame(gameLoop);
    return;
  }
    const deltaTime = timestamp - lastFrameTime;
    lastFrameTime = timestamp;
    
    updateDayNight(deltaTime);
    
    ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
    poopCtx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
// 更新观鸟模式状态指示器
if (birdingModeActive) {
    const birdingStatusIndicator = document.getElementById('birdingStatusIndicator');
    const birdingDuration = gameTime - birdingModeStartTime;
    const birdingMinutes = Math.floor(birdingDuration / 60000);
    const birdingSeconds = Math.floor((birdingDuration % 60000) / 1000);
    
    // 只显示观鸟已进行的时间，不显示倒计时
    birdingStatusIndicator.textContent = `进行中 ${birdingMinutes}:${birdingSeconds.toString().padStart(2, '0')}`;
 }
    if (gameMode === 'normal' && isDaytime) {
        updateGoldenFilter();
    }
    
    drawBackground();
    drawSunMoon();
    drawStars();
    drawClouds();
    
    updateNightObjects(deltaTime);
    
    drawMountains();
    nightObjects.forEach(obj => drawNightObject(obj));
    
    drawTrees();
    drawReeds();
    drawWallAndHole();
    drawGroundObjects();
    generateBird();
    
    updateBirds(deltaTime);
    updatePoops(deltaTime);
    updateGroundObjects(deltaTime);
    updateFruits(deltaTime);
      // 在陀螺仪模式下，我们需要持续更新取景框位置
  if (gyroModeActive) {
    updateViewfinderFromGyro();
  }
    birds.forEach(bird => drawBird(bird));
    drawPoops();
    
    drawViewfinder();
    
    requestAnimationFrame(gameLoop);
}

window.onload = init; </script></body></html>
